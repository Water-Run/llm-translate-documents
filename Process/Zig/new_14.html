<figure><figcaption class="zig-cap"><cite class="file">test_defining_variadic_function.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> testing = std.testing;
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">"builtin"</span>);

<span class="tok-kw">fn</span> <span class="tok-fn">add</span>(count: <span class="tok-type">c_int</span>, ...) <span class="tok-kw">callconv</span>(.c) <span class="tok-type">c_int</span> {
    <span class="tok-kw">var</span> ap = <span class="tok-builtin">@cVaStart</span>();
    <span class="tok-kw">defer</span> <span class="tok-builtin">@cVaEnd</span>(&amp;ap);
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> sum: <span class="tok-type">c_int</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; count) : (i += <span class="tok-number">1</span>) {
        sum += <span class="tok-builtin">@cVaArg</span>(&amp;ap, <span class="tok-type">c_int</span>);
    }
    <span class="tok-kw">return</span> sum;
}

<span class="tok-kw">test</span> <span class="tok-str">"defining a variadic function"</span> {
    <span class="tok-kw">if</span> (builtin.cpu.arch == .aarch64 <span class="tok-kw">and</span> builtin.os.tag != .macos) {
        <span class="tok-comment">// https://github.com/ziglang/zig/issues/14096</span>
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    }
    <span class="tok-kw">if</span> (builtin.cpu.arch == .x86_64 <span class="tok-kw">and</span> builtin.os.tag == .windows) {
        <span class="tok-comment">// https://github.com/ziglang/zig/issues/16961</span>
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    }

    <span class="tok-kw">try</span> std.testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">c_int</span>, <span class="tok-number">0</span>), add(<span class="tok-number">0</span>));
    <span class="tok-kw">try</span> std.testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">c_int</span>, <span class="tok-number">1</span>), add(<span class="tok-number">1</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">c_int</span>, <span class="tok-number">1</span>)));
    <span class="tok-kw">try</span> std.testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">c_int</span>, <span class="tok-number">3</span>), add(<span class="tok-number">2</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">c_int</span>, <span class="tok-number">1</span>), <span class="tok-builtin">@as</span>(<span class="tok-type">c_int</span>, <span class="tok-number">2</span>)));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_defining_variadic_function.zig</kbd>
1/1 test_defining_variadic_function.test.defining a variadic function...OK
All 1 tests passed.
</samp></pre></figure>

      
      <h3 id="Exporting-a-C-Library"><a href="https://ziglang.org/documentation/0.15.2/#toc-Exporting-a-C-Library">导出 C 库</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Exporting-a-C-Library">§</a></h3>

      <p>
      Zig 的主要用例之一是导出一个具有 C ABI 的库供其他编程语言调用。在函数、变量和类型前面使用 <code><span class="tok-kw">export</span></code> 关键字会使它们成为库 API 的一部分:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">mathtest.zig</cite></figcaption><pre><code><span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(a: <span class="tok-type">i32</span>, b: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> a + b;
}</code></pre></figure>

      <p>制作静态库:</p>
      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-lib mathtest.zig</kbd>
</samp></pre></figure>
      <p>制作动态库:</p>
      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-lib mathtest.zig -dynamic</kbd>
</samp></pre></figure>
      <p>这是一个使用 <a href="https://ziglang.org/documentation/0.15.2/#Zig-Build-System">Zig 构建系统</a>的示例:</p>
      <figure><figcaption class="c-cap"><cite class="file">test.c</cite></figcaption><pre><code>// This header is generated by zig from mathtest.zig
#include "mathtest.h"
#include &lt;stdio.h&gt;

int main(int argc, char **argv) {
    int32_t result = add(42, 1337);
    printf("%d\n", result);
    return 0;
}</code></pre></figure>
      <figure><figcaption class="zig-cap"><cite class="file">build_c.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">build</span>(b: *std.Build) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> lib = b.addLibrary(.{
        .linkage = .dynamic,
        .name = <span class="tok-str">"mathtest"</span>,
        .root_module = b.createModule(.{
            .root_source_file = b.path(<span class="tok-str">"mathtest.zig"</span>),
        }),
        .version = .{ .major = <span class="tok-number">1</span>, .minor = <span class="tok-number">0</span>, .patch = <span class="tok-number">0</span> },
    });
    <span class="tok-kw">const</span> exe = b.addExecutable(.{
        .name = <span class="tok-str">"test"</span>,
        .root_module = b.createModule(.{
            .link_libc = <span class="tok-null">true</span>,
        }),
    });
    exe.root_module.addCSourceFile(.{ .file = b.path(<span class="tok-str">"test.c"</span>), .flags = &amp;.{<span class="tok-str">"-std=c99"</span>} });
    exe.root_module.linkLibrary(lib);

    b.default_step.dependOn(&amp;exe.step);

    <span class="tok-kw">const</span> run_cmd = exe.run();

    <span class="tok-kw">const</span> test_step = b.step(<span class="tok-str">"test"</span>, <span class="tok-str">"Test the program"</span>);
    test_step.dependOn(&amp;run_cmd.step);
}</code></pre></figure>

      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build test</kbd>
1379
</samp></pre></figure>
      <p>另见:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#export">export</a></li>
</ul>

      
      <h3 id="Mixing-Object-Files"><a href="https://ziglang.org/documentation/0.15.2/#toc-Mixing-Object-Files">混合目标文件</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Mixing-Object-Files">§</a></h3>

      <p>
      您可以将 Zig 目标文件与任何其他遵循 C ABI 的目标文件混合。示例:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">base64.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> base64 = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).base64;

<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">decode_base_64</span>(
    dest_ptr: [*]<span class="tok-type">u8</span>,
    dest_len: <span class="tok-type">usize</span>,
    source_ptr: [*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    source_len: <span class="tok-type">usize</span>,
) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> src = source_ptr[<span class="tok-number">0</span>..source_len];
    <span class="tok-kw">const</span> dest = dest_ptr[<span class="tok-number">0</span>..dest_len];
    <span class="tok-kw">const</span> base64_decoder = base64.standard.Decoder;
    <span class="tok-kw">const</span> decoded_size = base64_decoder.calcSizeForSlice(src) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    base64_decoder.decode(dest[<span class="tok-number">0</span>..decoded_size], src) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    <span class="tok-kw">return</span> decoded_size;
}</code></pre></figure>

      <figure><figcaption class="c-cap"><cite class="file">test.c</cite></figcaption><pre><code>// This header is generated by zig from base64.zig
#include "base64.h"

#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char **argv) {
    const char *encoded = "YWxsIHlvdXIgYmFzZSBhcmUgYmVsb25nIHRvIHVz";
    char buf[200];

    size_t len = decode_base_64(buf, 200, encoded, strlen(encoded));
    buf[len] = 0;
    puts(buf);

    return 0;
}</code></pre></figure>
      <figure><figcaption class="zig-cap"><cite class="file">build_object.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">build</span>(b: *std.Build) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> obj = b.addObject(.{
        .name = <span class="tok-str">"base64"</span>,
        .root_module = b.createModule(.{
            .root_source_file = b.path(<span class="tok-str">"base64.zig"</span>),
        }),
    });

    <span class="tok-kw">const</span> exe = b.addExecutable(.{
        .name = <span class="tok-str">"test"</span>,
        .root_module = b.createModule(.{
            .link_libc = <span class="tok-null">true</span>,
        }),
    });
    exe.root_module.addCSourceFile(.{ .file = b.path(<span class="tok-str">"test.c"</span>), .flags = &amp;.{<span class="tok-str">"-std=c99"</span>} });
    exe.root_module.addObject(obj);
    b.installArtifact(exe);
}</code></pre></figure>

      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build</kbd>
$ <kbd>./zig-out/bin/test</kbd>
all your base are belong to us
</samp></pre></figure>
      <p>另见:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Targets">目标</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Zig-Build-System">Zig 构建系统</a></li>
</ul>

      
      
      <h2 id="WebAssembly"><a href="https://ziglang.org/documentation/0.15.2/#toc-WebAssembly">WebAssembly</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#WebAssembly">§</a></h2>

      <p>Zig 开箱即支持构建 WebAssembly。</p>
      <h3 id="Freestanding"><a href="https://ziglang.org/documentation/0.15.2/#toc-Freestanding">独立环境</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Freestanding">§</a></h3>

      <p>对于像 web 浏览器和 nodejs 这样的宿主环境,使用独立操作系统目标构建可执行文件。这是一个使用 nodejs 运行编译为 WebAssembly 的 Zig 代码的示例。</p>
      <figure><figcaption class="zig-cap"><cite class="file">math.zig</cite></figcaption><pre><code><span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">print</span>(<span class="tok-type">i32</span>) <span class="tok-type">void</span>;

<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(a: <span class="tok-type">i32</span>, b: <span class="tok-type">i32</span>) <span class="tok-type">void</span> {
    print(a + b);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe math.zig -target wasm32-freestanding -fno-entry --export=add</kbd>
</samp></pre></figure>

      <figure><figcaption class="javascript-cap"><cite class="file">test.js</cite></figcaption><pre><code>const fs = require('fs');
const source = fs.readFileSync("./math.wasm");
const typedArray = new Uint8Array(source);

WebAssembly.instantiate(typedArray, {
  env: {
    print: (result) =&gt; { console.log(`The result is ${result}`); }
  }}).then(result =&gt; {
  const add = result.instance.exports.add;
  add(1, 2);
});</code></pre></figure>
      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>node test.js</kbd>
The result is 3
</samp></pre></figure>
      
      <h3 id="WASI"><a href="https://ziglang.org/documentation/0.15.2/#toc-WASI">WASI</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#WASI">§</a></h3>

      <p>Zig 对 WebAssembly 系统接口 (WASI) 的支持正在积极开发中。
      使用标准库和读取命令行参数的示例:</p>
      <figure><figcaption class="zig-cap"><cite class="file">wasi_args.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> general_purpose_allocator: std.heap.GeneralPurposeAllocator(.{}) = .init;
    <span class="tok-kw">const</span> gpa = general_purpose_allocator.allocator();
    <span class="tok-kw">const</span> args = <span class="tok-kw">try</span> std.process.argsAlloc(gpa);
    <span class="tok-kw">defer</span> std.process.argsFree(gpa, args);

    <span class="tok-kw">for</span> (args, <span class="tok-number">0</span>..) |arg, i| {
        std.debug.print(<span class="tok-str">"{}: {s}\n"</span>, .{ i, arg });
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe wasi_args.zig -target wasm32-wasi</kbd>
</samp></pre></figure>

      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>wasmtime wasi_args.wasm 123 hello</kbd>
0: wasi_args.wasm
1: 123
2: hello
</samp></pre></figure>
      <p>一个更有趣的示例是从运行时提取预打开列表。
      这现在通过 <code>std.fs.wasi.Preopens</code> 在标准库中得到支持:</p>
      <figure><figcaption class="zig-cap"><cite class="file">wasi_preopens.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> fs = std.fs;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> general_purpose_allocator: std.heap.GeneralPurposeAllocator(.{}) = .init;
    <span class="tok-kw">const</span> gpa = general_purpose_allocator.allocator();

    <span class="tok-kw">var</span> arena_instance = std.heap.ArenaAllocator.init(gpa);
    <span class="tok-kw">defer</span> arena_instance.deinit();
    <span class="tok-kw">const</span> arena = arena_instance.allocator();

    <span class="tok-kw">const</span> preopens = <span class="tok-kw">try</span> fs.wasi.preopensAlloc(arena);

    <span class="tok-kw">for</span> (preopens.names, <span class="tok-number">0</span>..) |preopen, i| {
        std.debug.print(<span class="tok-str">"{}: {s}\n"</span>, .{ i, preopen });
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe wasi_preopens.zig -target wasm32-wasi</kbd>
</samp></pre></figure>

      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>wasmtime --dir=. wasi_preopens.wasm</kbd>
0: stdin
1: stdout
2: stderr
3: .
</samp></pre></figure>
      
      
      <h2 id="Targets"><a href="https://ziglang.org/documentation/0.15.2/#toc-Targets">目标</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Targets">§</a></h2>

      <p>
      <strong>目标</strong>指的是将用于运行可执行文件的计算机。它由 CPU 架构、启用的 CPU 特性集、操作系统、最小和最大操作系统版本、ABI 和 ABI 版本组成。
      </p>
      <p>
      Zig 是一种通用编程语言,这意味着它被设计为针对大量目标生成最优代码。命令 <code>zig targets</code> 提供有关编译器所知的所有目标的信息。</p>
      <p>当没有向编译器提供目标选项时,默认选择是以<strong>宿主计算机</strong>为目标,这意味着生成的可执行文件<em>不适合复制到另一台计算机</em>。为了将可执行文件复制到另一台计算机,编译器需要通过 <code>-target</code> 选项了解目标要求。
      </p>
      <p>
      Zig 标准库(<code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>)</code>)具有跨平台抽象,使相同的源代码可以在许多目标上运行。有些代码比其他代码更具可移植性。通常,Zig 代码与其他编程语言相比具有极高的可移植性。
      </p>
      <p>
      每个平台都需要自己的实现以使 Zig 的跨平台抽象正常工作。这些实现处于不同的完成程度。编译器的每个标记发布都附带发布说明,其中提供每个目标的完整支持表。
      </p>
      
      <h2 id="Style-Guide"><a href="https://ziglang.org/documentation/0.15.2/#toc-Style-Guide">风格指南</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Style-Guide">§</a></h2>

      <p>
这些编码约定不由编译器强制执行,但它们与编译器一起在本文档中提供,以便在任何人希望引用公认的 Zig 编码风格权威时提供参考点。
      </p>
      <h3 id="Avoid-Redundancy-in-Names"><a href="https://ziglang.org/documentation/0.15.2/#toc-Avoid-Redundancy-in-Names">避免名称中的冗余</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Avoid-Redundancy-in-Names">§</a></h3>

      <p>避免在类型名称中使用这些词:</p>
      <ul>
        <li>Value</li>
        <li>Data</li>
        <li>Context</li>
        <li>Manager</li>
        <li>utils、misc 或某人的首字母缩写</li>
      </ul>
      <p>一切都是值,所有类型都是数据,一切都是上下文,所有逻辑都管理状态。使用适用于所有类型的词不会传达任何信息。</p>
      <p>使用"实用程序"、"杂项"或某人的首字母缩写的诱惑是分类失败,或者更常见的是过度分类。此类声明可以存在于需要它们的模块的根部,无需命名空间。</p>
      

      <h3 id="Avoid-Redundant-Names-in-Fully-Qualified-Namespaces"><a href="https://ziglang.org/documentation/0.15.2/#toc-Avoid-Redundant-Names-in-Fully-Qualified-Namespaces">避免完全限定命名空间中的冗余名称</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Avoid-Redundant-Names-in-Fully-Qualified-Namespaces">§</a></h3>

      <p>编译器为每个声明分配一个<strong>完全限定命名空间</strong>,创建一个树结构。根据完全限定的命名空间选择名称,并避免冗余的名称段。</p>
      <figure><figcaption class="zig-cap"><cite class="file">redundant_fqn.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> json = <span class="tok-kw">struct</span> {
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> JsonValue = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        number: <span class="tok-type">f64</span>,
        boolean: <span class="tok-type">bool</span>,
        <span class="tok-comment">// ...</span>
    };
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    std.debug.print(<span class="tok-str">"{s}\n"</span>, .{<span class="tok-builtin">@typeName</span>(json.JsonValue)});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe redundant_fqn.zig</kbd>
$ <kbd>./redundant_fqn</kbd>
redundant_fqn.json.JsonValue
</samp></pre></figure>

      <p>在此示例中,"json"在完全限定的命名空间中重复。解决方案是从 <code>JsonValue</code> 中删除 <code>Json</code>。在这个示例中,我们有一个名为 <code>json</code> 的空结构,但请记住文件也充当完全限定命名空间的一部分。</p>
      <p>此示例是<a href="https://ziglang.org/documentation/0.15.2/#Avoid-Redundancy-in-Names">避免名称中的冗余</a>中指定规则的例外。类型的含义已缩减为其核心:它是一个 json 值。该名称不能在不正确的情况下更具体。</p>
      

      <h3 id="Whitespace"><a href="https://ziglang.org/documentation/0.15.2/#toc-Whitespace">空白</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Whitespace">§</a></h3>

      <ul>
        <li>
          4 空格缩进
        </li>
        <li>
          在同一行上打开大括号,除非需要换行。
        </li>
        <li>如果事物列表长度超过 2,则将每个项目放在自己的行上,并在末尾放置一个额外的逗号。
        </li>
        <li>
          行长度:目标为 100;使用常识。
        </li>
      </ul>
      
      <h3 id="Names"><a href="https://ziglang.org/documentation/0.15.2/#toc-Names">名称</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Names">§</a></h3>

      <p>
      大致来说:<code>camelCaseFunctionName</code>、<code>TitleCaseTypeName</code>、<code>snake_case_variable_name</code>。更准确地说:
      </p>
      <ul>
        <li>
            如果 <code>x</code> 是 <code><span class="tok-type">type</span></code>,那么 <code>x</code> 应该是 <code>TitleCase</code>,除非它是一个包含 0 个字段且永远不会被实例化的 <code><span class="tok-kw">struct</span></code>,在这种情况下它被视为"命名空间"并使用 <code>snake_case</code>。
        </li>
        <li>
            如果 <code>x</code> 是可调用的,并且 <code>x</code> 的返回类型是 <code><span class="tok-type">type</span></code>,那么 <code>x</code> 应该是 <code>TitleCase</code>。
        </li>
        <li>
            如果 <code>x</code> 在其他情况下是可调用的,那么 <code>x</code> 应该是 <code>camelCase</code>。
        </li>
        <li>
            否则,<code>x</code> 应该是 <code>snake_case</code>。
        </li>
      </ul>
      <p>
      首字母缩略词、首字母缩写词、专有名词或书面英语中具有大写规则的任何其他单词都与任何其他单词一样受命名约定的约束。甚至只有 2 个字母长的首字母缩略词也受这些约定的约束。
      </p>
      <p>
      文件名分为两类:类型和命名空间。如果文件(隐式为结构)具有顶级字段,则应使用 <code class="file">TitleCase</code> 像任何其他具有字段的结构一样命名。否则,应使用 <code class="file">snake_case</code>。目录名称应为 <code class="file">snake_case</code>。
      </p>
      <p>
      这些是一般经验法则;如果做不同的事情更有意义,那就做有意义的事情。例如,如果有一个既定的约定,如 <code>ENOENT</code>,遵循既定的约定。
      </p>
      
      <h3 id="Examples"><a href="https://ziglang.org/documentation/0.15.2/#toc-Examples">示例</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Examples">§</a></h3>

      <figure><figcaption class="zig-cap"><cite class="file">style_example.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> namespace_name = <span class="tok-builtin">@import</span>(<span class="tok-str">"dir_name/file_name.zig"</span>);
<span class="tok-kw">const</span> TypeName = <span class="tok-builtin">@import</span>(<span class="tok-str">"dir_name/TypeName.zig"</span>);
<span class="tok-kw">var</span> global_var: <span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;
<span class="tok-kw">const</span> const_name = <span class="tok-number">42</span>;
<span class="tok-kw">const</span> primitive_type_alias = <span class="tok-type">f32</span>;
<span class="tok-kw">const</span> string_alias = []<span class="tok-type">u8</span>;

<span class="tok-kw">const</span> StructName = <span class="tok-kw">struct</span> {
    field: <span class="tok-type">i32</span>,
};
<span class="tok-kw">const</span> StructAlias = StructName;

<span class="tok-kw">fn</span> <span class="tok-fn">functionName</span>(param_name: TypeName) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> functionPointer = functionName;
    functionPointer();
    functionPointer = otherFunction;
    functionPointer();
}
<span class="tok-kw">const</span> functionAlias = functionName;

<span class="tok-kw">fn</span> <span class="tok-fn">ListTemplateFunction</span>(<span class="tok-kw">comptime</span> ChildType: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> fixed_size: <span class="tok-type">usize</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> List(ChildType, fixed_size);
}

<span class="tok-kw">fn</span> <span class="tok-fn">ShortList</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        field_name: [n]T,
        <span class="tok-kw">fn</span> <span class="tok-fn">methodName</span>() <span class="tok-type">void</span> {}
    };
}

<span class="tok-comment">// The word XML loses its casing when used in Zig identifiers.</span>
<span class="tok-kw">const</span> xml_document =
    <span class="tok-str">\\&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
    <span class="tok-str">\\&lt;document&gt;</span>
    <span class="tok-str">\\&lt;/document&gt;</span>
;
<span class="tok-kw">const</span> XmlParser = <span class="tok-kw">struct</span> {
    field: <span class="tok-type">i32</span>,
};

<span class="tok-comment">// The initials BE (Big Endian) are just another word in Zig identifier names.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">readU32Be</span>() <span class="tok-type">u32</span> {}</code></pre></figure>
      <p>
      有关更多示例,请参阅 <a href="https://ziglang.org/documentation/0.15.2/#Zig-Standard-Library">Zig 标准库</a>。
      </p>
      
      <h3 id="Doc-Comment-Guidance"><a href="https://ziglang.org/documentation/0.15.2/#toc-Doc-Comment-Guidance">文档注释指南</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Doc-Comment-Guidance">§</a></h3>

      <ul>
        <li>省略基于所记录事物的名称而冗余的任何信息。</li>
        <li>鼓励在多个类似函数上复制信息,因为它有助于 IDE 和其他工具提供更好的帮助文本。</li>
        <li>使用词<strong>假设</strong>来表示在违反时导致<em>未检查</em><a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>的不变量。</li>
        <li>使用词<strong>断言</strong>来表示在违反时导致<em>安全检查</em><a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>的不变量。</li>
      </ul>
      
      
      <h2 id="Source-Encoding"><a href="https://ziglang.org/documentation/0.15.2/#toc-Source-Encoding">源码编码</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Source-Encoding">§</a></h2>

      <p>Zig 源代码以 UTF-8 编码。无效的 UTF-8 字节序列会导致编译错误。</p>
      <p>在所有 zig 源代码中(包括在注释中),永远不允许某些码位:</p>
      <ul>
        <li>Ascii 控制字符,除了 U+000a (LF)、U+000d (CR) 和 U+0009 (HT):U+0000 - U+0008、U+000b - U+000c、U+000e - U+0001f、U+007f。</li>
        <li>非 Ascii Unicode 行结束符:U+0085 (NEL)、U+2028 (LS)、U+2029 (PS)。</li>
      </ul>
      <p>
      LF(字节值 0x0a,码位 U+000a,<code><span class="tok-str">'\n'</span></code>)是 Zig 源代码中的行终止符。此字节值终止 zig 源代码的每一行,除了文件的最后一行。建议非空源文件以空行结尾,这意味着最后一个字节将是 0x0a (LF)。
      </p>
      <p>
      每个 LF 可以紧接着一个 CR(字节值 0x0d,码位 U+000d,<code><span class="tok-str">'\r'</span></code>)形成 Windows 样式的行尾,但这是不鼓励的。请注意,在多行字符串中,CRLF 序列在编译到 zig 程序中时将被编码为 LF。在任何其他上下文中都不允许 CR。
      </p>
      <p>
      HT 硬制表符(字节值 0x09,码位 U+0009,<code><span class="tok-str">'\t'</span></code>)作为标记分隔符可与 SP 空格(字节值 0x20,码位 U+0020,<code><span class="tok-str">' '</span></code>)互换使用,但不鼓励使用硬制表符。参见<a href="https://ziglang.org/documentation/0.15.2/#Grammar">语法</a>。
      </p>
      <p>
      为了与其他工具兼容,如果 UTF-8 编码的字节顺序标记(U+FEFF)是源文本中的第一个 Unicode 码位,编译器会忽略它。源代码中的任何其他位置都不允许字节顺序标记。
      </p>
      <p>
      请注意,在源文件上运行 <kbd>zig fmt</kbd> 将实现此处提到的所有建议。
      </p>
      <p>
      请注意,读取 Zig 源代码的工具可以在假定源代码是正确的 Zig 代码的情况下做出假设。例如,在识别行尾时,工具可以使用简单的搜索,如 <code>/\n/</code>,或<a href="https://msdn.microsoft.com/en-us/library/dd409797.aspx">高级</a>搜索,如 <code>/\r\n?|[\n\u0085\u2028\u2029]/</code>,在任何一种情况下,行尾都将被正确识别。再例如,在识别一行第一个标记之前的空白时,工具可以使用简单的搜索,如 <code>/[ \t]/</code>,或<a href="https://tc39.es/ecma262/#sec-characterclassescape">高级</a>搜索,如 <code>/\s/</code>,在任何一种情况下,空白都将被正确识别。
      </p>
      

      <h2 id="Keyword-Reference"><a href="https://ziglang.org/documentation/0.15.2/#toc-Keyword-Reference">关键字参考</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Keyword-Reference">§</a></h2>

      <div class="table-wrapper">
      <table>
        <thead>
        <tr>
          <th scope="col">关键字</th>
          <th scope="col">描述</th>
        </tr>
        </thead>
        <tbody>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">addrspace</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">addrspace</span></code> 关键字。
            <ul>
              <li>TODO 添加 addrspace 的文档</li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">align</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">align</span></code> 可用于指定指针的对齐。它也可以在变量或函数声明之后使用,以指定指向该变量或函数的指针的对齐。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Alignment">对齐</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">allowzero</span></code></pre>
          </th>
          <td>
            指针属性 <code><span class="tok-kw">allowzero</span></code> 允许指针具有地址零。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#allowzero">allowzero</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">and</span></code></pre>
          </th>
          <td>
            布尔运算符 <code><span class="tok-kw">and</span></code>。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Operators">运算符</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">anyframe</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">anyframe</span></code> 可用作保存指向函数帧的指针的变量的类型。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Async-Functions">异步函数</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">anytype</span></code></pre>
          </th>
          <td>
            函数参数可以用 <code><span class="tok-kw">anytype</span></code> 代替类型进行声明。类型将在调用函数的位置推断。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Function-Parameter-Type-Inference">函数参数类型推断</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">asm</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">asm</span></code> 开始一个内联汇编表达式。这允许直接控制编译时生成的机器代码。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Assembly">汇编</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">break</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">break</span></code> 可以与块标签一起使用以从块返回值。它也可以用于在迭代自然完成之前退出循环。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Blocks">块</a>、<a href="https://ziglang.org/documentation/0.15.2/#while">while</a>、<a href="https://ziglang.org/documentation/0.15.2/#for">for</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">callconv</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">callconv</span></code> 可用于在函数类型中指定调用约定。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Functions">函数</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">catch</span></code></pre>
          </th>
          <td>
            如果它之前的表达式计算为错误,则可以使用 <code><span class="tok-kw">catch</span></code> 来计算表达式。<code><span class="tok-kw">catch</span></code> 之后的表达式可以选择捕获错误值。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#catch">catch</a>、<a href="https://ziglang.org/documentation/0.15.2/#Operators">运算符</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">comptime</span></code></pre>
          </th>
          <td>
            声明前的 <code><span class="tok-kw">comptime</span></code> 可用于将变量或函数参数标记为在编译时已知。它也可以用于保证表达式在编译时运行。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">const</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">const</span></code> 声明一个无法修改的变量。用作指针属性时,它表示指针引用的值无法修改。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Variables">变量</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">continue</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">continue</span></code> 可以在循环中使用以跳回到循环的开始。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#while">while</a>、<a href="https://ziglang.org/documentation/0.15.2/#for">for</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">defer</span></code></pre>
          </th>
          <td>
            当控制流离开当前块时,<code><span class="tok-kw">defer</span></code> 将执行一个表达式。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#defer">defer</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">else</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">else</span></code> 可用于为 <code><span class="tok-kw">if</span></code>、<code><span class="tok-kw">switch</span></code>、<code><span class="tok-kw">while</span></code> 和 <code><span class="tok-kw">for</span></code> 表达式提供备用分支。
            <ul>
              <li>如果在 if 表达式之后使用,如果测试值返回 false、null 或错误,则将执行 else 分支。</li>
              <li>如果在 switch 表达式中使用,如果测试值不匹配其他情况,则将执行 else 分支。</li>
              <li>如果在循环表达式之后使用,如果循环在没有中断的情况下完成,则将执行 else 分支。</li>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#if">if</a>、<a href="https://ziglang.org/documentation/0.15.2/#switch">switch</a>、<a href="https://ziglang.org/documentation/0.15.2/#while">while</a>、<a href="https://ziglang.org/documentation/0.15.2/#for">for</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">enum</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">enum</span></code> 定义一个枚举类型。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#enum">enum</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">errdefer</span></code></pre>
          </th>
          <td>
            如果函数返回错误,当控制流离开当前块时,<code><span class="tok-kw">errdefer</span></code> 将执行一个表达式,errdefer 表达式可以捕获解包的值。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#errdefer">errdefer</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">error</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">error</span></code> 定义一个错误类型。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Errors">错误</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">export</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">export</span></code> 使函数或变量在生成的目标文件中外部可见。导出的函数默认使用 C 调用约定。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Functions">函数</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">extern</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">extern</span></code> 可用于声明将在静态链接时或在动态链接时在运行时解析的函数或变量。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Functions">函数</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">fn</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">fn</span></code> 声明一个函数。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Functions">函数</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">for</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">for</span></code> 表达式可用于迭代切片、数组或元组的元素。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#for">for</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">if</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">if</span></code> 表达式可以测试布尔表达式、可选值或错误联合。对于可选值或错误联合,if 表达式可以捕获解包的值。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#if">if</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">inline</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">inline</span></code> 可用于标记循环表达式,使其在编译时展开。它也可以用于强制函数在所有调用位置内联。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#inline-while">inline while</a>、<a href="https://ziglang.org/documentation/0.15.2/#inline-for">inline for</a>、<a href="https://ziglang.org/documentation/0.15.2/#Functions">函数</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">linksection</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">linksection</span></code> 关键字可用于指定函数或全局变量将放入哪个节(例如 <code>.text</code>)。
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">noalias</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">noalias</span></code> 关键字。
            <ul>
              <li>TODO 添加 noalias 的文档</li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">noinline</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">noinline</span></code> 禁止函数在所有调用位置内联。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Functions">函数</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">nosuspend</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">nosuspend</span></code> 关键字可用于块、语句或表达式之前,以标记未到达挂起点的范围。特别是,在 <code><span class="tok-kw">nosuspend</span></code> 范围内:
            <ul>
              <li>使用 <code><span class="tok-kw">suspend</span></code> 关键字会导致编译错误。</li>
              <li>对尚未完成的函数帧使用 <code>await</code> 会导致安全检查的<a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>。</li>
              <li>调用异步函数可能导致安全检查的<a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>,因为它等效于 <code>await async some_async_fn()</code>,其中包含 <code>await</code>。</li>
            </ul>
            <code><span class="tok-kw">nosuspend</span></code> 范围内的代码不会导致封闭函数成为<a href="https://ziglang.org/documentation/0.15.2/#Async-Functions">异步函数</a>。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Async-Functions">异步函数</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">opaque</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">opaque</span></code> 定义一个不透明类型。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#opaque">opaque</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">or</span></code></pre>
          </th>
          <td>
            布尔运算符 <code><span class="tok-kw">or</span></code>。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Operators">运算符</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">orelse</span></code></pre>
          </th>
          <td>
            如果它之前的表达式计算为 null,则可以使用 <code><span class="tok-kw">orelse</span></code> 来计算表达式。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Optionals">可选值</a>、<a href="https://ziglang.org/documentation/0.15.2/#Operators">运算符</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">packed</span></code></pre>
          </th>
          <td>
            struct 定义前的 <code><span class="tok-kw">packed</span></code> 关键字会将 struct 的内存布局更改为保证的 <code><span class="tok-kw">packed</span></code> 布局。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#packed-struct">packed struct</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">pub</span></code></pre>
          </th>
          <td>
            顶级声明前的 <code><span class="tok-kw">pub</span></code> 使该声明可以从声明它的文件以外的文件中引用。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#import">import</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">resume</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">resume</span></code> 将在函数挂起的点之后继续执行函数帧。
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">return</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">return</span></code> 使用一个值退出函数。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Functions">函数</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">struct</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">struct</span></code> 定义一个结构。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#struct">struct</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">suspend</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">suspend</span></code> 将使控制流返回到函数的调用位置或恢复者。<code><span class="tok-kw">suspend</span></code> 也可以在函数内的块之前使用,以允许函数在控制流返回到调用位置之前访问其帧。
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">switch</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">switch</span></code> 表达式可用于测试通用类型的值。<code><span class="tok-kw">switch</span></code> case 可以捕获<a href="https://ziglang.org/documentation/0.15.2/#Tagged-union">标记联合</a>的字段值。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#switch">switch</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">test</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">test</span></code> 关键字可用于表示用于确保行为符合预期的顶级代码块。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Zig-Test">Zig 测试</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">threadlocal</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">threadlocal</span></code> 可用于将变量指定为线程局部。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Thread-Local-Variables">线程局部变量</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">try</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">try</span></code> 计算错误联合表达式。如果它是错误,则使用相同的错误从当前函数返回。否则,表达式结果为解包的值。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#try">try</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">union</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">union</span></code> 定义一个联合。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#union">union</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">unreachable</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">unreachable</span></code> 可用于断言控制流永远不会到达特定位置。根据构建模式,<code><span class="tok-kw">unreachable</span></code> 可能会触发 panic。
            <ul>
              <li>在 <code>Debug</code> 和 <code>ReleaseSafe</code> 模式下触发 panic,或使用 <kbd>zig test</kbd> 时。</li>
              <li>在 <code>ReleaseFast</code> 和 <code>ReleaseSmall</code> 模式下不触发 panic。</li>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#unreachable">unreachable</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">var</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">var</span></code> 声明一个可以修改的变量。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Variables">变量</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">volatile</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">volatile</span></code> 可用于表示指针的加载或存储具有副作用。它也可以修改内联汇编表达式以表示它具有副作用。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#volatile">volatile</a>、<a href="https://ziglang.org/documentation/0.15.2/#Assembly">汇编</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">while</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">while</span></code> 表达式可用于重复测试布尔、可选或错误联合表达式,并在该表达式分别计算为 false、null 或错误时停止循环。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#while">while</a></li>
            </ul>
          </td>
        </tr>
        </tbody>
      </table>
      </div>
      

      <h2 id="Appendix"><a href="https://ziglang.org/documentation/0.15.2/#toc-Appendix">附录</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Appendix">§</a></h2>

      <h3 id="Containers"><a href="https://ziglang.org/documentation/0.15.2/#toc-Containers">容器</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Containers">§</a></h3>

      <p>
      Zig 中的<em>容器</em>是充当命名空间以保存<a href="https://ziglang.org/documentation/0.15.2/#Container-Level-Variables">变量</a>和<a href="https://ziglang.org/documentation/0.15.2/#Functions">函数</a>声明的任何语法结构。容器也是可以实例化的类型定义。<a href="https://ziglang.org/documentation/0.15.2/#struct">结构</a>、<a href="https://ziglang.org/documentation/0.15.2/#enum">枚举</a>、<a href="https://ziglang.org/documentation/0.15.2/#union">联合</a>、<a href="https://ziglang.org/documentation/0.15.2/#opaque">不透明</a>,甚至 Zig 源文件本身都是容器。
      </p>
      <p>
      尽管容器(除 Zig 源文件外)使用花括号包围其定义,但它们不应与<a href="https://ziglang.org/documentation/0.15.2/#Blocks">块</a>或函数混淆。容器不包含语句。
      </p>
      

      <h3 id="Grammar"><a href="https://ziglang.org/documentation/0.15.2/#toc-Grammar">语法</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Grammar">§</a></h3>