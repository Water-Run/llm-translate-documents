<figure><figcaption class="zig-cap"><cite class="file">test_unresolved_comptime_value.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">max</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T) T {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (a &gt; b) a <span class="tok-kw">else</span> b;
}
<span class="tok-kw">test</span> <span class="tok-str">"try to pass a runtime type"</span> {
    foo(<span class="tok-null">false</span>);
}
<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(condition: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = max(<span class="tok-kw">if</span> (condition) <span class="tok-type">f32</span> <span class="tok-kw">else</span> <span class="tok-type">u64</span>, <span class="tok-number">1234</span>, <span class="tok-number">5678</span>);
    _ = result;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_unresolved_comptime_value.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_unresolved_comptime_value.zig:8:28: </span><span class="sgr-31m">error: </span><span class="sgr-1m">unable to resolve comptime value
</span>    const result = max(if (condition) f32 else u64, 1234, 5678);
                           <span class="sgr-32m">^~~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_unresolved_comptime_value.zig:8:24: </span><span class="sgr-36m">note: </span><span class="sgr-1m">argument to comptime parameter must be comptime-known
</span>    const result = max(if (condition) f32 else u64, 1234, 5678);
                       <span class="sgr-32m">^~~~~~~~~~~~~~~~~~~~~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_unresolved_comptime_value.zig:1:8: </span><span class="sgr-36m">note: </span><span class="sgr-1m">parameter declared comptime here
</span>fn max(comptime T: type, a: T, b: T) T {
       <span class="sgr-32m">^~~~~~~~
</span><span class="sgr-2m">referenced by:
    test.try to pass a runtime type: /home/andy/dev/zig/doc/langref/test_unresolved_comptime_value.zig:5:8
</span>
</samp></pre></figure>

      <p>
      这是一个错误,因为程序员尝试将仅在运行时已知的值传递给期望编译时已知值的函数。
      </p>
      <p>
      另一种导致错误的情况是,如果我们传递的类型在分析函数时违反了类型检查器的规则。这就是<em>编译时鸭子类型</em>的含义。
      </p>
      <p>
      例如:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_mismatched_type.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">max</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T) T {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (a &gt; b) a <span class="tok-kw">else</span> b;
}
<span class="tok-kw">test</span> <span class="tok-str">"try to compare bools"</span> {
    _ = max(<span class="tok-type">bool</span>, <span class="tok-null">true</span>, <span class="tok-null">false</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_mismatched_type.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_mismatched_type.zig:2:18: </span><span class="sgr-31m">error: </span><span class="sgr-1m">operator &gt; not allowed for type 'bool'
</span>    return if (a &gt; b) a else b;
               <span class="sgr-32m">~~^~~
</span><span class="sgr-2m">referenced by:
    test.try to compare bools: /home/andy/dev/zig/doc/langref/test_comptime_mismatched_type.zig:5:12
</span>
</samp></pre></figure>

      <p>
      另一方面,在带有 <code><span class="tok-kw">comptime</span></code> 参数的函数定义内部,该值在编译时是已知的。这意味着如果我们愿意,实际上可以让它对 bool 类型起作用:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_max_with_bool.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">max</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T) T {
    <span class="tok-kw">if</span> (T == <span class="tok-type">bool</span>) {
        <span class="tok-kw">return</span> a <span class="tok-kw">or</span> b;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a &gt; b) {
        <span class="tok-kw">return</span> a;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> b;
    }
}
<span class="tok-kw">test</span> <span class="tok-str">"try to compare bools"</span> {
    <span class="tok-kw">try</span> <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect(max(<span class="tok-type">bool</span>, <span class="tok-null">false</span>, <span class="tok-null">true</span>) == <span class="tok-null">true</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_max_with_bool.zig</kbd>
1/1 test_comptime_max_with_bool.test.try to compare bools...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      这可以工作,因为当条件在编译时已知时,Zig 会隐式内联 <code><span class="tok-kw">if</span></code> 表达式,并且编译器保证它将跳过对未采用分支的分析。
      </p>
      <p>
      这意味着在这种情况下为 <code>max</code> 生成的实际函数如下所示:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">compiler_generated_function.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">max</span>(a: <span class="tok-type">bool</span>, b: <span class="tok-type">bool</span>) <span class="tok-type">bool</span> {
    {
        <span class="tok-kw">return</span> a <span class="tok-kw">or</span> b;
    }
}</code></pre></figure>

      <p>
      所有处理编译时已知值的代码都被消除了,我们只剩下完成任务所需的运行时代码。
      </p>
      <p>
      对于 <code><span class="tok-kw">switch</span></code> 表达式也是如此 - 当目标表达式在编译时已知时,它们会被隐式内联。
      </p>
      
      <h4 id="Compile-Time-Variables"><a href="https://ziglang.org/documentation/0.15.2/#toc-Compile-Time-Variables">编译时变量</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Compile-Time-Variables">§</a></h4>

      <p>
      在 Zig 中,程序员可以将变量标记为 <code><span class="tok-kw">comptime</span></code>。这向编译器保证变量的每次加载和存储都在编译时执行。任何违反此规则的行为都会导致编译错误。
      </p>
      <p>
      这与我们可以 <code><span class="tok-kw">inline</span></code> 循环的事实相结合,使我们能够编写部分在编译时求值、部分在运行时求值的函数。
      </p>
      <p>
      例如:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_evaluation.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">const</span> CmdFn = <span class="tok-kw">struct</span> {
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    func: <span class="tok-kw">fn</span> (<span class="tok-type">i32</span>) <span class="tok-type">i32</span>,
};

<span class="tok-kw">const</span> cmd_fns = [_]CmdFn{
    CmdFn{ .name = <span class="tok-str">"one"</span>, .func = one },
    CmdFn{ .name = <span class="tok-str">"two"</span>, .func = two },
    CmdFn{ .name = <span class="tok-str">"three"</span>, .func = three },
};
<span class="tok-kw">fn</span> <span class="tok-fn">one</span>(value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> value + <span class="tok-number">1</span>;
}
<span class="tok-kw">fn</span> <span class="tok-fn">two</span>(value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> value + <span class="tok-number">2</span>;
}
<span class="tok-kw">fn</span> <span class="tok-fn">three</span>(value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> value + <span class="tok-number">3</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">performFn</span>(<span class="tok-kw">comptime</span> prefix_char: <span class="tok-type">u8</span>, start_value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> result: <span class="tok-type">i32</span> = start_value;
    <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> i = <span class="tok-number">0</span>;
    <span class="tok-kw">inline</span> <span class="tok-kw">while</span> (i &lt; cmd_fns.len) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (cmd_fns[i].name[<span class="tok-number">0</span>] == prefix_char) {
            result = cmd_fns[i].func(result);
        }
    }
    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">test</span> <span class="tok-str">"perform fn"</span> {
    <span class="tok-kw">try</span> expect(performFn(<span class="tok-str">'t'</span>, <span class="tok-number">1</span>) == <span class="tok-number">6</span>);
    <span class="tok-kw">try</span> expect(performFn(<span class="tok-str">'o'</span>, <span class="tok-number">0</span>) == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> expect(performFn(<span class="tok-str">'w'</span>, <span class="tok-number">99</span>) == <span class="tok-number">99</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_evaluation.zig</kbd>
1/1 test_comptime_evaluation.test.perform fn...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      这个例子有点牵强,因为编译时求值组件是不必要的;如果全部在运行时完成,此代码也能正常工作。但它确实生成了不同的代码。在这个例子中,函数 <code>performFn</code> 针对提供的不同 <code>prefix_char</code> 值生成了三次:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">performFn_1</cite></figcaption><pre><code><span class="tok-comment">// 来自这一行:</span>
<span class="tok-comment">// expect(performFn('t', 1) == 6);</span>
<span class="tok-kw">fn</span> <span class="tok-fn">performFn</span>(start_value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> result: <span class="tok-type">i32</span> = start_value;
    result = two(result);
    result = three(result);
    <span class="tok-kw">return</span> result;
}</code></pre></figure>
      <figure><figcaption class="zig-cap"><cite class="file">performFn_2</cite></figcaption><pre><code><span class="tok-comment">// 来自这一行:</span>
<span class="tok-comment">// expect(performFn('o', 0) == 1);</span>
<span class="tok-kw">fn</span> <span class="tok-fn">performFn</span>(start_value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> result: <span class="tok-type">i32</span> = start_value;
    result = one(result);
    <span class="tok-kw">return</span> result;
}</code></pre></figure>
      <figure><figcaption class="zig-cap"><cite class="file">performFn_3</cite></figcaption><pre><code><span class="tok-comment">// 来自这一行:</span>
<span class="tok-comment">// expect(performFn('w', 99) == 99);</span>
<span class="tok-kw">fn</span> <span class="tok-fn">performFn</span>(start_value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> result: <span class="tok-type">i32</span> = start_value;
    _ = &amp;result;
    <span class="tok-kw">return</span> result;
}</code></pre></figure>
      <p>
      注意,即使在调试构建中也会发生这种情况。
      这不是一种编写更优化代码的方式,而是一种确保<em>应该</em>在编译时发生的事情<em>确实</em>在编译时发生的方式。这可以捕获更多错误并允许表达能力,在其他语言中需要使用宏、生成的代码或预处理器才能实现。
      </p>
      
      <h4 id="Compile-Time-Expressions"><a href="https://ziglang.org/documentation/0.15.2/#toc-Compile-Time-Expressions">编译时表达式</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Compile-Time-Expressions">§</a></h4>

      <p>
      在 Zig 中,给定表达式是在编译时已知还是在运行时已知很重要。程序员可以使用 <code><span class="tok-kw">comptime</span></code> 表达式来保证表达式将在编译时求值。如果无法做到这一点,编译器将发出错误。例如:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_call_extern_function.zig</cite></figcaption><pre><code><span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">exit</span>() <span class="tok-type">noreturn</span>;

<span class="tok-kw">test</span> <span class="tok-str">"foo"</span> {
    <span class="tok-kw">comptime</span> {
        exit();
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_call_extern_function.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_call_extern_function.zig:5:13: </span><span class="sgr-31m">error: </span><span class="sgr-1m">comptime call of extern function
</span>        exit();
        <span class="sgr-32m">~~~~^~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_call_extern_function.zig:4:5: </span><span class="sgr-36m">note: </span><span class="sgr-1m">'comptime' keyword forces comptime evaluation
</span>    comptime {
    <span class="sgr-32m">^~~~~~~~
</span>
</samp></pre></figure>

      <p>
      程序在编译时调用 <code>exit()</code>(或任何其他外部函数)是没有意义的,所以这是一个编译错误。然而,<code><span class="tok-kw">comptime</span></code> 表达式的作用远不止有时会导致编译错误。
      </p>
      <p>
      在 <code><span class="tok-kw">comptime</span></code> 表达式中:
      </p>
      <ul>
          <li>所有变量都是 <code><span class="tok-kw">comptime</span></code> 变量。</li>
          <li>所有 <code><span class="tok-kw">if</span></code>、<code><span class="tok-kw">while</span></code>、<code><span class="tok-kw">for</span></code> 和 <code><span class="tok-kw">switch</span></code>
          表达式在编译时求值,或者如果无法做到则发出编译错误。</li>
          <li>所有 <code><span class="tok-kw">return</span></code> 和 <code><span class="tok-kw">try</span></code> 表达式都是无效的(除非函数本身在编译时调用)。</li>
          <li>所有具有运行时副作用或依赖于运行时值的代码都会发出编译错误。</li>
          <li>所有函数调用都会导致编译器在编译时解释函数,如果函数试图做具有全局运行时副作用的事情,则发出编译错误。</li>
      </ul>
      <p>
      这意味着程序员可以创建一个在编译时和运行时都被调用的函数,而无需对函数进行修改。
      </p>
      <p>
      让我们看一个例子:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_fibonacci_recursion.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">fn</span> <span class="tok-fn">fibonacci</span>(index: <span class="tok-type">u32</span>) <span class="tok-type">u32</span> {
    <span class="tok-kw">if</span> (index &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> index;
    <span class="tok-kw">return</span> fibonacci(index - <span class="tok-number">1</span>) + fibonacci(index - <span class="tok-number">2</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"fibonacci"</span> {
    <span class="tok-comment">// 在运行时测试 fibonacci</span>
    <span class="tok-kw">try</span> expect(fibonacci(<span class="tok-number">7</span>) == <span class="tok-number">13</span>);

    <span class="tok-comment">// 在编译时测试 fibonacci</span>
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> expect(fibonacci(<span class="tok-number">7</span>) == <span class="tok-number">13</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_fibonacci_recursion.zig</kbd>
1/1 test_fibonacci_recursion.test.fibonacci...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      想象一下,如果我们忘记了递归函数的基本情况并尝试运行测试:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_fibonacci_comptime_overflow.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">fn</span> <span class="tok-fn">fibonacci</span>(index: <span class="tok-type">u32</span>) <span class="tok-type">u32</span> {
    <span class="tok-comment">//if (index &lt; 2) return index;</span>
    <span class="tok-kw">return</span> fibonacci(index - <span class="tok-number">1</span>) + fibonacci(index - <span class="tok-number">2</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"fibonacci"</span> {
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> expect(fibonacci(<span class="tok-number">7</span>) == <span class="tok-number">13</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_fibonacci_comptime_overflow.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_fibonacci_comptime_overflow.zig:5:28: </span><span class="sgr-31m">error: </span><span class="sgr-1m">overflow of integer type 'u32' with value '-1'
</span>    return fibonacci(index - 1) + fibonacci(index - 2);
                     <span class="sgr-32m">~~~~~~^~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_fibonacci_comptime_overflow.zig:5:21: </span><span class="sgr-36m">note: </span><span class="sgr-1m">called at comptime here</span><span class="sgr-2m"> (7 times)
</span>    return fibonacci(index - 1) + fibonacci(index - 2);
           <span class="sgr-32m">~~~~~~~~~^~~~~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_fibonacci_comptime_overflow.zig:9:34: </span><span class="sgr-36m">note: </span><span class="sgr-1m">called at comptime here
</span>    try comptime expect(fibonacci(7) == 13);
                        <span class="sgr-32m">~~~~~~~~~^~~
</span>
</samp></pre></figure>

      <p>
      编译器产生一个错误,这是尝试在编译时求值函数的堆栈跟踪。
      </p>
      <p>
      幸运的是,我们使用了无符号整数,所以当我们尝试从 0 减去 1 时,它触发了<a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>,如果编译器知道它发生了,这总是一个编译错误。
      但是如果我们使用有符号整数会发生什么?
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">fibonacci_comptime_infinite_recursion.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.assert;

<span class="tok-kw">fn</span> <span class="tok-fn">fibonacci</span>(index: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-comment">//if (index &lt; 2) return index;</span>
    <span class="tok-kw">return</span> fibonacci(index - <span class="tok-number">1</span>) + fibonacci(index - <span class="tok-number">2</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"fibonacci"</span> {
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> assert(fibonacci(<span class="tok-number">7</span>) == <span class="tok-number">13</span>);
}</code></pre></figure>

      <p>
      编译器应该注意到在编译时求值此函数花费了超过 1000 个分支,因此发出错误并放弃。如果程序员想要增加编译时计算的预算,他们可以使用名为 <a href="https://ziglang.org/documentation/0.15.2/#setEvalBranchQuota">@setEvalBranchQuota</a> 的内置函数将默认数字 1000 更改为其他值。
      </p>
      <p>
      然而,<a href="https://github.com/ziglang/zig/issues/13724">编译器中存在一个设计缺陷</a>,导致它发生栈溢出而不是在这里表现出正确的行为。对此我深感抱歉。我希望在下一个版本之前解决这个问题。
      </p>
      <p>
      如果我们修复了基本情况,但在 <code>expect</code> 行中放入了错误的值会怎样?
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_fibonacci_comptime_unreachable.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.assert;

<span class="tok-kw">fn</span> <span class="tok-fn">fibonacci</span>(index: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">if</span> (index &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> index;
    <span class="tok-kw">return</span> fibonacci(index - <span class="tok-number">1</span>) + fibonacci(index - <span class="tok-number">2</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"fibonacci"</span> {
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> assert(fibonacci(<span class="tok-number">7</span>) == <span class="tok-number">99999</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_fibonacci_comptime_unreachable.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/debug.zig:559:14: </span><span class="sgr-31m">error: </span><span class="sgr-1m">reached unreachable code
</span>    if (!ok) unreachable; // assertion failure
             <span class="sgr-32m">^~~~~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_fibonacci_comptime_unreachable.zig:9:24: </span><span class="sgr-36m">note: </span><span class="sgr-1m">called at comptime here
</span>    try comptime assert(fibonacci(7) == 99999);
                 <span class="sgr-32m">~~~~~~^~~~~~~~~~~~~~~~~~~~~~~
</span>
</samp></pre></figure>


      <p>
      在<a href="https://ziglang.org/documentation/0.15.2/#Containers">容器</a>级别(在任何函数之外),所有表达式都隐式地是 <code><span class="tok-kw">comptime</span></code> 表达式。这意味着我们可以使用函数来初始化复杂的静态数据。例如:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_container-level_comptime_expressions.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> first_25_primes = firstNPrimes(<span class="tok-number">25</span>);
<span class="tok-kw">const</span> sum_of_first_25_primes = sum(&amp;first_25_primes);

<span class="tok-kw">fn</span> <span class="tok-fn">firstNPrimes</span>(<span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) [n]<span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> prime_list: [n]<span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> next_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> test_number: <span class="tok-type">i32</span> = <span class="tok-number">2</span>;
    <span class="tok-kw">while</span> (next_index &lt; prime_list.len) : (test_number += <span class="tok-number">1</span>) {
        <span class="tok-kw">var</span> test_prime_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> is_prime = <span class="tok-null">true</span>;
        <span class="tok-kw">while</span> (test_prime_index &lt; next_index) : (test_prime_index += <span class="tok-number">1</span>) {
            <span class="tok-kw">if</span> (test_number % prime_list[test_prime_index] == <span class="tok-number">0</span>) {
                is_prime = <span class="tok-null">false</span>;
                <span class="tok-kw">break</span>;
            }
        }
        <span class="tok-kw">if</span> (is_prime) {
            prime_list[next_index] = test_number;
            next_index += <span class="tok-number">1</span>;
        }
    }
    <span class="tok-kw">return</span> prime_list;
}

<span class="tok-kw">fn</span> <span class="tok-fn">sum</span>(numbers: []<span class="tok-kw">const</span> <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> result: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (numbers) |x| {
        result += x;
    }
    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">test</span> <span class="tok-str">"variable values"</span> {
    <span class="tok-kw">try</span> <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect(sum_of_first_25_primes == <span class="tok-number">1060</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_container-level_comptime_expressions.zig</kbd>
1/1 test_container-level_comptime_expressions.test.variable values...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      当我们编译这个程序时,Zig 生成的常量带有预先计算好的答案。以下是生成的 LLVM IR 中的行:
      </p>
      <pre><code class="llvm">@0 = internal unnamed_addr constant [25 x i32] [i32 2, i32 3, i32 5, i32 7, i32 11, i32 13, i32 17, i32 19, i32 23, i32 29, i32 31, i32 37, i32 41, i32 43, i32 47, i32 53, i32 59, i32 61, i32 67, i32 71, i32 73, i32 79, i32 83, i32 89, i32 97]
@1 = internal unnamed_addr constant i32 1060</code></pre>
      <p>
      请注意,我们不需要对这些函数的语法做任何特殊处理。例如,我们可以按原样使用 <code>sum</code> 函数调用一个长度和值仅在运行时已知的数字切片。
      </p>
      
      
      <h3 id="Generic-Data-Structures"><a href="https://ziglang.org/documentation/0.15.2/#toc-Generic-Data-Structures">泛型数据结构</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Generic-Data-Structures">§</a></h3>

      <p>
      Zig 使用编译时能力来实现泛型数据结构,而不引入任何特殊情况语法。
      </p>
      <p>
			这是一个泛型 <code>List</code> 数据结构的例子。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">generic_data_structure.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">List</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        items: []T,
        len: <span class="tok-type">usize</span>,
    };
}

<span class="tok-comment">// 可以通过传入一个类型来实例化泛型 List 数据结构:</span>
<span class="tok-kw">var</span> buffer: [<span class="tok-number">10</span>]<span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;
<span class="tok-kw">var</span> list = List(<span class="tok-type">i32</span>){
    .items = &amp;buffer,
    .len = <span class="tok-number">0</span>,
};</code></pre></figure>

      <p>
      就是这样。它是一个返回匿名 <code><span class="tok-kw">struct</span></code> 的函数。
      出于错误消息和调试的目的,Zig 从创建匿名结构时调用的函数名称和参数推断出名称 <code><span class="tok-str">"List(i32)"</span></code>。
      </p>
      <p>
      要显式地为类型命名,我们将其分配给一个常量。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">anonymous_struct_name.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Node = <span class="tok-kw">struct</span> {
    next: ?*Node,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
};

<span class="tok-kw">var</span> node_a = Node{
    .next = <span class="tok-null">null</span>,
    .name = <span class="tok-str">"Node A"</span>,
};

<span class="tok-kw">var</span> node_b = Node{
    .next = &amp;node_a,
    .name = <span class="tok-str">"Node B"</span>,
};</code></pre></figure>

      <p>
      在这个例子中,<code>Node</code> 结构引用了自己。
      这可以工作,因为所有顶层声明都是顺序无关的。
      只要编译器可以确定结构的大小,它就可以自由引用自己。
      在这种情况下,<code>Node</code> 作为指针引用自己,指针在编译时具有明确定义的大小,所以它可以正常工作。
      </p>
      
      <h3 id="Case-Study-print-in-Zig"><a href="https://ziglang.org/documentation/0.15.2/#toc-Case-Study-print-in-Zig">案例研究:Zig 中的 print</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Case-Study-print-in-Zig">§</a></h3>

      <p>
      将所有这些结合在一起,让我们看看 <code>print</code> 在 Zig 中是如何工作的。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">print.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;

<span class="tok-kw">const</span> a_number: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
<span class="tok-kw">const</span> a_string = <span class="tok-str">"foobar"</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    print(<span class="tok-str">"here is a string: '{s}' here is a number: {}\n"</span>, .{ a_string, a_number });
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe print.zig</kbd>
$ <kbd>./print</kbd>
here is a string: 'foobar' here is a number: 1234
</samp></pre></figure>


      <p>
      让我们深入了解这个实现,看看它是如何工作的:
      </p>

      <figure><figcaption class="zig-cap"><cite class="file">poc_print_fn.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Writer = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// 调用 print 然后刷新缓冲区。</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">print</span>(self: *Writer, <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> State = <span class="tok-kw">enum</span> {
            start,
            open_brace,
            close_brace,
        };

        <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> start_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> state = State.start;
        <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> next_arg: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (format, <span class="tok-number">0</span>..) |c, i| {
            <span class="tok-kw">switch</span> (state) {
                State.start =&gt; <span class="tok-kw">switch</span> (c) {
                    <span class="tok-str">'{'</span> =&gt; {
                        <span class="tok-kw">if</span> (start_index &lt; i) <span class="tok-kw">try</span> self.write(format[start_index..i]);
                        state = State.open_brace;
                    },
                    <span class="tok-str">'}'</span> =&gt; {
                        <span class="tok-kw">if</span> (start_index &lt; i) <span class="tok-kw">try</span> self.write(format[start_index..i]);
                        state = State.close_brace;
                    },
                    <span class="tok-kw">else</span> =&gt; {},
                },
                State.open_brace =&gt; <span class="tok-kw">switch</span> (c) {
                    <span class="tok-str">'{'</span> =&gt; {
                        state = State.start;
                        start_index = i;
                    },
                    <span class="tok-str">'}'</span> =&gt; {
                        <span class="tok-kw">try</span> self.printValue(args[next_arg]);
                        next_arg += <span class="tok-number">1</span>;
                        state = State.start;
                        start_index = i + <span class="tok-number">1</span>;
                    },
                    <span class="tok-str">'s'</span> =&gt; {
                        <span class="tok-kw">continue</span>;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">"Unknown format character: "</span> ++ [<span class="tok-number">1</span>]<span class="tok-type">u8</span>{c}),
                },
                State.close_brace =&gt; <span class="tok-kw">switch</span> (c) {
                    <span class="tok-str">'}'</span> =&gt; {
                        state = State.start;
                        start_index = i;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">"Single '}' encountered in format string"</span>),
                },
            }
        }
        <span class="tok-kw">comptime</span> {
            <span class="tok-kw">if</span> (args.len != next_arg) {
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">"Unused arguments"</span>);
            }
            <span class="tok-kw">if</span> (state != State.start) {
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">"Incomplete format string: "</span> ++ format);
            }
        }
        <span class="tok-kw">if</span> (start_index &lt; format.len) {
            <span class="tok-kw">try</span> self.write(format[start_index..format.len]);
        }
        <span class="tok-kw">try</span> self.flush();
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(self: *Writer, value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
        _ = self;
        _ = value;
    }
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">printValue</span>(self: *Writer, value: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
        _ = self;
        _ = value;
    }
    <span class="tok-kw">fn</span> <span class="tok-fn">flush</span>(self: *Writer) !<span class="tok-type">void</span> {
        _ = self;
    }
};</code></pre></figure>

      <p>
      这是一个概念验证实现;标准库中的实际函数具有更多格式化功能。
      </p>
      <p>
      请注意,这不是硬编码到 Zig 编译器中的;这是标准库中的用户代码。
      </p>
      <p>
      当从上面的示例代码分析此函数时,Zig 部分求值该函数并生成一个实际上看起来像这样的函数:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">生成的 print 函数</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">print</span>(self: *Writer, arg0: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, arg1: <span class="tok-type">i32</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.write(<span class="tok-str">"here is a string: '"</span>);
    <span class="tok-kw">try</span> self.printValue(arg0);
    <span class="tok-kw">try</span> self.write(<span class="tok-str">"' here is a number: "</span>);
    <span class="tok-kw">try</span> self.printValue(arg1);
    <span class="tok-kw">try</span> self.write(<span class="tok-str">"\n"</span>);
    <span class="tok-kw">try</span> self.flush();
}</code></pre></figure>
      <p>
      <code>printValue</code> 是一个接受任意类型参数的函数,并根据类型执行不同的操作:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">poc_printValue_fn.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Writer = <span class="tok-kw">struct</span> {
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">printValue</span>(self: *Writer, value: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(value))) {
            .int =&gt; {
                <span class="tok-kw">return</span> self.writeInt(value);
            },
            .float =&gt; {
                <span class="tok-kw">return</span> self.writeFloat(value);
            },
            .pointer =&gt; {
                <span class="tok-kw">return</span> self.write(value);
            },
            <span class="tok-kw">else</span> =&gt; {
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">"Unable to print type '"</span> ++ <span class="tok-builtin">@typeName</span>(<span class="tok-builtin">@TypeOf</span>(value)) ++ <span class="tok-str">"'"</span>);
            },
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(self: *Writer, value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
        _ = self;
        _ = value;
    }
    <span class="tok-kw">fn</span> <span class="tok-fn">writeInt</span>(self: *Writer, value: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
        _ = self;
        _ = value;
    }
    <span class="tok-kw">fn</span> <span class="tok-fn">writeFloat</span>(self: *Writer, value: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
        _ = self;
        _ = value;
    }
};</code></pre></figure>

      <p>
      现在,如果我们给 <code>print</code> 传递太多参数会发生什么?
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_print_too_many_args.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;

<span class="tok-kw">const</span> a_number: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
<span class="tok-kw">const</span> a_string = <span class="tok-str">"foobar"</span>;

<span class="tok-kw">test</span> <span class="tok-str">"print too many arguments"</span> {
    print(<span class="tok-str">"here is a string: '{s}' here is a number: {}\n"</span>, .{
        a_string,
        a_number,
        a_number,
    });
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_print_too_many_args.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/Io/Writer.zig:717:18: </span><span class="sgr-31m">error: </span><span class="sgr-1m">unused argument in 'here is a string: '{s}' here is a number: {}
                                                        '
</span>            1 =&gt; @compileError("unused argument in '" ++ fmt ++ "'"),
                 <span class="sgr-32m">^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</span><span class="sgr-2m">referenced by:
    print__anon_454: /home/andy/dev/zig/lib/std/debug.zig:231:23
    test.print too many arguments: /home/andy/dev/zig/doc/langref/test_print_too_many_args.zig:7:10
</span>
</samp></pre></figure>

      <p>
      Zig 为程序员提供了防止自己犯错所需的工具。
      </p>
      <p>
      Zig 不关心格式参数是否是字符串字面量,只关心它是可以强制转换为 <code>[]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code> 的编译时已知值:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">print_comptime-known_format.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;

<span class="tok-kw">const</span> a_number: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
<span class="tok-kw">const</span> a_string = <span class="tok-str">"foobar"</span>;
<span class="tok-kw">const</span> fmt = <span class="tok-str">"here is a string: '{s}' here is a number: {}\n"</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    print(fmt, .{ a_string, a_number });
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe print_comptime-known_format.zig</kbd>
$ <kbd>./print_comptime-known_format</kbd>
here is a string: 'foobar' here is a number: 1234
</samp></pre></figure>

      <p>
      这可以正常工作。
      </p>
      <p>
      Zig 不会在编译器中对字符串格式化进行特殊处理,而是公开足够的能力来在用户空间完成此任务。它这样做而不在 Zig 之上引入另一种语言,例如宏语言或预处理器语言。它完全是 Zig。
      </p>
      
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#inline-while">inline while</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#inline-for">inline for</a></li>
</ul>

      
      <h2 id="Assembly"><a href="https://ziglang.org/documentation/0.15.2/#toc-Assembly">汇编</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Assembly">§</a></h2>

      <p>
      对于某些用例,可能需要直接控制 Zig 程序生成的机器码,而不是依赖于 Zig 的代码生成。对于这些情况,可以使用内联汇编。以下是在 x86_64 Linux 上使用内联汇编实现 Hello, World 的示例:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">inline_assembly.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">noreturn</span> {
    <span class="tok-kw">const</span> msg = <span class="tok-str">"hello world\n"</span>;
    _ = syscall3(SYS_write, STDOUT_FILENO, <span class="tok-builtin">@intFromPtr</span>(msg), msg.len);
    _ = syscall1(SYS_exit, <span class="tok-number">0</span>);
    <span class="tok-kw">unreachable</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SYS_write = <span class="tok-number">1</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SYS_exit = <span class="tok-number">60</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> STDOUT_FILENO = <span class="tok-number">1</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">syscall1</span>(number: <span class="tok-type">usize</span>, arg1: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (<span class="tok-str">"syscall"</span>
        : [ret] <span class="tok-str">"={rax}"</span> (-&gt; <span class="tok-type">usize</span>),
        : [number] <span class="tok-str">"{rax}"</span> (number),
          [arg1] <span class="tok-str">"{rdi}"</span> (arg1),
        : .{ .rcx = <span class="tok-null">true</span>, .r11 = <span class="tok-null">true</span> });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">syscall3</span>(number: <span class="tok-type">usize</span>, arg1: <span class="tok-type">usize</span>, arg2: <span class="tok-type">usize</span>, arg3: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (<span class="tok-str">"syscall"</span>
        : [ret] <span class="tok-str">"={rax}"</span> (-&gt; <span class="tok-type">usize</span>),
        : [number] <span class="tok-str">"{rax}"</span> (number),
          [arg1] <span class="tok-str">"{rdi}"</span> (arg1),
          [arg2] <span class="tok-str">"{rsi}"</span> (arg2),
          [arg3] <span class="tok-str">"{rdx}"</span> (arg3),
        : .{ .rcx = <span class="tok-null">true</span>, .r11 = <span class="tok-null">true</span> });
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe inline_assembly.zig -target x86_64-linux</kbd>
$ <kbd>./inline_assembly</kbd>
hello world
</samp></pre></figure>

      <p>
      剖析语法:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">汇编语法说明.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">syscall1</span>(number: <span class="tok-type">usize</span>, arg1: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-comment">// 内联汇编是一个返回值的表达式。</span>
    <span class="tok-comment">// `asm` 关键字开始表达式。</span>
    <span class="tok-kw">return</span> <span class="tok-kw">asm</span>
    <span class="tok-comment">// `volatile` 是一个可选修饰符,告诉 Zig 这个</span>
    <span class="tok-comment">// 内联汇编表达式有副作用。没有</span>
    <span class="tok-comment">// `volatile`,如果结果未使用,Zig 允许删除内联汇编</span>
    <span class="tok-comment">// 代码。</span>
    <span class="tok-kw">volatile</span> (
    <span class="tok-comment">// 接下来是一个编译时字符串,即汇编代码。</span>
    <span class="tok-comment">// 在此字符串中,可以在需要寄存器的地方使用 `%[ret]`、`%[number]`</span>
    <span class="tok-comment">// 或 `%[arg1]`,以指定</span>
    <span class="tok-comment">// Zig 用于参数或返回值的寄存器,</span>
    <span class="tok-comment">// 如果使用寄存器约束字符串。但在</span>
    <span class="tok-comment">// 下面的代码中,没有使用这个。可以通过</span>
    <span class="tok-comment">// 双百分号转义来获得字面 `%`: `%%`。</span>
    <span class="tok-comment">// 多行字符串语法在这里通常很方便。</span>
        <span class="tok-str">\\syscall</span>
        <span class="tok-comment">// 接下来是输出。将来 Zig 可能</span>
        <span class="tok-comment">// 支持多个输出,取决于</span>
        <span class="tok-comment">// https://github.com/ziglang/zig/issues/215 如何解决。</span>
        <span class="tok-comment">// 允许没有输出,在这种情况下</span>
        <span class="tok-comment">// 这个冒号将直接跟在输入的冒号后面。</span>
        :
        <span class="tok-comment">// 这指定了在上面汇编字符串的 `%[ret]` 语法中</span>
        <span class="tok-comment">// 要使用的名称。此示例不使用它,</span>
        <span class="tok-comment">// 但语法是强制性的。</span>
          [ret]
          <span class="tok-comment">// 接下来是输出约束字符串。此功能在</span>
          <span class="tok-comment">// Zig 中仍被视为不稳定,因此必须使用 LLVM/GCC 文档</span>
          <span class="tok-comment">// 来理解语义。</span>
          <span class="tok-comment">// http://releases.llvm.org/10.0.0/docs/LangRef.html#inline-asm-constraint-string</span>
          <span class="tok-comment">// https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html</span>
          <span class="tok-comment">// 在此示例中,约束字符串表示"此</span>
          <span class="tok-comment">// 内联汇编指令的结果值是 $rax 中的任何值"。</span>
          <span class="tok-str">"={rax}"</span>
          <span class="tok-comment">// 接下来是值绑定,或 `-&gt;` 然后是类型。</span>
          <span class="tok-comment">// 类型是内联汇编表达式的结果类型。</span>
          <span class="tok-comment">// 如果是值绑定,则会使用 `%[ret]` 语法</span>
          <span class="tok-comment">// 来引用绑定到该值的寄存器。</span>
          (-&gt; <span class="tok-type">usize</span>),
          <span class="tok-comment">// 接下来是输入列表。</span>
          <span class="tok-comment">// 这些输入的约束意味着,"当执行汇编代码时,</span>
          <span class="tok-comment">// $rax 应具有 `number` 的值,$rdi 应具有</span>
          <span class="tok-comment">// `arg1` 的值"。允许任意数量的输入参数,</span>
          <span class="tok-comment">// 包括无。</span>
        : [number] <span class="tok-str">"{rax}"</span> (number),
          [arg1] <span class="tok-str">"{rdi}"</span> (arg1),
          <span class="tok-comment">// 接下来是破坏列表。这些声明一组寄存器,</span>
          <span class="tok-comment">// 执行此汇编代码后其值将不会保留。</span>
          <span class="tok-comment">// 这些不包括输出或输入寄存器。特殊破坏</span>
          <span class="tok-comment">// 值 "memory" 表示汇编写入任意未声明的</span>
          <span class="tok-comment">// 内存位置 - 不仅是声明的间接</span>
          <span class="tok-comment">// 输出指向的内存。在此示例中,我们列出了 $rcx 和 $r11,因为已知</span>
          <span class="tok-comment">// 内核系统调用不保留这些寄存器。</span>
        : .{ .rcx = <span class="tok-null">true</span>, .r11 = <span class="tok-null">true</span> });
}</code></pre></figure>

      <p>
      对于 x86 和 x86_64 目标,语法是 AT&amp;T 语法,而不是更流行的 Intel 语法。这是由于技术限制;汇编解析由 LLVM 提供,其对 Intel 语法的支持有问题且测试不充分。
      </p>
      <p>
      有一天 Zig 可能会有自己的汇编器。这将允许它更无缝地集成到语言中,并兼容流行的 NASM 语法。在 1.0.0 发布之前,本文档部分将更新,对 AT&amp;T 与 Intel/NASM 语法的状态给出决定性的声明。
      </p>
      <h3 id="Output-Constraints"><a href="https://ziglang.org/documentation/0.15.2/#toc-Output-Constraints">输出约束</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Output-Constraints">§</a></h3>

      <p>
      输出约束在 Zig 中仍被视为不稳定,因此必须使用
      <a href="http://releases.llvm.org/10.0.0/docs/LangRef.html#inline-asm-constraint-string">LLVM 文档</a>
      和
      <a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">GCC 文档</a>
      来理解语义。
      </p>
      <p>
      请注意,计划通过 <a href="https://github.com/ziglang/zig/issues/215">issue #215</a> 对输出约束进行一些破坏性更改。
      </p>
      

      <h3 id="Input-Constraints"><a href="https://ziglang.org/documentation/0.15.2/#toc-Input-Constraints">输入约束</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Input-Constraints">§</a></h3>

      <p>
      输入约束在 Zig 中仍被视为不稳定,因此必须使用
      <a href="http://releases.llvm.org/10.0.0/docs/LangRef.html#inline-asm-constraint-string">LLVM 文档</a>
      和
      <a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">GCC 文档</a>
      来理解语义。
      </p>
      <p>
      请注意,计划通过 <a href="https://github.com/ziglang/zig/issues/215">issue #215</a> 对输入约束进行一些破坏性更改。
      </p>
      

      <h3 id="Clobbers"><a href="https://ziglang.org/documentation/0.15.2/#toc-Clobbers">破坏</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Clobbers">§</a></h3>

      <p>
      破坏是执行汇编代码后其值将不会保留的寄存器集。这些不包括输出或输入寄存器。特殊破坏值 <code><span class="tok-str">"memory"</span></code> 表示汇编导致写入任意未声明的内存位置 - 不仅是声明的间接输出指向的内存。
      </p>
      <p>
      对于给定的内联汇编表达式,未能声明完整的破坏集是未检查的<a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>。
      </p>
      

      <h3 id="Global-Assembly"><a href="https://ziglang.org/documentation/0.15.2/#toc-Global-Assembly">全局汇编</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Global-Assembly">§</a></h3>

      <p>
      当汇编表达式出现在<a href="https://ziglang.org/documentation/0.15.2/#Containers">容器</a>级别的 <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a> 块中时,这是<strong>全局汇编</strong>。
      </p>
      <p>
      这种汇编与内联汇编有不同的规则。首先,<code><span class="tok-kw">volatile</span></code> 无效,因为所有全局汇编都无条件包含。
      其次,没有输入、输出或破坏。所有全局汇编都逐字连接成一个长字符串并一起汇编。内联汇编表达式中关于 <code>%</code> 的模板替换规则不适用。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_global_assembly.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">comptime</span> {
    <span class="tok-kw">asm</span> (
        <span class="tok-str">\\.global my_func;</span>
        <span class="tok-str">\\.type my_func, @function;</span>
        <span class="tok-str">\\my_func:</span>
        <span class="tok-str">\\  lea (%rdi,%rsi,1),%eax</span>
        <span class="tok-str">\\  retq</span>
    );
}

<span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">my_func</span>(a: <span class="tok-type">i32</span>, b: <span class="tok-type">i32</span>) <span class="tok-type">i32</span>;

<span class="tok-kw">test</span> <span class="tok-str">"global assembly"</span> {
    <span class="tok-kw">try</span> expect(my_func(<span class="tok-number">12</span>, <span class="tok-number">34</span>) == <span class="tok-number">46</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_global_assembly.zig -target x86_64-linux -fllvm</kbd>
1/1 test_global_assembly.test.global assembly...OK
All 1 tests passed.
</samp></pre></figure>

      
      

      <h2 id="Atomics"><a href="https://ziglang.org/documentation/0.15.2/#toc-Atomics">原子操作</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Atomics">§</a></h2>

      <p>TODO: @atomic rmw</p>
      <p>TODO: 内置原子内存排序枚举</p>

      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#atomicLoad">@atomicLoad</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#atomicStore">@atomicStore</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#atomicRmw">@atomicRmw</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cmpxchgWeak">@cmpxchgWeak</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cmpxchgStrong">@cmpxchgStrong</a></li>
</ul>


      

      <h2 id="Async-Functions"><a href="https://ziglang.org/documentation/0.15.2/#toc-Async-Functions">异步函数</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Async-Functions">§</a></h2>

      <p>异步函数在 0.11.0 版本发布时出现了回归。目前的计划是将它们作为支持 I/O 实现的更低级别原语重新引入。</p>
      <p>跟踪问题: <a href="https://github.com/ziglang/zig/issues/23446">提案:无栈协程作为低级原语</a></p>
      

      <h2 id="Builtin-Functions"><a href="https://ziglang.org/documentation/0.15.2/#toc-Builtin-Functions">内置函数</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Builtin-Functions">§</a></h2>

      <p>
      内置函数由编译器提供,并以 <code>@</code> 为前缀。
      参数上的 <code><span class="tok-kw">comptime</span></code> 关键字表示该参数必须在编译时已知。
      </p>
      <h3 id="addrSpaceCast"><a href="https://ziglang.org/documentation/0.15.2/#toc-addrSpaceCast">@addrSpaceCast</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#addrSpaceCast">§</a></h3>

      <pre><code><span class="tok-builtin">@addrSpaceCast</span>(ptr: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      将指针从一个地址空间转换到另一个地址空间。新的地址空间根据结果类型推断。根据当前目标和地址空间,此转换可能是无操作、复杂操作或非法的。如果转换合法,则生成的指针指向与指针操作数相同的内存位置。在相同地址空间之间转换指针始终有效。
      </p>
      
      <h3 id="addWithOverflow"><a href="https://ziglang.org/documentation/0.15.2/#toc-addWithOverflow">@addWithOverflow</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#addWithOverflow">§</a></h3>

      <pre><code><span class="tok-builtin">@addWithOverflow</span>(a: <span class="tok-kw">anytype</span>, b: <span class="tok-kw">anytype</span>) <span class="tok-kw">struct</span> { <span class="tok-builtin">@TypeOf</span>(a, b), <span class="tok-type">u1</span> }</code></pre>
      <p>
      执行 <code>a + b</code> 并返回包含结果和可能的溢出位的元组。
      </p>
      
      <h3 id="alignCast"><a href="https://ziglang.org/documentation/0.15.2/#toc-alignCast">@alignCast</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#alignCast">§</a></h3>

      <pre><code><span class="tok-builtin">@alignCast</span>(ptr: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      <code>ptr</code> 可以是 <code>*T</code>、<code>?*T</code> 或 <code>[]T</code>。
			改变指针的对齐方式。要使用的对齐方式根据结果类型推断。
      </p>
      <p>向生成的代码添加<a href="https://ziglang.org/documentation/0.15.2/#Incorrect-Pointer-Alignment">指针对齐安全检查</a>,以确保指针如承诺的那样对齐。</p>

      
      <h3 id="alignOf"><a href="https://ziglang.org/documentation/0.15.2/#toc-alignOf">@alignOf</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#alignOf">§</a></h3>

      <pre><code><span class="tok-builtin">@alignOf</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">comptime_int</span></code></pre>
      <p>
      此函数返回此类型在当前目标上应对齐到的字节数,以匹配 C ABI。当指针的子类型具有此对齐方式时,可以从类型中省略对齐方式。
      </p>
      <pre><code><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.assert;
<span class="tok-kw">comptime</span> {
    assert(*<span class="tok-type">u32</span> == *<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<span class="tok-type">u32</span>)) <span class="tok-type">u32</span>);
}</code></pre>
      <p>
      结果是特定于目标的编译时常量。保证小于或等于 <a href="https://ziglang.org/documentation/0.15.2/#sizeOf">@sizeOf(T)</a>。
      </p>
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Alignment">对齐</a></li>
</ul>

      

      <h3 id="as"><a href="https://ziglang.org/documentation/0.15.2/#toc-as">@as</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#as">§</a></h3>

      <pre><code><span class="tok-builtin">@as</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, expression) T</code></pre>
      <p>
      执行<a href="https://ziglang.org/documentation/0.15.2/#Type-Coercion">类型强制转换</a>。当转换明确且安全时允许此转换,并且是在可能的情况下在类型之间转换的首选方式。
      </p>
      

      <h3 id="atomicLoad"><a href="https://ziglang.org/documentation/0.15.2/#toc-atomicLoad">@atomicLoad</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#atomicLoad">§</a></h3>

      <pre><code><span class="tok-builtin">@atomicLoad</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *<span class="tok-kw">const</span> T, <span class="tok-kw">comptime</span> ordering: AtomicOrder) T</code></pre>
      <p>
      此内置函数原子地解引用指向 <code>T</code> 的指针并返回值。
      </p>
      <p>
      <code>T</code> 必须是指针、<code><span class="tok-type">bool</span></code>、浮点数、整数、枚举或打包结构。
      </p>
      <p><code>AtomicOrder</code> 可以通过 <code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).builtin.AtomicOrder</code> 找到。</p>
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#atomicStore">@atomicStore</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#atomicRmw">@atomicRmw</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cmpxchgWeak">@cmpxchgWeak</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cmpxchgStrong">@cmpxchgStrong</a></li>
</ul>

      

      <h3 id="atomicRmw"><a href="https://ziglang.org/documentation/0.15.2/#toc-atomicRmw">@atomicRmw</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#atomicRmw">§</a></h3>

      <pre><code><span class="tok-builtin">@atomicRmw</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *T, <span class="tok-kw">comptime</span> op: AtomicRmwOp, operand: T, <span class="tok-kw">comptime</span> ordering: AtomicOrder) T</code></pre>
      <p>
      此内置函数解引用指向 <code>T</code> 的指针,原子地修改值并返回先前的值。
      </p>
      <p>
      <code>T</code> 必须是指针、<code><span class="tok-type">bool</span></code>、浮点数、整数、枚举或打包结构。
      </p>
      <p><code>AtomicOrder</code> 可以通过 <code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).builtin.AtomicOrder</code> 找到。</p>
      <p><code>AtomicRmwOp</code> 可以通过 <code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).builtin.AtomicRmwOp</code> 找到。</p>
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#atomicStore">@atomicStore</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#atomicLoad">@atomicLoad</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cmpxchgWeak">@cmpxchgWeak</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cmpxchgStrong">@cmpxchgStrong</a></li>
</ul>

      

      <h3 id="atomicStore"><a href="https://ziglang.org/documentation/0.15.2/#toc-atomicStore">@atomicStore</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#atomicStore">§</a></h3>

      <pre><code><span class="tok-builtin">@atomicStore</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *T, value: T, <span class="tok-kw">comptime</span> ordering: AtomicOrder) <span class="tok-type">void</span></code></pre>
      <p>
      此内置函数解引用指向 <code>T</code> 的指针并原子地存储给定的值。
      </p>
      <p>
      <code>T</code> 必须是指针、<code><span class="tok-type">bool</span></code>、浮点数、整数、枚举或打包结构。
      </p>
      <p><code>AtomicOrder</code> 可以通过 <code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).builtin.AtomicOrder</code> 找到。</p>
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#atomicLoad">@atomicLoad</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#atomicRmw">@atomicRmw</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cmpxchgWeak">@cmpxchgWeak</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cmpxchgStrong">@cmpxchgStrong</a></li>
</ul>

      

      <h3 id="bitCast"><a href="https://ziglang.org/documentation/0.15.2/#toc-bitCast">@bitCast</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#bitCast">§</a></h3>

      <pre><code><span class="tok-builtin">@bitCast</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      将一种类型的值转换为另一种类型。返回类型是推断的结果类型。
      </p>
      <p>
      断言 <code><span class="tok-builtin">@sizeOf</span>(<span class="tok-builtin">@TypeOf</span>(value)) == <span class="tok-builtin">@sizeOf</span>(DestType)</code>。
      </p>
      <p>
      断言 <code><span class="tok-builtin">@typeInfo</span>(DestType) != .pointer</code>。如果需要这个,请使用 <code><span class="tok-builtin">@ptrCast</span></code> 或 <code><span class="tok-builtin">@ptrFromInt</span></code>。
      </p>
      <p>
      例如可用于这些事情:
      </p>
      <ul>
          <li>将 <code><span class="tok-type">f32</span></code> 转换为 <code><span class="tok-type">u32</span></code> 位</li>
          <li>将 <code><span class="tok-type">i32</span></code> 转换为 <code><span class="tok-type">u32</span></code> 保留二进制补码</li>
      </ul>
      <p>
      如果 <code>value</code> 在编译时已知,则在编译时工作。对未定义布局的值进行位转换是编译错误;这意味着,除了具有专用转换内置函数的类型(枚举、指针、错误集)的限制之外,裸结构、错误联合、切片、可选类型以及任何其他没有明确定义内存布局的类型也不能在此操作中使用。
      </p>
      

      <h3 id="bitOffsetOf"><a href="https://ziglang.org/documentation/0.15.2/#toc-bitOffsetOf">@bitOffsetOf</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#bitOffsetOf">§</a></h3>

      <pre><code><span class="tok-builtin">@bitOffsetOf</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">comptime_int</span></code></pre>
      <p>
      返回字段相对于其包含结构的位偏移量。
      </p>
      <p>
      对于非<a href="https://ziglang.org/documentation/0.15.2/#packed-struct">打包结构</a>,这将始终能被 <code><span class="tok-number">8</span></code> 整除。
      对于打包结构,非字节对齐的字段将共享一个字节偏移量,但它们将有不同的位偏移量。
      </p>
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#offsetOf">@offsetOf</a></li>
</ul>

      

      <h3 id="bitSizeOf"><a href="https://ziglang.org/documentation/0.15.2/#toc-bitSizeOf">@bitSizeOf</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#bitSizeOf">§</a></h3>

      <pre><code><span class="tok-builtin">@bitSizeOf</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">comptime_int</span></code></pre>
      <p>
      此函数返回在内存中存储 <code>T</code> 所需的位数,如果该类型是打包结构/联合中的字段。
      结果是特定于目标的编译时常量。
      </p>
      <p>
      此函数在运行时测量大小。对于在运行时不允许的类型,例如 <code><span class="tok-type">comptime_int</span></code> 和 <code><span class="tok-type">type</span></code>,结果为 <code><span class="tok-number">0</span></code>。
      </p>
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#sizeOf">@sizeOf</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#typeInfo">@typeInfo</a></li>
</ul>

      

      <h3 id="branchHint"><a href="https://ziglang.org/documentation/0.15.2/#toc-branchHint">@branchHint</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#branchHint">§</a></h3>

      <pre><code><span class="tok-builtin">@branchHint</span>(hint: BranchHint) <span class="tok-type">void</span></code></pre>
      <p>向优化器提示给定控制流分支被到达的可能性。</p>
      <p><code>BranchHint</code> 可以通过 <code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).builtin.BranchHint</code> 找到。</p>
      <p>此函数仅在控制流分支的第一条语句或函数的第一条语句中有效。</p>
      

      <h3 id="breakpoint"><a href="https://ziglang.org/documentation/0.15.2/#toc-breakpoint">@breakpoint</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#breakpoint">§</a></h3>

      <pre><code><span class="tok-builtin">@breakpoint</span>() <span class="tok-type">void</span></code></pre>
      <p>
      此函数插入特定于平台的调试陷阱指令,导致调试器在此处中断。
      与 <code><span class="tok-builtin">@trap</span>()</code> 不同,如果程序恢复,执行可能会在此点之后继续。
      </p>
      <p>
      此函数仅在函数作用域内有效。
      </p>
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#trap">@trap</a></li>
</ul>

      

      <h3 id="mulAdd"><a href="https://ziglang.org/documentation/0.15.2/#toc-mulAdd">@mulAdd</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#mulAdd">§</a></h3>

      <pre><code><span class="tok-builtin">@mulAdd</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T, c: T) T</code></pre>
      <p>
      融合乘加,类似于 <code>(a * b) + c</code>,但只舍入一次,因此更准确。
      </p>
      <p>
      支持<a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a>和<a href="https://ziglang.org/documentation/0.15.2/#Vectors">浮点数向量</a>。
      </p>
      

      <h3 id="byteSwap"><a href="https://ziglang.org/documentation/0.15.2/#toc-byteSwap">@byteSwap</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#byteSwap">§</a></h3>