<figure><figcaption class="zig-cap"><cite class="file">test_misaligned_pointer.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> BitField = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    a: <span class="tok-type">u3</span>,
    b: <span class="tok-type">u3</span>,
    c: <span class="tok-type">u2</span>,
};

<span class="tok-kw">var</span> bit_field = BitField{
    .a = <span class="tok-number">1</span>,
    .b = <span class="tok-number">2</span>,
    .c = <span class="tok-number">3</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">"pointer to non-byte-aligned field"</span> {
    <span class="tok-kw">try</span> expect(bar(&amp;bit_field.b) == <span class="tok-number">2</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>(x: *<span class="tok-kw">const</span> <span class="tok-type">u3</span>) <span class="tok-type">u3</span> {
    <span class="tok-kw">return</span> x.*;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_misaligned_pointer.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_misaligned_pointer.zig:17:20: </span><span class="sgr-31m">error: </span><span class="sgr-1m">expected type '*const u3', found '*align(1:3:1) u3'
</span>    try expect(bar(&amp;bit_field.b) == 2);
                   <span class="sgr-32m">^~~~~~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_misaligned_pointer.zig:17:20: </span><span class="sgr-36m">note: </span><span class="sgr-1m">pointer host size '1' cannot cast into pointer host size '0'
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_misaligned_pointer.zig:17:20: </span><span class="sgr-36m">note: </span><span class="sgr-1m">pointer bit offset '3' cannot cast into pointer bit offset '0'
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_misaligned_pointer.zig:20:11: </span><span class="sgr-36m">note: </span><span class="sgr-1m">parameter type declared here
</span>fn bar(x: *const u3) u3 {
          <span class="sgr-32m">^~~~~~~~~
</span>
</samp></pre></figure>

      <p>
      在这种情况下,函数 <code>bar</code> 不能被调用,因为指向非 ABI 对齐字段的指针包含位偏移信息,但函数期望一个 ABI 对齐的指针。
      </p>
      <p>
      指向非 ABI 对齐字段的指针与其宿主整数内的其他字段共享相同的地址:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_packed_struct_field_address.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> BitField = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    a: <span class="tok-type">u3</span>,
    b: <span class="tok-type">u3</span>,
    c: <span class="tok-type">u2</span>,
};

<span class="tok-kw">var</span> bit_field = BitField{
    .a = <span class="tok-number">1</span>,
    .b = <span class="tok-number">2</span>,
    .c = <span class="tok-number">3</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">"pointers of sub-byte-aligned fields share addresses"</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromPtr</span>(&amp;bit_field.a) == <span class="tok-builtin">@intFromPtr</span>(&amp;bit_field.b));
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromPtr</span>(&amp;bit_field.a) == <span class="tok-builtin">@intFromPtr</span>(&amp;bit_field.c));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_packed_struct_field_address.zig</kbd>
1/1 test_packed_struct_field_address.test.pointers of sub-byte-aligned fields share addresses...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      这可以通过 <a href="https://ziglang.org/documentation/0.15.2/#bitOffsetOf">@bitOffsetOf</a> 和 <a href="https://ziglang.org/documentation/0.15.2/#offsetOf">offsetOf</a> 观察到:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_bitOffsetOf_offsetOf.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> BitField = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    a: <span class="tok-type">u3</span>,
    b: <span class="tok-type">u3</span>,
    c: <span class="tok-type">u2</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">"offsets of non-byte-aligned fields"</span> {
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">try</span> expect(<span class="tok-builtin">@bitOffsetOf</span>(BitField, <span class="tok-str">"a"</span>) == <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> expect(<span class="tok-builtin">@bitOffsetOf</span>(BitField, <span class="tok-str">"b"</span>) == <span class="tok-number">3</span>);
        <span class="tok-kw">try</span> expect(<span class="tok-builtin">@bitOffsetOf</span>(BitField, <span class="tok-str">"c"</span>) == <span class="tok-number">6</span>);

        <span class="tok-kw">try</span> expect(<span class="tok-builtin">@offsetOf</span>(BitField, <span class="tok-str">"a"</span>) == <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> expect(<span class="tok-builtin">@offsetOf</span>(BitField, <span class="tok-str">"b"</span>) == <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> expect(<span class="tok-builtin">@offsetOf</span>(BitField, <span class="tok-str">"c"</span>) == <span class="tok-number">0</span>);
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_bitOffsetOf_offsetOf.zig</kbd>
1/1 test_bitOffsetOf_offsetOf.test.offsets of non-byte-aligned fields...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      紧凑结构体的对齐方式与其后备整数相同,但是,指向紧凑结构体的过度对齐指针可以覆盖这一点:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_overaligned_packed_struct.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> S = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    a: <span class="tok-type">u32</span>,
    b: <span class="tok-type">u32</span>,
};
<span class="tok-kw">test</span> <span class="tok-str">"overaligned pointer to packed struct"</span> {
    <span class="tok-kw">var</span> foo: S <span class="tok-kw">align</span>(<span class="tok-number">4</span>) = .{ .a = <span class="tok-number">1</span>, .b = <span class="tok-number">2</span> };
    <span class="tok-kw">const</span> ptr: *<span class="tok-kw">align</span>(<span class="tok-number">4</span>) S = &amp;foo;
    <span class="tok-kw">const</span> ptr_to_b: *<span class="tok-type">u32</span> = &amp;ptr.b;
    <span class="tok-kw">try</span> expect(ptr_to_b.* == <span class="tok-number">2</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_overaligned_packed_struct.zig</kbd>
1/1 test_overaligned_packed_struct.test.overaligned pointer to packed struct...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      也可以设置结构体字段的对齐方式:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_aligned_struct_fields.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expectEqual = std.testing.expectEqual;

<span class="tok-kw">test</span> <span class="tok-str">"aligned struct fields"</span> {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        a: <span class="tok-type">u32</span> <span class="tok-kw">align</span>(<span class="tok-number">2</span>),
        b: <span class="tok-type">u32</span> <span class="tok-kw">align</span>(<span class="tok-number">64</span>),
    };
    <span class="tok-kw">var</span> foo = S{ .a = <span class="tok-number">1</span>, .b = <span class="tok-number">2</span> };

    <span class="tok-kw">try</span> expectEqual(<span class="tok-number">64</span>, <span class="tok-builtin">@alignOf</span>(S));
    <span class="tok-kw">try</span> expectEqual(*<span class="tok-kw">align</span>(<span class="tok-number">2</span>) <span class="tok-type">u32</span>, <span class="tok-builtin">@TypeOf</span>(&amp;foo.a));
    <span class="tok-kw">try</span> expectEqual(*<span class="tok-kw">align</span>(<span class="tok-number">64</span>) <span class="tok-type">u32</span>, <span class="tok-builtin">@TypeOf</span>(&amp;foo.b));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_aligned_struct_fields.zig</kbd>
1/1 test_aligned_struct_fields.test.aligned struct fields...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      比较紧凑结构体会导致比较后备整数,
      并且仅适用于 <code>==</code> 和 <code>!=</code> <a href="https://ziglang.org/documentation/0.15.2/#Operators">运算符</a>。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_packed_struct_equality.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"packed struct equality"</span> {
    <span class="tok-kw">const</span> S = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
        a: <span class="tok-type">u4</span>,
        b: <span class="tok-type">u4</span>,
    };
    <span class="tok-kw">const</span> x: S = .{ .a = <span class="tok-number">1</span>, .b = <span class="tok-number">2</span> };
    <span class="tok-kw">const</span> y: S = .{ .b = <span class="tok-number">2</span>, .a = <span class="tok-number">1</span> };
    <span class="tok-kw">try</span> expect(x == y);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_packed_struct_equality.zig</kbd>
1/1 test_packed_struct_equality.test.packed struct equality...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      字段访问和赋值可以理解为对后备整数进行位移操作的简写。这些操作不是<a href="https://ziglang.org/documentation/0.15.2/#Atomics">原子的</a>,
      因此在结合内存映射输入输出(MMIO)使用字段访问语法时要小心。不要在 <a href="https://ziglang.org/documentation/0.15.2/#volatile">volatile</a> <a href="https://ziglang.org/documentation/0.15.2/#Pointers">指针</a>上使用字段访问,
      而是先构造一个完整的新值,然后将该值写入 volatile 指针。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">packed_struct_mmio.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">const</span> GpioRegister = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u8</span>) {
    GPIO0: <span class="tok-type">bool</span>,
    GPIO1: <span class="tok-type">bool</span>,
    GPIO2: <span class="tok-type">bool</span>,
    GPIO3: <span class="tok-type">bool</span>,
    reserved: <span class="tok-type">u4</span> = <span class="tok-number">0</span>,
};

<span class="tok-kw">const</span> gpio: *<span class="tok-kw">volatile</span> GpioRegister = <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-number">0x0123</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeToGpio</span>(new_states: GpioRegister) <span class="tok-type">void</span> {
    <span class="tok-comment">// 不应该这样做的示例:</span>
    <span class="tok-comment">// 错误! gpio.GPIO0 = true; 错误!</span>

    <span class="tok-comment">// 而是这样做:</span>
    gpio.* = new_states;
}</code></pre></figure>
      

      <h3 id="Struct-Naming"><a href="https://ziglang.org/documentation/0.15.2/#toc-Struct-Naming">结构体命名</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Struct-Naming">§</a></h3>

      <p>由于所有结构体都是匿名的,Zig 会根据几条规则推断类型名称。</p>
      <ul>
          <li>如果结构体在变量的初始化表达式中,它将以该变量命名。</li>
          <li>如果结构体在 <code><span class="tok-kw">return</span></code> 表达式中,它将以它返回的函数命名,并附加序列化的参数值。</li>
          <li>否则,结构体将获得一个名称,如 <code>(filename.funcname__struct_ID)</code>。</li>
          <li>如果结构体在另一个结构体内声明,它将以父结构体和前述规则推断出的名称命名,用点分隔。</li>
      </ul>
      <figure><figcaption class="zig-cap"><cite class="file">struct_name.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> Foo = <span class="tok-kw">struct</span> {};
    std.debug.print(<span class="tok-str">"variable: {s}\n"</span>, .{<span class="tok-builtin">@typeName</span>(Foo)});
    std.debug.print(<span class="tok-str">"anonymous: {s}\n"</span>, .{<span class="tok-builtin">@typeName</span>(<span class="tok-kw">struct</span> {})});
    std.debug.print(<span class="tok-str">"function: {s}\n"</span>, .{<span class="tok-builtin">@typeName</span>(List(<span class="tok-type">i32</span>))});
}

<span class="tok-kw">fn</span> <span class="tok-fn">List</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        x: T,
    };
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe struct_name.zig</kbd>
$ <kbd>./struct_name</kbd>
variable: struct_name.main.Foo
anonymous: struct_name.main__struct_22691
function: struct_name.List(i32)
</samp></pre></figure>

      

      <h3 id="Anonymous-Struct-Literals"><a href="https://ziglang.org/documentation/0.15.2/#toc-Anonymous-Struct-Literals">匿名结构体字面量</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Anonymous-Struct-Literals">§</a></h3>

      <p>
      Zig 允许省略字面量的结构体类型。当结果被<a href="https://ziglang.org/documentation/0.15.2/#Type-Coercion">强制转换</a>时,
      结构体字面量将直接实例化<a href="https://ziglang.org/documentation/0.15.2/#Result-Location-Semantics">结果位置</a>,
      无需复制:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_struct_result.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Point = <span class="tok-kw">struct</span> { x: <span class="tok-type">i32</span>, y: <span class="tok-type">i32</span> };

<span class="tok-kw">test</span> <span class="tok-str">"anonymous struct literal"</span> {
    <span class="tok-kw">const</span> pt: Point = .{
        .x = <span class="tok-number">13</span>,
        .y = <span class="tok-number">67</span>,
    };
    <span class="tok-kw">try</span> expect(pt.x == <span class="tok-number">13</span>);
    <span class="tok-kw">try</span> expect(pt.y == <span class="tok-number">67</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_struct_result.zig</kbd>
1/1 test_struct_result.test.anonymous struct literal...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      结构体类型可以被推断。这里<a href="https://ziglang.org/documentation/0.15.2/#Result-Location-Semantics">结果位置</a>
      不包含类型,因此 Zig 推断类型:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_anonymous_struct.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"fully anonymous struct"</span> {
    <span class="tok-kw">try</span> check(.{
        .int = <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1234</span>),
        .float = <span class="tok-builtin">@as</span>(<span class="tok-type">f64</span>, <span class="tok-number">12.34</span>),
        .b = <span class="tok-null">true</span>,
        .s = <span class="tok-str">"hi"</span>,
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">check</span>(args: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> expect(args.int == <span class="tok-number">1234</span>);
    <span class="tok-kw">try</span> expect(args.float == <span class="tok-number">12.34</span>);
    <span class="tok-kw">try</span> expect(args.b);
    <span class="tok-kw">try</span> expect(args.s[<span class="tok-number">0</span>] == <span class="tok-str">'h'</span>);
    <span class="tok-kw">try</span> expect(args.s[<span class="tok-number">1</span>] == <span class="tok-str">'i'</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_anonymous_struct.zig</kbd>
1/1 test_anonymous_struct.test.fully anonymous struct...OK
All 1 tests passed.
</samp></pre></figure>

      

      <h3 id="Tuples"><a href="https://ziglang.org/documentation/0.15.2/#toc-Tuples">元组</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Tuples">§</a></h3>

      <p>
      匿名结构体可以在不指定字段名称的情况下创建,被称为"元组"。空元组看起来像 <code>.{}</code>,可以在其中一个<a href="https://ziglang.org/documentation/0.15.2/#Hello-World">Hello World 示例</a>中看到。
      </p>
      <p>
      字段使用从 0 开始的数字隐式命名。因为它们的名称是整数,
      所以不能使用 <code>.</code> 语法访问它们,除非也将它们包装在
      <code>@""</code> 中。<code>@""</code> 内的名称始终被识别为
      <a href="https://ziglang.org/documentation/0.15.2/#Identifiers">标识符</a>。
      </p>
      <p>
      与数组一样,元组有一个 .len 字段,可以被索引(前提是索引在编译时已知)
      并且可以与 ++ 和 ** 运算符一起使用。它们也可以使用 <a href="https://ziglang.org/documentation/0.15.2/#inline-for">inline for</a> 进行迭代。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_tuples.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"tuple"</span> {
    <span class="tok-kw">const</span> values = .{
        <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1234</span>),
        <span class="tok-builtin">@as</span>(<span class="tok-type">f64</span>, <span class="tok-number">12.34</span>),
        <span class="tok-null">true</span>,
        <span class="tok-str">"hi"</span>,
    } ++ .{<span class="tok-null">false</span>} ** <span class="tok-number">2</span>;
    <span class="tok-kw">try</span> expect(values[<span class="tok-number">0</span>] == <span class="tok-number">1234</span>);
    <span class="tok-kw">try</span> expect(values[<span class="tok-number">4</span>] == <span class="tok-null">false</span>);
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (values, <span class="tok-number">0</span>..) |v, i| {
        <span class="tok-kw">if</span> (i != <span class="tok-number">2</span>) <span class="tok-kw">continue</span>;
        <span class="tok-kw">try</span> expect(v);
    }
    <span class="tok-kw">try</span> expect(values.len == <span class="tok-number">6</span>);
    <span class="tok-kw">try</span> expect(values.@"3"[<span class="tok-number">0</span>] == <span class="tok-str">'h'</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_tuples.zig</kbd>
1/1 test_tuples.test.tuple...OK
All 1 tests passed.
</samp></pre></figure>

      <h4 id="Destructuring-Tuples"><a href="https://ziglang.org/documentation/0.15.2/#toc-Destructuring-Tuples">解构元组</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Destructuring-Tuples">§</a></h4>

      <p>
        元组可以被<a href="https://ziglang.org/documentation/0.15.2/#Destructuring">解构</a>。
      </p>
      <p>
        元组解构有助于从块中返回多个值:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">destructuring_block.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> digits = [_]<span class="tok-type">i8</span> { <span class="tok-number">3</span>, <span class="tok-number">8</span>, <span class="tok-number">9</span>, <span class="tok-number">0</span>, <span class="tok-number">7</span>, <span class="tok-number">4</span>, <span class="tok-number">1</span> };

    <span class="tok-kw">const</span> min, <span class="tok-kw">const</span> max = blk: {
        <span class="tok-kw">var</span> min: <span class="tok-type">i8</span> = <span class="tok-number">127</span>;
        <span class="tok-kw">var</span> max: <span class="tok-type">i8</span> = -<span class="tok-number">128</span>;

        <span class="tok-kw">for</span> (digits) |digit| {
            <span class="tok-kw">if</span> (digit &lt; min) min = digit;
            <span class="tok-kw">if</span> (digit &gt; max) max = digit;
        }

        <span class="tok-kw">break</span> :blk .{ min, max };
    };

    print(<span class="tok-str">"min = {}\n"</span>, .{ min });
    print(<span class="tok-str">"max = {}\n"</span>, .{ max });
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe destructuring_block.zig</kbd>
$ <kbd>./destructuring_block</kbd>
min = 0
max = 9
</samp></pre></figure>

      <p>
        元组解构有助于处理将多个值作为元组返回的函数和内置函数:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">destructuring_return_value.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;

<span class="tok-kw">fn</span> <span class="tok-fn">divmod</span>(numerator: <span class="tok-type">u32</span>, denominator: <span class="tok-type">u32</span>) <span class="tok-kw">struct</span> { <span class="tok-type">u32</span>, <span class="tok-type">u32</span> } {
    <span class="tok-kw">return</span> .{ numerator / denominator, numerator % denominator };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> div, <span class="tok-kw">const</span> mod = divmod(<span class="tok-number">10</span>, <span class="tok-number">3</span>);

    print(<span class="tok-str">"10 / 3 = {}\n"</span>, .{div});
    print(<span class="tok-str">"10 % 3 = {}\n"</span>, .{mod});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe destructuring_return_value.zig</kbd>
$ <kbd>./destructuring_return_value</kbd>
10 / 3 = 3
10 % 3 = 1
</samp></pre></figure>

      <p>另见:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Destructuring">解构</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Destructuring-Arrays">解构数组</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Destructuring-Vectors">解构向量</a></li>
</ul>

      
      
      <p>另见:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#fieldParentPtr">@fieldParentPtr</a></li>
</ul>

      
      <h2 id="enum"><a href="https://ziglang.org/documentation/0.15.2/#toc-enum">enum</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#enum">§</a></h2>

      <figure><figcaption class="zig-cap"><cite class="file">test_enums.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;
<span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).mem;

<span class="tok-comment">// 声明一个枚举。</span>
<span class="tok-kw">const</span> Type = <span class="tok-kw">enum</span> {
    ok,
    not_ok,
};

<span class="tok-comment">// 声明一个特定的枚举字段。</span>
<span class="tok-kw">const</span> c = Type.ok;

<span class="tok-comment">// 如果您想访问枚举的序数值,可以</span>
<span class="tok-comment">// 指定标签类型。</span>
<span class="tok-kw">const</span> Value = <span class="tok-kw">enum</span>(<span class="tok-type">u2</span>) {
    zero,
    one,
    two,
};
<span class="tok-comment">// 现在您可以在 u2 和 Value 之间进行转换。</span>
<span class="tok-comment">// 序数值从 0 开始,从前一个成员向上递增 1。</span>
<span class="tok-kw">test</span> <span class="tok-str">"enum ordinal value"</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value.zero) == <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value.one) == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value.two) == <span class="tok-number">2</span>);
}

<span class="tok-comment">// 您可以覆盖枚举的序数值。</span>
<span class="tok-kw">const</span> Value2 = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {
    hundred = <span class="tok-number">100</span>,
    thousand = <span class="tok-number">1000</span>,
    million = <span class="tok-number">1000000</span>,
};
<span class="tok-kw">test</span> <span class="tok-str">"set enum ordinal value"</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value2.hundred) == <span class="tok-number">100</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value2.thousand) == <span class="tok-number">1000</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value2.million) == <span class="tok-number">1000000</span>);
}

<span class="tok-comment">// 您也可以仅覆盖某些值。</span>
<span class="tok-kw">const</span> Value3 = <span class="tok-kw">enum</span>(<span class="tok-type">u4</span>) {
    a,
    b = <span class="tok-number">8</span>,
    c,
    d = <span class="tok-number">4</span>,
    e,
};
<span class="tok-kw">test</span> <span class="tok-str">"enum implicit ordinal values and overridden values"</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value3.a) == <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value3.b) == <span class="tok-number">8</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value3.c) == <span class="tok-number">9</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value3.d) == <span class="tok-number">4</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value3.e) == <span class="tok-number">5</span>);
}

<span class="tok-comment">// 枚举可以有方法,与结构体和联合体相同。</span>
<span class="tok-comment">// 枚举方法并不特殊,它们只是命名空间</span>
<span class="tok-comment">// 函数,您可以使用点语法调用。</span>
<span class="tok-kw">const</span> Suit = <span class="tok-kw">enum</span> {
    clubs,
    spades,
    diamonds,
    hearts,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isClubs</span>(self: Suit) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> self == Suit.clubs;
    }
};
<span class="tok-kw">test</span> <span class="tok-str">"enum method"</span> {
    <span class="tok-kw">const</span> p = Suit.spades;
    <span class="tok-kw">try</span> expect(!p.isClubs());
}

<span class="tok-comment">// 可以对枚举进行 switch。</span>
<span class="tok-kw">const</span> Foo = <span class="tok-kw">enum</span> {
    string,
    number,
    none,
};
<span class="tok-kw">test</span> <span class="tok-str">"enum switch"</span> {
    <span class="tok-kw">const</span> p = Foo.number;
    <span class="tok-kw">const</span> what_is_it = <span class="tok-kw">switch</span> (p) {
        Foo.string =&gt; <span class="tok-str">"this is a string"</span>,
        Foo.number =&gt; <span class="tok-str">"this is a number"</span>,
        Foo.none =&gt; <span class="tok-str">"this is a none"</span>,
    };
    <span class="tok-kw">try</span> expect(mem.eql(<span class="tok-type">u8</span>, what_is_it, <span class="tok-str">"this is a number"</span>));
}

<span class="tok-comment">// @typeInfo 可用于访问枚举的整数标签类型。</span>
<span class="tok-kw">const</span> Small = <span class="tok-kw">enum</span> {
    one,
    two,
    three,
    four,
};
<span class="tok-kw">test</span> <span class="tok-str">"std.meta.Tag"</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@typeInfo</span>(Small).@"enum".tag_type == <span class="tok-type">u2</span>);
}

<span class="tok-comment">// @typeInfo 告诉我们字段数量和字段名称:</span>
<span class="tok-kw">test</span> <span class="tok-str">"@typeInfo"</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@typeInfo</span>(Small).@"enum".fields.len == <span class="tok-number">4</span>);
    <span class="tok-kw">try</span> expect(mem.eql(<span class="tok-type">u8</span>, <span class="tok-builtin">@typeInfo</span>(Small).@"enum".fields[<span class="tok-number">1</span>].name, <span class="tok-str">"two"</span>));
}

<span class="tok-comment">// @tagName 给出枚举值的 [:0]const u8 表示:</span>
<span class="tok-kw">test</span> <span class="tok-str">"@tagName"</span> {
    <span class="tok-kw">try</span> expect(mem.eql(<span class="tok-type">u8</span>, <span class="tok-builtin">@tagName</span>(Small.three), <span class="tok-str">"three"</span>));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_enums.zig</kbd>
1/8 test_enums.test.enum ordinal value...OK
2/8 test_enums.test.set enum ordinal value...OK
3/8 test_enums.test.enum implicit ordinal values and overridden values...OK
4/8 test_enums.test.enum method...OK
5/8 test_enums.test.enum switch...OK
6/8 test_enums.test.std.meta.Tag...OK
7/8 test_enums.test.@typeInfo...OK
8/8 test_enums.test.@tagName...OK
All 8 tests passed.
</samp></pre></figure>

      <p>另见:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#typeInfo">@typeInfo</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#tagName">@tagName</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#sizeOf">@sizeOf</a></li>
</ul>


      <h3 id="extern-enum"><a href="https://ziglang.org/documentation/0.15.2/#toc-extern-enum">extern enum</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#extern-enum">§</a></h3>

      <p>
      默认情况下,枚举不保证与 C ABI 兼容:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">enum_export_error.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Foo = <span class="tok-kw">enum</span> { a, b, c };
<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">entry</span>(foo: Foo) <span class="tok-type">void</span> {
    _ = foo;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-obj enum_export_error.zig -target x86_64-linux</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/enum_export_error.zig:2:17: </span><span class="sgr-31m">error: </span><span class="sgr-1m">parameter of type 'enum_export_error.Foo' not allowed in function with calling convention 'x86_64_sysv'
</span>export fn entry(foo: Foo) void {
                <span class="sgr-32m">^~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/enum_export_error.zig:2:17: </span><span class="sgr-36m">note: </span><span class="sgr-1m">enum tag type 'u2' is not extern compatible
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/enum_export_error.zig:2:17: </span><span class="sgr-36m">note: </span><span class="sgr-1m">only integers with 0, 8, 16, 32, 64 and 128 bits are extern compatible
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/enum_export_error.zig:1:13: </span><span class="sgr-36m">note: </span><span class="sgr-1m">enum declared here
</span>const Foo = enum { a, b, c };
            <span class="sgr-32m">^~~~~~~~~~~~~~~~
</span><span class="sgr-2m">referenced by:
    root: /home/andy/dev/zig/lib/std/start.zig:3:22
    comptime: /home/andy/dev/zig/lib/std/start.zig:31:9
    2 reference(s) hidden; use '-freference-trace=4' to see all references
</span>
</samp></pre></figure>

      <p>
      对于 C ABI 兼容的枚举,为枚举提供显式标签类型:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">enum_export.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Foo = <span class="tok-kw">enum</span>(<span class="tok-type">c_int</span>) { a, b, c };
<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">entry</span>(foo: Foo) <span class="tok-type">void</span> {
    _ = foo;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-obj enum_export.zig</kbd>
</samp></pre></figure>

      

      <h3 id="Enum-Literals"><a href="https://ziglang.org/documentation/0.15.2/#toc-Enum-Literals">枚举字面量</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Enum-Literals">§</a></h3>

      <p>
      枚举字面量允许在不指定枚举类型的情况下指定枚举字段的名称:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_enum_literals.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Color = <span class="tok-kw">enum</span> {
    auto,
    off,
    on,
};

<span class="tok-kw">test</span> <span class="tok-str">"enum literals"</span> {
    <span class="tok-kw">const</span> color1: Color = .auto;
    <span class="tok-kw">const</span> color2 = Color.auto;
    <span class="tok-kw">try</span> expect(color1 == color2);
}

<span class="tok-kw">test</span> <span class="tok-str">"switch using enum literals"</span> {
    <span class="tok-kw">const</span> color = Color.on;
    <span class="tok-kw">const</span> result = <span class="tok-kw">switch</span> (color) {
        .auto =&gt; <span class="tok-null">false</span>,
        .on =&gt; <span class="tok-null">true</span>,
        .off =&gt; <span class="tok-null">false</span>,
    };
    <span class="tok-kw">try</span> expect(result);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_enum_literals.zig</kbd>
1/2 test_enum_literals.test.enum literals...OK
2/2 test_enum_literals.test.switch using enum literals...OK
All 2 tests passed.
</samp></pre></figure>

      

      <h3 id="Non-exhaustive-enum"><a href="https://ziglang.org/documentation/0.15.2/#toc-Non-exhaustive-enum">非穷尽枚举</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Non-exhaustive-enum">§</a></h3>

      <p>
      可以通过添加尾部 <code>_</code> 字段创建非穷尽枚举。
      枚举必须指定标签类型,并且不能消耗每个枚举值。
      </p>
      <p>
      对非穷尽枚举使用 <a href="https://ziglang.org/documentation/0.15.2/#enumFromInt">@enumFromInt</a> 涉及
      <a href="https://ziglang.org/documentation/0.15.2/#intCast">@intCast</a> 到整数标签类型的安全语义,但除此之外始终会产生
      定义良好的枚举值。
      </p>
      <p>
      对非穷尽枚举的 switch 可以包含 <code>_</code> 分支作为 <code><span class="tok-kw">else</span></code> 分支的替代。
      使用 <code>_</code> 分支时,如果 switch 未处理所有已知标签名称,编译器会报错。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_switch_non-exhaustive.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Number = <span class="tok-kw">enum</span>(<span class="tok-type">u8</span>) {
    one,
    two,
    three,
    _,
};

<span class="tok-kw">test</span> <span class="tok-str">"switch on non-exhaustive enum"</span> {
    <span class="tok-kw">const</span> number = Number.one;
    <span class="tok-kw">const</span> result = <span class="tok-kw">switch</span> (number) {
        .one =&gt; <span class="tok-null">true</span>,
        .two, .three =&gt; <span class="tok-null">false</span>,
        _ =&gt; <span class="tok-null">false</span>,
    };
    <span class="tok-kw">try</span> expect(result);
    <span class="tok-kw">const</span> is_one = <span class="tok-kw">switch</span> (number) {
        .one =&gt; <span class="tok-null">true</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
    };
    <span class="tok-kw">try</span> expect(is_one);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_switch_non-exhaustive.zig</kbd>
1/1 test_switch_non-exhaustive.test.switch on non-exhaustive enum...OK
All 1 tests passed.
</samp></pre></figure>

      
      

      <h2 id="union"><a href="https://ziglang.org/documentation/0.15.2/#toc-union">union</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#union">§</a></h2>

      <p>
      裸 <code><span class="tok-kw">union</span></code> 将值可以是的一组可能类型定义为字段列表。一次只能有一个字段处于活动状态。
      裸联合体的内存表示不受保证。
      裸联合体不能用于重新解释内存。为此,请使用 <a href="https://ziglang.org/documentation/0.15.2/#ptrCast">@ptrCast</a>,
      或使用具有保证内存布局的 <a href="https://ziglang.org/documentation/0.15.2/#extern-union">extern union</a> 或 <a href="https://ziglang.org/documentation/0.15.2/#packed-union">packed union</a>。
      <a href="https://ziglang.org/documentation/0.15.2/#Wrong-Union-Field-Access">访问非活动字段</a>是
      经过安全检查的<a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_wrong_union_access.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Payload = <span class="tok-kw">union</span> {
    int: <span class="tok-type">i64</span>,
    float: <span class="tok-type">f64</span>,
    boolean: <span class="tok-type">bool</span>,
};
<span class="tok-kw">test</span> <span class="tok-str">"simple union"</span> {
    <span class="tok-kw">var</span> payload = Payload{ .int = <span class="tok-number">1234</span> };
    payload.float = <span class="tok-number">12.34</span>;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_wrong_union_access.zig</kbd>
1/1 test_wrong_union_access.test.simple union...thread 2895385 panic: access of union field 'float' while field 'int' is active
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_wrong_union_access.zig:8:12</span>: <span class="sgr-2m">0x102c083 in test.simple union (test_wrong_union_access.zig)</span>
    payload.float = 12.34;
           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:218:25</span>: <span class="sgr-2m">0x115cdb0 in mainTerminal (test_runner.zig)</span>
        if (test_fn.func()) |_| {
                        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:66:28</span>: <span class="sgr-2m">0x1155fd1 in main (test_runner.zig)</span>
        return mainTerminal();
                           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x114fd6d in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x114f601 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
error: the following test command crashed:
/home/andy/dev/zig/.zig-cache/o/ceece336399a577bb1b9c6460feb4406/test --seed=0xa290ca33
</samp></pre></figure>

      <p>您可以通过赋值整个联合体来激活另一个字段:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_simple_union.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Payload = <span class="tok-kw">union</span> {
    int: <span class="tok-type">i64</span>,
    float: <span class="tok-type">f64</span>,
    boolean: <span class="tok-type">bool</span>,
};
<span class="tok-kw">test</span> <span class="tok-str">"simple union"</span> {
    <span class="tok-kw">var</span> payload = Payload{ .int = <span class="tok-number">1234</span> };
    <span class="tok-kw">try</span> expect(payload.int == <span class="tok-number">1234</span>);
    payload = Payload{ .float = <span class="tok-number">12.34</span> };
    <span class="tok-kw">try</span> expect(payload.float == <span class="tok-number">12.34</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_simple_union.zig</kbd>
1/1 test_simple_union.test.simple union...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      为了对联合体使用 <a href="https://ziglang.org/documentation/0.15.2/#switch">switch</a>,它必须是<a href="https://ziglang.org/documentation/0.15.2/#Tagged-union">标记联合体</a>。
      </p>
      <p>
      当标签是 <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a> 已知名称时,要初始化联合体,请参阅 <a href="https://ziglang.org/documentation/0.15.2/#unionInit">@unionInit</a>。
      </p>

      <h3 id="Tagged-union"><a href="https://ziglang.org/documentation/0.15.2/#toc-Tagged-union">标记联合体</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Tagged-union">§</a></h3>

      <p>联合体可以使用枚举标签类型声明。
      这会将联合体变成<em>标记</em>联合体,使其有资格
      与 <a href="https://ziglang.org/documentation/0.15.2/#switch">switch</a> 表达式一起使用。
      标记联合体强制转换为其标签类型:<a href="https://ziglang.org/documentation/0.15.2/#Type-Coercion-Unions-and-Enums">类型强制转换:联合体和枚举</a>。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_tagged_union.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> ComplexTypeTag = <span class="tok-kw">enum</span> {
    ok,
    not_ok,
};
<span class="tok-kw">const</span> ComplexType = <span class="tok-kw">union</span>(ComplexTypeTag) {
    ok: <span class="tok-type">u8</span>,
    not_ok: <span class="tok-type">void</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">"switch on tagged union"</span> {
    <span class="tok-kw">const</span> c = ComplexType{ .ok = <span class="tok-number">42</span> };
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@as</span>(ComplexTypeTag, c) == ComplexTypeTag.ok);

    <span class="tok-kw">switch</span> (c) {
        .ok =&gt; |value| <span class="tok-kw">try</span> expect(value == <span class="tok-number">42</span>),
        .not_ok =&gt; <span class="tok-kw">unreachable</span>,
    }
}

<span class="tok-kw">test</span> <span class="tok-str">"get tag type"</span> {
    <span class="tok-kw">try</span> expect(std.meta.Tag(ComplexType) == ComplexTypeTag);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_tagged_union.zig</kbd>
1/2 test_tagged_union.test.switch on tagged union...OK
2/2 test_tagged_union.test.get tag type...OK
All 2 tests passed.
</samp></pre></figure>

      <p>为了在 switch 表达式中修改标记联合体的有效负载,
      在变量名称前放置 <code>*</code> 使其成为指针:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_switch_modify_tagged_union.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> ComplexTypeTag = <span class="tok-kw">enum</span> {
    ok,
    not_ok,
};
<span class="tok-kw">const</span> ComplexType = <span class="tok-kw">union</span>(ComplexTypeTag) {
    ok: <span class="tok-type">u8</span>,
    not_ok: <span class="tok-type">void</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">"modify tagged union in switch"</span> {
    <span class="tok-kw">var</span> c = ComplexType{ .ok = <span class="tok-number">42</span> };

    <span class="tok-kw">switch</span> (c) {
        ComplexTypeTag.ok =&gt; |*value| value.* += <span class="tok-number">1</span>,
        ComplexTypeTag.not_ok =&gt; <span class="tok-kw">unreachable</span>,
    }

    <span class="tok-kw">try</span> expect(c.ok == <span class="tok-number">43</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_switch_modify_tagged_union.zig</kbd>
1/1 test_switch_modify_tagged_union.test.modify tagged union in switch...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      联合体可以推断枚举标签类型。
      此外,联合体可以像结构体和枚举一样具有方法。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_union_method.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Variant = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    int: <span class="tok-type">i32</span>,
    boolean: <span class="tok-type">bool</span>,

    <span class="tok-comment">// 推断枚举标签类型时可以省略 void。</span>
    none,

    <span class="tok-kw">fn</span> <span class="tok-fn">truthy</span>(self: Variant) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self) {
            Variant.int =&gt; |x_int| x_int != <span class="tok-number">0</span>,
            Variant.boolean =&gt; |x_bool| x_bool,
            Variant.none =&gt; <span class="tok-null">false</span>,
        };
    }
};

<span class="tok-kw">test</span> <span class="tok-str">"union method"</span> {
    <span class="tok-kw">var</span> v1: Variant = .{ .int = <span class="tok-number">1</span> };
    <span class="tok-kw">var</span> v2: Variant = .{ .boolean = <span class="tok-null">false</span> };
    <span class="tok-kw">var</span> v3: Variant = .none;

    <span class="tok-kw">try</span> expect(v1.truthy());
    <span class="tok-kw">try</span> expect(!v2.truthy());
    <span class="tok-kw">try</span> expect(!v3.truthy());
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_union_method.zig</kbd>
1/1 test_union_method.test.union method...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      具有推断枚举标签类型的联合体也可以为其推断标签分配序数值。
      这要求标签指定显式整数类型。
      <a href="https://ziglang.org/documentation/0.15.2/#intFromEnum">@intFromEnum</a> 可用于访问与活动字段对应的序数值。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_tagged_union_with_tag_values.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Tagged = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>(<span class="tok-type">u32</span>)) {
    int: <span class="tok-type">i64</span> = <span class="tok-number">123</span>,
    boolean: <span class="tok-type">bool</span> = <span class="tok-number">67</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">"tag values"</span> {
    <span class="tok-kw">const</span> int: Tagged = .{ .int = -<span class="tok-number">40</span> };
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(int) == <span class="tok-number">123</span>);

    <span class="tok-kw">const</span> boolean: Tagged = .{ .boolean = <span class="tok-null">false</span> };
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(boolean) == <span class="tok-number">67</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_tagged_union_with_tag_values.zig</kbd>
1/1 test_tagged_union_with_tag_values.test.tag values...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      <a href="https://ziglang.org/documentation/0.15.2/#tagName">@tagName</a> 可用于返回表示字段名称的 <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a>
      <code>[:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code> 值:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_tagName.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Small2 = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    a: <span class="tok-type">i32</span>,
    b: <span class="tok-type">bool</span>,
    c: <span class="tok-type">u8</span>,
};
<span class="tok-kw">test</span> <span class="tok-str">"@tagName"</span> {
    <span class="tok-kw">try</span> expect(std.mem.eql(<span class="tok-type">u8</span>, <span class="tok-builtin">@tagName</span>(Small2.a), <span class="tok-str">"a"</span>));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_tagName.zig</kbd>
1/1 test_tagName.test.@tagName...OK
All 1 tests passed.
</samp></pre></figure>

      

      <h3 id="extern-union"><a href="https://ziglang.org/documentation/0.15.2/#toc-extern-union">extern union</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#extern-union">§</a></h3>

      <p>
      <code><span class="tok-kw">extern</span> <span class="tok-kw">union</span></code> 的内存布局保证与目标 C ABI 兼容。
      </p>
      <p>另见:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#extern-struct">extern struct</a></li>
</ul>

      

      <h3 id="packed-union"><a href="https://ziglang.org/documentation/0.15.2/#toc-packed-union">packed union</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#packed-union">§</a></h3>

      <p><code><span class="tok-kw">packed</span> <span class="tok-kw">union</span></code> 具有定义良好的内存布局,并且有资格
          位于 <a href="https://ziglang.org/documentation/0.15.2/#packed-struct">packed struct</a> 中。</p>
      

      <h3 id="Anonymous-Union-Literals"><a href="https://ziglang.org/documentation/0.15.2/#toc-Anonymous-Union-Literals">匿名联合体字面量</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Anonymous-Union-Literals">§</a></h3>

      <p><a href="https://ziglang.org/documentation/0.15.2/#Anonymous-Struct-Literals">匿名结构体字面量</a>语法可用于在不指定类型的情况下初始化联合体:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_anonymous_union.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Number = <span class="tok-kw">union</span> {
    int: <span class="tok-type">i32</span>,
    float: <span class="tok-type">f64</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">"anonymous union literal syntax"</span> {
    <span class="tok-kw">const</span> i: Number = .{ .int = <span class="tok-number">42</span> };
    <span class="tok-kw">const</span> f = makeNumber();
    <span class="tok-kw">try</span> expect(i.int == <span class="tok-number">42</span>);
    <span class="tok-kw">try</span> expect(f.float == <span class="tok-number">12.34</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">makeNumber</span>() Number {
    <span class="tok-kw">return</span> .{ .float = <span class="tok-number">12.34</span> };
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_anonymous_union.zig</kbd>
1/1 test_anonymous_union.test.anonymous union literal syntax...OK
All 1 tests passed.
</samp></pre></figure>

      

      

      <h2 id="opaque"><a href="https://ziglang.org/documentation/0.15.2/#toc-opaque">opaque</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#opaque">§</a></h2>

      <p>
      <code><span class="tok-kw">opaque</span> {}</code> 声明一个具有未知(但非零)大小和对齐方式的新类型。
      它可以包含与 <a href="https://ziglang.org/documentation/0.15.2/#struct">structs</a>、<a href="https://ziglang.org/documentation/0.15.2/#union">unions</a> 和
      <a href="https://ziglang.org/documentation/0.15.2/#enum">enums</a> 相同的声明。
      </p>
      <p>
      这通常用于与不公开结构体详细信息的 C 代码交互时的类型安全。
      示例:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_opaque.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Derp = <span class="tok-kw">opaque</span> {};
<span class="tok-kw">const</span> Wat = <span class="tok-kw">opaque</span> {};

<span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">bar</span>(d: *Derp) <span class="tok-type">void</span>;
<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(w: *Wat) <span class="tok-kw">callconv</span>(.c) <span class="tok-type">void</span> {
    bar(w);
}

<span class="tok-kw">test</span> <span class="tok-str">"call foo"</span> {
    foo(<span class="tok-null">undefined</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_opaque.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_opaque.zig:6:9: </span><span class="sgr-31m">error: </span><span class="sgr-1m">expected type '*test_opaque.Derp', found '*test_opaque.Wat'
</span>    bar(w);
        <span class="sgr-32m">^
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_opaque.zig:6:9: </span><span class="sgr-36m">note: </span><span class="sgr-1m">pointer type child 'test_opaque.Wat' cannot cast into pointer type child 'test_opaque.Derp'
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_opaque.zig:2:13: </span><span class="sgr-36m">note: </span><span class="sgr-1m">opaque declared here
</span>const Wat = opaque {};
            <span class="sgr-32m">^~~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_opaque.zig:1:14: </span><span class="sgr-36m">note: </span><span class="sgr-1m">opaque declared here
</span>const Derp = opaque {};
             <span class="sgr-32m">^~~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_opaque.zig:4:18: </span><span class="sgr-36m">note: </span><span class="sgr-1m">parameter type declared here
</span>extern fn bar(d: *Derp) void;
                 <span class="sgr-32m">^~~~~
</span><span class="sgr-2m">referenced by:
    test.call foo: /home/andy/dev/zig/doc/langref/test_opaque.zig:10:8
</span>
</samp></pre></figure>

      

      <h2 id="Blocks"><a href="https://ziglang.org/documentation/0.15.2/#toc-Blocks">块</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Blocks">§</a></h2>

      <p>
      块用于限制变量声明的作用域:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_blocks.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">"access variable after block scope"</span> {
    {
        <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
        _ = &amp;x;
    }
    x += <span class="tok-number">1</span>;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_blocks.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_blocks.zig:6:5: </span><span class="sgr-31m">error: </span><span class="sgr-1m">use of undeclared identifier 'x'
</span>    x += 1;
    <span class="sgr-32m">^
</span>
</samp></pre></figure>

      <p>块是表达式。当带有标签时,<code><span class="tok-kw">break</span></code> 可用于
      从块返回值:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_labeled_break.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"labeled break from labeled block expression"</span> {
    <span class="tok-kw">var</span> y: <span class="tok-type">i32</span> = <span class="tok-number">123</span>;

    <span class="tok-kw">const</span> x = blk: {
        y += <span class="tok-number">1</span>;
        <span class="tok-kw">break</span> :blk y;
    };
    <span class="tok-kw">try</span> expect(x == <span class="tok-number">124</span>);
    <span class="tok-kw">try</span> expect(y == <span class="tok-number">124</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_labeled_break.zig</kbd>
1/1 test_labeled_break.test.labeled break from labeled block expression...OK
All 1 tests passed.
</samp></pre></figure>

      <p>这里,<code>blk</code> 可以是任何名称。</p>
      <p>另见:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Labeled-while">带标签的 while</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Labeled-for">带标签的 for</a></li>
</ul>


      <h3 id="Shadowing"><a href="https://ziglang.org/documentation/0.15.2/#toc-Shadowing">遮蔽</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Shadowing">§</a></h3>

      <p><a href="https://ziglang.org/documentation/0.15.2/#Identifiers">标识符</a>永远不允许通过使用相同名称来"隐藏"其他标识符:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_shadowing.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> pi = <span class="tok-number">3.14</span>;

<span class="tok-kw">test</span> <span class="tok-str">"inside test block"</span> {
    <span class="tok-comment">// 让我们甚至进入另一个块</span>
    {
        <span class="tok-kw">var</span> pi: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_shadowing.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_shadowing.zig:6:13: </span><span class="sgr-31m">error: </span><span class="sgr-1m">local variable shadows declaration of 'pi'
</span>        var pi: i32 = 1234;
            <span class="sgr-32m">^~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_shadowing.zig:1:1: </span><span class="sgr-36m">note: </span><span class="sgr-1m">declared here
</span>const pi = 3.14;
<span class="sgr-32m">^~~~~~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>
      因此,当您阅读 Zig 代码时,您始终可以依赖标识符在其定义的作用域内始终如一地表示相同的含义。但是请注意,如果
      作用域是分开的,则可以使用相同的名称:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_scopes.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">"separate scopes"</span> {
    {
        <span class="tok-kw">const</span> pi = <span class="tok-number">3.14</span>;
        _ = pi;
    }
    {
        <span class="tok-kw">var</span> pi: <span class="tok-type">bool</span> = <span class="tok-null">true</span>;
        _ = &amp;pi;
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_scopes.zig</kbd>
1/1 test_scopes.test.separate scopes...OK
All 1 tests passed.
</samp></pre></figure>

      

      <h3 id="Empty-Blocks"><a href="https://ziglang.org/documentation/0.15.2/#toc-Empty-Blocks">空块</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Empty-Blocks">§</a></h3>

      <p>空块等同于 <code><span class="tok-type">void</span>{}</code>:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_empty_block.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> {
    <span class="tok-kw">const</span> a = {};
    <span class="tok-kw">const</span> b = <span class="tok-type">void</span>{};
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(a) == <span class="tok-type">void</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(b) == <span class="tok-type">void</span>);
    <span class="tok-kw">try</span> expect(a == b);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_empty_block.zig</kbd>
1/1 test_empty_block.test_0...OK
All 1 tests passed.
</samp></pre></figure>

      
      

      <h2 id="switch"><a href="https://ziglang.org/documentation/0.15.2/#toc-switch">switch</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#switch">§</a></h2>

      <figure><figcaption class="zig-cap"><cite class="file">test_switch.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">"builtin"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"switch simple"</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">u64</span> = <span class="tok-number">10</span>;
    <span class="tok-kw">const</span> zz: <span class="tok-type">u64</span> = <span class="tok-number">103</span>;

    <span class="tok-comment">// switch 表达式的所有分支必须能够被强制转换为</span>
    <span class="tok-comment">// 通用类型。</span>
    <span class="tok-comment">//</span>
    <span class="tok-comment">// 分支不能贯穿。如果需要贯穿行为,请组合</span>
    <span class="tok-comment">// case 并使用 if。</span>
    <span class="tok-kw">const</span> b = <span class="tok-kw">switch</span> (a) {
        <span class="tok-comment">// 可以通过 ',' 组合多个 case</span>
        <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span> =&gt; <span class="tok-number">0</span>,

        <span class="tok-comment">// 可以使用 ... 语法指定范围。这些范围包含</span>
        <span class="tok-comment">// 两端。</span>
        <span class="tok-number">5</span>...<span class="tok-number">100</span> =&gt; <span class="tok-number">1</span>,

        <span class="tok-comment">// 分支可以任意复杂。</span>
        <span class="tok-number">101</span> =&gt; blk: {
            <span class="tok-kw">const</span> c: <span class="tok-type">u64</span> = <span class="tok-number">5</span>;
            <span class="tok-kw">break</span> :blk c * <span class="tok-number">2</span> + <span class="tok-number">1</span>;
        },

        <span class="tok-comment">// 允许对任意表达式进行 switch,只要该</span>
        <span class="tok-comment">// 表达式在编译时已知。</span>
        zz =&gt; zz,
        blk: {
            <span class="tok-kw">const</span> d: <span class="tok-type">u32</span> = <span class="tok-number">5</span>;
            <span class="tok-kw">const</span> e: <span class="tok-type">u32</span> = <span class="tok-number">100</span>;
            <span class="tok-kw">break</span> :blk d + e;
        } =&gt; <span class="tok-number">107</span>,

        <span class="tok-comment">// else 分支捕获所有尚未捕获的内容。</span>
        <span class="tok-comment">// 除非处理整个值范围,否则 else 分支是</span>
        <span class="tok-comment">// 强制性的。</span>
        <span class="tok-kw">else</span> =&gt; <span class="tok-number">9</span>,
    };

    <span class="tok-kw">try</span> expect(b == <span class="tok-number">1</span>);
}

<span class="tok-comment">// Switch 表达式可以在函数外部使用:</span>
<span class="tok-kw">const</span> os_msg = <span class="tok-kw">switch</span> (builtin.target.os.tag) {
    .linux =&gt; <span class="tok-str">"we found a linux user"</span>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-str">"not a linux user"</span>,
};

<span class="tok-comment">// 在函数内部,如果目标表达式在编译时已知,</span>
<span class="tok-comment">// switch 语句会隐式地在编译时求值。</span>
<span class="tok-kw">test</span> <span class="tok-str">"switch inside function"</span> {
    <span class="tok-kw">switch</span> (builtin.target.os.tag) {
        .fuchsia =&gt; {
            <span class="tok-comment">// 在 fuchsia 以外的操作系统上,块甚至不会被分析,</span>
            <span class="tok-comment">// 因此不会触发此编译错误。</span>
            <span class="tok-comment">// 在 fuchsia 上会触发此编译错误。</span>
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">"fuchsia not supported"</span>);
        },
        <span class="tok-kw">else</span> =&gt; {},
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_switch.zig</kbd>
1/2 test_switch.test.switch simple...OK
2/2 test_switch.test.switch inside function...OK
All 2 tests passed.
</samp></pre></figure>

      <p>
      <code><span class="tok-kw">switch</span></code> 可用于捕获<a href="https://ziglang.org/documentation/0.15.2/#Tagged-union">标记联合体</a>的字段值。可以通过在捕获变量名称前放置 <code>*</code> 来修改字段值,
      将其转换为指针。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_switch_tagged_union.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"switch on tagged union"</span> {
    <span class="tok-kw">const</span> Point = <span class="tok-kw">struct</span> {
        x: <span class="tok-type">u8</span>,
        y: <span class="tok-type">u8</span>,
    };
    <span class="tok-kw">const</span> Item = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        a: <span class="tok-type">u32</span>,
        c: Point,
        d,
        e: <span class="tok-type">u32</span>,
    };

    <span class="tok-kw">var</span> a = Item{ .c = Point{ .x = <span class="tok-number">1</span>, .y = <span class="tok-number">2</span> } };

    <span class="tok-comment">// 允许对更复杂的枚举进行 switch。</span>
    <span class="tok-kw">const</span> b = <span class="tok-kw">switch</span> (a) {
        <span class="tok-comment">// 匹配允许使用捕获组,并将返回匹配的枚举</span>
        <span class="tok-comment">// 值。如果两个 case 的有效负载类型相同,</span>
        <span class="tok-comment">// 它们可以放入同一个 switch 分支。</span>
        Item.a, Item.e =&gt; |item| item,

        <span class="tok-comment">// 可以使用 `*` 语法获取匹配值的引用。</span>
        Item.c =&gt; |*item| blk: {
            item.*.x += <span class="tok-number">1</span>;
            <span class="tok-kw">break</span> :blk <span class="tok-number">6</span>;
        },

        <span class="tok-comment">// 如果 case 类型穷尽处理,则不需要 else</span>
        Item.d =&gt; <span class="tok-number">8</span>,
    };

    <span class="tok-kw">try</span> expect(b == <span class="tok-number">6</span>);
    <span class="tok-kw">try</span> expect(a.c.x == <span class="tok-number">2</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_switch_tagged_union.zig</kbd>
1/1 test_switch_tagged_union.test.switch on tagged union...OK
All 1 tests passed.
</samp></pre></figure>

      <p>另见:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#enum">enum</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#compileError">@compileError</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Compile-Variables">编译变量</a></li>
</ul>


      <h3 id="Exhaustive-Switching"><a href="https://ziglang.org/documentation/0.15.2/#toc-Exhaustive-Switching">穷尽 Switch</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Exhaustive-Switching">§</a></h3>

      <p>
      当 <code><span class="tok-kw">switch</span></code> 表达式没有 <code><span class="tok-kw">else</span></code> 子句时,
      它必须穷尽地列出所有可能的值。不这样做会导致编译错误:
      </p>