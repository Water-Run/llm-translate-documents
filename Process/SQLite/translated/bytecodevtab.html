<!-- 由WaterRun使用gpt-5.1-codex-mini翻译, 2026年2月 -->
<!DOCTYPE html>
<html><head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link href="sqlite.css" rel="stylesheet">
<title>Bytecode() 和 Tables_Used() 表值函数</title>
<!-- path= -->
</head>
<body>
<div class=nosearch>
<a href="index.html">
<img class="logo" src="images/sqlite370_banner.svg" alt="SQLite" border="0">
</a>
<div><!-- IE hack to prevent disappearing logo --></div>
<div class="translation-note desktoponly">
由WaterRun使用gpt-5.1-codex-mini翻译
</div>
<div class="tagline desktoponly">
小巧。快速。可靠。任选其三。
</div>
<div class="menu mainmenu">
<ul>
<li><a href="index.html">主页</a>
<li class='mobileonly'><a href="javascript:void(0)" onclick='toggle_div("submenu")'>菜单</a>
<li class='wideonly'><a href='about.html'>关于</a>
<li class='desktoponly'><a href="docs.html">文档</a>
<li class='desktoponly'><a href="download.html">下载</a>
<li class='wideonly'><a href='copyright.html'>许可证</a>
<li class='desktoponly'><a href="support.html">支持</a>
<li class='desktoponly'><a href="prosupport.html">购买</a>
<li class='desktoponly'><a href="https://github.com/Water-Run/llm-translate-documents">翻译仓库</a>
<li class='search' id='search_menubutton'>
<a href="javascript:void(0)" onclick='toggle_search()'>搜索</a>
</ul>
</div>
<div class="menu submenu" id="submenu">
<ul>
<li><a href='about.html'>关于</a>
<li><a href='docs.html'>文档</a>
<li><a href='download.html'>下载</a>
<li><a href='support.html'>支持</a>
<li><a href='prosupport.html'>购买</a>
<li><a href="https://github.com/Water-Run/llm-translate-documents">翻译仓库</a>
</ul>
</div>
<div class="searchmenu" id="searchmenu">
<form method="GET" action="search">
<select name="s" id="searchtype">
<option value="d">搜索文档</option>
<option value="c">搜索更新日志</option>
</select>
<input type="text" name="q" id="searchbox" value="">
<input type="submit" value="前往">
</form>
</div>
</div>
<script>
function toggle_div(nm) {
var w = document.getElementById(nm);
if( w.style.display=="block" ){
w.style.display = "none";
}else{
w.style.display = "block";
}
}
function toggle_search() {
var w = document.getElementById("searchmenu");
if( w.style.display=="block" ){
w.style.display = "none";
} else {
w.style.display = "block";
setTimeout(function(){
document.getElementById("searchbox").focus()
}, 30);
}
}
function div_off(nm){document.getElementById(nm).style.display="none";}
window.onbeforeunload = function(e){div_off("submenu");}
/* Disable the Search feature if we are not operating from CGI, since */
/* Search is accomplished using CGI and will not work without it. */
if( !location.origin || !location.origin.match || !location.origin.match(/http/) ){
document.getElementById("search_menubutton").style.display = "none";
}
/* Used by the Hide/Show button beside syntax diagrams, to toggle the */
function hideorshow(btn,obj){
var x = document.getElementById(obj);
var b = document.getElementById(btn);
if( x.style.display!='none' ){
x.style.display = 'none';
b.innerHTML='show';
}else{
x.style.display = '';
b.innerHTML='hide';
}
return false;
}
var antiRobot = 0;
function antiRobotGo(){
if( antiRobot!=3 ) return;
antiRobot = 7;
var j = document.getElementById("mtimelink");
if(j && j.hasAttribute("data-href")) j.href=j.getAttribute("data-href");
}
function antiRobotDefense(){
document.body.onmousedown=function(){
antiRobot |= 2;
antiRobotGo();
document.body.onmousedown=null;
}
document.body.onmousemove=function(){
antiRobot |= 2;
antiRobotGo();
document.body.onmousemove=null;
}
setTimeout(function(){
antiRobot |= 1;
antiRobotGo();
}, 100)
antiRobotGo();
}
antiRobotDefense();
</script>
<div class=fancy>
<div class=nosearch>
<div class="fancy_title">
Bytecode() 和 Tables_Used() 表值函数
</div>
<details class="fancy_toc">
<summary>目录</summary>
<div id="toc_sub"><div class="fancy-toc1"><a href="#overview">1. 概述</a></div>
<div class="fancy-toc1"><a href="#usage">2. 用法</a></div>
<div class="fancy-toc2"><a href="#schema_for_bytecode">2.1. bytecode 的模式</a></div>
<div class="fancy-toc2"><a href="#schema_for_tables_used">2.2. tables_used 的模式</a></div>
</div>
</details>
</div>




<h1 id="overview"><span>1. </span>概述</h1>

<p>
bytecode 和 tables_used 是内置于 SQLite 的<a href="vtab.html">虚拟表</a>，用于访问<a href="c3ref/stmt.html">预编译语句</a>的信息。bytecode 与 tables_used 都以<a href="vtab.html#tabfunc2">表值函数</a>的形式运行。它们接受一个必需参数，该参数可以是 SQL 语句的文本，也可以是指向现有预编译语句的指针。bytecode 函数为预编译语句中的每个<a href="opcode.html">字节码</a>操作返回一行结果；tables_used 函数为预编译语句访问的每个持久 B 树（表或索引）返回一行。
</p><h1 id="usage"><span>2. </span>用法</h1>

<p>
只有在使用 <a href="compile.html#enable_bytecode_vtab">-DSQLITE_ENABLE_BYTECODE_VTAB</a> 编译选项编译 SQLite 时，bytecode 与 tables_used 表才可用。<a href="cli.html">CLI</a> 就是这样编译的，所以可以使用标准<a href="cli.html">CLI</a> 作为测试平台进行实验。
</p><p>
这两个虚拟表都是只读的<a href="vtab.html#epoonlyvtab">同名仅可写虚拟表</a>，必须在 SELECT 语句的 FROM 子句中直接引用。它们都要求一个参数，该参数就是要分析的 SQL 语句。例如：
</p><div class="codeblock"><pre>SELECT * FROM bytecode('SELECT * FROM bytecode(?1)');
</pre></div>

<p>
参数可以是 SQL 语句的文本，此时返回该语句的 bytecode（或 tables_used），也可以是像 ?1 或 $stmt 这样的参数，随后通过<a href="c3ref/bind_blob.html">sqlite3_bind_pointer()</a> 接口绑定到<a href="c3ref/stmt.html">预编译语句</a>对象。请为<a href="c3ref/bind_blob.html">sqlite3_bind_pointer()</a> 接口使用 "stmt-pointer" 指针类型。
</p><h2 id="schema_for_bytecode"><span>2.1. </span>bytecode 的模式</h2>

<p>
bytecode 虚拟表的模式为：
</p><div class="codeblock"><pre>CREATE TABLE bytecode(
  addr INT,
  opcode TEXT,
  p1 INT,
  p2 INT,
  p3 INT,
  p4 TEXT,
  p5 INT,
  comment TEXT,
  subprog TEXT,
  nexec INT,
  ncycle INT,
  stmt HIDDEN
);
</pre></div>

<p>
前八列分别表示运行该语句的虚拟机中的一个<a href="opcode.html">字节码</a>的地址、操作码和操作数。这些列与使用 EXPLAIN 输出的列相同。
</p><p> bytecode 虚拟表会显示预编译语句中的所有操作，包括主语句主体以及用于实现触发器或外键动作的子程序。"subprog" 字段在预编译语句主主体中为 NULL；在触发器或外键动作中，该字段分别为触发器名称或字符串 "(FK)"。
</p><p> "nexec" 与 "ncycle" 两列显示每个操作码的执行次数以及该操作码消耗的 CPU 周期总数。除非 SQLite 是在启用了<a href="compile.html#enable_stmt_scanstatus">SQLITE_ENABLE_STMT_SCANSTATUS</a> 编译选项的情况下构建，并且已经通过<a href="c3ref/db_config.html">sqlite3_db_config</a>(db,<a href="c3ref/c_dbconfig_defensive.html#sqlitedbconfigstmtscanstatus">SQLITE_DBCONFIG_STMT_SCANSTATUS</a>,...) 接口启用了扫描状态统计，否则这些字段的值始终为 0。nexec 与 ncycle 的值会累积，直到使用<a href="c3ref/stmt_scanstatus_reset.html">sqlite3_stmt_scanstatus_reset()</a> 重置。
</p><p>
除非 SQLite 是为 X86_64 或 AARCH64 处理器使用 GCC、Clang 或 MSVC 编译，或为 PPC 处理器使用 GCC 或 Clang 编译，否则 "ncycle" 列目前始终返回 0。
</p><h2 id="schema_for_tables_used"><span>2.2. </span>tables_used 的模式</h2>

<p>
tables_used 表的模式为：
</p><div class="codeblock"><pre>CREATE TABLE tables_used(
  type TEXT,
  schema TEXT,
  name TEXT,
  wr INT,
  subprog TEXT,
  stmt HIDDEN
);
</pre></div>

<p>
tables_used 表用于显示预编译语句访问的数据库文件中的哪些 B 树会被读取或写入，包括主语句以及相关的触发器与外键动作。各列含义如下：
</p><ul>
<li><p><b>type</b> → 表示该 B 树的作用，是 "table" 还是 "index"。
</p></li><li><p><b>schema</b> → 表示该 B 树位于哪个数据库文件中。主数据库（通常情况）为 "main"，TEMP 表与索引为 "temp"，或者是通过<a href="lang_attach.html">ATTACH</a> 语句赋予的附加数据库名。
</p></li><li><p><b>name</b> → 表或索引的名称。
</p></li><li><p><b>wr</b> → 如果该对象被读取则为 0，被写入则为 1。
</p></li><li><p><b>subprog</b> → 表示访问该对象的子程序。NULL 表示预编译语句的主主体；否则该字段为触发器名称或外键动作标记 "(FK)"。
</p></li></ul>
<p align="center"><small><i>本页最后更新于 2025-11-13 07:12:58Z </small></i></p>

</div>
