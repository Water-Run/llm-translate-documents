<!-- slice index: 1 -->
<!-- lines 0–1497 / total 11964 -->
<!-- title: Lua 5.4 Reference Manual -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<title>Lua 5.4 参考手册</title>
<link rel="stylesheet" type="text/css" href="Lua%205.4%20Reference%20Manual_files/lua.css">
<link rel="stylesheet" type="text/css" href="Lua%205.4%20Reference%20Manual_files/manual.css">
<meta charset="UTF-8">
</head>

<body>

<h1>
<a href="https://www.lua.org/"></a>
Lua 5.4 参考手册
</h1>

<p>
作者：Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes

</p><p>
<small>
版权所有 © 2020–2025 Lua.org, PUC-Rio.
根据<a href="https://www.lua.org/license.html">Lua 许可证</a>条款自由提供。
</small>

</p><div class="menubar">
<a href="https://www.lua.org/manual/5.4/contents.html#contents">官网目录</a>
·
<a href="https://www.lua.org/manual/5.4/contents.html#index">官网索引</a>
·
<a href="https://www.lua.org/manual/">官网其他版本文档</a>
</div>

<!-- ====================================================================== -->
<p>

<!-- $Id: manual.of $ -->




</p><h1>1 – <a name="1">引言</a></h1>

<p>
Lua 是一种强大、高效、轻量、可嵌入的脚本语言。
它支持过程式编程、面向对象编程、函数式编程、数据驱动编程和数据描述。


</p><p>
Lua 将简单的过程式语法与基于关联数组和可扩展语义的强大数据描述结构相结合。
Lua 是动态类型的，通过基于寄存器的虚拟机解释执行字节码，
并具有分代垃圾回收的自动内存管理，
使其成为配置、脚本编写和快速原型开发的理想选择。


</p><p>
Lua 以库的形式实现，使用<em>纯净 C</em>（标准 C 和 C++ 的公共子集）编写。
Lua 发行版包含一个名为 <code>lua</code> 的宿主程序，
它使用 Lua 库提供一个完整的独立 Lua 解释器，
用于交互式或批处理使用。
Lua 既可以作为任何需要脚本语言的程序的强大、轻量、可嵌入的脚本语言，
也可以作为强大但轻量高效的独立语言。


</p><p>
作为扩展语言，Lua 没有"主"程序的概念：
它工作时<em>嵌入</em>在宿主客户端中，
称为<em>嵌入程序</em>或简称<em>宿主</em>。
（通常，这个宿主是独立的 <code>lua</code> 程序。）
宿主程序可以调用函数来执行一段 Lua 代码，
可以读写 Lua 变量，
并可以注册 C 函数供 Lua 代码调用。
通过使用 C 函数，Lua 可以被增强以应对各种不同的领域，
从而创建共享语法框架的定制编程语言。


</p><p>
Lua 是自由软件，
按照其许可证中所述，不提供任何保证。
本手册中描述的实现可在 Lua 官方网站 <code>www.lua.org</code> 获取。


</p><p>
像任何其他参考手册一样，
本文档在某些地方较为枯燥。
有关 Lua 设计决策的讨论，
请参阅 Lua 网站上提供的技术论文。
有关 Lua 编程的详细介绍，
请参阅 Roberto 的书《Lua 程序设计》。



</p><h1>2 – <a name="2">基本概念</a></h1>



<p>
本节描述语言的基本概念。





</p><h2>2.1 – <a name="2.1">值和类型</a></h2>

<p>
Lua 是一种动态类型语言。
这意味着变量没有类型；只有值有类型。
语言中没有类型定义。
所有值都携带自己的类型。


</p><p>
Lua 中的所有值都是第一类值。
这意味着所有值都可以存储在变量中，
作为参数传递给其他函数，并作为结果返回。


</p><p>
Lua 中有八种基本类型：
<em>nil</em>、<em>boolean</em>、<em>number</em>、
<em>string</em>、<em>function</em>、<em>userdata</em>、
<em>thread</em> 和 <em>table</em>。
类型 <em>nil</em> 只有一个值 <b>nil</b>，
其主要属性是与任何其他值不同；
它通常表示缺少有用的值。
类型 <em>boolean</em> 有两个值，<b>false</b> 和 <b>true</b>。
<b>nil</b> 和 <b>false</b> 都使条件为假；
它们统称为<em>假值</em>。
任何其他值都使条件为真。
尽管名称如此，
<b>false</b> 经常被用作 <b>nil</b> 的替代，
主要区别在于 <b>false</b> 在表中表现为常规值，
而表中的 <b>nil</b> 表示不存在的键。


</p><p>
类型 <em>number</em> 表示整数和实数（浮点数），
使用两个子类型：<em>integer</em> 和 <em>float</em>。
标准 Lua 使用 64 位整数和双精度（64 位）浮点数，
但您也可以编译 Lua 使其使用 32 位整数和/或单精度（32 位）浮点数。
整数和浮点数都使用 32 位的选项对于小型机器和嵌入式系统特别有吸引力。
（参见文件 <code>luaconf.h</code> 中的宏 <code>LUA_32BITS</code>。）


</p><p>
除非另有说明，
操作整数值时的任何溢出都会<em>回绕</em>，
遵循二进制补码算术的常规规则。
（换句话说，
实际结果是唯一可表示的整数，
它在模 <em>2<sup>n</sup></em> 意义下等于数学结果，
其中 <em>n</em> 是整数类型的位数。）


</p><p>
Lua 有明确的规则规定何时使用每个子类型，
但也会根据需要在它们之间自动转换（参见 <a href="#3.4.3">§3.4.3</a>）。
因此，
程序员可以选择大部分忽略整数和浮点数之间的差异，
或者完全控制每个数字的表示。


</p><p>
类型 <em>string</em> 表示不可变的字节序列。

Lua 是 8 位清洁的：
字符串可以包含任何 8 位值，
包括嵌入的零（'<code>\0</code>'）。
Lua 也与编码无关；
它不对字符串的内容做任何假设。
Lua 中任何字符串的长度必须能容纳在一个 Lua 整数中。


</p><p>
Lua 可以调用（和操作）用 Lua 编写的函数和
用 C 编写的函数（参见 <a href="#3.4.10">§3.4.10</a>）。
两者都由类型 <em>function</em> 表示。


</p><p>
类型 <em>userdata</em> 用于允许任意 C 数据存储在 Lua 变量中。
userdata 值表示一块原始内存。
有两种 userdata：
<em>完全 userdata</em>，
它是一个带有由 Lua 管理的内存块的对象，
以及<em>轻量 userdata</em>，
它只是一个 C 指针值。
Userdata 在 Lua 中除了赋值和相等性测试外没有预定义操作。
通过使用<em>元表</em>，
程序员可以为完全 userdata 值定义操作
（参见 <a href="#2.4">§2.4</a>）。
Userdata 值不能在 Lua 中创建或修改，
只能通过 C API。
这保证了宿主程序和 C 库拥有的数据的完整性。


</p><p>
类型 <em>thread</em> 表示独立的执行线程，
用于实现协程（参见 <a href="#2.6">§2.6</a>）。
Lua 线程与操作系统线程无关。
Lua 在所有系统上都支持协程，
即使那些本身不支持线程的系统。


</p><p>
类型 <em>table</em> 实现关联数组，
即不仅可以用数字作为索引，
还可以用除 <b>nil</b> 和 NaN 之外的任何 Lua 值作为索引的数组。
（<em>非数字</em>是 IEEE 754 标准使用的特殊浮点值，
用于表示未定义的数值结果，如 <code>0/0</code>。）
表可以是<em>异构的</em>；
即它们可以包含所有类型的值（除了 <b>nil</b>）。
任何与值 <b>nil</b> 关联的键都不被认为是表的一部分。
反之，任何不属于表的键都有一个关联值 <b>nil</b>。


</p><p>
表是 Lua 中唯一的数据结构机制；
它们可以用来表示普通数组、列表、
符号表、集合、记录、图、树等。
为了表示记录，Lua 使用字段名作为索引。
语言通过提供 <code>a.name</code> 作为 <code>a["name"]</code> 的语法糖来支持这种表示。
Lua 中有几种方便的创建表的方法
（参见 <a href="#3.4.9">§3.4.9</a>）。


</p><p>
像索引一样，
表字段的值可以是任何类型。
特别地，
因为函数是第一类值，
表字段可以包含函数。
因此表也可以携带<em>方法</em>（参见 <a href="#3.4.11">§3.4.11</a>）。


</p><p>
表的索引遵循语言中原始相等性的定义。
表达式 <code>a[i]</code> 和 <code>a[j]</code>
表示同一个表元素
当且仅当 <code>i</code> 和 <code>j</code> 原始相等
（即不使用元方法的相等）。
特别地，具有整数值的浮点数
等于它们各自的整数
（例如，<code>1.0 == 1</code>）。
为避免歧义，
任何用作键的等于整数的浮点数
都会转换为该整数。
例如，如果您写 <code>a[2.0] = true</code>，
实际插入表中的键将是整数 <code>2</code>。


</p><p>
表、函数、线程和（完全）userdata 值是<em>对象</em>：
变量实际上不<em>包含</em>这些值，
只包含对它们的<em>引用</em>。
赋值、参数传递和函数返回
总是操作这些值的引用；
这些操作不涉及任何形式的复制。


</p><p>
库函数 <a href="#pdf-type"><code>type</code></a> 返回一个描述给定值类型的字符串
（参见 <a href="#pdf-type"><code>type</code></a>）。





</p><h2>2.2 – <a name="2.2">环境和全局环境</a></h2>

<p>
正如我们将在 <a href="#3.2">§3.2</a> 和 <a href="#3.3.3">§3.3.3</a> 中进一步讨论的，
任何对自由名称（即未绑定到任何声明的名称）<code>var</code> 的引用
在语法上都被翻译为 <code>_ENV.var</code>。
此外，每个代码块都在一个名为 <code>_ENV</code> 的外部局部变量的作用域中编译（参见 <a href="#3.3.2">§3.3.2</a>），
所以 <code>_ENV</code> 本身在代码块中永远不是自由名称。


</p><p>
尽管存在这个外部 <code>_ENV</code> 变量和自由名称的翻译，
<code>_ENV</code> 是一个完全正规的名称。
特别地，
您可以定义具有该名称的新变量和参数。
每次对自由名称的引用都使用程序中该点可见的 <code>_ENV</code>，
遵循 Lua 的常规可见性规则（参见 <a href="#3.5">§3.5</a>）。


</p><p>
任何用作 <code>_ENV</code> 值的表都称为<em>环境</em>。


</p><p>
Lua 保留一个称为<em>全局环境</em>的特殊环境。
该值保存在 C 注册表的特殊索引中（参见 <a href="#4.3">§4.3</a>）。
在 Lua 中，全局变量 <a href="#pdf-_G"><code>_G</code></a> 使用相同的值初始化。
（<a href="#pdf-_G"><code>_G</code></a> 从不在内部使用，
所以更改其值只会影响您自己的代码。）


</p><p>
当 Lua 加载代码块时，
其 <code>_ENV</code> 变量的默认值是全局环境（参见 <a href="#pdf-load"><code>load</code></a>）。
因此，默认情况下，
Lua 代码中的自由名称引用全局环境中的条目，
因此，它们也被称为<em>全局变量</em>。
此外，所有标准库都加载到全局环境中，
其中一些函数在该环境上操作。
您可以使用 <a href="#pdf-load"><code>load</code></a>（或 <a href="#pdf-loadfile"><code>loadfile</code></a>）
加载具有不同环境的代码块。
（在 C 中，您必须加载代码块，然后更改其第一个上值的值；参见 <a href="#lua_setupvalue"><code>lua_setupvalue</code></a>。）





</p><h2>2.3 – <a name="2.3">错误处理</a></h2>

<p>
Lua 中的几个操作可以<em>引发</em>错误。
错误会中断程序的正常流程，
可以通过<em>捕获</em>错误来继续。


</p><p>
Lua 代码可以通过调用 <a href="#pdf-error"><code>error</code></a> 函数显式引发错误。
（此函数永不返回。）


</p><p>
要在 Lua 中捕获错误，
您可以进行<em>保护调用</em>，
使用 <a href="#pdf-pcall"><code>pcall</code></a>（或 <a href="#pdf-xpcall"><code>xpcall</code></a>）。
函数 <a href="#pdf-pcall"><code>pcall</code></a> 在<em>保护模式</em>下调用给定函数。
运行函数时的任何错误都会停止其执行，
并且控制立即返回到 <code>pcall</code>，
它返回一个状态码。


</p><p>
因为 Lua 是嵌入式扩展语言，
Lua 代码通过宿主程序中的 C 代码调用开始运行。
（当您独立使用 Lua 时，
<code>lua</code> 应用程序是宿主程序。）
通常，这个调用是受保护的；
所以，当在编译或执行 Lua 代码块期间发生未受保护的错误时，
控制返回到宿主，
宿主可以采取适当的措施，
如打印错误消息。


</p><p>
每当发生错误时，
都会传播一个<em>错误对象</em>，其中包含有关错误的信息。
Lua 本身只生成错误对象为字符串的错误，
但程序可以使用任何值作为错误对象生成错误。
由 Lua 程序或其宿主处理此类错误对象。
由于历史原因，
错误对象通常称为<em>错误消息</em>，
即使它不必是字符串。


</p><p>
当您使用 <a href="#pdf-xpcall"><code>xpcall</code></a>（或 C 中的 <a href="#lua_pcall"><code>lua_pcall</code></a>）时，
您可以给出一个<em>消息处理器</em>
以在发生错误时调用。
此函数使用原始错误对象调用
并返回新的错误对象。
它在错误展开堆栈之前调用，
以便它可以收集有关错误的更多信息，
例如通过检查堆栈并创建堆栈回溯。
此消息处理器仍受保护调用的保护；
所以，消息处理器内的错误
将再次调用消息处理器。
如果此循环持续太长时间，
Lua 会中断它并返回适当的消息。
消息处理器仅对常规运行时错误调用。
它不会对内存分配错误
或运行终结器或其他消息处理器时的错误调用。


</p><p>
Lua 还提供了<em>警告</em>系统（参见 <a href="#pdf-warn"><code>warn</code></a>）。
与错误不同，警告不会以任何方式干扰程序执行。
它们通常只向用户生成消息，
尽管可以从 C 调整此行为（参见 <a href="#lua_setwarnf"><code>lua_setwarnf</code></a>）。





</p><h2>2.4 – <a name="2.4">元表和元方法</a></h2>

<p>
Lua 中的每个值都可以有一个<em>元表</em>。
这个<em>元表</em>是一个普通的 Lua 表，
定义了原始值在特定事件下的行为。
您可以通过在元表中设置特定字段来更改值行为的几个方面。
例如，当非数字值是加法的操作数时，
Lua 会在该值的元表的 <code>__add</code> 字段中查找函数。
如果找到一个，
Lua 调用此函数来执行加法。


</p><p>
元表中每个事件的键是一个字符串，
事件名称前缀两个下划线；
相应的值称为<em>元值</em>。
对于大多数事件，元值必须是函数，
然后称为<em>元方法</em>。
在前面的例子中，键是字符串"<code>__add</code>"
元方法是执行加法的函数。
除非另有说明，
元方法实际上可以是任何可调用值，
它是函数或具有 <code>__call</code> 元方法的值。


</p><p>
您可以使用 <a href="#pdf-getmetatable"><code>getmetatable</code></a> 函数查询任何值的元表。
Lua 使用原始访问在元表中查询元方法（参见 <a href="#pdf-rawget"><code>rawget</code></a>）。


</p><p>
您可以使用 <a href="#pdf-setmetatable"><code>setmetatable</code></a> 函数替换表的元表。
您不能从 Lua 代码更改其他类型的元表，
除非使用调试库（<a href="#6.10">§6.10</a>）。


</p><p>
表和完全 userdata 有单独的元表，
尽管多个表和 userdata 可以共享它们的元表。
所有其他类型的值每种类型共享一个元表；
即所有数字有一个元表，
所有字符串有一个，等等。
默认情况下，值没有元表，
但字符串库为字符串类型设置元表（参见 <a href="#6.4">§6.4</a>）。


</p><p>
以下给出了由元表控制的操作的详细列表。
每个事件由其相应的键标识。
按照惯例，Lua 使用的所有元表键都由
两个下划线后跟小写拉丁字母组成。



</p><ul>

<li><b><code>__add</code>：</b>
加法（<code>+</code>）操作。
如果加法的任何操作数不是数字，
Lua 将尝试调用元方法。
它首先检查第一个操作数（即使它是数字）；
如果该操作数没有为 <code>__add</code> 定义元方法，
则 Lua 将检查第二个操作数。
如果 Lua 能找到元方法，
它以两个操作数作为参数调用元方法，
调用的结果（调整为一个值）
是操作的结果。
否则，如果找不到元方法，
Lua 引发错误。
</li>

<li><b><code>__sub</code>：</b>
减法（<code>-</code>）操作。
行为类似于加法操作。
</li>

<li><b><code>__mul</code>：</b>
乘法（<code>*</code>）操作。
行为类似于加法操作。
</li>

<li><b><code>__div</code>：</b>
除法（<code>/</code>）操作。
行为类似于加法操作。
</li>

<li><b><code>__mod</code>：</b>
取模（<code>%</code>）操作。
行为类似于加法操作。
</li>

<li><b><code>__pow</code>：</b>
幂运算（<code>^</code>）操作。
行为类似于加法操作。
</li>

<li><b><code>__unm</code>：</b>
取负（一元 <code>-</code>）操作。
行为类似于加法操作。
</li>

<li><b><code>__idiv</code>：</b>
整除（<code>//</code>）操作。
行为类似于加法操作。
</li>

<li><b><code>__band</code>：</b>
按位与（<code>&amp;</code>）操作。
行为类似于加法操作，
除了如果任何操作数既不是整数
也不是可强制转换为整数的浮点数（参见 <a href="#3.4.3">§3.4.3</a>），
Lua 将尝试元方法。
</li>

<li><b><code>__bor</code>：</b>
按位或（<code>|</code>）操作。
行为类似于按位与操作。
</li>

<li><b><code>__bxor</code>：</b>
按位异或（二元 <code>~</code>）操作。
行为类似于按位与操作。
</li>

<li><b><code>__bnot</code>：</b>
按位非（一元 <code>~</code>）操作。
行为类似于按位与操作。
</li>

<li><b><code>__shl</code>：</b>
按位左移（<code>&lt;&lt;</code>）操作。
行为类似于按位与操作。
</li>

<li><b><code>__shr</code>：</b>
按位右移（<code>&gt;&gt;</code>）操作。
行为类似于按位与操作。
</li>

<li><b><code>__concat</code>：</b>
连接（<code>..</code>）操作。
行为类似于加法操作，
除了如果任何操作数既不是字符串也不是数字
（总是可强制转换为字符串），
Lua 将尝试元方法。
</li>

<li><b><code>__len</code>：</b>
长度（<code>#</code>）操作。
如果对象不是字符串，
Lua 将尝试其元方法。
如果有元方法，
Lua 以对象作为参数调用它，
调用的结果（总是调整为一个值）
是操作的结果。
如果没有元方法但对象是表，
则 Lua 使用表长度操作（参见 <a href="#3.4.7">§3.4.7</a>）。
否则，Lua 引发错误。
</li>

<li><b><code>__eq</code>：</b>
相等（<code>==</code>）操作。
行为类似于加法操作，
除了仅当被比较的值
都是表或都是完全 userdata
且它们不是原始相等时，
Lua 才会尝试元方法。
调用的结果总是转换为布尔值。
</li>

<li><b><code>__lt</code>：</b>
小于（<code>&lt;</code>）操作。
行为类似于加法操作，
除了仅当被比较的值
既不都是数字也不都是字符串时，
Lua 才会尝试元方法。
此外，调用的结果总是转换为布尔值。
</li>

<li><b><code>__le</code>：</b>
小于等于（<code>&lt;=</code>）操作。
行为类似于小于操作。
</li>

<li><b><code>__index</code>：</b>
索引访问操作 <code>table[key]</code>。
当 <code>table</code> 不是表或
<code>key</code> 不在 <code>table</code> 中时发生此事件。
在 <code>table</code> 的元表中查找元值。


<p>
此事件的元值可以是函数、表
或任何具有 <code>__index</code> 元值的值。
如果它是函数，
以 <code>table</code> 和 <code>key</code> 作为参数调用它，
调用的结果（调整为一个值）
是操作的结果。
否则，
最终结果是用 <code>key</code> 索引此元值的结果。
此索引是常规的，不是原始的，
因此可以触发另一个 <code>__index</code> 元值。
</p></li>

<li><b><code>__newindex</code>：</b>
索引赋值 <code>table[key] = value</code>。
像索引事件一样，
当 <code>table</code> 不是表或
<code>key</code> 不在 <code>table</code> 中时发生此事件。
在 <code>table</code> 的元表中查找元值。


<p>
像索引一样，
此事件的元值可以是函数、表
或任何具有 <code>__newindex</code> 元值的值。
如果它是函数，
以 <code>table</code>、<code>key</code> 和 <code>value</code> 作为参数调用它。
否则，
Lua 用相同的键和值
在此元值上重复索引赋值。
此赋值是常规的，不是原始的，
因此可以触发另一个 <code>__newindex</code> 元值。


</p><p>
每当调用 <code>__newindex</code> 元值时，
Lua 不执行原始赋值。
如果需要，
元方法本身可以调用 <a href="#pdf-rawset"><code>rawset</code></a>
来进行赋值。
</p></li>

<li><b><code>__call</code>：</b>
调用操作 <code>func(args)</code>。
当 Lua 尝试调用非函数值时发生此事件
（即 <code>func</code> 不是函数）。
在 <code>func</code> 中查找元方法。
如果存在，
以 <code>func</code> 作为第一个参数调用元方法，
后跟原始调用的参数（<code>args</code>）。
调用的所有结果
都是操作的结果。
这是唯一允许多个结果的元方法。
</li>

</ul>

<p>
除了前面的列表，
解释器还遵循元表中的以下键：
<code>__gc</code>（参见 <a href="#2.5.3">§2.5.3</a>），
<code>__close</code>（参见 <a href="#3.3.8">§3.3.8</a>），
<code>__mode</code>（参见 <a href="#2.5.4">§2.5.4</a>）
和 <code>__name</code>。
（条目 <code>__name</code>，
当它包含字符串时，
可能被 <a href="#pdf-tostring"><code>tostring</code></a> 和错误消息使用。）


</p><p>
对于一元运算符（取负、长度和按位非），
元方法使用一个虚拟的第二个操作数计算和调用，
等于第一个。
此额外操作数仅用于简化 Lua 的内部
（通过使这些运算符表现得像二元操作）
并可能在将来的版本中删除。
对于大多数用途，此额外操作数是无关紧要的。


</p><p>
因为元表是常规表，
它们可以包含任意字段，
而不仅仅是上面定义的事件名称。
标准库中的一些函数
（例如 <a href="#pdf-tostring"><code>tostring</code></a>）
为自己的目的使用元表中的其他字段。


</p><p>
在将表设置为某个对象的元表之前
将所有需要的元方法添加到表中是一个好习惯。
特别是，<code>__gc</code> 元方法仅在遵循此顺序时才有效
（参见 <a href="#2.5.3">§2.5.3</a>）。
在创建对象后立即设置其元表也是一个好习惯。





</p><h2>2.5 – <a name="2.5">垃圾回收</a></h2>



<p>
Lua 执行自动内存管理。
这意味着您不必担心为新对象分配内存
或在不再需要对象时释放它。
Lua 通过运行<em>垃圾回收器</em>来自动管理内存，以回收所有<em>死</em>对象。
Lua 使用的所有内存都受自动管理：
字符串、表、userdata、函数、线程、内部结构等。


</p><p>
一旦回收器可以确定对象在程序的正常执行中不会再被访问，
该对象就被认为是<em>死的</em>。
（这里的"正常执行"不包括可以复活死对象的终结器
（参见 <a href="#2.5.3">§2.5.3</a>），
也不包括使用调试库的操作。）
请注意，回收器可以确定对象已死的时间
可能与程序员的预期不一致。
唯一的保证是 Lua 不会回收
在程序正常执行中可能仍被访问的对象，
并且它最终会回收从 Lua 无法访问的对象。
（在这里，
<em>从 Lua 无法访问</em>意味着既没有变量也没有
另一个活动对象引用该对象。）
因为 Lua 不了解 C 代码，
它永远不会回收通过注册表可访问的对象（参见 <a href="#4.3">§4.3</a>），
其中包括全局环境（参见 <a href="#2.2">§2.2</a>）。


</p><p>
Lua 中的垃圾回收器（GC）可以在两种模式下工作：
增量式和分代式。


</p><p>
具有默认参数的默认 GC 模式
适用于大多数用途。
但是，在分配和释放内存上浪费大量时间的程序
可以从其他设置中受益。
请记住，GC 行为在平台之间
和不同 Lua 版本之间都是不可移植的；
因此，最佳设置也是不可移植的。


</p><p>
您可以通过在 C 中调用 <a href="#lua_gc"><code>lua_gc</code></a>
或在 Lua 中调用 <a href="#pdf-collectgarbage"><code>collectgarbage</code></a> 来更改 GC 模式和参数。
您还可以使用这些函数直接控制回收器
（例如，停止和重新启动它）。





</p><h3>2.5.1 – <a name="2.5.1">增量式垃圾回收</a></h3>

<p>
在增量模式下，
每个 GC 周期以与程序执行交错的小步骤
执行标记-清除回收。
在此模式下，
回收器使用三个数字来控制其垃圾回收周期：
<em>垃圾回收器暂停</em>、
<em>垃圾回收器步进倍增器</em>
和<em>垃圾回收器步长</em>。


</p><p>
垃圾回收器暂停
控制回收器在开始新周期之前等待多长时间。
当内存使用达到上一次回收后使用量的 <em>n%</em> 时，
回收器开始新周期。
较大的值使回收器不那么激进。
等于或小于 100 的值意味着回收器不会等待开始新周期。
值为 200 意味着回收器等待总内存使用量
翻倍后才开始新周期。
默认值为 200；最大值为 1000。


</p><p>
垃圾回收器步进倍增器
控制回收器相对于内存分配的速度，
即对于每分配一千字节内存，
它标记或清除多少元素。
较大的值使回收器更激进，但也增加
每个增量步骤的大小。
您不应使用小于 100 的值，
因为它们使回收器太慢，
可能导致回收器永远不会完成一个周期。
默认值为 100；最大值为 1000。


</p><p>
垃圾回收器步长控制
每个增量步骤的大小，
具体来说是解释器在执行步骤之前
分配多少字节。
此参数是对数的：
值 <em>n</em> 意味着解释器在步骤之间将分配 <em>2<sup>n</sup></em>
字节并在步骤期间执行等效工作。
较大的值（例如 60）使回收器成为停止世界
（非增量）回收器。
默认值为 13，
这意味着步长约为 8 Kbytes。





</p><h3>2.5.2 – <a name="2.5.2">分代式垃圾回收</a></h3>

<p>
在分代模式下，
回收器进行频繁的<em>次要</em>回收，
仅遍历最近创建的对象。
如果在次要回收后内存使用仍高于限制，
回收器执行停止世界的<em>主要</em>回收，
遍历所有对象。
分代模式使用两个参数：
<em>次要倍增器</em>和<em>主要倍增器</em>。


</p><p>
次要倍增器控制次要回收的频率。
对于次要倍增器 <em>x</em>，
当内存增长到上一次主要回收后内存使用量的 <em>x%</em> 时，
将进行新的次要回收。
例如，对于倍增器 20，
当内存使用量比上一次主要回收后的使用量
增加 20% 时，回收器将进行次要回收。
默认值为 20；最大值为 200。


</p><p>
主要倍增器控制主要回收的频率。
对于主要倍增器 <em>x</em>，
当内存增长到上一次主要回收后内存使用量的 <em>x%</em> 时，
将进行新的主要回收。
例如，对于倍增器 100，
当内存使用量比上一次回收后的使用量
增加超过两倍时，回收器将进行主要回收。
默认值为 100；最大值为 1000。





</p><h3>2.5.3 – <a name="2.5.3">垃圾回收元方法</a></h3>

<p>
您可以为表设置垃圾回收器元方法，
并使用 C API 为完全 userdata 设置
（参见 <a href="#2.4">§2.4</a>）。
这些元方法称为<em>终结器</em>，
当垃圾回收器检测到相应的表或 userdata 已死时调用。
终结器允许您协调 Lua 的垃圾回收
与外部资源管理，如关闭文件、
网络或数据库连接，
或释放您自己的内存。


</p><p>
要使对象（表或 userdata）在回收时被终结，
您必须<em>标记</em>它以进行终结。

您在设置对象的元表时标记对象以进行终结，
且元表有 <code>__gc</code> 元方法。
请注意，如果您设置的元表没有 <code>__gc</code> 字段，
然后在元表中创建该字段，
则对象不会被标记以进行终结。


</p><p>
当标记的对象变为死对象时，
垃圾回收器不会立即回收它。
相反，Lua 将其放入列表中。
回收后，
Lua 遍历该列表。
对于列表中的每个对象，
它检查对象的 <code>__gc</code> 元方法：
如果存在，
Lua 以对象作为唯一参数调用它。


</p><p>
在每个垃圾回收周期结束时，
以与对象标记以进行终结的相反顺序
调用终结器，
在该周期中回收的对象中；
即第一个被调用的终结器是与程序中最后标记的对象关联的。
每个终结器的执行可能在
常规代码执行期间的任何时刻发生。


</p><p>
因为被回收的对象必须仍被终结器使用，
该对象（和仅通过它可访问的其他对象）
必须被 Lua <em>复活</em>。
通常，这种复活是暂时的，
对象内存在下一个垃圾回收周期中释放。
但是，如果终结器将对象存储在某个全局位置
（例如全局变量），
则复活是永久的。
此外，如果终结器再次标记正在终结的对象以进行终结，
其终结器将在对象已死的下一个周期中再次调用。
在任何情况下，
对象内存仅在对象已死
且未标记以进行终结的 GC 周期中释放。


</p><p>
当您关闭状态时（参见 <a href="#lua_close"><code>lua_close</code></a>），
Lua 按照标记的相反顺序
调用所有标记以进行终结的对象的终结器。
如果任何终结器在该阶段标记对象以进行回收，
这些标记无效。


</p><p>
终结器不能让步也不能运行垃圾回收器。
因为它们可以在不可预测的时间运行，
限制每个终结器
仅执行正确释放其关联资源所必需的最少操作是一个好习惯。


</p><p>
运行终结器时的任何错误都会生成警告；
错误不会传播。





</p><h3>2.5.4 – <a name="2.5.4">弱表</a></h3>

<p>
<em>弱表</em>是其元素为<em>弱引用</em>的表。
弱引用被垃圾回收器忽略。
换句话说，
如果对对象的唯一引用是弱引用，
则垃圾回收器将回收该对象。


</p><p>
弱表可以有弱键、弱值或两者都有。
具有弱值的表允许回收其值，
但阻止回收其键。
具有弱键和弱值的表允许回收
键和值。
在任何情况下，如果键或值被回收，
整个对从表中删除。
表的弱性由其元表的 <code>__mode</code> 字段控制。
此元值如果存在，必须是以下字符串之一：
"<code>k</code>"，用于具有弱键的表；
"<code>v</code>"，用于具有弱值的表；
或"<code>kv</code>"，用于同时具有弱键和弱值的表。


</p><p>
具有弱键和强值的表
也称为<em>临时表</em>。
在临时表中，
仅当值的键可达时，值才被认为是可达的。
特别地，
如果对键的唯一引用来自其值，
则删除该对。


</p><p>
表弱性的任何更改可能仅在下一个回收周期生效。
特别是，如果您将弱性更改为更强的模式，
Lua 仍可能在更改生效之前
从该表中回收一些项目。


</p><p>
只有具有显式构造的对象
才会从弱表中删除。
值，如数字和轻量 C 函数，
不受垃圾回收的约束，
因此不会从弱表中删除
（除非它们的关联值被回收）。
虽然字符串受垃圾回收的约束，
但它们没有显式构造，
它们的相等性是按值的；
它们表现得更像值而不是对象。
因此，它们不会从弱表中删除。


</p><p>
复活的对象
（即正在终结的对象
和仅通过正在终结的对象可访问的对象）
在弱表中有特殊行为。
它们在运行其终结器之前从弱值中删除，
但仅在运行其终结器后的下一次回收中从弱键中删除，
当此类对象实际被释放时。
此行为允许终结器通过弱表
访问与对象关联的属性。


</p><p>
如果弱表在回收周期中是复活对象之一，
它可能在下一个周期之前不会正确清除。







</p><h2>2.6 – <a name="2.6">协程</a></h2>

<p>
Lua 支持协程，
也称为<em>协作式多线程</em>。
Lua 中的协程表示独立的执行线程。
但是，与多线程系统中的线程不同，
协程仅通过显式调用 yield 函数来暂停其执行。


</p><p>
您通过调用 <a href="#pdf-coroutine.create"><code>coroutine.create</code></a> 创建协程。
其唯一参数是协程的主函数。
<code>create</code> 函数只创建新协程并
返回其句柄（类型为 <em>thread</em> 的对象）；
它不启动协程。


</p><p>
您通过调用 <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> 执行协程。
当您第一次调用 <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> 时，
将 <a href="#pdf-coroutine.create"><code>coroutine.create</code></a> 返回的线程作为第一个参数传递，
协程通过调用其主函数开始执行。
传递给 <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> 的额外参数作为
参数传递给该函数。
协程开始运行后，
它运行直到终止或<em>让步</em>。


</p><p>
协程可以以两种方式终止其执行：
正常情况下，当其主函数返回时
（显式或隐式，在最后一条指令后）；
以及异常情况下，如果有未受保护的错误。
在正常终止的情况下，
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> 返回 <b>true</b>，
加上协程主函数返回的任何值。
在错误的情况下，<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> 返回 <b>false</b>
加上错误对象。
在这种情况下，协程不会展开其堆栈，
以便在错误后可以使用调试 API 检查它。


</p><p>
协程通过调用 <a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a> 让步。
当协程让步时，
相应的 <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> 立即返回，
即使让步发生在嵌套函数调用内
（即不在主函数中，
而是在主函数直接或间接调用的函数中）。
在让步的情况下，<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> 也返回 <b>true</b>，
加上传递给 <a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a> 的任何值。
下次您恢复同一协程时，
它从让步点继续执行，
对 <a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a> 的调用返回传递给 <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> 的任何额外参数。


</p><p>
像 <a href="#pdf-coroutine.create"><code>coroutine.create</code></a> 一样，
<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a> 函数也创建协程，
但它不返回协程本身，
而是返回一个函数，当调用时，恢复协程。
传递给此函数的任何参数
作为额外参数传递给 <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>。
<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a> 返回 <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> 返回的所有值，
除了第一个（布尔错误码）。
与 <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> 不同，
<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a> 创建的函数
将任何错误传播给调用者。
在这种情况下，
该函数还关闭协程（参见 <a href="#pdf-coroutine.close"><code>coroutine.close</code></a>）。


</p><p>
作为协程如何工作的示例，
考虑以下代码：

</p><pre>     function foo (a)
       print("foo", a)
       return coroutine.yield(2*a)
     end
     
     co = coroutine.create(function (a,b)
           print("co-body", a, b)
           local r = foo(a+1)
           print("co-body", r)
           local r, s = coroutine.yield(a+b, a-b)
           print("co-body", r, s)
           return b, "end"
     end)
     
     print("main", coroutine.resume(co, 1, 10))
     print("main", coroutine.resume(co, "r"))
     print("main", coroutine.resume(co, "x", "y"))
     print("main", coroutine.resume(co, "x", "y"))
</pre><p>
运行时，它产生以下输出：

</p><pre>     co-body 1       10
     foo     2
     main    true    4
     co-body r
     main    true    11      -9
     co-body x       y
     main    true    10      end
     main    false   cannot resume dead coroutine
</pre>

<p>
您还可以通过 C API 创建和操作协程：
参见函数 <a href="#lua_newthread"><code>lua_newthread</code></a>、<a href="#lua_resume"><code>lua_resume</code></a>
和 <a href="#lua_yield"><code>lua_yield</code></a>。





</p><h1>3 – <a name="3">语言</a></h1>



<p>
本节描述 Lua 的词法、语法和语义。
换句话说，
本节描述哪些标记是有效的，
它们如何组合，
以及它们的组合意味着什么。


</p><p>
语言结构将使用通常的扩展 BNF 表示法解释，
其中 {<em>a</em>} 表示 0 个或多个 <em>a</em>，
[<em>a</em>] 表示可选的 <em>a</em>。
非终结符显示为 non-terminal，
关键字显示为 <b>kword</b>，
其他终结符显示为 '<b>=</b>'。
Lua 的完整语法可在本手册末尾的 <a href="#9">§9</a> 中找到。





</p><h2>3.1 – <a name="3.1">词法约定</a></h2>

<p>
Lua 是自由格式语言。
它忽略词法元素（标记）之间的空格和注释，
除了作为两个标记之间的分隔符。
在源代码中，
Lua 将标准 ASCII 空白字符识别为空格：
空格、换页、换行、
回车、水平制表符和垂直制表符。


</p><p>
Lua 中的<em>名称</em>
（也称为<em>标识符</em>）
可以是拉丁字母、阿拉伯-印度数字和下划线的任何字符串，
不以数字开头且
不是保留字。
标识符用于命名变量、表字段和标签。


</p><p>
以下<em>关键字</em>是保留的，
不能用作名称：


</p><pre>     and       break     do        else      elseif    end
     false     for       function  goto      if        in
     local     nil       not       or        repeat    return
     then      true      until     while
</pre>

<p>
Lua 是区分大小写的语言：
<code>and</code> 是保留字，但 <code>And</code> 和 <code>AND</code>
是两个不同的有效名称。
按照惯例，
程序应避免创建以下划线后跟
一个或多个大写字母开头的名称（如 <a href="#pdf-_VERSION"><code>_VERSION</code></a>）。


</p><p>
以下字符串表示其他标记：

</p><pre>     +     -     *     /     %     ^     #
     &amp;     ~     |     &lt;&lt;    &gt;&gt;    //
     ==    ~=    &lt;=    &gt;=    &lt;     &gt;     =
     (     )     {     }     [     ]     ::
     ;     :     ,     .     ..    ...
</pre>

<p>
<em>短字面字符串</em>
可以由匹配的单引号或双引号分隔，
并可以包含以下类似 C 的转义序列：
'<code>\a</code>'（响铃）、
'<code>\b</code>'（退格）、
'<code>\f</code>'（换页）、
'<code>\n</code>'（换行）、
'<code>\r</code>'（回车）、
'<code>\t</code>'（水平制表符）、
'<code>\v</code>'（垂直制表符）、
'<code>\\</code>'（反斜杠）、
'<code>\"</code>'（引号 [双引号]）
和 '<code>\'</code>'（撇号 [单引号]）。
反斜杠后跟换行符
在字符串中产生换行符。
转义序列 '<code>\z</code>' 跳过以下空白字符跨度，
包括换行符；
这对于将长字面字符串分成多行
而不将换行符和空格添加到字符串内容中特别有用。
短字面字符串不能包含未转义的换行符
或不形成有效转义序列的转义。


</p><p>
我们可以通过其数值在短字面字符串中指定任何字节，
包括嵌入的零。
这可以通过转义序列 <code>\x<em>XX</em></code> 完成，
其中 <em>XX</em> 是恰好两个十六进制数字的序列，
或通过转义序列 <code>\<em>ddd</em></code>，
其中 <em>ddd</em> 是最多三个十进制数字的序列。
（请注意，如果十进制转义序列后跟数字，
它必须使用恰好三位数字表示。）


</p><p>
Unicode 字符的 UTF-8 编码
可以使用转义序列 <code>\u{<em>XXX</em>}</code>
（带有强制性的括号）插入字面字符串中，
其中 <em>XXX</em> 是表示字符码点的
一个或多个十六进制数字的序列。
此码点可以是小于 <em>2<sup>31</sup></em> 的任何值。
（Lua 在这里使用原始 UTF-8 规范，
它不限于有效的 Unicode 码点。）


</p><p>
字面字符串也可以使用由<em>长括号</em>括起的长格式定义。
我们将<em>级别 <em>n</em> 的开放长括号</em>定义为开放
方括号后跟 <em>n</em> 个等号后跟另一个
开放方括号。
因此，级别 0 的开放长括号写为 <code>[[</code>，
级别 1 的开放长括号写为 <code>[=[</code>，
依此类推。
<em>闭合长括号</em>类似定义；
例如，
级别 4 的闭合长括号写为 <code>]====]</code>。
<em>长字面量</em>以任何级别的开放长括号开始，
在相同级别的第一个闭合长括号处结束。
它可以包含任何文本，除了相同级别的闭合括号。
这种括号形式的字面量可以运行多行，
不解释任何转义序列，
并忽略任何其他级别的长括号。
任何类型的行尾序列
（回车、换行、回车后跟换行
或换行后跟回车）
都转换为简单的换行符。
当开放长括号紧跟换行符时，
换行符不包含在字符串中。


</p><p>
作为示例，在使用 ASCII 的系统中
（其中 '<code>a</code>' 编码为 97，
换行编码为 10，'<code>1</code>' 编码为 49），
以下五个字面字符串表示相同的字符串：

</p><pre>     a = 'alo\n123"'
     a = "alo\n123\""
     a = '\97lo\10\04923"'
     a = [[alo
     123"]]
     a = [==[
     alo
     123"]==]
</pre>

<p>
字面字符串中未明确受前述规则影响的任何字节
表示其本身。
但是，Lua 以文本模式打开文件进行解析，
系统的文件函数可能对某些控制字符有问题。
因此，更安全的做法是
将二进制数据表示为带有
非文本字符显式转义序列的引用字面量。


</p><p>
<em>数字常量</em>（或<em>数字</em>）
可以写成带有可选小数部分
和可选十进制指数，
由字母 '<code>e</code>' 或 '<code>E</code>' 标记。
Lua 也接受十六进制常量，
以 <code>0x</code> 或 <code>0X</code> 开头。
十六进制常量也接受可选的小数部分
加上可选的二进制指数，
由字母 '<code>p</code>' 或 '<code>P</code>' 标记并以十进制写入。
（例如，<code>0x1.fp10</code> 表示 1984，
即 <em>0x1f / 16</em> 乘以 <em>2<sup>10</sup></em>。）


</p><p>
带有小数点或指数的数字常量
表示浮点数；
否则，
如果其值适合整数或它是十六进制常量，
它表示整数；
否则（即溢出的十进制整数数字），
它表示浮点数。
没有小数点或指数的十六进制数字
总是表示整数值；
如果值溢出，它<em>回绕</em>
以适应有效整数。


</p><p>
有效整数常量的示例是

</p><pre>     3   345   0xff   0xBEBADA
</pre><p>
有效浮点常量的示例是

</p><pre>     3.0     3.1416     314.16e-2     0.31416E1     34e1
     0x0.1E  0xA23p-4   0X1.921FB54442D18P+1
</pre>

<p>
<em>注释</em>以双连字符（<code>--</code>）开头，
在字符串外的任何位置。
如果 <code>--</code> 后的文本不是开放长括号，
注释是<em>短注释</em>，
运行到行尾。
否则，它是<em>长注释</em>，
运行到相应的闭合长括号。





</p><h2>3.2 – <a name="3.2">变量</a></h2>

<p>
变量是存储值的位置。
Lua 中有三种变量：
全局变量、局部变量和表字段。


</p><p>
单个名称可以表示全局变量或局部变量
（或函数的形式参数，
这是一种特殊的局部变量）：

</p><pre>	var ::= Name
</pre><p>
Name 表示标识符（参见 <a href="#3.1">§3.1</a>）。


</p><p>
除非显式声明为局部变量（参见 <a href="#3.3.7">§3.3.7</a>），
否则任何变量名都被假定为全局的。
局部变量是<em>词法作用域的</em>：
局部变量可以被在其作用域内定义的函数
自由访问（参见 <a href="#3.5">§3.5</a>）。


</p><p>
在第一次赋值给变量之前，其值为 <b>nil</b>。


</p><p>
方括号用于索引表：

</p><pre>	var ::= prefixexp '<b>[</b>' exp '<b>]</b>'
</pre><p>
访问表字段的含义可以通过元表更改
（参见 <a href="#2.4">§2.4</a>）。


</p><p>
语法 <code>var.Name</code> 只是 <code>var["Name"]</code> 的语法糖：

</p><pre>	var ::= prefixexp '<b>.</b>' Name
</pre>

<p>
对全局变量 <code>x</code> 的访问
等同于 <code>_ENV.x</code>。
由于代码块编译的方式，
变量 <code>_ENV</code> 本身永远不是全局的（参见 <a href="#2.2">§2.2</a>）。





</p><h2>3.3 – <a name="3.3">语句</a></h2>



<p>
Lua 支持几乎传统的语句集，
类似于其他传统语言中的语句。
此集合包括
块、赋值、控制结构、函数调用
和变量声明。





</p><h3>3.3.1 – <a name="3.3.1">块</a></h3>

<p>
块是语句列表，
按顺序执行：

</p><pre>	block ::= {stat}
</pre><p>
<!-- slice ends -->


<!-- slice index: 2 -->
<!-- lines 1497–2984 / total 11964 -->
<!-- title: 3.4 – Expressions -->
Lua 有<em>空语句</em>，
允许你用分号分隔语句、
用分号开始一个代码块，
或者连续写两个分号：

</p><pre>	stat ::= '<b>;</b>'
</pre>

<p>
函数调用和赋值语句
都可以以左圆括号开始。
这种可能性导致了 Lua 语法的歧义。
考虑以下片段：

</p><pre>     a = b + c
     (print or io.write)('done')
</pre><p>
语法可以用两种方式理解这个片段：

</p><pre>     a = b + c(print or io.write)('done')
     
     a = b + c; (print or io.write)('done')
</pre><p>
当前的解析器总是以第一种方式理解这类结构，
将左圆括号解释为
函数调用参数的开始。
为了避免这种歧义，
最好总是在以圆括号开始的语句前
加上一个分号：

</p><pre>     ;(print or io.write)('done')
</pre>

<p>
代码块可以被显式地限定以产生单个语句：

</p><pre>	stat ::= <b>do</b> block <b>end</b>
</pre><p>
显式代码块对于
控制变量声明的作用域很有用。
显式代码块有时也用于
在另一个代码块中间
添加一个 <b>return</b> 语句（参见 <a href="#3.3.4">§3.3.4</a>）。





</p><h3>3.3.2 – <a name="3.3.2">代码块</a></h3>

<p>
Lua 的编译单元称为<em>代码块</em>。
从语法上讲，
代码块就是一个语句块：

</p><pre>	chunk ::= block
</pre>

<p>
Lua 将代码块作为具有可变数量参数的
匿名函数的函数体来处理
（参见 <a href="#3.4.11">§3.4.11</a>）。
因此，代码块可以定义局部变量、
接收参数并返回值。
此外，这样的匿名函数被编译为
外部局部变量 <code>_ENV</code> 作用域中的函数（参见 <a href="#2.2">§2.2</a>）。
结果函数总是将 <code>_ENV</code> 作为其唯一的外部变量，
即使它不使用该变量。


</p><p>
代码块可以存储在文件中或宿主程序内的字符串中。
要执行代码块，
Lua 首先<em>加载</em>它，
将代码块的代码预编译为虚拟机的指令，
然后 Lua 用虚拟机的解释器
执行编译后的代码。


</p><p>
代码块也可以预编译为二进制形式；
详见程序 <code>luac</code> 和函数 <a href="#pdf-string.dump"><code>string.dump</code></a>。
源码和编译形式的程序是可互换的；
Lua 会自动检测文件类型并相应地处理（参见 <a href="#pdf-load"><code>load</code></a>）。





</p><h3>3.3.3 – <a name="3.3.3">赋值</a></h3>

<p>
Lua 允许多重赋值。
因此，赋值的语法
在左侧定义一个变量列表，
在右侧定义一个表达式列表。
两个列表中的元素都用逗号分隔：

</p><pre>	stat ::= varlist '<b>=</b>' explist
	varlist ::= var {'<b>,</b>' var}
	explist ::= exp {'<b>,</b>' exp}
</pre><p>
表达式在 <a href="#3.4">§3.4</a> 中讨论。


</p><p>
在赋值之前，
值列表被<em>调整</em>为
变量列表的长度（参见 <a href="#3.4.12">§3.4.12</a>）。


</p><p>
如果在多重赋值中
一个变量既被赋值又被读取，
Lua 确保所有读取操作都获取变量
在赋值之前的值。
因此代码

</p><pre>     i = 3
     i, a[i] = i+1, 20
</pre><p>
将 <code>a[3]</code> 设置为 20，而不影响 <code>a[4]</code>，
因为 <code>a[i]</code> 中的 <code>i</code> 在被赋值为 4 之前
被求值（为 3）。
类似地，代码行

</p><pre>     x, y = y, x
</pre><p>
交换 <code>x</code> 和 <code>y</code> 的值，
而

</p><pre>     x, y, z = y, z, x
</pre><p>
循环置换 <code>x</code>、<code>y</code> 和 <code>z</code> 的值。


</p><p>
注意，这种保证只涵盖
在语法上位于赋值语句内的访问。
如果赋值期间调用的函数或元方法
改变了变量的值，
Lua 不保证该访问的顺序。


</p><p>
对全局名称 <code>x = val</code> 的赋值
等价于赋值
<code>_ENV.x = val</code>（参见 <a href="#2.2">§2.2</a>）。


</p><p>
对表字段和
全局变量（实际上也是表字段）赋值的含义
可以通过元表改变（参见 <a href="#2.4">§2.4</a>）。





</p><h3>3.3.4 – <a name="3.3.4">控制结构</a></h3><p>
控制结构
<b>if</b>、<b>while</b> 和 <b>repeat</b> 具有通常的含义和
熟悉的语法：




</p><pre>	stat ::= <b>while</b> exp <b>do</b> block <b>end</b>
	stat ::= <b>repeat</b> block <b>until</b> exp
	stat ::= <b>if</b> exp <b>then</b> block {<b>elseif</b> exp <b>then</b> block} [<b>else</b> block] <b>end</b>
</pre><p>
Lua 还有 <b>for</b> 语句，有两种形式（参见 <a href="#3.3.5">§3.3.5</a>）。


</p><p>
控制结构的条件表达式
可以返回任何值。
<b>false</b> 和 <b>nil</b> 都测试为假。
所有不同于 <b>nil</b> 和 <b>false</b> 的值都测试为真。
特别地，数字 0 和空字符串也测试为真。


</p><p>
在 <b>repeat</b>–<b>until</b> 循环中，
内部代码块不在 <b>until</b> 关键字处结束，
而只在条件之后结束。
因此，条件可以引用
在循环代码块内声明的局部变量。


</p><p>
<b>goto</b> 语句将程序控制转移到一个标签。
出于语法原因，
Lua 中的标签也被视为语句：



</p><pre>	stat ::= <b>goto</b> Name
	stat ::= label
	label ::= '<b>::</b>' Name '<b>::</b>'
</pre>

<p>
标签在定义它的整个代码块中可见，
但不包括嵌套的函数内部。
goto 可以跳转到任何可见的标签，只要它不会
进入局部变量的作用域。
不应在
同名标签可见的地方声明标签，
即使这个其他标签是在外层代码块中声明的。


</p><p>
<b>break</b> 语句终止
<b>while</b>、<b>repeat</b> 或 <b>for</b> 循环的执行，
跳到循环后的下一条语句：


</p><pre>	stat ::= <b>break</b>
</pre><p>
<b>break</b> 结束最内层的外围循环。


</p><p>
<b>return</b> 语句用于从函数或代码块
返回值
（代码块被作为匿名函数处理）。

函数可以返回多个值，
所以 <b>return</b> 语句的语法是

</p><pre>	stat ::= <b>return</b> [explist] ['<b>;</b>']
</pre>

<p>
<b>return</b> 语句只能写作
代码块的最后一条语句。
如果需要在代码块中间 <b>return</b>，
那么可以使用显式的内部代码块，
如习惯用法 <code>do return end</code>，
因为现在 <b>return</b> 是其（内部）代码块的最后一条语句。





</p><h3>3.3.5 – <a name="3.3.5">For 语句</a></h3>

<p>

<b>for</b> 语句有两种形式：
一种是数值型，一种是泛型。



</p><h4>数值型 <b>for</b> 循环</h4>

<p>
数值型 <b>for</b> 循环在控制变量
经历一个等差数列时重复执行代码块。
它有以下语法：

</p><pre>	stat ::= <b>for</b> Name '<b>=</b>' exp '<b>,</b>' exp ['<b>,</b>' exp] <b>do</b> block <b>end</b>
</pre><p>
给定的标识符（Name）定义控制变量，
它是循环体（<em>block</em>）的新局部变量。


</p><p>
循环开始时对三个控制表达式求值一次。
它们的值分别称为
<em>初始值</em>、<em>限制值</em>和<em>步长</em>。
如果步长不存在，它默认为 1。


</p><p>
如果初始值和步长都是整数，
循环用整数进行；
注意限制值可能不是整数。
否则，三个值被转换为
浮点数，循环用浮点数进行。
在这种情况下要注意浮点精度。


</p><p>
完成初始化后，
循环体随着控制变量的值
经历等差数列而重复执行，
从初始值开始，
公差由步长给定。
负步长产生递减序列；
步长等于零会引发错误。
当值小于或等于限制值时
（对于负步长则是大于或等于）循环继续。
如果初始值已经大于限制值
（或者对于负步长小于限制值），
循环体不执行。


</p><p>
对于整数循环，
控制变量永远不会回绕；
相反，在溢出的情况下循环结束。


</p><p>
你不应在循环期间
改变控制变量的值。
如果需要在循环后使用它的值，
在退出循环前将其赋值给另一个变量。





</p><h4>泛型 <b>for</b> 循环</h4>

<p>
泛型 <b>for</b> 语句在函数上工作，
这些函数称为<em>迭代器</em>。
在每次迭代时，调用迭代器函数以产生一个新值，
当这个新值是 <b>nil</b> 时停止。
泛型 <b>for</b> 循环有以下语法：

</p><pre>	stat ::= <b>for</b> namelist <b>in</b> explist <b>do</b> block <b>end</b>
	namelist ::= Name {'<b>,</b>' Name}
</pre><p>
像这样的 <b>for</b> 语句

</p><pre>     for <em>var_1</em>, ···, <em>var_n</em> in <em>explist</em> do <em>body</em> end
</pre><p>
工作如下。


</p><p>
名称 <em>var_i</em> 声明循环体的局部循环变量。
这些变量中的第一个是<em>控制变量</em>。


</p><p>
循环开始时对 <em>explist</em> 求值
以产生四个值：
一个<em>迭代器函数</em>、
一个<em>状态</em>、
控制变量的初始值
和一个<em>关闭值</em>。


</p><p>
然后，在每次迭代时，
Lua 用两个参数调用迭代器函数：
状态和控制变量。
这次调用的结果然后被赋值给循环变量，
遵循多重赋值的规则（参见 <a href="#3.3.3">§3.3.3</a>）。
如果控制变量变为 <b>nil</b>，
循环终止。
否则，执行循环体，循环进入
下一次迭代。


</p><p>
关闭值的行为像
待关闭变量（参见 <a href="#3.3.8">§3.3.8</a>），
可用于在循环结束时释放资源。
否则，它不干扰循环。


</p><p>
你不应在循环期间
改变控制变量的值。







</p><h3>3.3.6 – <a name="3.3.6">作为语句的函数调用</a></h3><p>
为了允许可能的副作用，
函数调用可以作为语句执行：

</p><pre>	stat ::= functioncall
</pre><p>
在这种情况下，所有返回值都被丢弃。
函数调用在 <a href="#3.4.10">§3.4.10</a> 中解释。





</p><h3>3.3.7 – <a name="3.3.7">局部变量声明</a></h3><p>
局部变量可以在代码块内的任何地方声明。
声明可以包含初始化：

</p><pre>	stat ::= <b>local</b> attnamelist ['<b>=</b>' explist]
	attnamelist ::=  Name attrib {'<b>,</b>' Name attrib}
</pre><p>
如果存在，初始赋值具有
多重赋值的相同语义（参见 <a href="#3.3.3">§3.3.3</a>）。
否则，所有变量都初始化为 <b>nil</b>。


</p><p>
每个变量名可以后缀一个属性
（尖括号之间的名称）：

</p><pre>	attrib ::= ['<b>&lt;</b>' Name '<b>&gt;</b>']
</pre><p>
有两种可能的属性：
<code>const</code>，它声明一个常量变量，
即初始化后不能被赋值的变量；
以及 <code>close</code>，它声明一个待关闭变量（参见 <a href="#3.3.8">§3.3.8</a>）。
一个变量列表最多可以包含一个待关闭变量。


</p><p>
代码块也是一个语句块（参见 <a href="#3.3.2">§3.3.2</a>），
所以局部变量可以在代码块中在任何显式代码块外声明。


</p><p>
局部变量的可见性规则在 <a href="#3.5">§3.5</a> 中解释。





</p><h3>3.3.8 – <a name="3.3.8">待关闭变量</a></h3>

<p>
待关闭变量的行为像常量局部变量，
只是它的值在变量
离开作用域时被<em>关闭</em>，包括正常的代码块终止、
通过 <b>break</b>/<b>goto</b>/<b>return</b> 退出其代码块，
或因错误退出。


</p><p>
在这里，<em>关闭</em>一个值意味着
调用它的 <code>__close</code> 元方法。
调用元方法时，
值本身作为第一个参数传递，
导致退出的错误对象（如果有）
作为第二个参数传递；
如果没有错误，第二个参数是 <b>nil</b>。


</p><p>
赋值给待关闭变量的值
必须有 <code>__close</code> 元方法
或是假值。
（<b>nil</b> 和 <b>false</b> 作为待关闭值被忽略。）


</p><p>
如果几个待关闭变量在同一事件中离开作用域，
它们按声明的相反顺序关闭。


</p><p>
如果在运行关闭方法时发生任何错误，
该错误像变量定义处
常规代码中的错误一样处理。
在错误之后，
其他挂起的关闭方法仍将被调用。


</p><p>
如果协程让出且永远不再恢复，
一些变量可能永远不会离开作用域，
因此它们将永远不会被关闭。
（这些变量是在协程内创建的
并且在协程让出时在作用域内的。）
类似地，如果协程以错误结束，
它不会展开其栈，
因此不会关闭任何变量。
在这两种情况下，
你可以使用终结器
或调用 <a href="#pdf-coroutine.close"><code>coroutine.close</code></a> 来关闭变量。
但是，如果协程是通过
<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a> 创建的，
那么在发生错误时其对应的函数将关闭协程。







</p><h2>3.4 – <a name="3.4">表达式</a></h2>



<p>
Lua 中的基本表达式如下：

</p><pre>	exp ::= prefixexp
	exp ::= <b>nil</b> | <b>false</b> | <b>true</b>
	exp ::= Numeral
	exp ::= LiteralString
	exp ::= functiondef
	exp ::= tableconstructor
	exp ::= '<b>...</b>'
	exp ::= exp binop exp
	exp ::= unop exp
	prefixexp ::= var | functioncall | '<b>(</b>' exp '<b>)</b>'
</pre>

<p>
数值和字面字符串在 <a href="#3.1">§3.1</a> 中解释；
变量在 <a href="#3.2">§3.2</a> 中解释；
函数定义在 <a href="#3.4.11">§3.4.11</a> 中解释；
函数调用在 <a href="#3.4.10">§3.4.10</a> 中解释；
表构造器在 <a href="#3.4.9">§3.4.9</a> 中解释。
可变参数表达式，
用三个点（'<code>...</code>'）表示，只能在
直接位于可变参数函数内时使用；
它们在 <a href="#3.4.11">§3.4.11</a> 中解释。


</p><p>
二元运算符包括算术运算符（参见 <a href="#3.4.1">§3.4.1</a>）、
位运算符（参见 <a href="#3.4.2">§3.4.2</a>）、
关系运算符（参见 <a href="#3.4.4">§3.4.4</a>）、逻辑运算符（参见 <a href="#3.4.5">§3.4.5</a>），
以及连接运算符（参见 <a href="#3.4.6">§3.4.6</a>）。
一元运算符包括一元减（参见 <a href="#3.4.1">§3.4.1</a>）、
一元位非（参见 <a href="#3.4.2">§3.4.2</a>）、
一元逻辑 <b>not</b>（参见 <a href="#3.4.5">§3.4.5</a>），
以及一元<em>长度运算符</em>（参见 <a href="#3.4.7">§3.4.7</a>）。





</p><h3>3.4.1 – <a name="3.4.1">算术运算符</a></h3><p>
Lua 支持以下算术运算符：

</p><ul>
<li><b><code>+</code>：</b>加法</li>
<li><b><code>-</code>：</b>减法</li>
<li><b><code>*</code>：</b>乘法</li>
<li><b><code>/</code>：</b>浮点除法</li>
<li><b><code>//</code>：</b>向下取整除法</li>
<li><b><code>%</code>：</b>取模</li>
<li><b><code>^</code>：</b>幂运算</li>
<li><b><code>-</code>：</b>一元减</li>
</ul>

<p>
除了幂运算和浮点除法，
算术运算符工作如下：
如果两个操作数都是整数，
运算在整数上执行，结果是整数。
否则，如果两个操作数都是数字，
那么它们被转换为浮点数，
运算遵循机器的浮点运算规则
（通常是 IEEE 754 标准），
结果是浮点数。
（字符串库在算术运算中将字符串强制转换为数字；
详见 <a href="#3.4.3">§3.4.3</a>。）


</p><p>
幂运算和浮点除法（<code>/</code>）
总是将它们的操作数转换为浮点数，
结果总是浮点数。
幂运算使用 ISO&nbsp;C 函数 <code>pow</code>，
所以它也适用于非整数指数。


</p><p>
向下取整除法（<code>//</code>）是
将商向负无穷舍入的除法，
结果是其操作数除法的向下取整。


</p><p>
取模被定义为除法的余数，
该除法将商向负无穷舍入（向下取整除法）。


</p><p>
在整数算术溢出的情况下，
所有运算都<em>回绕</em>。



</p><h3>3.4.2 – <a name="3.4.2">位运算符</a></h3><p>
Lua 支持以下位运算符：

</p><ul>
<li><b><code>&amp;</code>：</b>位与</li>
<li><b><code>|</code>：</b>位或</li>
<li><b><code>~</code>：</b>位异或</li>
<li><b><code>&gt;&gt;</code>：</b>右移</li>
<li><b><code>&lt;&lt;</code>：</b>左移</li>
<li><b><code>~</code>：</b>一元位非</li>
</ul>

<p>
所有位运算将其操作数转换为整数
（参见 <a href="#3.4.3">§3.4.3</a>），
对这些整数的所有位进行运算，
结果是整数。


</p><p>
右移和左移都用零填充空位。
负位移向另一个方向移动；
绝对值等于或大于
整数位数的位移
结果为零（因为所有位都被移出）。





</p><h3>3.4.3 – <a name="3.4.3">强制转换和转换</a></h3><p>
Lua 在运行时在某些
类型和表示之间提供一些自动转换。
位运算符总是将浮点操作数转换为整数。
幂运算和浮点除法
总是将整数操作数转换为浮点数。
应用于混合数字
（整数和浮点数）的所有其他算术运算
将整数操作数转换为浮点数。
C API 也根据需要将
整数转换为浮点数以及浮点数转换为整数。
此外，字符串连接接受数字作为参数，
除了字符串。


</p><p>
在从整数到浮点数的转换中，
如果整数值作为浮点数有精确表示，
那就是结果。
否则，
转换得到最接近的较高值或
最接近的较低的可表示值。
这种转换永远不会失败。


</p><p>
从浮点数到整数的转换
检查浮点数是否有精确的整数表示
（即浮点数有整数值且
在整数表示范围内）。
如果有，那个表示就是结果。
否则，转换失败。


</p><p>
Lua 中的几个地方在必要时将字符串强制转换为数字。
特别地，
字符串库设置元方法，试图在所有算术运算中
将字符串强制转换为数字。
如果转换失败，
库调用另一个操作数的元方法
（如果存在）或引发错误。
注意位运算符不进行这种强制转换。


</p><p>
最好不要依赖
从字符串到数字的隐式强制转换，
因为它们不总是被应用；
特别地，<code>"1"==1</code> 是假，<code>"1"&lt;1</code> 会引发错误
（参见 <a href="#3.4.4">§3.4.4</a>）。
这些强制转换主要是为了兼容性而存在，可能在
语言的未来版本中被移除。


</p><p>
字符串根据其语法和
Lua 词法分析器的规则被转换为整数或浮点数。
字符串也可以有前导和尾随空格以及符号。
从字符串到数字的所有转换
都接受点和当前区域设置标记
作为小数点字符。
（但是，Lua 词法分析器只接受点。）
如果字符串不是有效的数值，
转换失败。
如有必要，这第一步的结果然后
根据浮点数和整数之间转换的前述规则
转换为特定的数字子类型。


</p><p>
从数字到字符串的转换使用
未指定的人类可读格式。
要以任何特定方式将数字转换为字符串，
使用函数 <a href="#pdf-string.format"><code>string.format</code></a>。





</p><h3>3.4.4 – <a name="3.4.4">关系运算符</a></h3><p>
Lua 支持以下关系运算符：

</p><ul>
<li><b><code>==</code>：</b>等于</li>
<li><b><code>~=</code>：</b>不等于</li>
<li><b><code>&lt;</code>：</b>小于</li>
<li><b><code>&gt;</code>：</b>大于</li>
<li><b><code>&lt;=</code>：</b>小于或等于</li>
<li><b><code>&gt;=</code>：</b>大于或等于</li>
</ul><p>
这些运算符总是结果为 <b>false</b> 或 <b>true</b>。


</p><p>
等于（<code>==</code>）首先比较其操作数的类型。
如果类型不同，那么结果是 <b>false</b>。
否则，比较操作数的值。
如果字符串有相同的字节内容，则它们相等。
如果数字表示相同的数学值，则它们相等。


</p><p>
表、用户数据和线程
按引用比较：
两个对象只有在它们是同一对象时才被认为相等。
每次创建新对象
（表、用户数据或线程），
这个新对象不同于任何先前存在的对象。
函数总是等于其自身。
有任何可检测差异的函数
（不同的行为、不同的定义）总是不同。
在不同时间创建但没有可检测差异的函数
可能被归类为相等或不相等
（取决于内部缓存细节）。


</p><p>
你可以通过使用 <code>__eq</code> 元方法
改变 Lua 比较表和用户数据的方式（参见 <a href="#2.4">§2.4</a>）。


</p><p>
等于比较不将字符串转换为数字
或反之。
因此，<code>"0"==0</code> 求值为 <b>false</b>，
而 <code>t[0]</code> 和 <code>t["0"]</code> 表示表中
不同的条目。


</p><p>
运算符 <code>~=</code> 正好是等于（<code>==</code>）的否定。


</p><p>
顺序运算符工作如下。
如果两个参数都是数字，
那么它们根据其数学值比较，
不管它们的子类型。
否则，如果两个参数都是字符串，
那么它们的值根据当前区域设置比较。
否则，Lua 试图调用 <code>__lt</code> 或 <code>__le</code>
元方法（参见 <a href="#2.4">§2.4</a>）。
比较 <code>a &gt; b</code> 被翻译为 <code>b &lt; a</code>，
<code>a &gt;= b</code> 被翻译为 <code>b &lt;= a</code>。


</p><p>
遵循 IEEE 754 标准，
特殊值 NaN 被认为既不小于、
也不等于、也不大于任何值，包括其自身。





</p><h3>3.4.5 – <a name="3.4.5">逻辑运算符</a></h3><p>
Lua 中的逻辑运算符是
<b>and</b>、<b>or</b> 和 <b>not</b>。
像控制结构一样（参见 <a href="#3.3.4">§3.3.4</a>），
所有逻辑运算符将 <b>false</b> 和 <b>nil</b> 都视为假，
其他任何东西都视为真。


</p><p>
否定运算符 <b>not</b> 总是返回 <b>false</b> 或 <b>true</b>。
合取运算符 <b>and</b> 返回其第一个参数，
如果这个值是 <b>false</b> 或 <b>nil</b>；
否则，<b>and</b> 返回其第二个参数。
析取运算符 <b>or</b> 返回其第一个参数，
如果这个值不同于 <b>nil</b> 和 <b>false</b>；
否则，<b>or</b> 返回其第二个参数。
<b>and</b> 和 <b>or</b> 都使用短路求值；
即，
第二个操作数只在必要时才求值。
以下是一些例子：

</p><pre>     10 or 20            --&gt; 10
     10 or error()       --&gt; 10
     nil or "a"          --&gt; "a"
     nil and 10          --&gt; nil
     false and error()   --&gt; false
     false and nil       --&gt; false
     false or nil        --&gt; nil
     10 and 20           --&gt; 20
</pre>




<h3>3.4.6 – <a name="3.4.6">连接</a></h3><p>
Lua 中的字符串连接运算符
用两个点（'<code>..</code>'）表示。
如果两个操作数都是字符串或数字，
那么数字被转换为字符串，
格式未指定（参见 <a href="#3.4.3">§3.4.3</a>）。
否则，调用 <code>__concat</code> 元方法（参见 <a href="#2.4">§2.4</a>）。





</p><h3>3.4.7 – <a name="3.4.7">长度运算符</a></h3>

<p>
长度运算符用一元前缀运算符 <code>#</code> 表示。


</p><p>
字符串的长度是其字节数。
（这是当每个字符一个字节时字符串长度的通常含义。）


</p><p>
应用于表的长度运算符
返回该表中的边界。
表 <code>t</code> 中的<em>边界</em>是满足以下条件的
任何非负整数：

</p><pre>     (border == 0 or t[border] ~= nil) and
     (t[border + 1] == nil or border == math.maxinteger)
</pre><p>
换句话说，
边界是表中存在的
任何后跟缺失索引的正整数索引，
加上两个限制情况：
零，当索引 1 缺失时；
以及整数的最大值，当该索引存在时。
注意不是正整数的键
不干扰边界。


</p><p>
恰好有一个边界的表称为<em>序列</em>。
例如，表 <code>{10, 20, 30, 40, 50}</code> 是序列，
因为它只有一个边界（5）。
表 <code>{10, 20, 30, nil, 50}</code> 有两个边界（3 和 5），
因此它不是序列。
（索引 4 处的 <b>nil</b> 称为<em>空洞</em>。）
表 <code>{nil, 20, 30, nil, nil, 60, nil}</code>
有三个边界（0、3 和 6），
所以它也不是序列。
表 <code>{}</code> 是边界为 0 的序列。


</p><p>
当 <code>t</code> 是序列时，
<code>#t</code> 返回其唯一的边界，
这对应于序列长度的直观概念。
当 <code>t</code> 不是序列时，
<code>#t</code> 可以返回其任何边界。
（确切是哪一个取决于
表的内部表示的细节，
这又可能取决于表如何被填充以及
其非数值键的内存地址。）


</p><p>
表长度的计算
有 <em>O(log n)</em> 的保证最坏时间，
其中 <em>n</em> 是表中最大的整数键。


</p><p>
程序可以通过 <code>__len</code> 元方法
修改除字符串外任何值的长度运算符的行为（参见 <a href="#2.4">§2.4</a>）。





</p><h3>3.4.8 – <a name="3.4.8">优先级</a></h3><p>
Lua 中的运算符优先级遵循下表，
从较低到较高优先级：

</p><pre>     or
     and
     &lt;     &gt;     &lt;=    &gt;=    ~=    ==
     |
     ~
     &amp;
     &lt;&lt;    &gt;&gt;
     ..
     +     -
     *     /     //    %
     一元运算符 (not   #     -     ~)
     ^
</pre><p>
像往常一样，
你可以用括号改变表达式的优先级。
连接（'<code>..</code>'）和幂运算（'<code>^</code>'）
运算符是右结合的。
所有其他二元运算符都是左结合的。





</p><h3>3.4.9 – <a name="3.4.9">表构造器</a></h3><p>
表构造器是创建表的表达式。
每次构造器被求值时，都会创建一个新表。
构造器可用于创建空表
或创建表并初始化其某些字段。
构造器的一般语法是

</p><pre>	tableconstructor ::= '<b>{</b>' [fieldlist] '<b>}</b>'
	fieldlist ::= field {fieldsep field} [fieldsep]
	field ::= '<b>[</b>' exp '<b>]</b>' '<b>=</b>' exp | Name '<b>=</b>' exp | exp
	fieldsep ::= '<b>,</b>' | '<b>;</b>'
</pre>

<p>
每个形式为 <code>[exp1] = exp2</code> 的字段向新表添加一个条目，
键为 <code>exp1</code>，值为 <code>exp2</code>。
形式为 <code>name = exp</code> 的字段等价于
<code>["name"] = exp</code>。
形式为 <code>exp</code> 的字段等价于
<code>[i] = exp</code>，其中 <code>i</code> 是从 1 开始的
连续整数；
其他格式的字段不影响这个计数。
例如，

</p><pre>     a = { [f(1)] = g; "x", "y"; x = 1, f(x), [30] = 23; 45 }
</pre><p>
等价于

</p><pre>     do
       local t = {}
       t[f(1)] = g
       t[1] = "x"         -- 第 1 个 exp
       t[2] = "y"         -- 第 2 个 exp
       t.x = 1            -- t["x"] = 1
       t[3] = f(x)        -- 第 3 个 exp
       t[30] = 23
       t[4] = 45          -- 第 4 个 exp
       a = t
     end
</pre>

<p>
构造器中赋值的顺序未定义。
（只有在有重复键时这个顺序才相关。）


</p><p>
如果列表中的最后一个字段具有形式 <code>exp</code>
且该表达式是多返回值表达式，
那么此表达式返回的所有值会连续进入列表
（参见 <a href="#3.4.12">§3.4.12</a>）。


</p><p>
字段列表可以有可选的尾随分隔符，
作为对机器生成代码的便利。





</p><h3>3.4.10 – <a name="3.4.10">函数调用</a></h3><p>
Lua 中的函数调用有以下语法：

</p><pre>	functioncall ::= prefixexp args
</pre><p>
在函数调用中，
首先对 prefixexp 和 args 求值。
如果 prefixexp 的值有类型 <em>function</em>，
那么用给定的参数调用这个函数。
否则，如果存在，
调用 prefixexp 的 <code>__call</code> 元方法：
它的第一个参数是 prefixexp 的值，
后跟原始调用参数
（参见 <a href="#2.4">§2.4</a>）。


</p><p>
形式

</p><pre>	functioncall ::= prefixexp '<b>:</b>' Name args
</pre><p>
可用于模拟方法。
调用 <code>v:name(<em>args</em>)</code>
是 <code>v.name(v,<em>args</em>)</code> 的语法糖，
只是 <code>v</code> 只被求值一次。


</p><p>
参数有以下语法：

</p><pre>	args ::= '<b>(</b>' [explist] '<b>)</b>'
	args ::= tableconstructor
	args ::= LiteralString
</pre><p>
所有参数表达式在调用前求值。
形式为 <code>f{<em>fields</em>}</code> 的调用是
<code>f({<em>fields</em>})</code> 的语法糖；
即，参数列表是单个新表。
形式为 <code>f'<em>string</em>'</code>
（或 <code>f"<em>string</em>"</code> 或 <code>f[[<em>string</em>]]</code>）的调用
是 <code>f('<em>string</em>')</code> 的语法糖；
即，参数列表是单个字面字符串。


</p><p>
形式为 <code>return <em>functioncall</em></code> 且
不在待关闭变量作用域内的调用称为<em>尾调用</em>。
Lua 实现<em>正确的尾调用</em>
（或<em>正确的尾递归</em>）：
在尾调用中，
被调用函数重用调用函数的栈条目。
因此，程序可以执行的嵌套尾调用数量没有限制。
但是，尾调用会擦除关于
调用函数的任何调试信息。
注意尾调用只发生在特定语法下，
其中 <b>return</b> 有一个单独的函数调用作为参数，
并且它在任何待关闭变量的作用域之外。
这种语法使得调用函数精确地返回
被调用函数的返回值，
中间没有任何动作。
因此，以下示例都不是尾调用：

</p><pre>     return (f(x))        -- 结果调整为 1
     return 2 * f(x)      -- 结果乘以 2
     return x, f(x)       -- 额外的结果
     f(x); return         -- 结果被丢弃
     return x or f(x)     -- 结果调整为 1
</pre>




<h3>3.4.11 – <a name="3.4.11">函数定义</a></h3>

<p>
函数定义的语法是

</p><pre>	functiondef ::= <b>function</b> funcbody
	funcbody ::= '<b>(</b>' [parlist] '<b>)</b>' block <b>end</b>
</pre>

<p>
以下语法糖简化了函数定义：

</p><pre>	stat ::= <b>function</b> funcname funcbody
	stat ::= <b>local</b> <b>function</b> Name funcbody
	funcname ::= Name {'<b>.</b>' Name} ['<b>:</b>' Name]
</pre><p>
语句

</p><pre>     function f () <em>body</em> end
</pre><p>
翻译为

</p><pre>     f = function () <em>body</em> end
</pre><p>
语句

</p><pre>     function t.a.b.c.f () <em>body</em> end
</pre><p>
翻译为

</p><pre>     t.a.b.c.f = function () <em>body</em> end
</pre><p>
语句

</p><pre>     local function f () <em>body</em> end
</pre><p>
翻译为

</p><pre>     local f; f = function () <em>body</em> end
</pre><p>
而不是

</p><pre>     local f = function () <em>body</em> end
</pre><p>
（只有当函数体包含对 <code>f</code> 的引用时这才有区别。）


</p><p>
函数定义是可执行表达式，
其值具有类型 <em>function</em>。
当 Lua 预编译代码块时，
其所有函数体也被预编译，
但它们尚未被创建。
然后，每当 Lua 执行函数定义时，
函数被<em>实例化</em>（或<em>闭合</em>）。
这个函数实例，或<em>闭包</em>，
是表达式的最终值。


</p><p>
参数作为用参数值
初始化的局部变量：

</p><pre>	parlist ::= namelist ['<b>,</b>' '<b>...</b>'] | '<b>...</b>'
</pre><p>
当调用 Lua 函数时，
它将其参数列表调整为
其参数列表的长度（参见 <a href="#3.4.12">§3.4.12</a>），
除非该函数是<em>可变参数函数</em>，
用其参数列表末尾的三个点（'<code>...</code>'）
表示。
可变参数函数不调整其参数列表；
相反，它收集所有额外参数并通过
<em>可变参数表达式</em>将它们提供给函数，
该表达式也写作三个点。
此表达式的值是所有实际额外参数的列表，
类似于具有多个结果的函数（参见 <a href="#3.4.12">§3.4.12</a>）。


</p><p>
作为示例，考虑以下定义：

</p><pre>     function f(a, b) end
     function g(a, b, ...) end
     function r() return 1,2,3 end
</pre><p>
然后，我们有从参数到参数
以及到可变参数表达式的以下映射：

</p><pre>     调用             参数
     
     f(3)             a=3, b=nil
     f(3, 4)          a=3, b=4
     f(3, 4, 5)       a=3, b=4
     f(r(), 10)       a=1, b=10
     f(r())           a=1, b=2
     
     g(3)             a=3, b=nil, ... --&gt;  (无)
     g(3, 4)          a=3, b=4,   ... --&gt;  (无)
     g(3, 4, 5, 8)    a=3, b=4,   ... --&gt;  5  8
     g(5, r())        a=5, b=1,   ... --&gt;  2  3
</pre>

<p>
使用 <b>return</b> 语句返回结果（参见 <a href="#3.3.4">§3.3.4</a>）。
如果控制到达函数末尾
而没有遇到 <b>return</b> 语句，
那么函数返回时没有结果。


</p><p>

函数可以返回的值的数量
有系统相关的限制。
这个限制保证大于 1000。


</p><p>
<em>冒号</em>语法
用于模拟<em>方法</em>，
向函数添加隐式额外参数 <code>self</code>。
因此，语句

</p><pre>     function t.a.b.c:f (<em>params</em>) <em>body</em> end
</pre><p>
是以下的语法糖

</p><pre>     t.a.b.c.f = function (self, <em>params</em>) <em>body</em> end
</pre>




<h3>3.4.12 – <a name="3.4.12">表达式列表、多返回值
和调整</a></h3>

<p>
函数调用和可变参数表达式都可以产生多个值。
这些表达式称为<em>多返回值表达式</em>。


</p><p>
当多返回值表达式用作
表达式列表的最后一个元素时，
表达式的所有结果都被添加到
表达式列表产生的值列表中。
注意，在期望表达式列表的地方的
单个表达式
是该（单例）列表中的最后一个表达式。


</p><p>
以下是 Lua 期望表达式列表的地方：

</p><ul>

<li>一个 <b>return</b> 语句，
例如 <code>return e1, e2, e3</code>（参见 <a href="#3.3.4">§3.3.4</a>）。</li>

<li>一个表构造器，
例如 <code>{e1, e2, e3}</code>（参见 <a href="#3.4.9">§3.4.9</a>）。</li>

<li>函数调用的参数，
例如 <code>foo(e1, e2, e3)</code>（参见 <a href="#3.4.10">§3.4.10</a>）。</li>

<li>多重赋值，
例如 <code>a , b, c = e1, e2, e3</code>（参见 <a href="#3.3.3">§3.3.3</a>）。</li>

<li>局部变量声明，
例如 <code>local a , b, c = e1, e2, e3</code>（参见 <a href="#3.3.7">§3.3.7</a>）。</li>

<li>泛型 <b>for</b> 循环中的初始值，
例如 <code>for k in e1, e2, e3 do ... end</code>（参见 <a href="#3.3.5">§3.3.5</a>）。</li>

</ul><p>
在最后四种情况下，
表达式列表中的值列表
必须被<em>调整</em>为特定长度：
对非可变参数函数的调用中的参数数量
（参见 <a href="#3.4.11">§3.4.11</a>）、
多重赋值或局部变量声明中的
变量数量，
以及泛型 <b>for</b> 循环恰好四个值。
<em>调整</em>遵循以下规则：
如果值多于需要的，
额外的值被丢弃；
如果值少于需要的，
列表用 <b>nil</b> 扩展。
当表达式列表以多返回值表达式结束时，
该表达式的所有结果在调整前
进入值列表。


</p><p>
当多返回值表达式在
表达式列表中使用但不是最后一个元素时，
或在语法期望单个表达式的地方，
Lua 将该表达式的结果列表调整为一个元素。
作为特殊情况，
语法期望括号表达式内有单个表达式；
因此，在多返回值表达式周围添加括号
强制它恰好产生一个结果。


</p><p>
我们很少需要在
语法期望单个表达式的地方
使用可变参数表达式。
（通常在可变参数部分之前
添加常规参数并使用该参数更简单。）
当有这种需要时，
我们建议将可变参数表达式
赋值给单个变量并在其位置使用该变量。


</p><p>
以下是多返回值表达式使用的一些示例。
在所有情况下，当构造需要
"第 n 个结果"而没有这样的结果时，
它使用 <b>nil</b>。

</p><pre>     print(x, f())      -- 打印 x 和 f() 的所有结果。
     print(x, (f()))    -- 打印 x 和 f() 的第一个结果。
     print(f(), x)      -- 打印 f() 的第一个结果和 x。
     print(1 + f())     -- 打印 1 加上 f() 的第一个结果。
     local x = ...      -- x 获得第一个可变参数。
     x,y = ...          -- x 获得第一个可变参数，
                        -- y 获得第二个可变参数。
     x,y,z = w, f()     -- x 获得 w，y 获得 f() 的第一个结果，
                        -- z 获得 f() 的第二个结果。
     x,y,z = f()        -- x 获得 f() 的第一个结果，
                        -- y 获得 f() 的第二个结果，
                        -- z 获得 f() 的第三个结果。
     x,y,z = f(), g()   -- x 获得 f() 的第一个结果，
                        -- y 获得 g() 的第一个结果，
                        -- z 获得 g() 的第二个结果。
     x,y,z = (f())      -- x 获得 f() 的第一个结果，y 和 z 获得 nil。
     return f()         -- 返回 f() 的所有结果。
     return x, ...      -- 返回 x 和所有接收到的可变参数。
     return x,y,f()     -- 返回 x、y 和 f() 的所有结果。
     {f()}              -- 用 f() 的所有结果创建列表。
     {...}              -- 用所有可变参数创建列表。
     {f(), 5}           -- 用 f() 的第一个结果和 5 创建列表。
</pre>






<h2>3.5 – <a name="3.5">可见性规则</a></h2>

<p>

Lua 是词法作用域的语言。
局部变量的作用域从
其声明后的第一条语句开始，持续到
包含该声明的最内层代码块的最后一条非空语句。
（<em>空语句</em>是标签和空语句。）
考虑以下示例：

</p><pre>     x = 10                -- 全局变量
     do                    -- 新代码块
       local x = x         -- 新的 'x'，值为 10
       print(x)            --&gt; 10
       x = x+1
       do                  -- 另一个代码块
         local x = x+1     -- 另一个 'x'
         print(x)          --&gt; 12
       end
       print(x)            --&gt; 11
     end
     print(x)              --&gt; 10（全局的）
</pre>

<p>
注意，在像 <code>local x = x</code> 这样的声明中，
被声明的新 <code>x</code> 还不在作用域内，
所以第二个 <code>x</code> 指的是外部变量。


</p><p>
由于词法作用域规则，
局部变量可以被定义在其作用域内的
函数自由访问。
被内部函数使用的局部变量在内部函数中
称为<em>上值</em>
（或<em>外部局部变量</em>，或简称<em>外部变量</em>）。


</p><p>
注意，每次执行 <b>local</b> 语句
都定义新的局部变量。
考虑以下示例：

</p><pre>     a = {}
     local x = 20
     for i = 1, 10 do
       local y = 0
       a[i] = function () y = y + 1; return x + y end
     end
</pre><p>
循环创建十个闭包
（即匿名函数的十个实例）。
这些闭包中的每一个都使用不同的 <code>y</code> 变量，
而它们都共享同一个 <code>x</code>。





</p><h1>4 – <a name="4">应用程序接口</a></h1>



<p>

本节描述 Lua 的 C&nbsp;API，即
宿主程序可用于与 Lua 通信的
C&nbsp;函数集。
所有 API 函数及相关类型和常量
都在头文件 <a name="pdf-lua.h"><code>lua.h</code></a> 中声明。


</p><p>
即使我们使用术语"函数"，
API 中的任何功能都可能以宏的形式提供。
除非另有说明，
所有这样的宏都只使用它们的每个参数一次
（除了第一个参数，它总是 Lua 状态），
因此不会产生任何隐藏的副作用。


</p><p>
与大多数 C&nbsp;库一样，
Lua API 函数不检查其参数
的有效性或一致性。
但是，你可以通过定义宏
<a name="pdf-LUA_USE_APICHECK"><code>LUA_USE_APICHECK</code></a> 来编译 Lua
以改变这种行为。


</p><p>
Lua 库是完全可重入的：
它没有全局变量。
它将需要的所有信息保存在动态结构中，
称为 <em>Lua 状态</em>。


</p><p>
每个 Lua 状态有一个或多个线程，
它们对应于独立的、协作的执行线。
类型 <a href="#lua_State"><code>lua_State</code></a>（尽管其名称）指的是线程。
（间接地，通过线程，它也指
与线程关联的 Lua 状态。）


</p><p>
指向线程的指针必须作为第一个参数传递给
库中的每个函数，除了 <a href="#lua_newstate"><code>lua_newstate</code></a>，
它从头创建 Lua 状态并返回
新状态中<em>主线程</em>的指针。





</p><h2>4.1 – <a name="4.1">栈</a></h2>



<p>
Lua 使用<em>虚拟栈</em>在 C 之间传递值。
这个栈中的每个元素表示一个 Lua 值
（<b>nil</b>、数字、字符串等）。
API 中的函数可以通过它们接收的
Lua 状态参数访问这个栈。


</p><p>
每当 Lua 调用 C 时，被调用的函数都会获得一个新栈，
它独立于之前的栈以及
仍然活动的 C&nbsp;函数的栈。
这个栈最初包含 C&nbsp;函数的任何参数，
并且 C&nbsp;函数可以在其中存储临时
Lua 值，必须将其结果压入栈
以返回给调用者（参见 <a href="#lua_CFunction"><code>lua_CFunction</code></a>）。


</p><p>
为了方便，
API 中的大多数查询操作不遵循严格的栈规则。
相反，它们可以通过使用<em>索引</em>
引用栈中的任何元素：
正索引表示绝对栈位置，
从栈底的 1 开始；
负索引表示相对于栈顶的偏移量。
更具体地说，如果栈有 <em>n</em> 个元素，
那么索引 1 表示第一个元素
（即最先压入栈的元素），
索引 <em>n</em> 表示最后一个元素；
索引 -1 也表示最后一个元素
（即栈顶的元素），
索引 <em>-n</em> 表示第一个元素。





</p><h3>4.1.1 – <a name="4.1.1">栈大小</a></h3>

<p>
当你与 Lua API 交互时，
你负责确保一致性。
特别地，
<em>你负责控制栈溢出</em>。
当你调用任何 API 函数时，
你必须确保栈有足够的空间容纳结果。


</p><p>
上述规则有一个例外：
当你调用 Lua 函数
而没有固定数量的结果时（参见 <a href="#lua_call"><code>lua_call</code></a>），
Lua 确保栈有足够的空间用于所有结果。
但是，它不确保任何额外空间。
因此，在这样的调用之后在栈上压入任何东西之前
你应该使用 <a href="#lua_checkstack"><code>lua_checkstack</code></a>。


</p><p>
<!-- slice ends -->

<!-- slice index: 3 -->
<!-- lines 2984–4481 / total 11964 -->
<!-- title: 4.2 – C Closures -->
当Lua调用C时，
它确保栈有至少<a name="pdf-LUA_MINSTACK"><code>LUA_MINSTACK</code></a>个额外元素的空间；
也就是说，你可以安全地向其中压入最多<code>LUA_MINSTACK</code>个值。
<code>LUA_MINSTACK</code>被定义为20，
所以通常你不必担心栈空间问题，
除非你的代码中有循环向栈压入元素。
在必要时，
你可以使用函数<a href="#lua_checkstack"><code>lua_checkstack</code></a>
来确保栈有足够的空间压入新元素。





</p><h3>4.1.2 – <a name="4.1.2">有效索引和可接受索引</a></h3>

<p>
API中任何接收栈索引的函数
只能使用<em>有效索引</em>或<em>可接受索引</em>。


</p><p>
<em>有效索引</em>是指向一个
存储可修改Lua值的位置的索引。
它包括1和栈顶之间的栈索引
(<code>1 &#8804; abs(index) &#8804; top</code>)

加上<em>伪索引</em>，
伪索引代表某些可被C代码访问
但不在栈中的位置。
伪索引用于访问注册表（见<a href="#4.3">§4.3</a>）
和C函数的上值（见<a href="#4.2">§4.2</a>）。


</p><p>
不需要特定可变位置的函数，
只需要一个值（例如，查询函数），
可以使用可接受索引调用。
<em>可接受索引</em>可以是任何有效索引，
但它也可以是栈顶之后
在为栈分配的空间内的任何正索引，
也就是说，索引最大到栈的大小。
（注意0永远不是可接受索引。）
指向上值（见<a href="#4.2">§4.2</a>）的索引如果大于当前C函数
实际的上值数量也是可接受的（但无效）。
除非另有说明，
API中的函数使用可接受索引工作。


</p><p>
可接受索引的作用是避免在查询栈时
进行额外的栈顶测试。
例如，一个C函数可以查询它的第三个参数
而无需检查是否有第三个参数，
也就是说，无需检查3是否是有效索引。


</p><p>
对于可以使用可接受索引调用的函数，
任何非有效索引都被视为包含
一个虚拟类型<a name="pdf-LUA_TNONE"><code>LUA_TNONE</code></a>的值，
其行为类似于nil值。





</p><h3>4.1.3 – <a name="4.1.3">指向字符串的指针</a></h3>

<p>
API中的几个函数返回指向栈中Lua字符串的指针（<code>const char*</code>）。
（见<a href="#lua_pushfstring"><code>lua_pushfstring</code></a>、<a href="#lua_pushlstring"><code>lua_pushlstring</code></a>、
<a href="#lua_pushstring"><code>lua_pushstring</code></a>和<a href="#lua_tolstring"><code>lua_tolstring</code></a>。
另见辅助库中的<a href="#luaL_checklstring"><code>luaL_checklstring</code></a>、<a href="#luaL_checkstring"><code>luaL_checkstring</code></a>
和<a href="#luaL_tolstring"><code>luaL_tolstring</code></a>。）


</p><p>
通常，
Lua的垃圾回收可以释放或移动内部内存，
从而使指向内部字符串的指针失效。
为了允许安全使用这些指针，
API保证只要栈索引处的字符串值
没有从栈中移除，指向该索引处字符串的任何指针就是有效的。
（不过它可以被移动到另一个索引。）
当索引是伪索引（指向一个上值）时，
只要对应的调用处于活动状态且
对应的上值未被修改，该指针就是有效的。


</p><p>
调试接口中的一些函数
也返回指向字符串的指针，
即<a href="#lua_getlocal"><code>lua_getlocal</code></a>、<a href="#lua_getupvalue"><code>lua_getupvalue</code></a>、
<a href="#lua_setlocal"><code>lua_setlocal</code></a>和<a href="#lua_setupvalue"><code>lua_setupvalue</code></a>。
对于这些函数，只要调用者函数处于活动状态且
给定的闭包（如果提供了）在栈中，
该指针就保证是有效的。


</p><p>
除了这些保证外，
垃圾回收器可以自由地使
任何指向内部字符串的指针失效。







</p><h2>4.2 – <a name="4.2">C闭包</a></h2>

<p>
当创建一个C函数时，
可以将一些值与其关联，
从而创建一个<em>C闭包</em>
（见<a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a>）；
这些值称为<em>上值</em>，在函数被调用时
可以访问它们。


</p><p>
每当调用C函数时，
它的上值位于特定的伪索引处。
这些伪索引由宏
<a href="#lua_upvalueindex"><code>lua_upvalueindex</code></a>产生。
与函数关联的第一个上值在索引
<code>lua_upvalueindex(1)</code>处，依此类推。
对<code>lua_upvalueindex(<em>n</em>)</code>的任何访问，
其中<em>n</em>大于当前函数的上值数量
（但不大于256，
即闭包中上值最大数量加一），
都会产生一个可接受但无效的索引。


</p><p>
C闭包也可以改变其
相应上值的值。





</p><h2>4.3 – <a name="4.3">注册表</a></h2>

<p>
Lua提供了一个<em>注册表</em>，
一个预定义的表，任何C代码都可以使用它
来存储需要存储的任何Lua值。
注册表表总是可以在伪索引
<a name="pdf-LUA_REGISTRYINDEX"><code>LUA_REGISTRYINDEX</code></a>处访问。
任何C库都可以在这个表中存储数据，
但它必须注意选择与其他库使用的键
不同的键，以避免冲突。
通常，你应该使用包含你的库名的字符串作为键，
或使用代码中C对象地址的轻量用户数据，
或使用代码创建的任何Lua对象。
与变量名一样，
以下划线后跟大写字母开头的字符串键
保留给Lua使用。


</p><p>
注册表中的整数键被
引用机制使用（见<a href="#luaL_ref"><code>luaL_ref</code></a>）
以及一些预定义值。
因此，注册表中的整数键
不得用于其他目的。


</p><p>
当你创建一个新的Lua状态时，
它的注册表带有一些预定义值。
这些预定义值用在<code>lua.h</code>中定义为常量的
整数键索引。
定义了以下常量：

</p><ul>
<li><b><a name="pdf-LUA_RIDX_MAINTHREAD"><code>LUA_RIDX_MAINTHREAD</code></a>: </b> 在此索引处，注册表包含
状态的主线程。
（主线程是与状态一起创建的线程。）
</li>

<li><b><a name="pdf-LUA_RIDX_GLOBALS"><code>LUA_RIDX_GLOBALS</code></a>: </b> 在此索引处，注册表包含
全局环境。
</li>
</ul>




<h2>4.4 – <a name="4.4">C中的错误处理</a></h2>



<p>
在内部，Lua使用C的<code>longjmp</code>机制来处理错误。
（如果你将Lua编译为C++，Lua将使用异常；
在源代码中搜索<code>LUAI_THROW</code>以了解详情。）
当Lua遇到任何错误，
例如内存分配错误或类型错误时，
它会<em>引发</em>一个错误；
也就是说，它执行一个长跳转。
<em>保护环境</em>使用<code>setjmp</code>
来设置一个恢复点；
任何错误都会跳转到最近的活动恢复点。


</p><p>
在C函数内部，你可以通过调用<a href="#lua_error"><code>lua_error</code></a>
显式引发错误。


</p><p>
API中的大多数函数都可能引发错误，
例如由于内存分配错误。
每个函数的文档都会说明
它是否可能引发错误。


</p><p>
如果错误发生在任何保护环境之外，
Lua会调用一个<em>panic函数</em>（见<a href="#lua_atpanic"><code>lua_atpanic</code></a>），
然后调用<code>abort</code>，
从而退出宿主应用程序。
你的panic函数可以通过
永不返回来避免这种退出
（例如，长跳转到Lua外部你自己的恢复点）。


</p><p>
panic函数，
顾名思义，
是一种最后手段的机制。
程序应该避免它。
作为一般规则，
当Lua调用带有Lua状态的C函数时，
它可以对该Lua状态做任何事情，
因为它应该已经受到保护。
然而，
当C代码操作其他Lua状态时
（例如，函数的Lua状态参数、
存储在注册表中的Lua状态，或
<a href="#lua_newthread"><code>lua_newthread</code></a>的结果），
它应该仅在不会引发错误的API调用中使用它们。


</p><p>
panic函数的运行方式类似于消息处理器（见<a href="#2.3">§2.3</a>）；
特别是，错误对象位于栈顶。
但是，不保证有栈空间。
要在栈上压入任何东西，
panic函数必须首先检查可用空间（见<a href="#4.1.1">§4.1.1</a>）。





</p><h3>4.4.1 – <a name="4.4.1">状态码</a></h3>

<p>
API中几个报告错误的函数使用以下
状态码来指示不同类型的错误或其他条件：

</p><ul>

<li><b><a name="pdf-LUA_OK"><code>LUA_OK</code></a> (0): </b> 无错误。</li>

<li><b><a name="pdf-LUA_ERRRUN"><code>LUA_ERRRUN</code></a>: </b> 运行时错误。</li>

<li><b><a name="pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>: </b>
内存分配错误。
对于此类错误，Lua不调用消息处理器。
</li>

<li><b><a name="pdf-LUA_ERRERR"><code>LUA_ERRERR</code></a>: </b> 运行消息处理器时的错误。</li>

<li><b><a name="pdf-LUA_ERRSYNTAX"><code>LUA_ERRSYNTAX</code></a>: </b> 预编译期间的语法错误。</li>

<li><b><a name="pdf-LUA_YIELD"><code>LUA_YIELD</code></a>: </b> 线程（协程）让出。</li>

<li><b><a name="pdf-LUA_ERRFILE"><code>LUA_ERRFILE</code></a>: </b> 与文件相关的错误；
例如，无法打开或读取文件。</li>

</ul><p>
这些常量在头文件<code>lua.h</code>中定义。







</p><h2>4.5 – <a name="4.5">在C中处理让出</a></h2>

<p>
在内部，Lua使用C的<code>longjmp</code>机制来让出协程。
因此，如果C函数<code>foo</code>调用API函数
且该API函数让出
（直接或通过调用另一个让出的函数间接让出），
Lua无法再返回到<code>foo</code>，
因为<code>longjmp</code>从C栈中移除了它的帧。


</p><p>
为了避免这种问题，
Lua在试图跨API调用让出时会引发错误，
但有三个函数例外：
<a href="#lua_yieldk"><code>lua_yieldk</code></a>、<a href="#lua_callk"><code>lua_callk</code></a>和<a href="#lua_pcallk"><code>lua_pcallk</code></a>。
所有这些函数都接收一个<em>延续函数</em>
（作为名为<code>k</code>的参数）以在让出后继续执行。


</p><p>
我们需要设定一些术语来解释延续。
我们有一个从Lua调用的C函数，我们将其称为
<em>原始函数</em>。
这个原始函数然后调用C API中的这三个函数之一，
我们将其称为<em>被调用函数</em>，
然后让出当前线程。
当被调用函数是<a href="#lua_yieldk"><code>lua_yieldk</code></a>时，或当被调用函数是<a href="#lua_callk"><code>lua_callk</code></a>或<a href="#lua_pcallk"><code>lua_pcallk</code></a>
且它们调用的函数让出时，这种情况就会发生。


</p><p>
假设运行的线程在执行被调用函数时让出。
线程恢复后，
它最终将完成运行被调用函数。
但是，
被调用函数无法返回到原始函数，
因为它在C栈中的帧被让出破坏了。
相反，Lua调用<em>延续函数</em>，
该函数作为参数传递给被调用函数。
顾名思义，
延续函数应该继续
原始函数的任务。


</p><p>
作为说明，考虑以下函数：

</p><pre>     int original_function (lua_State *L) {
       ...     /* 代码 1 */
       status = lua_pcall(L, n, m, h);  /* 调用 Lua */
       ...     /* 代码 2 */
     }
</pre><p>
现在我们想允许
<a href="#lua_pcall"><code>lua_pcall</code></a>运行的Lua代码让出。
首先，我们可以像这样重写我们的函数：

</p><pre>     int k (lua_State *L, int status, lua_KContext ctx) {
       ...  /* 代码 2 */
     }
     
     int original_function (lua_State *L) {
       ...     /* 代码 1 */
       return k(L, lua_pcall(L, n, m, h), ctx);
     }
</pre><p>
在上面的代码中，
新函数<code>k</code>是一个
<em>延续函数</em>（类型为<a href="#lua_KFunction"><code>lua_KFunction</code></a>），
它应该完成原始函数
在调用<a href="#lua_pcall"><code>lua_pcall</code></a>之后要做的所有工作。
现在，我们必须通知Lua，如果<a href="#lua_pcall"><code>lua_pcall</code></a>执行的Lua代码
以某种方式被中断（错误或让出），
它必须调用<code>k</code>，
所以我们像这样重写代码，
用<a href="#lua_pcallk"><code>lua_pcallk</code></a>替换<a href="#lua_pcall"><code>lua_pcall</code></a>：

</p><pre>     int original_function (lua_State *L) {
       ...     /* 代码 1 */
       return k(L, lua_pcallk(L, n, m, h, ctx2, k), ctx1);
     }
</pre><p>
注意对延续的外部显式调用：
Lua只在需要时才会调用延续，即
在出错或让出后恢复的情况下。
如果被调用的函数正常返回且从未让出，
<a href="#lua_pcallk"><code>lua_pcallk</code></a>（和<a href="#lua_callk"><code>lua_callk</code></a>）也会正常返回。
（当然，在这种情况下，你可以直接在原始函数内部
完成等效的工作，而不是调用延续。）


</p><p>
除了Lua状态外，
延续函数还有两个其他参数：
调用的最终状态和最初传递给<a href="#lua_pcallk"><code>lua_pcallk</code></a>的
上下文值（<code>ctx</code>）。
Lua不使用此上下文值；
它只是将此值从原始函数传递到
延续函数。
对于<a href="#lua_pcallk"><code>lua_pcallk</code></a>，
状态与<a href="#lua_pcallk"><code>lua_pcallk</code></a>返回的值相同，
但在让出后执行时为<a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>
（而不是<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>）。
对于<a href="#lua_yieldk"><code>lua_yieldk</code></a>和<a href="#lua_callk"><code>lua_callk</code></a>，
当Lua调用延续时，状态始终为<a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>。
（对于这两个函数，
Lua在出错的情况下不会调用延续，
因为它们不处理错误。）
同样，当使用<a href="#lua_callk"><code>lua_callk</code></a>时，
你应该用<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>作为状态
调用延续函数。
（对于<a href="#lua_yieldk"><code>lua_yieldk</code></a>，直接调用
延续函数没有太大意义，
因为<a href="#lua_yieldk"><code>lua_yieldk</code></a>通常不会返回。）


</p><p>
Lua将延续函数视为原始函数。
延续函数从原始函数接收相同的Lua栈，
状态与被调用函数返回时的状态相同。
（例如，
在<a href="#lua_callk"><code>lua_callk</code></a>之后，函数及其参数从栈中移除
并被调用的结果替换。）
它也具有相同的上值。
它返回的任何内容都由Lua处理，就像
它是原始函数的返回值一样。





</p><h2>4.6 – <a name="4.6">函数和类型</a></h2>

<p>
这里我们按字母顺序列出C API中的
所有函数和类型。
每个函数都有一个这样的指示符：
<span class="apii">[-o, +p, <em>x</em>]</span>


</p><p>
第一个字段<code>o</code>
是函数从栈中弹出多少个元素。
第二个字段<code>p</code>
是函数向栈压入多少个元素。
（任何函数总是在弹出其参数后压入其结果。）
<code>x|y</code>形式的字段表示函数可以压入（或弹出）
<code>x</code>或<code>y</code>个元素，
取决于情况；
问号'<code>?</code>'表示
我们仅通过查看其参数无法知道
函数弹出/压入多少个元素。
（例如，它们可能取决于栈中的内容。）
第三个字段<code>x</code>
表示函数是否可能引发错误：
'<code>-</code>'表示函数从不引发任何错误；
'<code>m</code>'表示函数可能仅引发内存不足错误；
'<code>v</code>'表示函数可能引发文本中解释的错误；
'<code>e</code>'表示函数可以运行任意Lua代码，
直接或通过元方法，
因此可能引发任何错误。



</p><hr><h3><a name="lua_absindex"><code>lua_absindex</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_absindex (lua_State *L, int idx);</pre>

<p>
将可接受索引<code>idx</code>
转换为等效的绝对索引
（即不依赖于栈大小的索引）。





</p><hr><h3><a name="lua_Alloc"><code>lua_Alloc</code></a></h3>
<pre>typedef void * (*lua_Alloc) (void *ud,
                             void *ptr,
                             size_t osize,
                             size_t nsize);</pre>

<p>
Lua状态使用的内存分配函数的类型。
分配器函数必须提供
类似于<code>realloc</code>的功能，
但不完全相同。
它的参数是
<code>ud</code>，传递给<a href="#lua_newstate"><code>lua_newstate</code></a>的不透明指针；
<code>ptr</code>，指向正在分配/重新分配/释放的块的指针；
<code>osize</code>，块的原始大小或关于正在分配的内容的某些代码；
以及<code>nsize</code>，块的新大小。


</p><p>
当<code>ptr</code>不是<code>NULL</code>时，
<code>osize</code>是<code>ptr</code>指向的块的大小，
也就是分配或重新分配时给定的大小。


</p><p>
当<code>ptr</code>是<code>NULL</code>时，
<code>osize</code>编码Lua正在分配的对象类型。
<code>osize</code>是
<a href="#pdf-LUA_TSTRING"><code>LUA_TSTRING</code></a>、<a href="#pdf-LUA_TTABLE"><code>LUA_TTABLE</code></a>、<a href="#pdf-LUA_TFUNCTION"><code>LUA_TFUNCTION</code></a>、
<a href="#pdf-LUA_TUSERDATA"><code>LUA_TUSERDATA</code></a>或<a href="#pdf-LUA_TTHREAD"><code>LUA_TTHREAD</code></a>中的任何一个（且仅当）
Lua正在创建该类型的新对象时。
当<code>osize</code>是其他某个值时，
Lua正在为其他东西分配内存。


</p><p>
Lua假设分配器函数具有以下行为：


</p><p>
当<code>nsize</code>为零时，
分配器必须像<code>free</code>一样行为
然后返回<code>NULL</code>。


</p><p>
当<code>nsize</code>不为零时，
分配器必须像<code>realloc</code>一样行为。
特别是，当且仅当它无法满足请求时，
分配器返回<code>NULL</code>。


</p><p>
这是分配器函数的一个简单实现。
它在辅助库中由<a href="#luaL_newstate"><code>luaL_newstate</code></a>使用。

</p><pre>     static void *l_alloc (void *ud, void *ptr, size_t osize,
                                                size_t nsize) {
       (void)ud;  (void)osize;  /* 未使用 */
       if (nsize == 0) {
         free(ptr);
         return NULL;
       }
       else
         return realloc(ptr, nsize);
     }
</pre><p>
注意ISO C确保
<code>free(NULL)</code>无效，且
<code>realloc(NULL,size)</code>等同于<code>malloc(size)</code>。





</p><hr><h3><a name="lua_arith"><code>lua_arith</code></a></h3><p>
<span class="apii">[-(2|1), +1, <em>e</em>]</span>
</p><pre>void lua_arith (lua_State *L, int op);</pre>

<p>
对栈顶的两个值
（或一个，在取负的情况下）
执行算术或位运算，
栈顶的值是第二个操作数，
弹出这些值，并压入运算结果。
该函数遵循相应Lua运算符的语义
（也就是说，它可能调用元方法）。


</p><p>
<code>op</code>的值必须是以下常量之一：

</p><ul>

<li><b><a name="pdf-LUA_OPADD"><code>LUA_OPADD</code></a>: </b> 执行加法（<code>+</code>）</li>
<li><b><a name="pdf-LUA_OPSUB"><code>LUA_OPSUB</code></a>: </b> 执行减法（<code>-</code>）</li>
<li><b><a name="pdf-LUA_OPMUL"><code>LUA_OPMUL</code></a>: </b> 执行乘法（<code>*</code>）</li>
<li><b><a name="pdf-LUA_OPDIV"><code>LUA_OPDIV</code></a>: </b> 执行浮点除法（<code>/</code>）</li>
<li><b><a name="pdf-LUA_OPIDIV"><code>LUA_OPIDIV</code></a>: </b> 执行向下取整除法（<code>//</code>）</li>
<li><b><a name="pdf-LUA_OPMOD"><code>LUA_OPMOD</code></a>: </b> 执行取模（<code>%</code>）</li>
<li><b><a name="pdf-LUA_OPPOW"><code>LUA_OPPOW</code></a>: </b> 执行幂运算（<code>^</code>）</li>
<li><b><a name="pdf-LUA_OPUNM"><code>LUA_OPUNM</code></a>: </b> 执行数学取负（一元<code>-</code>）</li>
<li><b><a name="pdf-LUA_OPBNOT"><code>LUA_OPBNOT</code></a>: </b> 执行位非（<code>~</code>）</li>
<li><b><a name="pdf-LUA_OPBAND"><code>LUA_OPBAND</code></a>: </b> 执行位与（<code>&amp;</code>）</li>
<li><b><a name="pdf-LUA_OPBOR"><code>LUA_OPBOR</code></a>: </b> 执行位或（<code>|</code>）</li>
<li><b><a name="pdf-LUA_OPBXOR"><code>LUA_OPBXOR</code></a>: </b> 执行位异或（<code>~</code>）</li>
<li><b><a name="pdf-LUA_OPSHL"><code>LUA_OPSHL</code></a>: </b> 执行左移（<code>&lt;&lt;</code>）</li>
<li><b><a name="pdf-LUA_OPSHR"><code>LUA_OPSHR</code></a>: </b> 执行右移（<code>&gt;&gt;</code>）</li>

</ul>




<hr><h3><a name="lua_atpanic"><code>lua_atpanic</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);</pre>

<p>
设置一个新的panic函数并返回旧的panic函数（见<a href="#4.4">§4.4</a>）。





</p><hr><h3><a name="lua_call"><code>lua_call</code></a></h3><p>
<span class="apii">[-(nargs+1), +nresults, <em>e</em>]</span>
</p><pre>void lua_call (lua_State *L, int nargs, int nresults);</pre>

<p>
调用一个函数。
与常规Lua调用一样，
<code>lua_call</code>遵循<code>__call</code>元方法。
所以，这里的"函数"一词
意味着任何可调用的值。


</p><p>
要进行调用，你必须使用以下协议：
首先，要调用的函数被压入栈；
然后，调用的参数按
直接顺序压入；
也就是说，第一个参数先压入。
最后你调用<a href="#lua_call"><code>lua_call</code></a>；
<code>nargs</code>是你压入栈的参数数量。
当函数返回时，
所有参数和函数值都被弹出，
调用结果被压入栈。
结果数量被调整为<code>nresults</code>，
除非<code>nresults</code>是<a name="pdf-LUA_MULTRET"><code>LUA_MULTRET</code></a>。
在这种情况下，函数的所有结果都被压入；
Lua确保返回的值适合栈空间，
但它不保证栈中有任何额外空间。
函数结果按直接顺序压入栈
（第一个结果先压入），
所以调用后最后一个结果在栈顶。


</p><p>
调用和运行函数时的任何错误都会向上传播
（通过<code>longjmp</code>）。


</p><p>
以下示例展示了宿主程序如何执行
与此Lua代码等效的操作：

</p><pre>     a = f("how", t.x, 14)
</pre><p>
这是C中的写法：

</p><pre>     lua_getglobal(L, "f");                  /* 要调用的函数 */
     lua_pushliteral(L, "how");                       /* 第1个参数 */
     lua_getglobal(L, "t");                    /* 要索引的表 */
     lua_getfield(L, -1, "x");        /* 压入 t.x 的结果（第2个参数） */
     lua_remove(L, -2);                  /* 从栈中移除 't' */
     lua_pushinteger(L, 14);                          /* 第3个参数 */
     lua_call(L, 3, 1);     /* 用3个参数和1个结果调用 'f' */
     lua_setglobal(L, "a");                         /* 设置全局变量 'a' */
</pre><p>
注意上面的代码是<em>平衡的</em>：
在结束时，栈恢复到其原始配置。
这被认为是良好的编程实践。





</p><hr><h3><a name="lua_callk"><code>lua_callk</code></a></h3><p>
<span class="apii">[-(nargs + 1), +nresults, <em>e</em>]</span>
</p><pre>void lua_callk (lua_State *L,
                int nargs,
                int nresults,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>
此函数的行为与<a href="#lua_call"><code>lua_call</code></a>完全相同，
但允许被调用的函数让出（见<a href="#4.5">§4.5</a>）。





</p><hr><h3><a name="lua_CFunction"><code>lua_CFunction</code></a></h3>
<pre>typedef int (*lua_CFunction) (lua_State *L);</pre>

<p>
C函数的类型。


</p><p>
为了与Lua正确通信，
C函数必须使用以下协议，
该协议定义了参数和结果的传递方式：
C函数从Lua的栈中按
直接顺序接收其参数（第一个参数先压入）。
所以，当函数开始时，
<code>lua_gettop(L)</code>返回函数接收的参数数量。
第一个参数（如果有）在索引1处，
其最后一个参数在索引<code>lua_gettop(L)</code>处。
要向Lua返回值，C函数只需按
直接顺序将它们压入栈
（第一个结果先压入），
并在C中返回结果的数量。
栈中结果下方的任何其他值都将被Lua
正确丢弃。
与Lua函数一样，Lua调用的C函数也可以返回
多个结果。


</p><p>
作为示例，以下函数接收可变数量的
数字参数并返回它们的平均值和总和：

</p><pre>     static int foo (lua_State *L) {
       int n = lua_gettop(L);    /* 参数数量 */
       lua_Number sum = 0.0;
       int i;
       for (i = 1; i &lt;= n; i++) {
         if (!lua_isnumber(L, i)) {
           lua_pushliteral(L, "incorrect argument");
           lua_error(L);
         }
         sum += lua_tonumber(L, i);
       }
       lua_pushnumber(L, sum/n);        /* 第一个结果 */
       lua_pushnumber(L, sum);         /* 第二个结果 */
       return 2;                   /* 结果数量 */
     }
</pre>




<hr><h3><a name="lua_checkstack"><code>lua_checkstack</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_checkstack (lua_State *L, int n);</pre>

<p>
确保栈至少有<code>n</code>个额外元素的空间，
也就是说，你可以安全地向其压入最多<code>n</code>个值。
如果它无法满足请求，则返回false，
要么是因为这会导致栈
大于固定的最大大小
（通常至少几千个元素），要么是
因为它无法为额外空间分配内存。
此函数从不缩小栈；
如果栈已经有额外元素的空间，
它保持不变。





</p><hr><h3><a name="lua_close"><code>lua_close</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void lua_close (lua_State *L);</pre>

<p>
关闭主线程中所有活动的待关闭变量，
释放给定Lua状态中的所有对象
（如果有，调用相应的垃圾回收元方法），
并释放此状态使用的所有动态内存。


</p><p>
在多个平台上，你可能不需要调用此函数，
因为当宿主程序结束时，所有资源都会自然释放。
另一方面，创建多个状态的长时间运行的程序，
例如守护进程或Web服务器，
可能需要在不再需要状态时立即关闭它们。





</p><hr><h3><a name="lua_closeslot"><code>lua_closeslot</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
</p><pre>void lua_closeslot (lua_State *L, int index);</pre>

<p>
关闭给定索引处的待关闭槽位并将其值设置为<b>nil</b>。
该索引必须是之前标记为待关闭
（见<a href="#lua_toclose"><code>lua_toclose</code></a>）且仍处于活动状态（即尚未关闭）的最后一个索引。


</p><p>
通过此函数调用的<code>__close</code>元方法不能让出。


</p><p>
（此函数在版本5.4.3中引入。）





</p><hr><h3><a name="lua_closethread"><code>lua_closethread</code></a></h3><p>
<span class="apii">[-0, +?, –]</span>
</p><pre>int lua_closethread (lua_State *L, lua_State *from);</pre>

<p>
重置线程，清理其调用栈并关闭所有待
关闭的变量。
返回状态码：
对于线程中无错误，返回<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>
（无论是停止线程的原始错误还是
关闭方法中的错误），
否则返回错误状态。
如果出错，
将错误对象留在栈顶。


</p><p>
参数<code>from</code>代表正在重置<code>L</code>的协程。
如果没有这样的协程，
此参数可以是<code>NULL</code>。


</p><p>
（此函数在版本5.4.6中引入。）





</p><hr><h3><a name="lua_compare"><code>lua_compare</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
</p><pre>int lua_compare (lua_State *L, int index1, int index2, int op);</pre>

<p>
比较两个Lua值。
如果索引<code>index1</code>处的值在与索引<code>index2</code>处的值
比较时满足<code>op</code>，
则返回1，遵循相应Lua运算符的语义
（也就是说，它可能调用元方法）。
否则返回0。
如果任何索引无效，也返回0。


</p><p>
<code>op</code>的值必须是以下常量之一：

</p><ul>

<li><b><a name="pdf-LUA_OPEQ"><code>LUA_OPEQ</code></a>: </b> 比较相等性（<code>==</code>）</li>
<li><b><a name="pdf-LUA_OPLT"><code>LUA_OPLT</code></a>: </b> 比较小于（<code>&lt;</code>）</li>
<li><b><a name="pdf-LUA_OPLE"><code>LUA_OPLE</code></a>: </b> 比较小于或等于（<code>&lt;=</code>）</li>

</ul>




<hr><h3><a name="lua_concat"><code>lua_concat</code></a></h3><p>
<span class="apii">[-n, +1, <em>e</em>]</span>
</p><pre>void lua_concat (lua_State *L, int n);</pre>

<p>
连接栈顶的<code>n</code>个值，
弹出它们，并将结果留在栈顶。
如果<code>n</code>是1，结果是栈上的单个值
（也就是说，函数什么也不做）；
如果<code>n</code>是0，结果是空字符串。
连接按照Lua的通常语义执行
（见<a href="#3.4.6">§3.4.6</a>）。





</p><hr><h3><a name="lua_copy"><code>lua_copy</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void lua_copy (lua_State *L, int fromidx, int toidx);</pre>

<p>
将索引<code>fromidx</code>处的元素
复制到有效索引<code>toidx</code>，
替换该位置的值。
其他位置的值不受影响。





</p><hr><h3><a name="lua_createtable"><code>lua_createtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>void lua_createtable (lua_State *L, int narr, int nrec);</pre>

<p>
创建一个新的空表并将其压入栈。
参数<code>narr</code>是表将作为序列
拥有多少元素的提示；
参数<code>nrec</code>是表将拥有多少其他元素的提示。
Lua可以使用这些提示为新表预分配内存。
当你事先知道表将拥有多少元素时，
这种预分配可能有助于提高性能。
否则你可以使用函数<a href="#lua_newtable"><code>lua_newtable</code></a>。





</p><hr><h3><a name="lua_dump"><code>lua_dump</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_dump (lua_State *L,
                        lua_Writer writer,
                        void *data,
                        int strip);</pre>

<p>
将函数转储为二进制块。
在栈顶接收一个Lua函数
并产生一个二进制块，如果再次加载，
会生成与转储的函数等效的函数。
当它产生块的部分时，
<a href="#lua_dump"><code>lua_dump</code></a>调用函数<code>writer</code>（见<a href="#lua_Writer"><code>lua_Writer</code></a>）
并传递给定的<code>data</code>
来写入它们。


</p><p>
如果<code>strip</code>为true，
二进制表示可能不包含关于函数的
所有调试信息，
以节省空间。


</p><p>
返回的值是最后一次
调用writer返回的错误码；
0表示无错误。


</p><p>
此函数不会从栈中弹出Lua函数。





</p><hr><h3><a name="lua_error"><code>lua_error</code></a></h3><p>
<span class="apii">[-1, +0, <em>v</em>]</span>
</p><pre>int lua_error (lua_State *L);</pre>

<p>
引发Lua错误，
使用栈顶的值作为错误对象。
此函数执行长跳转，
因此永不返回
（见<a href="#luaL_error"><code>luaL_error</code></a>）。





</p><hr><h3><a name="lua_gc"><code>lua_gc</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_gc (lua_State *L, int what, ...);</pre>

<p>
控制垃圾回收器。


</p><p>
此函数执行多个任务，
根据参数<code>what</code>的值。
对于需要额外参数的选项，
它们列在选项之后。

</p><ul>

<li><b><code>LUA_GCCOLLECT</code>: </b>
执行完整的垃圾回收周期。
</li>

<li><b><code>LUA_GCSTOP</code>: </b>
停止垃圾回收器。
</li>

<li><b><code>LUA_GCRESTART</code>: </b>
重启垃圾回收器。
</li>

<li><b><code>LUA_GCCOUNT</code>: </b>
返回Lua当前使用的内存量（以Kb为单位）。
</li>

<li><b><code>LUA_GCCOUNTB</code>: </b>
返回Lua当前使用的内存字节数
除以1024的余数。
</li>

<li><b><code>LUA_GCSTEP</code> <code>(int stepsize)</code>: </b>
执行垃圾回收的增量步骤，
对应于分配<code>stepsize</code> Kb。
</li>

<li><b><code>LUA_GCISRUNNING</code>: </b>
返回一个布尔值，表示回收器是否正在运行
（即未停止）。
</li>

<li><b><code>LUA_GCINC</code> (int pause, int stepmul, stepsize): </b>
将回收器更改为增量模式
并使用给定参数（见<a href="#2.5.1">§2.5.1</a>）。
返回之前的模式（<code>LUA_GCGEN</code>或<code>LUA_GCINC</code>）。
</li>

<li><b><code>LUA_GCGEN</code> (int minormul, int majormul): </b>
将回收器更改为分代模式
并使用给定参数（见<a href="#2.5.2">§2.5.2</a>）。
返回之前的模式（<code>LUA_GCGEN</code>或<code>LUA_GCINC</code>）。
</li>

</ul><p>
有关这些选项的更多详细信息，
见<a href="#pdf-collectgarbage"><code>collectgarbage</code></a>。


</p><p>
此函数不应由终结器调用。





</p><hr><h3><a name="lua_getallocf"><code>lua_getallocf</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_Alloc lua_getallocf (lua_State *L, void **ud);</pre>

<p>
返回给定状态的内存分配函数。
如果<code>ud</code>不是<code>NULL</code>，Lua在<code>*ud</code>中存储
设置内存分配器函数时给定的不透明指针。





</p><hr><h3><a name="lua_getfield"><code>lua_getfield</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
</p><pre>int lua_getfield (lua_State *L, int index, const char *k);</pre>

<p>
将值<code>t[k]</code>压入栈，
其中<code>t</code>是给定索引处的值。
与Lua中一样，此函数可能触发
"index"事件的元方法（见<a href="#2.4">§2.4</a>）。


</p><p>
返回压入值的类型。





</p><hr><h3><a name="lua_getextraspace"><code>lua_getextraspace</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void *lua_getextraspace (lua_State *L);</pre>

<p>
返回指向与给定Lua状态关联的
原始内存区域的指针。
应用程序可以将此区域用于任何目的；
Lua不将其用于任何用途。


</p><p>
每个新线程的此区域都用
主线程区域的副本初始化。


</p><p>
默认情况下，此区域的大小为指向void的指针的大小，
但你可以用不同大小重新编译Lua以用于此区域。
（见<code>luaconf.h</code>中的<code>LUA_EXTRASPACE</code>。）





</p><hr><h3><a name="lua_getglobal"><code>lua_getglobal</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
</p><pre>int lua_getglobal (lua_State *L, const char *name);</pre>

<p>
将全局变量<code>name</code>的值压入栈。
返回该值的类型。





</p><hr><h3><a name="lua_geti"><code>lua_geti</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
</p><pre>int lua_geti (lua_State *L, int index, lua_Integer i);</pre>

<p>
将值<code>t[i]</code>压入栈，
其中<code>t</code>是给定索引处的值。
与Lua中一样，此函数可能触发
"index"事件的元方法（见<a href="#2.4">§2.4</a>）。


</p><p>
返回压入值的类型。





</p><hr><h3><a name="lua_getmetatable"><code>lua_getmetatable</code></a></h3><p>
<span class="apii">[-0, +(0|1), –]</span>
</p><pre>int lua_getmetatable (lua_State *L, int index);</pre>

<p>
如果给定索引处的值有元表，
函数将该元表压入栈并返回1。
否则，
函数返回0且不向栈压入任何内容。





</p><hr><h3><a name="lua_gettable"><code>lua_gettable</code></a></h3><p>
<span class="apii">[-1, +1, <em>e</em>]</span>
</p><pre>int lua_gettable (lua_State *L, int index);</pre>

<p>
将值<code>t[k]</code>压入栈，
其中<code>t</code>是给定索引处的值，
<code>k</code>是栈顶的值。


</p><p>
此函数从栈中弹出键，
将结果值压入其位置。
与Lua中一样，此函数可能触发
"index"事件的元方法（见<a href="#2.4">§2.4</a>）。


</p><p>
返回压入值的类型。





</p><hr><h3><a name="lua_gettop"><code>lua_gettop</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_gettop (lua_State *L);</pre>

<p>
返回栈中顶部元素的索引。
因为索引从1开始，
此结果等于栈中元素的数量；
特别是，0表示空栈。





</p><hr><h3><a name="lua_getiuservalue"><code>lua_getiuservalue</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>int lua_getiuservalue (lua_State *L, int index, int n);</pre>

<p>
将给定索引处完整用户数据关联的
第<code>n</code>个用户值压入栈，并
返回压入值的类型。


</p><p>
如果用户数据没有该值，
压入<b>nil</b>并返回<a href="#pdf-LUA_TNONE"><code>LUA_TNONE</code></a>。





</p><hr><h3><a name="lua_insert"><code>lua_insert</code></a></h3><p>
<span class="apii">[-1, +1, –]</span>
</p><pre>void lua_insert (lua_State *L, int index);</pre>

<p>
将顶部元素移动到给定的有效索引，
向上移动此索引上方的元素以打开空间。
此函数不能用伪索引调用，
因为伪索引不是实际的栈位置。





</p><hr><h3><a name="lua_Integer"><code>lua_Integer</code></a></h3>
<pre>typedef ... lua_Integer;</pre>

<p>
Lua中整数的类型。


</p><p>
默认情况下，此类型是<code>long long</code>
（通常是64位二进制补码整数），
但可以更改为<code>long</code>或<code>int</code>
（通常是32位二进制补码整数）。
（见<code>luaconf.h</code>中的<code>LUA_INT_TYPE</code>。）


</p><p>
Lua还定义了常量
<a name="pdf-LUA_MININTEGER"><code>LUA_MININTEGER</code></a>和<a name="pdf-LUA_MAXINTEGER"><code>LUA_MAXINTEGER</code></a>，
分别表示适合此类型的最小值和最大值。





</p><hr><h3><a name="lua_isboolean"><code>lua_isboolean</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isboolean (lua_State *L, int index);</pre>

<p>
如果给定索引处的值是布尔值，
返回1，否则返回0。





</p><hr><h3><a name="lua_iscfunction"><code>lua_iscfunction</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_iscfunction (lua_State *L, int index);</pre>

<p>
如果给定索引处的值是C函数，
返回1，否则返回0。





</p><hr><h3><a name="lua_isfunction"><code>lua_isfunction</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isfunction (lua_State *L, int index);</pre>

<p>
如果给定索引处的值是函数
（C或Lua），返回1，否则返回0。





</p><hr><h3><a name="lua_isinteger"><code>lua_isinteger</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isinteger (lua_State *L, int index);</pre>

<p>
如果给定索引处的值是整数
（也就是说，值是数字且表示为整数），
返回1，否则返回0。





</p><hr><h3><a name="lua_islightuserdata"><code>lua_islightuserdata</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_islightuserdata (lua_State *L, int index);</pre>

<p>
如果给定索引处的值是轻量用户数据，
返回1，否则返回0。





</p><hr><h3><a name="lua_isnil"><code>lua_isnil</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isnil (lua_State *L, int index);</pre>

<p>
如果给定索引处的值是<b>nil</b>，
返回1，否则返回0。





</p><hr><h3><a name="lua_isnone"><code>lua_isnone</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isnone (lua_State *L, int index);</pre>

<p>
如果给定索引无效，
返回1，否则返回0。





</p><hr><h3><a name="lua_isnoneornil"><code>lua_isnoneornil</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isnoneornil (lua_State *L, int index);</pre>

<p>
如果给定索引无效
或此索引处的值是<b>nil</b>，
返回1，否则返回0。





</p><hr><h3><a name="lua_isnumber"><code>lua_isnumber</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isnumber (lua_State *L, int index);</pre>

<p>
如果给定索引处的值是数字
或可转换为数字的字符串，
返回1，否则返回0。





</p><hr><h3><a name="lua_isstring"><code>lua_isstring</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isstring (lua_State *L, int index);</pre>

<p>
如果给定索引处的值是字符串
或数字（总是可转换为字符串），
返回1，否则返回0。





</p><hr><h3><a name="lua_istable"><code>lua_istable</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_istable (lua_State *L, int index);</pre>

<p>
如果给定索引处的值是表，
返回1，否则返回0。





</p><hr><h3><a name="lua_isthread"><code>lua_isthread</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isthread (lua_State *L, int index);</pre>

<p>
如果给定索引处的值是线程，
返回1，否则返回0。





</p><hr><h3><a name="lua_isuserdata"><code>lua_isuserdata</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isuserdata (lua_State *L, int index);</pre>

<p>
如果给定索引处的值是用户数据
（完整或轻量），返回1，否则返回0。





</p><hr><h3><a name="lua_isyieldable"><code>lua_isyieldable</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isyieldable (lua_State *L);</pre>

<p>
如果给定的协程可以让出，
返回1，否则返回0。





</p><hr><h3><a name="lua_KContext"><code>lua_KContext</code></a></h3>
<pre>typedef ... lua_KContext;</pre>

<p>
延续函数上下文的类型。
它必须是数字类型。
当<code>intptr_t</code>可用时，
此类型定义为<code>intptr_t</code>，
这样它也可以存储指针。
否则，它定义为<code>ptrdiff_t</code>。





</p><hr><h3><a name="lua_KFunction"><code>lua_KFunction</code></a></h3>
<pre>typedef int (*lua_KFunction) (lua_State *L, int status, lua_KContext ctx);</pre>

<p>
延续函数的类型（见<a href="#4.5">§4.5</a>）。





</p><hr><h3><a name="lua_len"><code>lua_len</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
</p><pre>void lua_len (lua_State *L, int index);</pre>

<p>
返回给定索引处值的长度。
它等价于Lua中的'<code>#</code>'运算符（见<a href="#3.4.7">§3.4.7</a>），且
可能触发"length"事件的元方法（见<a href="#2.4">§2.4</a>）。
结果被压入栈。





</p><hr><h3><a name="lua_load"><code>lua_load</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>int lua_load (lua_State *L,
              lua_Reader reader,
              void *data,
              const char *chunkname,
              const char *mode);</pre>

<p>
加载Lua块而不运行它。
如果没有错误，
<code>lua_load</code>将编译的块作为Lua
函数压入栈顶。
否则，它压入错误消息。


</p><p>
<code>lua_load</code>函数使用用户提供的<code>reader</code>函数
来读取块（见<a href="#lua_Reader"><code>lua_Reader</code></a>）。
<code>data</code>参数是传递给reader函数的不透明值。


</p><p>
<code>chunkname</code>参数为块指定一个名称，
用于错误消息和调试信息（见<a href="#4.7">§4.7</a>）。


</p><p>
<code>lua_load</code>自动检测块是文本还是二进制
并相应加载（见程序<code>luac</code>）。
字符串<code>mode</code>的工作方式与函数<a href="#pdf-load"><code>load</code></a>中相同，
另外，<code>NULL</code>值等同于字符串"<code>bt</code>"。


</p><p>
<code>lua_load</code>在内部使用栈，
所以reader函数在返回时必须始终
保持栈不变。


</p><p>
<code>lua_load</code>可以返回
<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>、<a href="#pdf-LUA_ERRSYNTAX"><code>LUA_ERRSYNTAX</code></a>或<a href="#pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>。
该函数还可能返回与
读取函数引发的错误对应的其他值（见<a href="#4.4.1">§4.4.1</a>）。


</p><p>
如果结果函数有上值，
其第一个上值被设置为存储在注册表索引<code>LUA_RIDX_GLOBALS</code>
处的全局环境的值（见<a href="#4.3">§4.3</a>）。
加载主块时，
此上值将是<code>_ENV</code>变量（见<a href="#2.2">§2.2</a>）。
其他上值用<b>nil</b>初始化。





</p><hr><h3><a name="lua_newstate"><code>lua_newstate</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_State *lua_newstate (lua_Alloc f, void *ud);</pre>
<!-- slice ends -->

<!-- slice index: 4 -->
<!-- lines 4481–5979 / total 11964 -->
<!-- title: 4.7 – The Debug Interface -->
<p>
创建一个新的独立状态并返回其主线程。
如果无法创建状态（由于内存不足），则返回 <code>NULL</code>。
参数 <code>f</code> 是分配器函数；
Lua 将通过此函数完成此状态的所有内存分配（参见 <a href="#lua_Alloc"><code>lua_Alloc</code></a>）。
第二个参数 <code>ud</code> 是一个不透明指针，Lua 在每次调用时将其传递给分配器。





</p><hr><h3><a name="lua_newtable"><code>lua_newtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>void lua_newtable (lua_State *L);</pre>

<p>
创建一个新的空表并将其压入栈。
它等价于 <code>lua_createtable(L, 0, 0)</code>。





</p><hr><h3><a name="lua_newthread"><code>lua_newthread</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>lua_State *lua_newthread (lua_State *L);</pre>

<p>
创建一个新线程，将其压入栈，
并返回一个指向表示这个新线程的 <a href="#lua_State"><code>lua_State</code></a> 的指针。
此函数返回的新线程与原始线程共享
全局环境，
但拥有独立的执行栈。


</p><p>
线程会被垃圾回收，
就像任何 Lua 对象一样。





</p><hr><h3><a name="lua_newuserdatauv"><code>lua_newuserdatauv</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>void *lua_newuserdatauv (lua_State *L, size_t size, int nuvalue);</pre>

<p>
此函数创建并压入栈一个新的完整用户数据，
该用户数据有 <code>nuvalue</code> 个关联的 Lua 值，称为 <code>用户值</code>，
加上一块大小为 <code>size</code> 字节的关联原始内存块。
（用户值可以通过函数
<a href="#lua_setiuservalue"><code>lua_setiuservalue</code></a> 和 <a href="#lua_getiuservalue"><code>lua_getiuservalue</code></a> 设置和读取。）


</p><p>
该函数返回内存块的地址。
Lua 确保只要相应的用户数据存活，
此地址就有效（参见 <a href="#2.5">§2.5</a>）。
此外，如果用户数据被标记为需要终结（参见 <a href="#2.5.3">§2.5.3</a>），
其地址至少在调用其终结器之前都是有效的。





</p><hr><h3><a name="lua_next"><code>lua_next</code></a></h3><p>
<span class="apii">[-1, +(2|0), <em>v</em>]</span>
</p><pre>int lua_next (lua_State *L, int index);</pre>

<p>
从栈中弹出一个键，
并从给定索引处的表中压入一个键值对，
即给定键之后的"下一个"对。
如果表中没有更多元素，
则 <a href="#lua_next"><code>lua_next</code></a> 返回 0 且不压入任何值。


</p><p>
典型的表遍历看起来像这样：

</p><pre>     /* 表在栈的索引 't' 处 */
     lua_pushnil(L);  /* 第一个键 */
     while (lua_next(L, t) != 0) {
       /* 使用 'key'（在索引 -2 处）和 'value'（在索引 -1 处）*/
       printf("%s - %s\n",
              lua_typename(L, lua_type(L, -2)),
              lua_typename(L, lua_type(L, -1)));
       /* 移除 'value'；保留 'key' 用于下次迭代 */
       lua_pop(L, 1);
     }
</pre>

<p>
在遍历表时，
避免直接对键调用 <a href="#lua_tolstring"><code>lua_tolstring</code></a>，
除非你知道该键实际上是一个字符串。
请记住 <a href="#lua_tolstring"><code>lua_tolstring</code></a> 可能会改变
给定索引处的值；
这会干扰下一次对 <a href="#lua_next"><code>lua_next</code></a> 的调用。


</p><p>
如果给定的键既不是 <b>nil</b> 也不存在于表中，
此函数可能会引发错误。
有关在遍历期间修改表的注意事项，请参见函数 <a href="#pdf-next"><code>next</code></a>。





</p><hr><h3><a name="lua_Number"><code>lua_Number</code></a></h3>
<pre>typedef ... lua_Number;</pre>

<p>
Lua 中浮点数的类型。


</p><p>
默认情况下此类型是 double，
但可以更改为 float 或 long double。
（参见 <code>luaconf.h</code> 中的 <code>LUA_FLOAT_TYPE</code>。）





</p><hr><h3><a name="lua_numbertointeger"><code>lua_numbertointeger</code></a></h3>
<pre>int lua_numbertointeger (lua_Number n, lua_Integer *p);</pre>

<p>
尝试将 Lua 浮点数转换为 Lua 整数；
浮点数 <code>n</code> 必须具有整数值。
如果该值在 Lua 整数的范围内，
它将被转换为整数并赋值给 <code>*p</code>。
该宏返回一个布尔值，指示
转换是否成功。
（注意，如果没有此宏，正确进行此范围测试可能很棘手，
因为存在舍入问题。）


</p><p>
此宏可能会多次计算其参数。





</p><hr><h3><a name="lua_pcall"><code>lua_pcall</code></a></h3><p>
<span class="apii">[-(nargs + 1), +(nresults|1), –]</span>
</p><pre>int lua_pcall (lua_State *L, int nargs, int nresults, int msgh);</pre>

<p>
在保护模式下调用函数（或可调用对象）。


</p><p>
<code>nargs</code> 和 <code>nresults</code> 的含义与
<a href="#lua_call"><code>lua_call</code></a> 中相同。
如果调用期间没有错误，
<a href="#lua_pcall"><code>lua_pcall</code></a> 的行为与 <a href="#lua_call"><code>lua_call</code></a> 完全相同。
但是，如果有任何错误，
<a href="#lua_pcall"><code>lua_pcall</code></a> 会捕获它，
在栈上压入单个值（错误对象），
并返回错误代码。
与 <a href="#lua_call"><code>lua_call</code></a> 一样，
<a href="#lua_pcall"><code>lua_pcall</code></a> 总是从栈中移除函数
及其参数。


</p><p>
如果 <code>msgh</code> 是 0，
则栈上返回的错误对象
就是原始错误对象。
否则，<code>msgh</code> 是
<em>消息处理器</em>的栈索引。
（此索引不能是伪索引。）
在运行时错误的情况下，
将使用错误对象调用此处理器，
其返回值将是
<a href="#lua_pcall"><code>lua_pcall</code></a> 在栈上返回的对象。


</p><p>
通常，消息处理器用于向错误对象添加更多调试
信息，例如栈回溯。
这些信息无法在 <a href="#lua_pcall"><code>lua_pcall</code></a> 返回后收集，
因为那时栈已经展开。


</p><p>
<a href="#lua_pcall"><code>lua_pcall</code></a> 函数返回以下状态代码之一：
<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>、<a href="#pdf-LUA_ERRRUN"><code>LUA_ERRRUN</code></a>、<a href="#pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a> 或 <a href="#pdf-LUA_ERRERR"><code>LUA_ERRERR</code></a>。





</p><hr><h3><a name="lua_pcallk"><code>lua_pcallk</code></a></h3><p>
<span class="apii">[-(nargs + 1), +(nresults|1), –]</span>
</p><pre>int lua_pcallk (lua_State *L,
                int nargs,
                int nresults,
                int msgh,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>
此函数的行为与 <a href="#lua_pcall"><code>lua_pcall</code></a> 完全相同，
只是它允许被调用的函数让出（参见 <a href="#4.5">§4.5</a>）。





</p><hr><h3><a name="lua_pop"><code>lua_pop</code></a></h3><p>
<span class="apii">[-n, +0, <em>e</em>]</span>
</p><pre>void lua_pop (lua_State *L, int n);</pre>

<p>
从栈中弹出 <code>n</code> 个元素。
它实现为 <a href="#lua_settop"><code>lua_settop</code></a> 上的宏。





</p><hr><h3><a name="lua_pushboolean"><code>lua_pushboolean</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void lua_pushboolean (lua_State *L, int b);</pre>

<p>
将值为 <code>b</code> 的布尔值压入栈。





</p><hr><h3><a name="lua_pushcclosure"><code>lua_pushcclosure</code></a></h3><p>
<span class="apii">[-n, +1, <em>m</em>]</span>
</p><pre>void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);</pre>

<p>
将一个新的 C 闭包压入栈。
此函数接收一个指向 C 函数的指针
并将一个类型为 <code>function</code> 的 Lua 值压入栈，
当调用时，会调用相应的 C 函数。
参数 <code>n</code> 指定此函数将拥有多少个上值
（参见 <a href="#4.2">§4.2</a>）。


</p><p>
任何要被 Lua 调用的函数都必须
遵循正确的协议来接收其参数
并返回其结果（参见 <a href="#lua_CFunction"><code>lua_CFunction</code></a>）。


</p><p>
创建 C 函数时，
可以将一些值与之关联，
即所谓的上值；
这些上值在函数每次被调用时都可访问。
这种关联称为 C 闭包（参见 <a href="#4.2">§4.2</a>）。
要创建 C 闭包，
首先必须将其上值的初始值压入栈。
（当有多个上值时，第一个值先压入。）
然后调用 <a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a>
来创建并将 C 函数压入栈，
参数 <code>n</code> 指定将有多少个值
与该函数关联。
<a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a> 还会从栈中弹出这些值。


</p><p>
<code>n</code> 的最大值是 255。


</p><p>
当 <code>n</code> 为零时，
此函数创建一个<em>轻量 C 函数</em>，
它只是一个指向 C 函数的指针。
在这种情况下，它永远不会引发内存错误。





</p><hr><h3><a name="lua_pushcfunction"><code>lua_pushcfunction</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void lua_pushcfunction (lua_State *L, lua_CFunction f);</pre>

<p>
将一个 C 函数压入栈。
此函数等价于没有上值的 <a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a>。





</p><hr><h3><a name="lua_pushfstring"><code>lua_pushfstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>v</em>]</span>
</p><pre>const char *lua_pushfstring (lua_State *L, const char *fmt, ...);</pre>

<p>
将一个格式化字符串压入栈
并返回指向此字符串的指针（参见 <a href="#4.1.3">§4.1.3</a>）。
它类似于 ISO C 函数 <code>sprintf</code>，
但有两个重要区别。
首先，
你不必为结果分配空间；
结果是一个 Lua 字符串，Lua 负责内存分配
（和释放，通过垃圾回收）。
其次，
转换说明符非常受限。
没有标志、宽度或精度。
转换说明符只能是
'<code>%%</code>'（插入字符 '<code>%</code>'），
'<code>%s</code>'（插入零终止字符串，无大小限制），
'<code>%f</code>'（插入 <a href="#lua_Number"><code>lua_Number</code></a>），
'<code>%I</code>'（插入 <a href="#lua_Integer"><code>lua_Integer</code></a>），
'<code>%p</code>'（插入指针），
'<code>%d</code>'（插入 <code>int</code>），
'<code>%c</code>'（插入 <code>int</code> 作为单字节字符），以及
'<code>%U</code>'（插入 <code>long int</code> 作为 UTF-8 字节序列）。


</p><p>
此函数可能因内存溢出
或无效的转换说明符而引发错误。





</p><hr><h3><a name="lua_pushglobaltable"><code>lua_pushglobaltable</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void lua_pushglobaltable (lua_State *L);</pre>

<p>
将全局环境压入栈。





</p><hr><h3><a name="lua_pushinteger"><code>lua_pushinteger</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void lua_pushinteger (lua_State *L, lua_Integer n);</pre>

<p>
将值为 <code>n</code> 的整数压入栈。





</p><hr><h3><a name="lua_pushlightuserdata"><code>lua_pushlightuserdata</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void lua_pushlightuserdata (lua_State *L, void *p);</pre>

<p>
将一个轻量用户数据压入栈。


</p><p>
用户数据在 Lua 中表示 C 值。
<em>轻量用户数据</em>表示一个指针，即 <code>void*</code>。
它是一个值（像数字）：
你不创建它，它没有单独的元表，
并且它不会被回收（因为它从未被创建）。
轻量用户数据等于具有相同 C 地址的"任何"
轻量用户数据。





</p><hr><h3><a name="lua_pushliteral"><code>lua_pushliteral</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>const char *lua_pushliteral (lua_State *L, const char *s);</pre>

<p>
此宏等价于 <a href="#lua_pushstring"><code>lua_pushstring</code></a>，
但应仅在 <code>s</code> 是字面字符串时使用。
（Lua 可能会优化这种情况。）





</p><hr><h3><a name="lua_pushlstring"><code>lua_pushlstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>const char *lua_pushlstring (lua_State *L, const char *s, size_t len);</pre>

<p>
将 <code>s</code> 指向的大小为 <code>len</code> 的字符串
压入栈。
Lua 将制作或重用给定字符串的内部副本，
因此 <code>s</code> 处的内存可以在
函数返回后立即释放或重用。
字符串可以包含任何二进制数据，
包括嵌入的零。


</p><p>
返回指向字符串内部副本的指针（参见 <a href="#4.1.3">§4.1.3</a>）。





</p><hr><h3><a name="lua_pushnil"><code>lua_pushnil</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void lua_pushnil (lua_State *L);</pre>

<p>
将 nil 值压入栈。





</p><hr><h3><a name="lua_pushnumber"><code>lua_pushnumber</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void lua_pushnumber (lua_State *L, lua_Number n);</pre>

<p>
将值为 <code>n</code> 的浮点数压入栈。





</p><hr><h3><a name="lua_pushstring"><code>lua_pushstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>const char *lua_pushstring (lua_State *L, const char *s);</pre>

<p>
将 <code>s</code> 指向的零终止字符串
压入栈。
Lua 将制作或重用给定字符串的内部副本，
因此 <code>s</code> 处的内存可以在
函数返回后立即释放或重用。


</p><p>
返回指向字符串内部副本的指针（参见 <a href="#4.1.3">§4.1.3</a>）。


</p><p>
如果 <code>s</code> 是 <code>NULL</code>，则压入 <b>nil</b> 并返回 <code>NULL</code>。





</p><hr><h3><a name="lua_pushthread"><code>lua_pushthread</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>int lua_pushthread (lua_State *L);</pre>

<p>
将 <code>L</code> 表示的线程压入栈。
如果此线程是其状态的主线程，则返回 1。





</p><hr><h3><a name="lua_pushvalue"><code>lua_pushvalue</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void lua_pushvalue (lua_State *L, int index);</pre>

<p>
将给定索引处的元素的副本
压入栈。





</p><hr><h3><a name="lua_pushvfstring"><code>lua_pushvfstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>v</em>]</span>
</p><pre>const char *lua_pushvfstring (lua_State *L,
                              const char *fmt,
                              va_list argp);</pre>

<p>
等价于 <a href="#lua_pushfstring"><code>lua_pushfstring</code></a>，只是它接收 <code>va_list</code>
而不是可变数量的参数。





</p><hr><h3><a name="lua_rawequal"><code>lua_rawequal</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_rawequal (lua_State *L, int index1, int index2);</pre>

<p>
如果索引 <code>index1</code> 和
<code>index2</code> 处的两个值在原始意义上相等
（即，不调用 <code>__eq</code> 元方法而相等），
则返回 1。
否则返回 0。
如果任何索引无效，也返回 0。





</p><hr><h3><a name="lua_rawget"><code>lua_rawget</code></a></h3><p>
<span class="apii">[-1, +1, –]</span>
</p><pre>int lua_rawget (lua_State *L, int index);</pre>

<p>
类似于 <a href="#lua_gettable"><code>lua_gettable</code></a>，但进行原始访问
（即，不使用元方法）。
<code>index</code> 处的值必须是一个表。





</p><hr><h3><a name="lua_rawgeti"><code>lua_rawgeti</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>int lua_rawgeti (lua_State *L, int index, lua_Integer n);</pre>

<p>
将值 <code>t[n]</code> 压入栈，
其中 <code>t</code> 是给定索引处的表。
访问是原始的，
即，它不使用 <code>__index</code> 元值。


</p><p>
返回压入值的类型。





</p><hr><h3><a name="lua_rawgetp"><code>lua_rawgetp</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>int lua_rawgetp (lua_State *L, int index, const void *p);</pre>

<p>
将值 <code>t[k]</code> 压入栈，
其中 <code>t</code> 是给定索引处的表，
<code>k</code> 是表示为轻量用户数据的指针 <code>p</code>。
访问是原始的；
即，它不使用 <code>__index</code> 元值。


</p><p>
返回压入值的类型。





</p><hr><h3><a name="lua_rawlen"><code>lua_rawlen</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_Unsigned lua_rawlen (lua_State *L, int index);</pre>

<p>
返回给定索引处值的原始"长度"：
对于字符串，这是字符串长度；
对于表，这是没有元方法的长度操作符（'<code>#</code>'）的结果；
对于用户数据，这是为用户数据分配的内存块的大小。
对于其他值，此调用返回 0。





</p><hr><h3><a name="lua_rawset"><code>lua_rawset</code></a></h3><p>
<span class="apii">[-2, +0, <em>m</em>]</span>
</p><pre>void lua_rawset (lua_State *L, int index);</pre>

<p>
类似于 <a href="#lua_settable"><code>lua_settable</code></a>，但进行原始赋值
（即，不使用元方法）。
<code>index</code> 处的值必须是一个表。





</p><hr><h3><a name="lua_rawseti"><code>lua_rawseti</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>
</p><pre>void lua_rawseti (lua_State *L, int index, lua_Integer i);</pre>

<p>
执行等价于 <code>t[i] = v</code> 的操作，
其中 <code>t</code> 是给定索引处的表，
<code>v</code> 是栈顶的值。


</p><p>
此函数从栈中弹出该值。
赋值是原始的，
即，它不使用 <code>__newindex</code> 元值。





</p><hr><h3><a name="lua_rawsetp"><code>lua_rawsetp</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>
</p><pre>void lua_rawsetp (lua_State *L, int index, const void *p);</pre>

<p>
执行等价于 <code>t[p] = v</code> 的操作，
其中 <code>t</code> 是给定索引处的表，
<code>p</code> 被编码为轻量用户数据，
<code>v</code> 是栈顶的值。


</p><p>
此函数从栈中弹出该值。
赋值是原始的，
即，它不使用 <code>__newindex</code> 元值。





</p><hr><h3><a name="lua_Reader"><code>lua_Reader</code></a></h3>
<pre>typedef const char * (*lua_Reader) (lua_State *L,
                                    void *data,
                                    size_t *size);</pre>

<p>
<a href="#lua_load"><code>lua_load</code></a> 使用的读取器函数。
每次 <a href="#lua_load"><code>lua_load</code></a> 需要代码块的另一部分时，
它调用读取器，
传递其 <code>data</code> 参数。
读取器必须返回指向包含代码块新部分的内存块的指针，
并将 <code>size</code> 设置为块大小。
该块必须存在直到再次调用读取器函数。
要发出代码块结束的信号，
读取器必须返回 <code>NULL</code> 或将 <code>size</code> 设置为零。
读取器函数可以返回任何大于零的大小的片段。





</p><hr><h3><a name="lua_register"><code>lua_register</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
</p><pre>void lua_register (lua_State *L, const char *name, lua_CFunction f);</pre>

<p>
将 C 函数 <code>f</code> 设置为全局变量 <code>name</code> 的新值。
它被定义为宏：

</p><pre>     #define lua_register(L,n,f) \
            (lua_pushcfunction(L, f), lua_setglobal(L, n))
</pre>




<hr><h3><a name="lua_remove"><code>lua_remove</code></a></h3><p>
<span class="apii">[-1, +0, –]</span>
</p><pre>void lua_remove (lua_State *L, int index);</pre>

<p>
移除给定有效索引处的元素，
向下移动此索引之上的元素以填补空缺。
此函数不能用伪索引调用，
因为伪索引不是实际的栈位置。





</p><hr><h3><a name="lua_replace"><code>lua_replace</code></a></h3><p>
<span class="apii">[-1, +0, –]</span>
</p><pre>void lua_replace (lua_State *L, int index);</pre>

<p>
将栈顶元素移动到给定的有效索引
而不移动任何元素
（因此替换该给定索引处的值），
然后弹出栈顶元素。





</p><hr><h3><a name="lua_resetthread"><code>lua_resetthread</code></a></h3><p>
<span class="apii">[-0, +?, –]</span>
</p><pre>int lua_resetthread (lua_State *L);</pre>

<p>
此函数已弃用；
它等价于 <code>from</code> 为 <code>NULL</code> 的 <a href="#lua_closethread"><code>lua_closethread</code></a>。





</p><hr><h3><a name="lua_resume"><code>lua_resume</code></a></h3><p>
<span class="apii">[-?, +?, –]</span>
</p><pre>int lua_resume (lua_State *L, lua_State *from, int nargs,
                          int *nresults);</pre>

<p>
在给定线程 <code>L</code> 中启动和恢复协程。


</p><p>
要启动协程，
你将主函数加上任何参数
压入线程的空栈。
然后你调用 <a href="#lua_resume"><code>lua_resume</code></a>，
<code>nargs</code> 是参数的数量。
当协程挂起或完成执行时，此调用返回。
当它返回时，
<code>*nresults</code> 被更新，栈顶包含
传递给 <a href="#lua_yield"><code>lua_yield</code></a> 的 <code>*nresults</code> 个值
或由函数体返回的值。
如果协程让出，<a href="#lua_resume"><code>lua_resume</code></a> 返回
<a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>，
如果协程无错误地完成执行，返回
<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>，
或在出现错误时返回错误代码（参见 <a href="#4.4.1">§4.4.1</a>）。
在出现错误时，
错误对象在栈顶。


</p><p>
要恢复协程，
你从其栈中移除 <code>*nresults</code> 个让出的值，
压入要作为 <code>yield</code> 结果传递的值，
然后调用 <a href="#lua_resume"><code>lua_resume</code></a>。


</p><p>
参数 <code>from</code> 表示正在恢复 <code>L</code> 的协程。
如果没有这样的协程，
此参数可以是 <code>NULL</code>。





</p><hr><h3><a name="lua_rotate"><code>lua_rotate</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void lua_rotate (lua_State *L, int idx, int n);</pre>

<p>
旋转有效索引 <code>idx</code>
和栈顶之间的栈元素。
对于正数 <code>n</code>，
元素向栈顶方向旋转 <code>n</code> 个位置，
对于负数 <code>n</code>，
向栈底方向旋转 <code>-n</code> 个位置。
<code>n</code> 的绝对值不得大于正在旋转的切片的大小。
此函数不能用伪索引调用，
因为伪索引不是实际的栈位置。





</p><hr><h3><a name="lua_setallocf"><code>lua_setallocf</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);</pre>

<p>
将给定状态的分配器函数更改为 <code>f</code>，
用户数据为 <code>ud</code>。





</p><hr><h3><a name="lua_setfield"><code>lua_setfield</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
</p><pre>void lua_setfield (lua_State *L, int index, const char *k);</pre>

<p>
执行等价于 <code>t[k] = v</code> 的操作，
其中 <code>t</code> 是给定索引处的值，
<code>v</code> 是栈顶的值。


</p><p>
此函数从栈中弹出该值。
与 Lua 中一样，此函数可能触发
"newindex" 事件的元方法（参见 <a href="#2.4">§2.4</a>）。





</p><hr><h3><a name="lua_setglobal"><code>lua_setglobal</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
</p><pre>void lua_setglobal (lua_State *L, const char *name);</pre>

<p>
从栈中弹出一个值并
将其设置为全局变量 <code>name</code> 的新值。





</p><hr><h3><a name="lua_seti"><code>lua_seti</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
</p><pre>void lua_seti (lua_State *L, int index, lua_Integer n);</pre>

<p>
执行等价于 <code>t[n] = v</code> 的操作，
其中 <code>t</code> 是给定索引处的值，
<code>v</code> 是栈顶的值。


</p><p>
此函数从栈中弹出该值。
与 Lua 中一样，此函数可能触发
"newindex" 事件的元方法（参见 <a href="#2.4">§2.4</a>）。





</p><hr><h3><a name="lua_setiuservalue"><code>lua_setiuservalue</code></a></h3><p>
<span class="apii">[-1, +0, –]</span>
</p><pre>int lua_setiuservalue (lua_State *L, int index, int n);</pre>

<p>
从栈中弹出一个值并将其设置为
与给定索引处的完整用户数据关联的
第 <code>n</code> 个用户值。
如果用户数据没有该值，则返回 0。





</p><hr><h3><a name="lua_setmetatable"><code>lua_setmetatable</code></a></h3><p>
<span class="apii">[-1, +0, –]</span>
</p><pre>int lua_setmetatable (lua_State *L, int index);</pre>

<p>
从栈中弹出一个表或 <b>nil</b> 并
将该值设置为给定索引处值的新元表。
（<b>nil</b> 表示没有元表。）


</p><p>
（出于历史原因，此函数返回 <code>int</code>，
现在总是 1。）





</p><hr><h3><a name="lua_settable"><code>lua_settable</code></a></h3><p>
<span class="apii">[-2, +0, <em>e</em>]</span>
</p><pre>void lua_settable (lua_State *L, int index);</pre>

<p>
执行等价于 <code>t[k] = v</code> 的操作，
其中 <code>t</code> 是给定索引处的值，
<code>v</code> 是栈顶的值，
<code>k</code> 是栈顶下方的值。


</p><p>
此函数从栈中弹出键和值。
与 Lua 中一样，此函数可能触发
"newindex" 事件的元方法（参见 <a href="#2.4">§2.4</a>）。





</p><hr><h3><a name="lua_settop"><code>lua_settop</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
</p><pre>void lua_settop (lua_State *L, int index);</pre>

<p>
接受任何索引或 0，
并将栈顶设置为此索引。
如果新栈顶大于旧栈顶，
则新元素用 <b>nil</b> 填充。
如果 <code>index</code> 是 0，则移除所有栈元素。


</p><p>
此函数在从栈中移除标记为待关闭的索引时
可以运行任意代码。





</p><hr><h3><a name="lua_setwarnf"><code>lua_setwarnf</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void lua_setwarnf (lua_State *L, lua_WarnFunction f, void *ud);</pre>

<p>
设置 Lua 用于发出警告的警告函数
（参见 <a href="#lua_WarnFunction"><code>lua_WarnFunction</code></a>）。
<code>ud</code> 参数设置传递给
警告函数的值 <code>ud</code>。





</p><hr><h3><a name="lua_State"><code>lua_State</code></a></h3>
<pre>typedef struct lua_State lua_State;</pre>

<p>
一个不透明结构，指向一个线程并间接地
（通过线程）指向 Lua 解释器的整个状态。
Lua 库是完全可重入的：
它没有全局变量。
关于状态的所有信息都可以通过此结构访问。


</p><p>
指向此结构的指针必须作为第一个参数传递给
库中的每个函数，除了 <a href="#lua_newstate"><code>lua_newstate</code></a>，
它从头开始创建 Lua 状态。





</p><hr><h3><a name="lua_status"><code>lua_status</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_status (lua_State *L);</pre>

<p>
返回线程 <code>L</code> 的状态。


</p><p>
状态可以是正常线程的 <a href="#pdf-LUA_OK"><code>LUA_OK</code></a>，
如果线程以错误完成 <a href="#lua_resume"><code>lua_resume</code></a> 的执行则为错误代码，
或如果线程被挂起则为 <a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>。


</p><p>
你只能在状态为 <a href="#pdf-LUA_OK"><code>LUA_OK</code></a> 的线程中调用函数。
你可以恢复状态为 <a href="#pdf-LUA_OK"><code>LUA_OK</code></a>
（启动新协程）或 <a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>
（恢复协程）的线程。





</p><hr><h3><a name="lua_stringtonumber"><code>lua_stringtonumber</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>size_t lua_stringtonumber (lua_State *L, const char *s);</pre>

<p>
将零终止字符串 <code>s</code> 转换为数字，
将该数字压入栈，
并返回字符串的总大小，
即其长度加一。
转换可以得到整数或浮点数，
根据 Lua 的词法约定（参见 <a href="#3.1">§3.1</a>）。
字符串可以有前导和尾随空格以及符号。
如果字符串不是有效的数字，
返回 0 且不压入任何值。
（注意，结果可以用作布尔值，
如果转换成功则为真。）





</p><hr><h3><a name="lua_toboolean"><code>lua_toboolean</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_toboolean (lua_State *L, int index);</pre>

<p>
将给定索引处的 Lua 值转换为 C 布尔
值（0 或 1）。
与 Lua 中的所有测试一样，
<a href="#lua_toboolean"><code>lua_toboolean</code></a> 对于任何不同于 <b>false</b> 和 <b>nil</b> 的 Lua 值
都返回真；
否则返回假。
（如果你想只接受实际的布尔值，
使用 <a href="#lua_isboolean"><code>lua_isboolean</code></a> 来测试值的类型。）





</p><hr><h3><a name="lua_tocfunction"><code>lua_tocfunction</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_CFunction lua_tocfunction (lua_State *L, int index);</pre>

<p>
将给定索引处的值转换为 C 函数。
该值必须是 C 函数；
否则，返回 <code>NULL</code>。





</p><hr><h3><a name="lua_toclose"><code>lua_toclose</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>void lua_toclose (lua_State *L, int index);</pre>

<p>
将栈中给定索引标记为
待关闭槽（参见 <a href="#3.3.8">§3.3.8</a>）。
与 Lua 中的待关闭变量一样，
栈中该槽处的值将在它离开作用域时关闭。
这里，在 C 函数的上下文中，
离开作用域意味着正在运行的函数返回到 Lua，
或出现错误，
或通过 <a href="#lua_settop"><code>lua_settop</code></a> 或 <a href="#lua_pop"><code>lua_pop</code></a> 从栈中移除该槽，
或调用 <a href="#lua_closeslot"><code>lua_closeslot</code></a>。
标记为待关闭的槽不应通过 API 中的任何其他函数从栈中移除，
除了 <a href="#lua_settop"><code>lua_settop</code></a> 或 <a href="#lua_pop"><code>lua_pop</code></a>，
除非之前由 <a href="#lua_closeslot"><code>lua_closeslot</code></a> 停用。


</p><p>
如果给定槽处的值
既没有 <code>__close</code> 元方法也不是假值，
此函数会引发错误。


</p><p>
此函数不应对等于或低于活动待关闭槽的索引调用。


</p><p>
注意，无论是在出现错误还是正常返回的情况下，
当 <code>__close</code> 元方法运行时，
C 栈已经展开，
因此调用函数中声明的任何自动 C 变量
（例如，缓冲区）都将超出作用域。





</p><hr><h3><a name="lua_tointeger"><code>lua_tointeger</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_Integer lua_tointeger (lua_State *L, int index);</pre>

<p>
等价于 <code>isnum</code> 等于 <code>NULL</code> 的 <a href="#lua_tointegerx"><code>lua_tointegerx</code></a>。





</p><hr><h3><a name="lua_tointegerx"><code>lua_tointegerx</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_Integer lua_tointegerx (lua_State *L, int index, int *isnum);</pre>

<p>
将给定索引处的 Lua 值
转换为有符号整数类型 <a href="#lua_Integer"><code>lua_Integer</code></a>。
Lua 值必须是整数，
或可转换为整数的数字或字符串（参见 <a href="#3.4.3">§3.4.3</a>）；
否则，<code>lua_tointegerx</code> 返回 0。


</p><p>
如果 <code>isnum</code> 不是 <code>NULL</code>，
其引用被赋予一个布尔值，
指示操作是否成功。





</p><hr><h3><a name="lua_tolstring"><code>lua_tolstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
</p><pre>const char *lua_tolstring (lua_State *L, int index, size_t *len);</pre>

<p>
将给定索引处的 Lua 值转换为 C 字符串。
如果 <code>len</code> 不是 <code>NULL</code>，
它用字符串长度设置 <code>*len</code>。
Lua 值必须是字符串或数字；
否则，函数返回 <code>NULL</code>。
如果值是数字，
则 <code>lua_tolstring</code> 还会
<em>将栈中的实际值更改为字符串</em>。
（当在表遍历期间对键应用 <code>lua_tolstring</code> 时，
此更改会干扰 <a href="#lua_next"><code>lua_next</code></a>。）


</p><p>
<code>lua_tolstring</code> 返回指向
Lua 状态内字符串的指针（参见 <a href="#4.1.3">§4.1.3</a>）。
此字符串在其最后一个字符后总是有一个零（'<code>\0</code>'）
（如 C 中一样），
但其主体中可以包含其他零。


</p><p>
此函数只有在将数字转换为字符串时
才能引发内存错误
（因为那时它可能创建新字符串）。





</p><hr><h3><a name="lua_tonumber"><code>lua_tonumber</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_Number lua_tonumber (lua_State *L, int index);</pre>

<p>
等价于 <code>isnum</code> 等于 <code>NULL</code> 的 <a href="#lua_tonumberx"><code>lua_tonumberx</code></a>。





</p><hr><h3><a name="lua_tonumberx"><code>lua_tonumberx</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_Number lua_tonumberx (lua_State *L, int index, int *isnum);</pre>

<p>
将给定索引处的 Lua 值
转换为 C 类型 <a href="#lua_Number"><code>lua_Number</code></a>（参见 <a href="#lua_Number"><code>lua_Number</code></a>）。
Lua 值必须是数字或可转换为数字的字符串
（参见 <a href="#3.4.3">§3.4.3</a>）；
否则，<a href="#lua_tonumberx"><code>lua_tonumberx</code></a> 返回 0。


</p><p>
如果 <code>isnum</code> 不是 <code>NULL</code>，
其引用被赋予一个布尔值，
指示操作是否成功。





</p><hr><h3><a name="lua_topointer"><code>lua_topointer</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>const void *lua_topointer (lua_State *L, int index);</pre>

<p>
将给定索引处的值转换为通用
C 指针（<code>void*</code>）。
值可以是用户数据、表、线程、字符串或函数；
否则，<code>lua_topointer</code> 返回 <code>NULL</code>。
不同的对象会给出不同的指针。
没有办法将指针转换回其原始值。


</p><p>
通常此函数仅用于哈希和调试信息。





</p><hr><h3><a name="lua_tostring"><code>lua_tostring</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
</p><pre>const char *lua_tostring (lua_State *L, int index);</pre>

<p>
等价于 <code>len</code> 等于 <code>NULL</code> 的 <a href="#lua_tolstring"><code>lua_tolstring</code></a>。





</p><hr><h3><a name="lua_tothread"><code>lua_tothread</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_State *lua_tothread (lua_State *L, int index);</pre>

<p>
将给定索引处的值转换为 Lua 线程
（表示为 <code>lua_State*</code>）。
此值必须是线程；
否则，函数返回 <code>NULL</code>。





</p><hr><h3><a name="lua_touserdata"><code>lua_touserdata</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void *lua_touserdata (lua_State *L, int index);</pre>

<p>
如果给定索引处的值是完整用户数据，
返回其内存块地址。
如果值是轻量用户数据，
返回其值（一个指针）。
否则，返回 <code>NULL</code>。





</p><hr><h3><a name="lua_type"><code>lua_type</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_type (lua_State *L, int index);</pre>

<p>
返回给定有效索引处值的类型，
或对于无效但可接受的索引返回 <code>LUA_TNONE</code>。
<a href="#lua_type"><code>lua_type</code></a> 返回的类型由以下在 <code>lua.h</code> 中定义的常量编码：
<a name="pdf-LUA_TNIL"><code>LUA_TNIL</code></a>、
<a name="pdf-LUA_TNUMBER"><code>LUA_TNUMBER</code></a>、
<a name="pdf-LUA_TBOOLEAN"><code>LUA_TBOOLEAN</code></a>、
<a name="pdf-LUA_TSTRING"><code>LUA_TSTRING</code></a>、
<a name="pdf-LUA_TTABLE"><code>LUA_TTABLE</code></a>、
<a name="pdf-LUA_TFUNCTION"><code>LUA_TFUNCTION</code></a>、
<a name="pdf-LUA_TUSERDATA"><code>LUA_TUSERDATA</code></a>、
<a name="pdf-LUA_TTHREAD"><code>LUA_TTHREAD</code></a>，
以及
<a name="pdf-LUA_TLIGHTUSERDATA"><code>LUA_TLIGHTUSERDATA</code></a>。





</p><hr><h3><a name="lua_typename"><code>lua_typename</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>const char *lua_typename (lua_State *L, int tp);</pre>

<p>
返回由值 <code>tp</code> 编码的类型的名称，
该值必须是 <a href="#lua_type"><code>lua_type</code></a> 返回的值之一。





</p><hr><h3><a name="lua_Unsigned"><code>lua_Unsigned</code></a></h3>
<pre>typedef ... lua_Unsigned;</pre>

<p>
<a href="#lua_Integer"><code>lua_Integer</code></a> 的无符号版本。





</p><hr><h3><a name="lua_upvalueindex"><code>lua_upvalueindex</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_upvalueindex (int i);</pre>

<p>
返回表示正在运行的函数的第 <code>i</code> 个上值的伪索引
（参见 <a href="#4.2">§4.2</a>）。
<code>i</code> 必须在范围 <em>[1,256]</em> 内。





</p><hr><h3><a name="lua_version"><code>lua_version</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_Number lua_version (lua_State *L);</pre>

<p>
返回此核心的版本号。





</p><hr><h3><a name="lua_WarnFunction"><code>lua_WarnFunction</code></a></h3>
<pre>typedef void (*lua_WarnFunction) (void *ud, const char *msg, int tocont);</pre>

<p>
警告函数的类型，由 Lua 调用以发出警告。
第一个参数是由 <a href="#lua_setwarnf"><code>lua_setwarnf</code></a> 设置的不透明指针。
第二个参数是警告消息。
第三个参数是一个布尔值，
指示消息是否
将在下一次调用中继续。


</p><p>
有关警告的更多详细信息，请参见 <a href="#pdf-warn"><code>warn</code></a>。





</p><hr><h3><a name="lua_warning"><code>lua_warning</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void lua_warning (lua_State *L, const char *msg, int tocont);</pre>

<p>
发出带有给定消息的警告。
<code>tocont</code> 为真的调用中的消息应该
在对此函数的另一次调用中继续。


</p><p>
有关警告的更多详细信息，请参见 <a href="#pdf-warn"><code>warn</code></a>。





</p><hr><h3><a name="lua_Writer"><code>lua_Writer</code></a></h3>
<pre>typedef int (*lua_Writer) (lua_State *L,
                           const void* p,
                           size_t sz,
                           void* ud);</pre>

<p>
<a href="#lua_dump"><code>lua_dump</code></a> 使用的写入器函数的类型。
每次 <a href="#lua_dump"><code>lua_dump</code></a> 生成代码块的另一部分时，
它调用写入器，
传递要写入的缓冲区（<code>p</code>）、
其大小（<code>sz</code>）、
以及提供给 <a href="#lua_dump"><code>lua_dump</code></a> 的 <code>ud</code> 参数。


</p><p>
写入器返回错误代码：
0 表示没有错误；
任何其他值表示错误并停止 <a href="#lua_dump"><code>lua_dump</code></a> 再次调用写入器。





</p><hr><h3><a name="lua_xmove"><code>lua_xmove</code></a></h3><p>
<span class="apii">[-?, +?, –]</span>
</p><pre>void lua_xmove (lua_State *from, lua_State *to, int n);</pre>

<p>
在同一状态的不同线程之间交换值。


</p><p>
此函数从栈 <code>from</code> 中弹出 <code>n</code> 个值，
并将它们压入栈 <code>to</code>。





</p><hr><h3><a name="lua_yield"><code>lua_yield</code></a></h3><p>
<span class="apii">[-?, +?, <em>v</em>]</span>
</p><pre>int lua_yield (lua_State *L, int nresults);</pre>

<p>
此函数等价于 <a href="#lua_yieldk"><code>lua_yieldk</code></a>，
但它没有延续（参见 <a href="#4.5">§4.5</a>）。
因此，当线程恢复时，
它继续执行调用 <code>lua_yield</code> 的函数所在的函数。
为了避免意外，
此函数应该仅在尾调用中调用。





</p><hr><h3><a name="lua_yieldk"><code>lua_yieldk</code></a></h3><p>
<span class="apii">[-?, +?, <em>v</em>]</span>
</p><pre>int lua_yieldk (lua_State *L,
                int nresults,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>
让出协程（线程）。


</p><p>
当 C 函数调用 <a href="#lua_yieldk"><code>lua_yieldk</code></a> 时，
正在运行的协程挂起其执行，
启动此协程的 <a href="#lua_resume"><code>lua_resume</code></a> 调用返回。
参数 <code>nresults</code> 是栈中将作为结果
传递给 <a href="#lua_resume"><code>lua_resume</code></a> 的值的数量。


</p><p>
当协程再次恢复时，
Lua 调用给定的延续函数 <code>k</code> 以继续
执行让出的 C 函数（参见 <a href="#4.5">§4.5</a>）。
此延续函数接收来自前一个函数的相同栈，
其中 <code>n</code> 个结果被移除并
被传递给 <a href="#lua_resume"><code>lua_resume</code></a> 的参数替换。
此外，
延续函数接收传递给 <a href="#lua_yieldk"><code>lua_yieldk</code></a> 的值 <code>ctx</code>。


</p><p>
通常，此函数不返回；
当协程最终恢复时，
它继续执行延续函数。
但是，有一种特殊情况，
即当此函数从行或计数钩子内部调用时（参见 <a href="#4.7">§4.7</a>）。
在这种情况下，应该不带延续
（可能以 <a href="#lua_yield"><code>lua_yield</code></a> 的形式）且不带结果调用 <code>lua_yieldk</code>，
钩子应该在调用后立即返回。
Lua 将让出，
当协程再次恢复时，
它将继续正常执行
触发钩子的（Lua）函数。


</p><p>
如果从没有延续函数的待处理 C 调用的线程调用此函数
（这被称为 <em>C 调用边界</em>），
或从未在恢复内部运行的线程调用此函数
（通常是主线程），
此函数可能引发错误。







</p><h2>4.7 – <a name="4.7">调试接口</a></h2>

<p>
Lua 没有内置的调试功能。
相反，它通过函数和<em>钩子</em>提供了一个特殊接口。
此接口允许构建不同类型的调试器、性能分析器和其他
需要来自解释器的"内部信息"的工具。



</p><hr><h3><a name="lua_Debug"><code>lua_Debug</code></a></h3>
<pre>typedef struct lua_Debug {
  int event;
  const char *name;           /* (n) */
  const char *namewhat;       /* (n) */
  const char *what;           /* (S) */
  const char *source;         /* (S) */
  size_t srclen;              /* (S) */
  int currentline;            /* (l) */
  int linedefined;            /* (S) */
  int lastlinedefined;        /* (S) */
  unsigned char nups;         /* (u) 上值数量 */
  unsigned char nparams;      /* (u) 参数数量 */
  char isvararg;              /* (u) */
  char istailcall;            /* (t) */
  unsigned short ftransfer;   /* (r) 第一个传输值的索引 */
  unsigned short ntransfer;   /* (r) 传输值的数量 */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* 私有部分 */
  <em>其他字段</em>
} lua_Debug;</pre>

<p>
一个用于携带关于函数或活动记录的
不同信息片段的结构。
<a href="#lua_getstack"><code>lua_getstack</code></a> 仅填充此结构的私有部分，
供以后使用。
要用有用的信息填充 <a href="#lua_Debug"><code>lua_Debug</code></a> 的其他字段，
你必须使用适当的参数调用 <a href="#lua_getinfo"><code>lua_getinfo</code></a>。
（具体来说，要获取一个字段，
你必须将字段注释中括号内的字母
添加到 <a href="#lua_getinfo"><code>lua_getinfo</code></a> 的参数 <code>what</code> 中。）


</p><p>
<a href="#lua_Debug"><code>lua_Debug</code></a> 的字段具有以下含义：

</p><ul>
<!-- slice ends -->

<!-- slice index: 5 -->
<!-- lines 5979–7479 / total 11964 -->
<!-- title: 5 – The Auxiliary Library -->
<li><b><code>source</code>: </b>
创建该函数的代码块的来源。
如果 <code>source</code> 以 '<code>@</code>' 开头，
表示该函数定义在一个文件中，其中
文件名跟在 '<code>@</code>' 之后。
如果 <code>source</code> 以 '<code>=</code>' 开头，
其余内容以用户相关的方式描述来源。
否则，
该函数定义在一个字符串中，其中
<code>source</code> 就是那个字符串。
</li>

<li><b><code>srclen</code>: </b>
字符串 <code>source</code> 的长度。
</li>

<li><b><code>short_src</code>: </b>
<code>source</code> 的"可打印"版本，用于错误消息。
</li>

<li><b><code>linedefined</code>: </b>
函数定义开始的行号。
</li>

<li><b><code>lastlinedefined</code>: </b>
函数定义结束的行号。
</li>

<li><b><code>what</code>: </b>
如果函数是 Lua 函数，则为字符串 <code>"Lua"</code>，
如果是 C&nbsp;函数，则为 <code>"C"</code>，
如果是代码块的主体部分，则为 <code>"main"</code>。
</li>

<li><b><code>currentline</code>: </b>
给定函数正在执行的当前行。
当没有行信息可用时，
<code>currentline</code> 被设置为 -1。
</li>

<li><b><code>name</code>: </b>
给定函数的合理名称。
因为 Lua 中的函数是一等值，
它们没有固定的名称：
一些函数可以是多个全局变量的值，
而其他函数只能存储在表字段中。
<code>lua_getinfo</code> 函数检查函数如何被调用
以找到合适的名称。
如果找不到名称，
则 <code>name</code> 被设置为 <code>NULL</code>。
</li>

<li><b><code>namewhat</code>: </b>
解释 <code>name</code> 字段。
<code>namewhat</code> 的值可以是
<code>"global"</code>、<code>"local"</code>、<code>"method"</code>、
<code>"field"</code>、<code>"upvalue"</code> 或 <code>""</code>（空字符串），
取决于函数如何被调用。
（当没有其他选项适用时，Lua 使用空字符串。）
</li>

<li><b><code>istailcall</code>: </b>
如果此函数调用是由尾调用发起的，则为真。
在这种情况下，此层级的调用者不在栈中。
</li>

<li><b><code>nups</code>: </b>
函数的上值数量。
</li>

<li><b><code>nparams</code>: </b>
函数的参数数量
（对于 C&nbsp;函数总是 0）。
</li>

<li><b><code>isvararg</code>: </b>
如果函数是可变参数函数，则为真
（对于 C&nbsp;函数总是真）。
</li>

<li><b><code>ftransfer</code>: </b>
栈中第一个被"传递"的值的索引，
即调用中的参数或返回中的返回值。
（其他值在连续的索引中。）
使用此索引，您可以通过 <a href="#lua_getlocal"><code>lua_getlocal</code></a> 和 <a href="#lua_setlocal"><code>lua_setlocal</code></a> 访问和修改这些值。
此字段仅在
调用钩子期间有意义，表示第一个参数，
或在返回钩子期间有意义，表示第一个被返回的值。
（对于调用钩子，此值总是 1。）
</li>

<li><b><code>ntransfer</code>: </b>
被传递的值的数量（见前一项）。
（对于 Lua 函数的调用，
此值总是等于 <code>nparams</code>。）
</li>

</ul>




<hr><h3><a name="lua_gethook"><code>lua_gethook</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_Hook lua_gethook (lua_State *L);</pre>

<p>
返回当前的钩子函数。





</p><hr><h3><a name="lua_gethookcount"><code>lua_gethookcount</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_gethookcount (lua_State *L);</pre>

<p>
返回当前的钩子计数。





</p><hr><h3><a name="lua_gethookmask"><code>lua_gethookmask</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_gethookmask (lua_State *L);</pre>

<p>
返回当前的钩子掩码。





</p><hr><h3><a name="lua_getinfo"><code>lua_getinfo</code></a></h3><p>
<span class="apii">[-(0|1), +(0|1|2), <em>m</em>]</span>
</p><pre>int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);</pre>

<p>
获取关于特定函数或函数调用的信息。


</p><p>
要获取关于函数调用的信息，
参数 <code>ar</code> 必须是一个有效的激活记录，该记录
由之前对 <a href="#lua_getstack"><code>lua_getstack</code></a> 的调用填充，或
作为参数传递给钩子（见 <a href="#lua_Hook"><code>lua_Hook</code></a>）。


</p><p>
要获取关于函数的信息，您将其压入栈
并以字符 '<code>&gt;</code>' 开始 <code>what</code> 字符串。
（在这种情况下，
<code>lua_getinfo</code> 从栈顶弹出函数。）
例如，要知道函数 <code>f</code> 定义在哪一行，
您可以编写以下代码：

</p><pre>     lua_Debug ar;
     lua_getglobal(L, "f");  /* 获取全局变量 'f' */
     lua_getinfo(L, "&gt;S", &amp;ar);
     printf("%d\n", ar.linedefined);
</pre>

<p>
字符串 <code>what</code> 中的每个字符
选择结构 <code>ar</code> 的某些字段以填充，或
选择要压入栈的值。
（这些字符也在
结构 <a href="#lua_Debug"><code>lua_Debug</code></a> 的声明中文档化，
在每个字段后面的注释中的括号之间。）

</p><ul>

<li><b>'<code>f</code>': </b>
压入正在给定级别运行的函数到栈上；
</li>

<li><b>'<code>l</code>': </b> 填充字段 <code>currentline</code>；
</li>

<li><b>'<code>n</code>': </b> 填充字段 <code>name</code> 和 <code>namewhat</code>；
</li>

<li><b>'<code>r</code>': </b> 填充字段 <code>ftransfer</code> 和 <code>ntransfer</code>；
</li>

<li><b>'<code>S</code>': </b>
填充字段 <code>source</code>、<code>short_src</code>、
<code>linedefined</code>、<code>lastlinedefined</code> 和 <code>what</code>；
</li>

<li><b>'<code>t</code>': </b> 填充字段 <code>istailcall</code>；
</li>

<li><b>'<code>u</code>': </b> 填充字段
<code>nups</code>、<code>nparams</code> 和 <code>isvararg</code>；
</li>

<li><b>'<code>L</code>': </b>
压入一个表到栈上，其索引是
函数中包含某些相关代码的行，
即可以放置断点的行。
（没有代码的行包括空行和注释。）
如果此选项与选项 '<code>f</code>' 一起给出，
其表在函数之后压入。
这是唯一可能引发内存错误的选项。
</li>

</ul>

<p>
此函数返回 0 以表示 <code>what</code> 中的无效选项；
即使如此，有效选项也会被正确处理。





</p><hr><h3><a name="lua_getlocal"><code>lua_getlocal</code></a></h3><p>
<span class="apii">[-0, +(0|1), –]</span>
</p><pre>const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n);</pre>

<p>
获取关于给定激活记录或给定函数的
局部变量或临时值的信息。


</p><p>
在第一种情况下，
参数 <code>ar</code> 必须是一个有效的激活记录，该记录
由之前对 <a href="#lua_getstack"><code>lua_getstack</code></a> 的调用填充，或
作为参数传递给钩子（见 <a href="#lua_Hook"><code>lua_Hook</code></a>）。
索引 <code>n</code> 选择要检查的局部变量；
关于变量索引和名称的详细信息，见 <a href="#pdf-debug.getlocal"><code>debug.getlocal</code></a>。


</p><p>
<a href="#lua_getlocal"><code>lua_getlocal</code></a> 将变量的值压入栈
并返回其名称。


</p><p>
在第二种情况下，<code>ar</code> 必须是 <code>NULL</code>，要
检查的函数必须在栈顶。
在这种情况下，只有 Lua 函数的参数是可见的
（因为没有关于哪些变量是活动的信息），
并且没有值被压入栈。


</p><p>
当索引大于
活动局部变量的数量时，返回 <code>NULL</code>（并且不压入任何内容）。





</p><hr><h3><a name="lua_getstack"><code>lua_getstack</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_getstack (lua_State *L, int level, lua_Debug *ar);</pre>

<p>
获取关于解释器运行时栈的信息。


</p><p>
此函数填充 <a href="#lua_Debug"><code>lua_Debug</code></a> 结构的部分内容，
以识别在给定级别执行的函数的<em>激活记录</em>。
级别&nbsp;0 是当前正在运行的函数，
而级别 <em>n+1</em> 是调用了级别 <em>n</em> 的函数
（尾调用除外，它们不计入栈中）。
当使用大于栈深度的级别调用时，
<a href="#lua_getstack"><code>lua_getstack</code></a> 返回 0；
否则返回 1。





</p><hr><h3><a name="lua_getupvalue"><code>lua_getupvalue</code></a></h3><p>
<span class="apii">[-0, +(0|1), –]</span>
</p><pre>const char *lua_getupvalue (lua_State *L, int funcindex, int n);</pre>

<p>
获取关于索引 <code>funcindex</code> 处闭包的
第 <code>n</code> 个上值的信息。
它将上值的值压入栈
并返回其名称。
当索引 <code>n</code> 大于上值的数量时，
返回 <code>NULL</code>（并且不压入任何内容）。


</p><p>
关于上值的更多信息，见 <a href="#pdf-debug.getupvalue"><code>debug.getupvalue</code></a>。





</p><hr><h3><a name="lua_Hook"><code>lua_Hook</code></a></h3>
<pre>typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);</pre>

<p>
调试钩子函数的类型。


</p><p>
每当钩子被调用时，其 <code>ar</code> 参数的
<code>event</code> 字段被设置为触发钩子的特定事件。
Lua 用以下常量标识这些事件：
<a name="pdf-LUA_HOOKCALL"><code>LUA_HOOKCALL</code></a>、<a name="pdf-LUA_HOOKRET"><code>LUA_HOOKRET</code></a>、
<a name="pdf-LUA_HOOKTAILCALL"><code>LUA_HOOKTAILCALL</code></a>、<a name="pdf-LUA_HOOKLINE"><code>LUA_HOOKLINE</code></a> 和
<a name="pdf-LUA_HOOKCOUNT"><code>LUA_HOOKCOUNT</code></a>。
此外，对于行事件，字段 <code>currentline</code> 也会被设置。
要获取 <code>ar</code> 中任何其他字段的值，
钩子必须调用 <a href="#lua_getinfo"><code>lua_getinfo</code></a>。


</p><p>
对于调用事件，<code>event</code> 可以是 <code>LUA_HOOKCALL</code>（正常值），
或者是 <code>LUA_HOOKTAILCALL</code>（用于尾调用）；
在后者情况下，不会有相应的返回事件。


</p><p>
当 Lua 运行钩子时，它会禁用其他钩子调用。
因此，如果钩子回调 Lua 来执行函数或代码块，
此执行不会有任何钩子调用。


</p><p>
钩子函数不能有延续，
也就是说，它们不能使用非空 <code>k</code> 调用 <a href="#lua_yieldk"><code>lua_yieldk</code></a>、
<a href="#lua_pcallk"><code>lua_pcallk</code></a> 或 <a href="#lua_callk"><code>lua_callk</code></a>。


</p><p>
钩子函数可以在以下条件下让出：
只有计数和行事件可以让出；
要让出，钩子函数必须以 <code>nresults</code> 等于零
（即没有值）调用 <a href="#lua_yield"><code>lua_yield</code></a> 来结束其执行。





</p><hr><h3><a name="lua_sethook"><code>lua_sethook</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void lua_sethook (lua_State *L, lua_Hook f, int mask, int count);</pre>

<p>
设置调试钩子函数。


</p><p>
参数 <code>f</code> 是钩子函数。
<code>mask</code> 指定钩子将在哪些事件上被调用：
它由常量
<a name="pdf-LUA_MASKCALL"><code>LUA_MASKCALL</code></a>、
<a name="pdf-LUA_MASKRET"><code>LUA_MASKRET</code></a>、
<a name="pdf-LUA_MASKLINE"><code>LUA_MASKLINE</code></a> 和
<a name="pdf-LUA_MASKCOUNT"><code>LUA_MASKCOUNT</code></a>
的按位或组成。
<code>count</code> 参数仅在掩码
包含 <code>LUA_MASKCOUNT</code> 时有意义。
对于每个事件，钩子按如下解释调用：

</p><ul>

<li><b>调用钩子：</b> 在解释器调用函数时被调用。
钩子在 Lua 进入新函数后立即被调用。
</li>

<li><b>返回钩子：</b> 在解释器从函数返回时被调用。
钩子在 Lua 离开函数之前立即被调用。
</li>

<li><b>行钩子：</b> 在解释器即将
开始执行新的代码行时被调用，
或当它在代码中跳回时（甚至跳到同一行）。
此事件仅在 Lua 执行 Lua 函数时发生。
</li>

<li><b>计数钩子：</b> 在解释器执行每
<code>count</code> 条指令后被调用。
此事件仅在 Lua 执行 Lua 函数时发生。
</li>

</ul>

<p>
通过将 <code>mask</code> 设置为零来禁用钩子。





</p><hr><h3><a name="lua_setlocal"><code>lua_setlocal</code></a></h3><p>
<span class="apii">[-(0|1), +0, –]</span>
</p><pre>const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n);</pre>

<p>
设置给定激活记录的局部变量的值。
它将栈顶的值
赋给该变量并返回其名称。
它还从栈中弹出该值。


</p><p>
当索引大于
活动局部变量的数量时，返回 <code>NULL</code>（并且不弹出任何内容）。


</p><p>
参数 <code>ar</code> 和 <code>n</code> 与函数 <a href="#lua_getlocal"><code>lua_getlocal</code></a> 中的相同。





</p><hr><h3><a name="lua_setupvalue"><code>lua_setupvalue</code></a></h3><p>
<span class="apii">[-(0|1), +0, –]</span>
</p><pre>const char *lua_setupvalue (lua_State *L, int funcindex, int n);</pre>

<p>
设置闭包的上值的值。
它将栈顶的值
赋给该上值并返回其名称。
它还从栈中弹出该值。


</p><p>
当索引 <code>n</code> 大于上值的数量时，
返回 <code>NULL</code>（并且不弹出任何内容）。


</p><p>
参数 <code>funcindex</code> 和 <code>n</code> 与
函数 <a href="#lua_getupvalue"><code>lua_getupvalue</code></a> 中的相同。





</p><hr><h3><a name="lua_upvalueid"><code>lua_upvalueid</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void *lua_upvalueid (lua_State *L, int funcindex, int n);</pre>

<p>
返回索引 <code>funcindex</code> 处闭包的
编号为 <code>n</code> 的上值的唯一标识符。


</p><p>
这些唯一标识符允许程序检查不同的
闭包是否共享上值。
共享上值的 Lua 闭包
（即访问同一个外部局部变量）
将为这些上值索引返回相同的 id。


</p><p>
参数 <code>funcindex</code> 和 <code>n</code> 与
函数 <a href="#lua_getupvalue"><code>lua_getupvalue</code></a> 中的相同，
但 <code>n</code> 不能大于上值的数量。





</p><hr><h3><a name="lua_upvaluejoin"><code>lua_upvaluejoin</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void lua_upvaluejoin (lua_State *L, int funcindex1, int n1,
                                    int funcindex2, int n2);</pre>

<p>
使索引 <code>funcindex1</code> 处的 Lua 闭包的第 <code>n1</code> 个上值
引用索引 <code>funcindex2</code> 处的 Lua 闭包的第 <code>n2</code> 个上值。







</p><h1>5 – <a name="5">辅助库</a></h1>



<p>

<em>辅助库</em>提供了几个方便的函数
来实现 C 与 Lua 的接口。
虽然基本 API 为 C 与 Lua 之间的所有
交互提供了原语函数，
但辅助库为一些
常见任务提供了更高级别的函数。


</p><p>
辅助库中的所有函数和类型
都定义在头文件 <code>lauxlib.h</code> 中，并
具有前缀 <code>luaL_</code>。


</p><p>
辅助库中的所有函数都建立在
基本 API 之上，
因此它们提供的功能都可以用该 API 完成。
尽管如此，使用辅助库可以确保
代码更加一致。


</p><p>
辅助库中的几个函数在内部使用一些
额外的栈槽位。
当辅助库中的函数使用少于五个槽位时，
它不检查栈大小；
它只是假设有足够的槽位。


</p><p>
辅助库中的几个函数用于
检查 C&nbsp;函数参数。
因为错误消息是针对参数格式化的
（例如，"<code>bad argument #1</code>"），
您不应将这些函数用于其他栈值。


</p><p>
名为 <code>luaL_check*</code> 的函数
如果检查不满足，总是引发错误。





</p><h2>5.1 – <a name="5.1">函数和类型</a></h2>

<p>
这里我们按字母顺序列出辅助库中的所有函数和类型。



</p><hr><h3><a name="luaL_addchar"><code>luaL_addchar</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
</p><pre>void luaL_addchar (luaL_Buffer *B, char c);</pre>

<p>
将字节 <code>c</code> 添加到缓冲区 <code>B</code>
（见 <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>）。





</p><hr><h3><a name="luaL_addgsub"><code>luaL_addgsub</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
</p><pre>const void luaL_addgsub (luaL_Buffer *B, const char *s,
                         const char *p, const char *r);</pre>

<p>
将字符串 <code>s</code> 的副本添加到缓冲区 <code>B</code>（见 <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>），
将字符串 <code>p</code> 的任何出现
替换为字符串 <code>r</code>。





</p><hr><h3><a name="luaL_addlstring"><code>luaL_addlstring</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
</p><pre>void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l);</pre>

<p>
将 <code>s</code> 指向的长度为 <code>l</code> 的字符串添加到
缓冲区 <code>B</code>
（见 <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>）。
字符串可以包含嵌入的零。





</p><hr><h3><a name="luaL_addsize"><code>luaL_addsize</code></a></h3><p>
<span class="apii">[-?, +?, –]</span>
</p><pre>void luaL_addsize (luaL_Buffer *B, size_t n);</pre>

<p>
将长度为 <code>n</code> 的字符串添加到缓冲区 <code>B</code>，
该字符串之前已复制到
缓冲区区域（见 <a href="#luaL_prepbuffer"><code>luaL_prepbuffer</code></a>）。





</p><hr><h3><a name="luaL_addstring"><code>luaL_addstring</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
</p><pre>void luaL_addstring (luaL_Buffer *B, const char *s);</pre>

<p>
将 <code>s</code> 指向的以零结尾的字符串
添加到缓冲区 <code>B</code>
（见 <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>）。





</p><hr><h3><a name="luaL_addvalue"><code>luaL_addvalue</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
</p><pre>void luaL_addvalue (luaL_Buffer *B);</pre>

<p>
将栈顶的值
添加到缓冲区 <code>B</code>
（见 <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>）。
弹出该值。


</p><p>
这是字符串缓冲区上唯一可以（并且必须）
在栈上带有额外元素调用的函数，
该元素是要添加到缓冲区的值。





</p><hr><h3><a name="luaL_argcheck"><code>luaL_argcheck</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>void luaL_argcheck (lua_State *L,
                    int cond,
                    int arg,
                    const char *extramsg);</pre>

<p>
检查 <code>cond</code> 是否为真。
如果不是，则引发带有标准消息的错误（见 <a href="#luaL_argerror"><code>luaL_argerror</code></a>）。





</p><hr><h3><a name="luaL_argerror"><code>luaL_argerror</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>int luaL_argerror (lua_State *L, int arg, const char *extramsg);</pre>

<p>
引发一个错误，报告调用它的 C&nbsp;函数的参数 <code>arg</code>
存在问题，
使用包含 <code>extramsg</code> 作为注释的标准消息：

</p><pre>     bad argument #<em>arg</em> to '<em>funcname</em>' (<em>extramsg</em>)
</pre><p>
此函数从不返回。





</p><hr><h3><a name="luaL_argexpected"><code>luaL_argexpected</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>void luaL_argexpected (lua_State *L,
                       int cond,
                       int arg,
                       const char *tname);</pre>

<p>
检查 <code>cond</code> 是否为真。
如果不是，则引发关于参数 <code>arg</code> 类型的错误，
使用标准消息（见 <a href="#luaL_typeerror"><code>luaL_typeerror</code></a>）。





</p><hr><h3><a name="luaL_Buffer"><code>luaL_Buffer</code></a></h3>
<pre>typedef struct luaL_Buffer luaL_Buffer;</pre>

<p>
<em>字符串缓冲区</em>的类型。


</p><p>
字符串缓冲区允许 C&nbsp;代码逐段构建 Lua 字符串。
其使用模式如下：

</p><ul>

<li>首先声明类型为 <a href="#luaL_Buffer"><code>luaL_Buffer</code></a> 的变量 <code>b</code>。</li>

<li>然后用调用 <code>luaL_buffinit(L, &amp;b)</code> 初始化它。</li>

<li>
然后通过调用任何
<code>luaL_add*</code> 函数将字符串片段添加到缓冲区。
</li>

<li>
通过调用 <code>luaL_pushresult(&amp;b)</code> 完成。
此调用将最终字符串留在栈顶。
</li>

</ul>

<p>
如果您事先知道结果字符串的最大大小，
您可以像这样使用缓冲区：

</p><ul>

<li>首先声明类型为 <a href="#luaL_Buffer"><code>luaL_Buffer</code></a> 的变量 <code>b</code>。</li>

<li>然后初始化它并预分配
大小为 <code>sz</code> 的空间，调用 <code>luaL_buffinitsize(L, &amp;b, sz)</code>。</li>

<li>然后将字符串生成到该空间中。</li>

<li>
通过调用 <code>luaL_pushresultsize(&amp;b, sz)</code> 完成，
其中 <code>sz</code> 是复制到该空间的结果字符串的总大小（可能小于或
等于预分配的大小）。
</li>

</ul>

<p>
在其正常操作期间，
字符串缓冲区使用可变数量的栈槽位。
因此，在使用缓冲区时，您不能假设您知道
栈顶在哪里。
您可以在缓冲区操作之间的连续调用之间使用栈，
只要这种使用是平衡的；
也就是说，
当您调用缓冲区操作时，
栈处于与
上一次缓冲区操作后相同的级别。
（此规则的唯一例外是 <a href="#luaL_addvalue"><code>luaL_addvalue</code></a>。）
调用 <a href="#luaL_pushresult"><code>luaL_pushresult</code></a> 后，
栈恢复到缓冲区初始化时的级别，
加上栈顶的最终字符串。





</p><hr><h3><a name="luaL_buffaddr"><code>luaL_buffaddr</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>char *luaL_buffaddr (luaL_Buffer *B);</pre>

<p>
返回缓冲区 <code>B</code> 当前内容的地址
（见 <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>）。
注意，对缓冲区的任何添加都可能使此地址无效。





</p><hr><h3><a name="luaL_buffinit"><code>luaL_buffinit</code></a></h3><p>
<span class="apii">[-0, +?, –]</span>
</p><pre>void luaL_buffinit (lua_State *L, luaL_Buffer *B);</pre>

<p>
初始化缓冲区 <code>B</code>
（见 <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>）。
此函数不分配任何空间；
缓冲区必须声明为变量。





</p><hr><h3><a name="luaL_bufflen"><code>luaL_bufflen</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>size_t luaL_bufflen (luaL_Buffer *B);</pre>

<p>
返回缓冲区 <code>B</code> 当前内容的长度
（见 <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>）。





</p><hr><h3><a name="luaL_buffinitsize"><code>luaL_buffinitsize</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
</p><pre>char *luaL_buffinitsize (lua_State *L, luaL_Buffer *B, size_t sz);</pre>

<p>
等同于序列
<a href="#luaL_buffinit"><code>luaL_buffinit</code></a>、<a href="#luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a>。





</p><hr><h3><a name="luaL_buffsub"><code>luaL_buffsub</code></a></h3><p>
<span class="apii">[-?, +?, –]</span>
</p><pre>void luaL_buffsub (luaL_Buffer *B, int n);</pre>

<p>
从缓冲区 <code>B</code> 中移除 <code>n</code> 个字节
（见 <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>）。
缓冲区必须至少有那么多字节。





</p><hr><h3><a name="luaL_callmeta"><code>luaL_callmeta</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>e</em>]</span>
</p><pre>int luaL_callmeta (lua_State *L, int obj, const char *e);</pre>

<p>
调用元方法。


</p><p>
如果索引 <code>obj</code> 处的对象有元表，并且此
元表有字段 <code>e</code>，
此函数调用此字段，将对象作为其唯一参数传递。
在这种情况下，此函数返回真并将调用返回的值压入
栈。
如果没有元表或没有元方法，
此函数返回假而不在栈上压入任何值。





</p><hr><h3><a name="luaL_checkany"><code>luaL_checkany</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>void luaL_checkany (lua_State *L, int arg);</pre>

<p>
检查函数在位置 <code>arg</code> 是否有
任何类型（包括 <b>nil</b>）的参数。





</p><hr><h3><a name="luaL_checkinteger"><code>luaL_checkinteger</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>lua_Integer luaL_checkinteger (lua_State *L, int arg);</pre>

<p>
检查函数参数 <code>arg</code> 是否为整数
（或可以转换为整数）
并返回此整数。





</p><hr><h3><a name="luaL_checklstring"><code>luaL_checklstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>const char *luaL_checklstring (lua_State *L, int arg, size_t *l);</pre>

<p>
检查函数参数 <code>arg</code> 是否为字符串
并返回此字符串；
如果 <code>l</code> 不是 <code>NULL</code>，则用
字符串的长度填充其引用对象。


</p><p>
此函数使用 <a href="#lua_tolstring"><code>lua_tolstring</code></a> 获取其结果，
因此该函数的所有转换和注意事项都适用于此处。





</p><hr><h3><a name="luaL_checknumber"><code>luaL_checknumber</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>lua_Number luaL_checknumber (lua_State *L, int arg);</pre>

<p>
检查函数参数 <code>arg</code> 是否为数字
并返回此数字转换为 <code>lua_Number</code>。





</p><hr><h3><a name="luaL_checkoption"><code>luaL_checkoption</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>int luaL_checkoption (lua_State *L,
                      int arg,
                      const char *def,
                      const char *const lst[]);</pre>

<p>
检查函数参数 <code>arg</code> 是否为字符串，并
在数组 <code>lst</code> 中搜索此字符串
（必须以 NULL 结尾）。
返回在数组中找到该字符串的索引。
如果参数不是字符串或
找不到该字符串，则引发错误。


</p><p>
如果 <code>def</code> 不是 <code>NULL</code>，
当没有参数 <code>arg</code> 或此参数为 <b>nil</b> 时，
函数使用 <code>def</code> 作为默认值。


</p><p>
这是将字符串映射到 C&nbsp;枚举的有用函数。
（Lua 库中的通常约定是
使用字符串而不是数字来选择选项。）





</p><hr><h3><a name="luaL_checkstack"><code>luaL_checkstack</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>void luaL_checkstack (lua_State *L, int sz, const char *msg);</pre>

<p>
将栈大小增长到 <code>top + sz</code> 个元素，
如果栈不能增长到该大小，则引发错误。
<code>msg</code> 是要进入错误消息的附加文本
（或 <code>NULL</code> 表示没有附加文本）。





</p><hr><h3><a name="luaL_checkstring"><code>luaL_checkstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>const char *luaL_checkstring (lua_State *L, int arg);</pre>

<p>
检查函数参数 <code>arg</code> 是否为字符串
并返回此字符串。


</p><p>
此函数使用 <a href="#lua_tolstring"><code>lua_tolstring</code></a> 获取其结果，
因此该函数的所有转换和注意事项都适用于此处。





</p><hr><h3><a name="luaL_checktype"><code>luaL_checktype</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>void luaL_checktype (lua_State *L, int arg, int t);</pre>

<p>
检查函数参数 <code>arg</code> 是否具有类型 <code>t</code>。
关于 <code>t</code> 的类型编码，见 <a href="#lua_type"><code>lua_type</code></a>。





</p><hr><h3><a name="luaL_checkudata"><code>luaL_checkudata</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>void *luaL_checkudata (lua_State *L, int arg, const char *tname);</pre>

<p>
检查函数参数 <code>arg</code> 是否为
类型 <code>tname</code> 的用户数据（见 <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>）并
返回用户数据的内存块地址（见 <a href="#lua_touserdata"><code>lua_touserdata</code></a>）。





</p><hr><h3><a name="luaL_checkversion"><code>luaL_checkversion</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>void luaL_checkversion (lua_State *L);</pre>

<p>
检查进行调用的代码和被调用的 Lua 库
是否使用相同版本的 Lua 和相同的数字类型。





</p><hr><h3><a name="luaL_dofile"><code>luaL_dofile</code></a></h3><p>
<span class="apii">[-0, +?, <em>m</em>]</span>
</p><pre>int luaL_dofile (lua_State *L, const char *filename);</pre>

<p>
加载并运行给定的文件。
它定义为以下宏：

</p><pre>     (luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0))
</pre><p>
如果没有错误，它返回&nbsp;0（<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>），
如果有错误，则返回 1。





</p><hr><h3><a name="luaL_dostring"><code>luaL_dostring</code></a></h3><p>
<span class="apii">[-0, +?, –]</span>
</p><pre>int luaL_dostring (lua_State *L, const char *str);</pre>

<p>
加载并运行给定的字符串。
它定义为以下宏：

</p><pre>     (luaL_loadstring(L, str) || lua_pcall(L, 0, LUA_MULTRET, 0))
</pre><p>
如果没有错误，它返回&nbsp;0（<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>），
如果有错误，则返回 1。





</p><hr><h3><a name="luaL_error"><code>luaL_error</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>int luaL_error (lua_State *L, const char *fmt, ...);</pre>

<p>
引发错误。
错误消息格式由 <code>fmt</code>
加上任何额外参数给出，
遵循与 <a href="#lua_pushfstring"><code>lua_pushfstring</code></a> 相同的规则。
它还在消息开头添加发生错误的
文件名和行号，
如果此信息可用。


</p><p>
此函数从不返回，
但在 C&nbsp;函数中将其用作
<code>return luaL_error(<em>args</em>)</code> 是一种惯用法。





</p><hr><h3><a name="luaL_execresult"><code>luaL_execresult</code></a></h3><p>
<span class="apii">[-0, +3, <em>m</em>]</span>
</p><pre>int luaL_execresult (lua_State *L, int stat);</pre>

<p>
此函数为
标准库中与进程相关的函数
（<a href="#pdf-os.execute"><code>os.execute</code></a> 和 <a href="#pdf-io.close"><code>io.close</code></a>）生成返回值。





</p><hr><h3><a name="luaL_fileresult"><code>luaL_fileresult</code></a></h3><p>
<span class="apii">[-0, +(1|3), <em>m</em>]</span>
</p><pre>int luaL_fileresult (lua_State *L, int stat, const char *fname);</pre>

<p>
此函数为
标准库中与文件相关的函数
（<a href="#pdf-io.open"><code>io.open</code></a>、<a href="#pdf-os.rename"><code>os.rename</code></a>、<a href="#pdf-file:seek"><code>file:seek</code></a> 等）生成返回值。





</p><hr><h3><a name="luaL_getmetafield"><code>luaL_getmetafield</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>m</em>]</span>
</p><pre>int luaL_getmetafield (lua_State *L, int obj, const char *e);</pre>

<p>
将索引 <code>obj</code> 处对象的元表中的字段 <code>e</code> 压入栈
并返回压入值的类型。
如果对象没有元表，
或元表没有此字段，
则不压入任何内容并返回 <code>LUA_TNIL</code>。





</p><hr><h3><a name="luaL_getmetatable"><code>luaL_getmetatable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>int luaL_getmetatable (lua_State *L, const char *tname);</pre>

<p>
将注册表中与名称 <code>tname</code> 关联的元表压入栈
（见 <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>），
或者如果没有与该名称关联的元表，则压入 <b>nil</b>。
返回压入值的类型。





</p><hr><h3><a name="luaL_getsubtable"><code>luaL_getsubtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
</p><pre>int luaL_getsubtable (lua_State *L, int idx, const char *fname);</pre>

<p>
确保值 <code>t[fname]</code>（其中 <code>t</code> 是索引 <code>idx</code> 处的值）
是一个表，
并将该表压入栈。
如果在那里找到先前的表，则返回真，
如果创建新表，则返回假。





</p><hr><h3><a name="luaL_gsub"><code>luaL_gsub</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>const char *luaL_gsub (lua_State *L,
                       const char *s,
                       const char *p,
                       const char *r);</pre>

<p>
创建字符串 <code>s</code> 的副本，
将字符串 <code>p</code> 的任何出现
替换为字符串 <code>r</code>。
将结果字符串压入栈并返回它。





</p><hr><h3><a name="luaL_len"><code>luaL_len</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
</p><pre>lua_Integer luaL_len (lua_State *L, int index);</pre>

<p>
以数字形式返回给定索引处值的"长度"；
它等同于 Lua 中的 '<code>#</code>' 操作符（见 <a href="#3.4.7">§3.4.7</a>）。
如果操作的结果不是整数，则引发错误。
（这种情况只能通过元方法发生。）





</p><hr><h3><a name="luaL_loadbuffer"><code>luaL_loadbuffer</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>int luaL_loadbuffer (lua_State *L,
                     const char *buff,
                     size_t sz,
                     const char *name);</pre>

<p>
等同于 <a href="#luaL_loadbufferx"><code>luaL_loadbufferx</code></a>，其中 <code>mode</code> 等于 <code>NULL</code>。





</p><hr><h3><a name="luaL_loadbufferx"><code>luaL_loadbufferx</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>int luaL_loadbufferx (lua_State *L,
                      const char *buff,
                      size_t sz,
                      const char *name,
                      const char *mode);</pre>

<p>
将缓冲区作为 Lua 代码块加载。
此函数使用 <a href="#lua_load"><code>lua_load</code></a> 加载
<code>buff</code> 指向的大小为 <code>sz</code> 的缓冲区中的代码块。


</p><p>
此函数返回与 <a href="#lua_load"><code>lua_load</code></a> 相同的结果。
<code>name</code> 是代码块名称，
用于调试信息和错误消息。
字符串 <code>mode</code> 的工作方式与函数 <a href="#lua_load"><code>lua_load</code></a> 中的相同。





</p><hr><h3><a name="luaL_loadfile"><code>luaL_loadfile</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>int luaL_loadfile (lua_State *L, const char *filename);</pre>

<p>
等同于 <a href="#luaL_loadfilex"><code>luaL_loadfilex</code></a>，其中 <code>mode</code> 等于 <code>NULL</code>。





</p><hr><h3><a name="luaL_loadfilex"><code>luaL_loadfilex</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>int luaL_loadfilex (lua_State *L, const char *filename,
                                            const char *mode);</pre>

<p>
将文件作为 Lua 代码块加载。
此函数使用 <a href="#lua_load"><code>lua_load</code></a> 加载名为 <code>filename</code> 的文件中的代码块。
如果 <code>filename</code> 是 <code>NULL</code>，
则从标准输入加载。
如果文件的第一行以 <code>#</code> 开头，则忽略该行。


</p><p>
字符串 <code>mode</code> 的工作方式与函数 <a href="#lua_load"><code>lua_load</code></a> 中的相同。


</p><p>
此函数返回与 <a href="#lua_load"><code>lua_load</code></a> 相同的结果，
或者对于文件相关错误返回 <a href="#pdf-LUA_ERRFILE"><code>LUA_ERRFILE</code></a>。


</p><p>
与 <a href="#lua_load"><code>lua_load</code></a> 一样，此函数只加载代码块；
它不运行它。





</p><hr><h3><a name="luaL_loadstring"><code>luaL_loadstring</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>int luaL_loadstring (lua_State *L, const char *s);</pre>

<p>
将字符串作为 Lua 代码块加载。
此函数使用 <a href="#lua_load"><code>lua_load</code></a> 加载
以零结尾的字符串 <code>s</code> 中的代码块。


</p><p>
此函数返回与 <a href="#lua_load"><code>lua_load</code></a> 相同的结果。


</p><p>
同样与 <a href="#lua_load"><code>lua_load</code></a> 一样，此函数只加载代码块；
它不运行它。





</p><hr><h3><a name="luaL_newlib"><code>luaL_newlib</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>void luaL_newlib (lua_State *L, const luaL_Reg l[]);</pre>

<p>
创建一个新表并在其中注册
列表 <code>l</code> 中的函数。


</p><p>
它实现为以下宏：

</p><pre>     (luaL_newlibtable(L,l), luaL_setfuncs(L,l,0))
</pre><p>
数组 <code>l</code> 必须是实际的数组，
而不是指向它的指针。





</p><hr><h3><a name="luaL_newlibtable"><code>luaL_newlibtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>void luaL_newlibtable (lua_State *L, const luaL_Reg l[]);</pre>

<p>
创建一个新表，其大小经过优化
以存储数组 <code>l</code> 中的所有条目
（但实际上不存储它们）。
它旨在与 <a href="#luaL_setfuncs"><code>luaL_setfuncs</code></a> 结合使用
（见 <a href="#luaL_newlib"><code>luaL_newlib</code></a>）。


</p><p>
它实现为宏。
数组 <code>l</code> 必须是实际的数组，
而不是指向它的指针。





</p><hr><h3><a name="luaL_newmetatable"><code>luaL_newmetatable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>int luaL_newmetatable (lua_State *L, const char *tname);</pre>

<p>
如果注册表已经有键 <code>tname</code>，
则返回 0。
否则，
创建一个新表用作用户数据的元表，
将对 <code>__name = tname</code> 添加到此新表，
将对 <code>[tname] = new table</code> 添加到注册表，
并返回 1。


</p><p>
在两种情况下，
函数都将注册表中与 <code>tname</code> 关联的最终值
压入栈。





</p><hr><h3><a name="luaL_newstate"><code>luaL_newstate</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_State *luaL_newstate (void);</pre>

<p>
创建一个新的 Lua 状态。
它使用基于 ISO&nbsp;C 分配函数的分配器
调用 <a href="#lua_newstate"><code>lua_newstate</code></a>，
然后设置一个警告函数和一个恐慌函数（见 <a href="#4.4">§4.4</a>），
它们将消息打印到标准错误输出。


</p><p>
返回新状态，
或者如果有内存分配错误，则返回 <code>NULL</code>。





</p><hr><h3><a name="luaL_openlibs"><code>luaL_openlibs</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
</p><pre>void luaL_openlibs (lua_State *L);</pre>

<p>
将所有标准 Lua 库打开到给定状态中。





</p><hr><h3><a name="luaL_opt"><code>luaL_opt</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>T luaL_opt (L, func, arg, dflt);</pre>

<p>
此宏定义如下：

</p><pre>     (lua_isnoneornil(L,(arg)) ? (dflt) : func(L,(arg)))
</pre><p>
换句话说，如果参数 <code>arg</code> 是 nil 或不存在，
宏结果为默认值 <code>dflt</code>。
否则，它结果为使用状态 <code>L</code> 和参数索引 <code>arg</code> 作为
参数调用 <code>func</code> 的结果。
注意，它仅在需要时才评估表达式 <code>dflt</code>。





</p><hr><h3><a name="luaL_optinteger"><code>luaL_optinteger</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>lua_Integer luaL_optinteger (lua_State *L,
                             int arg,
                             lua_Integer d);</pre>

<p>
如果函数参数 <code>arg</code> 是整数
（或可以转换为整数），
则返回此整数。
如果此参数不存在或为 <b>nil</b>，
则返回 <code>d</code>。
否则，引发错误。





</p><hr><h3><a name="luaL_optlstring"><code>luaL_optlstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>const char *luaL_optlstring (lua_State *L,
                             int arg,
                             const char *d,
                             size_t *l);</pre>

<p>
如果函数参数 <code>arg</code> 是字符串，
则返回此字符串。
如果此参数不存在或为 <b>nil</b>，
则返回 <code>d</code>。
否则，引发错误。


</p><p>
如果 <code>l</code> 不是 <code>NULL</code>，
则用结果的长度填充其引用对象。
如果结果是 <code>NULL</code>
（仅在返回 <code>d</code> 且 <code>d == NULL</code> 时可能），
其长度被视为零。


</p><p>
此函数使用 <a href="#lua_tolstring"><code>lua_tolstring</code></a> 获取其结果，
因此该函数的所有转换和注意事项都适用于此处。





</p><hr><h3><a name="luaL_optnumber"><code>luaL_optnumber</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>lua_Number luaL_optnumber (lua_State *L, int arg, lua_Number d);</pre>

<p>
如果函数参数 <code>arg</code> 是数字，
则以 <code>lua_Number</code> 形式返回此数字。
如果此参数不存在或为 <b>nil</b>，
则返回 <code>d</code>。
否则，引发错误。





</p><hr><h3><a name="luaL_optstring"><code>luaL_optstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>const char *luaL_optstring (lua_State *L,
                            int arg,
                            const char *d);</pre>

<p>
如果函数参数 <code>arg</code> 是字符串，
则返回此字符串。
如果此参数不存在或为 <b>nil</b>，
则返回 <code>d</code>。
否则，引发错误。





</p><hr><h3><a name="luaL_prepbuffer"><code>luaL_prepbuffer</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
</p><pre>char *luaL_prepbuffer (luaL_Buffer *B);</pre>

<p>
等同于使用预定义大小 <a name="pdf-LUAL_BUFFERSIZE"><code>LUAL_BUFFERSIZE</code></a> 的
<a href="#luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a>。





</p><hr><h3><a name="luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
</p><pre>char *luaL_prepbuffsize (luaL_Buffer *B, size_t sz);</pre>

<p>
返回大小为 <code>sz</code> 的空间地址，
您可以在其中复制要添加到缓冲区 <code>B</code> 的字符串
（见 <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>）。
将字符串复制到此空间后，您必须调用
<a href="#luaL_addsize"><code>luaL_addsize</code></a>，传入字符串的大小，以实际将
其添加到缓冲区。





</p><hr><h3><a name="luaL_pushfail"><code>luaL_pushfail</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void luaL_pushfail (lua_State *L);</pre>

<p>
将 <b>fail</b> 值压入栈（见 <a href="#6">§6</a>）。





</p><hr><h3><a name="luaL_pushresult"><code>luaL_pushresult</code></a></h3><p>
<span class="apii">[-?, +1, <em>m</em>]</span>
</p><pre>void luaL_pushresult (luaL_Buffer *B);</pre>
<!-- slice ends -->

<!-- slice index: 6 -->
<!-- lines 7479–8973 / total 11964 -->
<!-- title: 6 – The Standard Libraries -->
<p>
完成对缓冲区 <code>B</code> 的使用，将最终字符串留在栈顶。





</p><hr><h3><a name="luaL_pushresultsize"><code>luaL_pushresultsize</code></a></h3><p>
<span class="apii">[-?, +1, <em>m</em>]</span>
</p><pre>void luaL_pushresultsize (luaL_Buffer *B, size_t sz);</pre>

<p>
等价于序列 <a href="#luaL_addsize"><code>luaL_addsize</code></a>, <a href="#luaL_pushresult"><code>luaL_pushresult</code></a>。





</p><hr><h3><a name="luaL_ref"><code>luaL_ref</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>
</p><pre>int luaL_ref (lua_State *L, int t);</pre>

<p>
在索引 <code>t</code> 处的表中，为栈顶的对象创建并返回一个<em>引用</em>（并弹出该对象）。


</p><p>
引用是一个唯一的整数键。
只要你不手动向表 <code>t</code> 中添加整数键，
<a href="#luaL_ref"><code>luaL_ref</code></a> 就能确保它返回的键的唯一性。
你可以通过调用 <code>lua_rawgeti(L, t, r)</code> 来检索引用 <code>r</code> 所指向的对象。
函数 <a href="#luaL_unref"><code>luaL_unref</code></a> 用于释放引用。


</p><p>
如果栈顶的对象是 <b>nil</b>，
<a href="#luaL_ref"><code>luaL_ref</code></a> 返回常量 <a name="pdf-LUA_REFNIL"><code>LUA_REFNIL</code></a>。
常量 <a name="pdf-LUA_NOREF"><code>LUA_NOREF</code></a> 保证与 <a href="#luaL_ref"><code>luaL_ref</code></a> 返回的任何引用都不同。





</p><hr><h3><a name="luaL_Reg"><code>luaL_Reg</code></a></h3>
<pre>typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;</pre>

<p>
用于由 <a href="#luaL_setfuncs"><code>luaL_setfuncs</code></a> 注册的函数数组的类型。
<code>name</code> 是函数名，<code>func</code> 是指向函数的指针。
任何 <a href="#luaL_Reg"><code>luaL_Reg</code></a> 数组必须以一个哨兵条目结束，
其中 <code>name</code> 和 <code>func</code> 都是 <code>NULL</code>。





</p><hr><h3><a name="luaL_requiref"><code>luaL_requiref</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
</p><pre>void luaL_requiref (lua_State *L, const char *modname,
                    lua_CFunction openf, int glb);</pre>

<p>
如果 <code>package.loaded[modname]</code> 不为真，
则以字符串 <code>modname</code> 作为参数调用函数 <code>openf</code>，
并将调用结果设置到 <code>package.loaded[modname]</code>，
就像该函数是通过 <a href="#pdf-require"><code>require</code></a> 调用的一样。


</p><p>
如果 <code>glb</code> 为真，
还会将模块存储到全局变量 <code>modname</code> 中。


</p><p>
在栈上留下模块的副本。





</p><hr><h3><a name="luaL_setfuncs"><code>luaL_setfuncs</code></a></h3><p>
<span class="apii">[-nup, +0, <em>m</em>]</span>
</p><pre>void luaL_setfuncs (lua_State *L, const luaL_Reg *l, int nup);</pre>

<p>
将数组 <code>l</code> 中的所有函数（参见 <a href="#luaL_Reg"><code>luaL_Reg</code></a>）注册到栈顶的表中
（位于可选的上值下方，见下文）。


</p><p>
当 <code>nup</code> 不为零时，
所有函数都会创建 <code>nup</code> 个上值，
这些上值用之前在库表之上压入栈的 <code>nup</code> 个值的副本初始化。
这些值在注册后会从栈中弹出。


</p><p>
值为 <code>NULL</code> 的函数表示一个占位符，
会被填充为 <b>false</b>。





</p><hr><h3><a name="luaL_setmetatable"><code>luaL_setmetatable</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void luaL_setmetatable (lua_State *L, const char *tname);</pre>

<p>
将栈顶对象的元表设置为在注册表中与名称 <code>tname</code> 关联的元表
（参见 <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>）。





</p><hr><h3><a name="luaL_Stream"><code>luaL_Stream</code></a></h3>
<pre>typedef struct luaL_Stream {
  FILE *f;
  lua_CFunction closef;
} luaL_Stream;</pre>

<p>
标准 I/O 库使用的文件句柄的标准表示。


</p><p>
文件句柄实现为完全用户数据，
具有名为 <code>LUA_FILEHANDLE</code> 的元表
（其中 <code>LUA_FILEHANDLE</code> 是包含实际元表名称的宏）。
该元表由 I/O 库创建（参见 <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>）。


</p><p>
该用户数据必须以结构 <code>luaL_Stream</code> 开头；
它可以在此初始结构之后包含其他数据。
字段 <code>f</code> 指向相应的 C 流
（或者它可以是 <code>NULL</code> 以表示一个未完全创建的句柄）。
字段 <code>closef</code> 指向一个 Lua 函数，
当句柄关闭或被收集时，该函数将被调用以关闭流；
此函数接收文件句柄作为其唯一参数，
并且必须在成功时返回真值，
或在出错时返回假值加上错误消息。
一旦 Lua 调用了此字段，
它会将字段值更改为 <code>NULL</code>
以表示句柄已关闭。





</p><hr><h3><a name="luaL_testudata"><code>luaL_testudata</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
</p><pre>void *luaL_testudata (lua_State *L, int arg, const char *tname);</pre>

<p>
此函数的工作方式类似于 <a href="#luaL_checkudata"><code>luaL_checkudata</code></a>，
但是当测试失败时，
它返回 <code>NULL</code> 而不是引发错误。





</p><hr><h3><a name="luaL_tolstring"><code>luaL_tolstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
</p><pre>const char *luaL_tolstring (lua_State *L, int idx, size_t *len);</pre>

<p>
以合理的格式将给定索引处的任何 Lua 值转换为 C 字符串。
结果字符串被压入栈并且也由函数返回（参见 <a href="#4.1.3">§4.1.3</a>）。
如果 <code>len</code> 不是 <code>NULL</code>，
函数还会将 <code>*len</code> 设置为字符串长度。


</p><p>
如果值具有带 <code>__tostring</code> 字段的元表，
那么 <code>luaL_tolstring</code> 会以该值作为参数调用相应的元方法，
并使用调用的结果作为其结果。





</p><hr><h3><a name="luaL_traceback"><code>luaL_traceback</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>void luaL_traceback (lua_State *L, lua_State *L1, const char *msg,
                     int level);</pre>

<p>
创建并压入栈 <code>L1</code> 的回溯。
如果 <code>msg</code> 不是 <code>NULL</code>，它会被附加在回溯的开头。
<code>level</code> 参数指示从哪个级别开始回溯。





</p><hr><h3><a name="luaL_typeerror"><code>luaL_typeerror</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>int luaL_typeerror (lua_State *L, int arg, const char *tname);</pre>

<p>
为调用它的 C 函数的参数 <code>arg</code> 引发类型错误，
使用标准消息；
<code>tname</code> 是预期类型的"名称"。
此函数永不返回。





</p><hr><h3><a name="luaL_typename"><code>luaL_typename</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>const char *luaL_typename (lua_State *L, int index);</pre>

<p>
返回给定索引处值的类型名称。





</p><hr><h3><a name="luaL_unref"><code>luaL_unref</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void luaL_unref (lua_State *L, int t, int ref);</pre>

<p>
从索引 <code>t</code> 处的表中释放引用 <code>ref</code>
（参见 <a href="#luaL_ref"><code>luaL_ref</code></a>）。
该条目从表中移除，
以便引用的对象可以被收集。
引用 <code>ref</code> 也被释放以便再次使用。


</p><p>
如果 <code>ref</code> 是 <a href="#pdf-LUA_NOREF"><code>LUA_NOREF</code></a> 或 <a href="#pdf-LUA_REFNIL"><code>LUA_REFNIL</code></a>，
<a href="#luaL_unref"><code>luaL_unref</code></a> 不做任何操作。





</p><hr><h3><a name="luaL_where"><code>luaL_where</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>void luaL_where (lua_State *L, int lvl);</pre>

<p>
将一个字符串压入栈，该字符串标识调用栈中级别 <code>lvl</code> 处的控制位置。
通常此字符串具有以下格式：

</p><pre>     <em>chunkname</em>:<em>currentline</em>:
</pre><p>
级别 0 是正在运行的函数，
级别 1 是调用正在运行的函数的函数，
依此类推。


</p><p>
此函数用于为错误消息构建前缀。







</p><h1>6 – <a name="6">标准库</a></h1>



<p>
标准 Lua 库提供了通过 C API 在 C 中实现的有用函数。
其中一些函数为语言提供基本服务
（例如 <a href="#pdf-type"><code>type</code></a> 和 <a href="#pdf-getmetatable"><code>getmetatable</code></a>）；
另一些提供对外部服务的访问（例如 I/O）；
还有一些本可以在 Lua 中实现，
但由于不同原因值得用 C 实现（例如 <a href="#pdf-table.sort"><code>table.sort</code></a>）。


</p><p>
所有库都是通过官方 C API 实现的，
并作为独立的 C 模块提供。
除非另有说明，
这些库函数不会将其参数数量调整为其预期参数。
例如，文档记载为 <code>foo(arg)</code> 的函数不应在没有参数的情况下调用。


</p><p>
符号 <b>fail</b> 表示代表某种失败的假值。
（目前，<b>fail</b> 等于 <b>nil</b>，
但这可能在未来版本中改变。
建议始终使用 <code>(not status)</code> 测试这些函数的成功，
而不是 <code>(status == nil)</code>。）


</p><p>
目前，Lua 具有以下标准库：

</p><ul>

<li>基础库（<a href="#6.1">§6.1</a>）；</li>

<li>协程库（<a href="#6.2">§6.2</a>）；</li>

<li>包库（<a href="#6.3">§6.3</a>）；</li>

<li>字符串操作（<a href="#6.4">§6.4</a>）；</li>

<li>基本 UTF-8 支持（<a href="#6.5">§6.5</a>）；</li>

<li>表操作（<a href="#6.6">§6.6</a>）；</li>

<li>数学函数（<a href="#6.7">§6.7</a>）（sin、log 等）；</li>

<li>输入和输出（<a href="#6.8">§6.8</a>）；</li>

<li>操作系统设施（<a href="#6.9">§6.9</a>）；</li>

<li>调试设施（<a href="#6.10">§6.10</a>）。</li>

</ul><p>
除了基础库和包库，
每个库都将其所有函数作为全局表的字段或其对象的方法提供。


</p><p>
要访问这些库，
C 宿主程序应调用 <a href="#luaL_openlibs"><code>luaL_openlibs</code></a> 函数，
它会打开所有标准库。
或者，
宿主程序可以通过使用 <a href="#luaL_requiref"><code>luaL_requiref</code></a> 
单独打开它们，调用
<a name="pdf-luaopen_base"><code>luaopen_base</code></a>（用于基础库），
<a name="pdf-luaopen_package"><code>luaopen_package</code></a>（用于包库），
<a name="pdf-luaopen_coroutine"><code>luaopen_coroutine</code></a>（用于协程库），
<a name="pdf-luaopen_string"><code>luaopen_string</code></a>（用于字符串库），
<a name="pdf-luaopen_utf8"><code>luaopen_utf8</code></a>（用于 UTF-8 库），
<a name="pdf-luaopen_table"><code>luaopen_table</code></a>（用于表库），
<a name="pdf-luaopen_math"><code>luaopen_math</code></a>（用于数学库），
<a name="pdf-luaopen_io"><code>luaopen_io</code></a>（用于 I/O 库），
<a name="pdf-luaopen_os"><code>luaopen_os</code></a>（用于操作系统库），
以及 <a name="pdf-luaopen_debug"><code>luaopen_debug</code></a>（用于调试库）。
这些函数在 <a name="pdf-lualib.h"><code>lualib.h</code></a> 中声明。





</p><h2>6.1 – <a name="6.1">基础函数</a></h2>

<p>
基础库为 Lua 提供核心函数。
如果你的应用程序中不包含此库，
你应该仔细检查是否需要为其某些功能提供实现。


</p><p>
</p><hr><h3><a name="pdf-assert"><code>assert (v [, message])</code></a></h3>


<p>
如果其参数 <code>v</code> 的值为假（即 <b>nil</b> 或 <b>false</b>），则引发错误；
否则，返回其所有参数。
在出错的情况下，
<code>message</code> 是错误对象；
当缺省时，它默认为"<code>assertion failed!</code>"




</p><p>
</p><hr><h3><a name="pdf-collectgarbage"><code>collectgarbage ([opt [, arg]])</code></a></h3>


<p>
此函数是垃圾收集器的通用接口。
它根据其第一个参数 <code>opt</code> 执行不同的函数：

</p><ul>

<li><b>"<code>collect</code>"：</b>
执行完整的垃圾收集周期。
这是默认选项。
</li>

<li><b>"<code>stop</code>"：</b>
停止垃圾收集器的自动执行。
收集器仅在显式调用时运行，
直到重新启动它的调用。
</li>

<li><b>"<code>restart</code>"：</b>
重新启动垃圾收集器的自动执行。
</li>

<li><b>"<code>count</code>"：</b>
以 Kbytes 为单位返回 Lua 使用的总内存。
该值有小数部分，
因此乘以 1024 可得到 Lua 使用的确切字节数。
</li>

<li><b>"<code>step</code>"：</b>
执行垃圾收集步骤。
步骤"大小"由 <code>arg</code> 控制。
值为零时，
收集器将执行一个基本（不可分割）步骤。
对于非零值，
收集器将像 Lua 分配了那么多内存（以 Kbytes 为单位）一样执行。
如果步骤完成了收集周期，则返回 <b>true</b>。
</li>

<li><b>"<code>isrunning</code>"：</b>
返回一个布尔值，指示收集器是否正在运行（即未停止）。
</li>

<li><b>"<code>incremental</code>"：</b>
将收集器模式更改为增量模式。
此选项后面可以跟三个数字：
垃圾收集器暂停、
步进乘数
和步长（参见 <a href="#2.5.1">§2.5.1</a>）。
零表示不更改该值。
</li>

<li><b>"<code>generational</code>"：</b>
将收集器模式更改为分代模式。
此选项后面可以跟两个数字：
垃圾收集器次要乘数
和主要乘数（参见 <a href="#2.5.2">§2.5.2</a>）。
零表示不更改该值。
</li>

</ul><p>
有关垃圾收集和其中一些选项的更多详细信息，请参见 <a href="#2.5">§2.5</a>。


</p><p>
此函数不应被析构器调用。




</p><p>
</p><hr><h3><a name="pdf-dofile"><code>dofile ([filename])</code></a></h3>
打开指定文件并将其内容作为 Lua 代码块执行。
当不带参数调用时，
<code>dofile</code> 执行标准输入（<code>stdin</code>）的内容。
返回代码块返回的所有值。
在出错的情况下，<code>dofile</code> 将错误传播给其调用者。
（也就是说，<code>dofile</code> 不在保护模式下运行。）




<p>
</p><hr><h3><a name="pdf-error"><code>error (message [, level])</code></a></h3>
以 <code>message</code> 作为错误对象引发错误（参见 <a href="#2.3">§2.3</a>）。
此函数永不返回。


<p>
通常，<code>error</code> 会在消息开头添加一些关于错误位置的信息，
如果消息是字符串的话。
<code>level</code> 参数指定如何获取错误位置。
对于级别 1（默认值），错误位置是调用 <code>error</code> 函数的地方。
级别 2 将错误指向调用 <code>error</code> 的函数被调用的地方；
依此类推。
传递级别 0 可避免向消息添加错误位置信息。




</p><p>
</p><hr><h3><a name="pdf-_G"><code>_G</code></a></h3>
一个全局变量（不是函数），
保存全局环境（参见 <a href="#2.2">§2.2</a>）。
Lua 本身不使用此变量；
更改其值不会影响任何环境，
反之亦然。




<p>
</p><hr><h3><a name="pdf-getmetatable"><code>getmetatable (object)</code></a></h3>


<p>
如果 <code>object</code> 没有元表，则返回 <b>nil</b>。
否则，
如果对象的元表具有 <code>__metatable</code> 字段，
则返回关联的值。
否则，返回给定对象的元表。




</p><p>
</p><hr><h3><a name="pdf-ipairs"><code>ipairs (t)</code></a></h3>


<p>
返回三个值（一个迭代器函数、表 <code>t</code> 和 0），
以便构造

</p><pre>     for i,v in ipairs(t) do <em>body</em> end
</pre><p>
将迭代键值对
(<code>1,t[1]</code>)、(<code>2,t[2]</code>)、...，
直到第一个缺失的索引。




</p><p>
</p><hr><h3><a name="pdf-load"><code>load (chunk [, chunkname [, mode [, env]]])</code></a></h3>


<p>
加载一个代码块。


</p><p>
如果 <code>chunk</code> 是一个字符串，则代码块就是这个字符串。
如果 <code>chunk</code> 是一个函数，
<code>load</code> 重复调用它以获取代码块片段。
每次调用 <code>chunk</code> 必须返回一个字符串，该字符串与之前的结果连接。
返回空字符串、<b>nil</b> 或无值表示代码块结束。


</p><p>
如果没有语法错误，
<code>load</code> 将编译后的代码块作为函数返回；
否则，它返回 <b>fail</b> 加上错误消息。


</p><p>
当你加载一个主代码块时，
结果函数将始终恰好有一个上值，
即 <code>_ENV</code> 变量（参见 <a href="#2.2">§2.2</a>）。
然而，
当你加载从函数创建的二进制代码块时（参见 <a href="#pdf-string.dump"><code>string.dump</code></a>），
结果函数可以有任意数量的上值，
并且不保证其第一个上值是 <code>_ENV</code> 变量。
（非主函数甚至可能没有 <code>_ENV</code> 上值。）


</p><p>
无论如何，如果结果函数有任何上值，
其第一个上值设置为 <code>env</code> 的值，
如果给定了该参数，
或者设置为全局环境的值。
其他上值用 <b>nil</b> 初始化。
所有上值都是新鲜的，也就是说，
它们不与任何其他函数共享。


</p><p>
<code>chunkname</code> 用作错误消息和调试信息的代码块名称（参见 <a href="#4.7">§4.7</a>）。
当缺省时，
如果 <code>chunk</code> 是字符串，它默认为 <code>chunk</code>，
否则为"<code>=(load)</code>"。


</p><p>
字符串 <code>mode</code> 控制代码块是文本还是二进制（即预编译的代码块）。
它可以是字符串"<code>b</code>"（仅二进制代码块）、
"<code>t</code>"（仅文本代码块）
或"<code>bt</code>"（二进制和文本）。
默认为"<code>bt</code>"。


</p><p>
加载格式错误的二进制代码块是安全的；
<code>load</code> 会发出适当的错误信号。
然而，
Lua 不会检查二进制代码块内代码的一致性；
运行恶意制作的字节码可能会使解释器崩溃。




</p><p>
</p><hr><h3><a name="pdf-loadfile"><code>loadfile ([filename [, mode [, env]]])</code></a></h3>


<p>
类似于 <a href="#pdf-load"><code>load</code></a>，
但从文件 <code>filename</code> 获取代码块，
或如果未给定文件名，则从标准输入获取。




</p><p>
</p><hr><h3><a name="pdf-next"><code>next (table [, index])</code></a></h3>


<p>
允许程序遍历表的所有字段。
其第一个参数是一个表，其第二个参数是此表中的索引。
调用 <code>next</code> 返回表的下一个索引及其关联的值。
当以 <b>nil</b> 作为其第二个参数调用时，
<code>next</code> 返回初始索引及其关联的值。
当以最后一个索引调用，
或在空表中以 <b>nil</b> 调用时，
<code>next</code> 返回 <b>nil</b>。
如果第二个参数缺失，则解释为 <b>nil</b>。
特别地，
你可以使用 <code>next(t)</code> 来检查表是否为空。


</p><p>
枚举索引的顺序未指定，
<em>即使对于数字索引也是如此</em>。
（要按数字顺序遍历表，请使用数字 <b>for</b>。）


</p><p>
在遍历表期间，你不应向表中的不存在字段分配任何值。
但是，你可以修改现有字段。
特别是，你可以将现有字段设置为 nil。




</p><p>
</p><hr><h3><a name="pdf-pairs"><code>pairs (t)</code></a></h3>


<p>
如果 <code>t</code> 有元方法 <code>__pairs</code>，
则以 <code>t</code> 作为参数调用它，并从调用中返回前三个结果。


</p><p>
否则，
返回三个值：<a href="#pdf-next"><code>next</code></a> 函数、表 <code>t</code> 和 <b>nil</b>，
以便构造

</p><pre>     for k,v in pairs(t) do <em>body</em> end
</pre><p>
将迭代表 <code>t</code> 的所有键值对。


</p><p>
有关在遍历期间修改表的注意事项，请参见函数 <a href="#pdf-next"><code>next</code></a>。




</p><p>
</p><hr><h3><a name="pdf-pcall"><code>pcall (f [, arg1, ···])</code></a></h3>


<p>
在<em>保护模式</em>下使用给定参数调用函数 <code>f</code>。
这意味着 <code>f</code> 内的任何错误都不会传播；
相反，<code>pcall</code> 捕获错误并返回状态码。
其第一个结果是状态码（布尔值），
如果调用成功且没有错误，则为 <b>true</b>。
在这种情况下，<code>pcall</code> 还会在此第一个结果之后返回调用的所有结果。
在出现任何错误的情况下，<code>pcall</code> 返回 <b>false</b> 加上错误对象。
请注意，<code>pcall</code> 捕获的错误不会调用消息处理程序。




</p><p>
</p><hr><h3><a name="pdf-print"><code>print (···)</code></a></h3>
接收任意数量的参数
并将其值打印到 <code>stdout</code>，
将每个参数转换为字符串，
遵循与 <a href="#pdf-tostring"><code>tostring</code></a> 相同的规则。


<p>
函数 <code>print</code> 不用于格式化输出，
而只是作为快速显示值的方法，
例如用于调试。
要完全控制输出，
请使用 <a href="#pdf-string.format"><code>string.format</code></a> 和 <a href="#pdf-io.write"><code>io.write</code></a>。




</p><p>
</p><hr><h3><a name="pdf-rawequal"><code>rawequal (v1, v2)</code></a></h3>
检查 <code>v1</code> 是否等于 <code>v2</code>，
不调用 <code>__eq</code> 元方法。
返回布尔值。




<p>
</p><hr><h3><a name="pdf-rawget"><code>rawget (table, index)</code></a></h3>
获取 <code>table[index]</code> 的实际值，
不使用 <code>__index</code> 元值。
<code>table</code> 必须是一个表；
<code>index</code> 可以是任何值。




<p>
</p><hr><h3><a name="pdf-rawlen"><code>rawlen (v)</code></a></h3>
返回对象 <code>v</code> 的长度，
它必须是表或字符串，
不调用 <code>__len</code> 元方法。
返回整数。




<p>
</p><hr><h3><a name="pdf-rawset"><code>rawset (table, index, value)</code></a></h3>
将 <code>table[index]</code> 的实际值设置为 <code>value</code>，
不使用 <code>__newindex</code> 元值。
<code>table</code> 必须是一个表，
<code>index</code> 是不同于 <b>nil</b> 和 NaN 的任何值，
<code>value</code> 是任何 Lua 值。


<p>
此函数返回 <code>table</code>。




</p><p>
</p><hr><h3><a name="pdf-select"><code>select (index, ···)</code></a></h3>


<p>
如果 <code>index</code> 是数字，
则返回参数编号 <code>index</code> 之后的所有参数；
负数从末尾开始索引（-1 是最后一个参数）。
否则，<code>index</code> 必须是字符串 <code>"#"</code>，
<code>select</code> 返回它接收的额外参数总数。




</p><p>
</p><hr><h3><a name="pdf-setmetatable"><code>setmetatable (table, metatable)</code></a></h3>


<p>
为给定表设置元表。
如果 <code>metatable</code> 是 <b>nil</b>，
则移除给定表的元表。
如果原始元表具有 <code>__metatable</code> 字段，
则引发错误。


</p><p>
此函数返回 <code>table</code>。


</p><p>
要从 Lua 代码更改其他类型的元表，
你必须使用调试库（<a href="#6.10">§6.10</a>）。




</p><p>
</p><hr><h3><a name="pdf-tonumber"><code>tonumber (e [, base])</code></a></h3>


<p>
当不带 <code>base</code> 调用时，
<code>tonumber</code> 尝试将其参数转换为数字。
如果参数已经是数字或可转换为数字的字符串，
那么 <code>tonumber</code> 返回此数字；
否则，它返回 <b>fail</b>。


</p><p>
字符串的转换可以产生整数或浮点数，
根据 Lua 的词法约定（参见 <a href="#3.1">§3.1</a>）。
字符串可以有前导和尾随空格以及符号。


</p><p>
当带 <code>base</code> 调用时，
那么 <code>e</code> 必须是一个字符串，被解释为该基数的整数数字。
基数可以是 2 到 36 之间的任何整数（包括 2 和 36）。
在大于 10 的基数中，字母'<code>A</code>'（大写或小写）
表示 10，'<code>B</code>' 表示 11，依此类推，
'<code>Z</code>' 表示 35。
如果字符串 <code>e</code> 在给定基数中不是有效的数字，
函数返回 <b>fail</b>。




</p><p>
</p><hr><h3><a name="pdf-tostring"><code>tostring (v)</code></a></h3>


<p>
接收任何类型的值并以人类可读的格式将其转换为字符串。


</p><p>
如果 <code>v</code> 的元表具有 <code>__tostring</code> 字段，
那么 <code>tostring</code> 以 <code>v</code> 作为参数调用相应的值，
并使用调用的结果作为其结果。
否则，如果 <code>v</code> 的元表具有带字符串值的 <code>__name</code> 字段，
<code>tostring</code> 可能在其最终结果中使用该字符串。


</p><p>
要完全控制数字的转换方式，
请使用 <a href="#pdf-string.format"><code>string.format</code></a>。




</p><p>
</p><hr><h3><a name="pdf-type"><code>type (v)</code></a></h3>


<p>
返回其唯一参数的类型，编码为字符串。
此函数的可能结果是
"<code>nil</code>"（一个字符串，不是值 <b>nil</b>）、
"<code>number</code>"、
"<code>string</code>"、
"<code>boolean</code>"、
"<code>table</code>"、
"<code>function</code>"、
"<code>thread</code>"
和"<code>userdata</code>"。




</p><p>
</p><hr><h3><a name="pdf-_VERSION"><code>_VERSION</code></a></h3>


<p>
一个全局变量（不是函数），
保存包含正在运行的 Lua 版本的字符串。
此变量的当前值是"<code>Lua 5.4</code>"。




</p><p>
</p><hr><h3><a name="pdf-warn"><code>warn (msg1, ···)</code></a></h3>


<p>
发出一个警告，其消息由其所有参数的连接组成（这些参数应该是字符串）。


</p><p>
按照惯例，
以'<code>@</code>'开头的单段消息旨在作为<em>控制消息</em>，
这是发给警告系统本身的消息。
特别是，Lua 中的标准警告函数识别控制消息"<code>@off</code>"
以停止发出警告，
以及"<code>@on</code>"以（重新）开始发出警告；
它忽略未知的控制消息。




</p><p>
</p><hr><h3><a name="pdf-xpcall"><code>xpcall (f, msgh [, arg1, ···])</code></a></h3>


<p>
此函数类似于 <a href="#pdf-pcall"><code>pcall</code></a>，
只是它设置了一个新的消息处理程序 <code>msgh</code>。







</p><h2>6.2 – <a name="6.2">协程操作</a></h2>

<p>
此库包含操作协程的操作，
这些操作位于表 <a name="pdf-coroutine"><code>coroutine</code></a> 中。
有关协程的一般描述，请参见 <a href="#2.6">§2.6</a>。


</p><p>
</p><hr><h3><a name="pdf-coroutine.close"><code>coroutine.close (co)</code></a></h3>


<p>
关闭协程 <code>co</code>，
也就是说，
关闭其所有待关闭的变量并将协程置于死亡状态。
给定的协程必须是死亡或挂起的。
在出错的情况下
（无论是停止协程的原始错误还是关闭方法中的错误），
返回 <b>false</b> 加上错误对象；
否则返回 <b>true</b>。




</p><p>
</p><hr><h3><a name="pdf-coroutine.create"><code>coroutine.create (f)</code></a></h3>


<p>
创建一个新的协程，主体为 <code>f</code>。
<code>f</code> 必须是一个函数。
返回这个新协程，
一个类型为 <code>"thread"</code> 的对象。




</p><p>
</p><hr><h3><a name="pdf-coroutine.isyieldable"><code>coroutine.isyieldable ([co])</code></a></h3>


<p>
当协程 <code>co</code> 可以让出时返回 <b>true</b>。
<code>co</code> 的默认值是正在运行的协程。


</p><p>
如果协程不是主线程并且不在不可让出的 C 函数内，则协程是可让出的。




</p><p>
</p><hr><h3><a name="pdf-coroutine.resume"><code>coroutine.resume (co [, val1, ···])</code></a></h3>


<p>
启动或继续执行协程 <code>co</code>。
第一次恢复协程时，
它开始运行其主体。
值 <code>val1</code>、... 作为参数传递给主体函数。
如果协程已让出，
<code>resume</code> 重新启动它；
值 <code>val1</code>、... 作为 yield 的结果传递。


</p><p>
如果协程运行没有任何错误，
<code>resume</code> 返回 <b>true</b> 加上传递给 <code>yield</code> 的任何值
（当协程让出时）或主体函数返回的任何值（当协程终止时）。
如果有任何错误，
<code>resume</code> 返回 <b>false</b> 加上错误消息。




</p><p>
</p><hr><h3><a name="pdf-coroutine.running"><code>coroutine.running ()</code></a></h3>


<p>
返回正在运行的协程加上一个布尔值，
当正在运行的协程是主协程时为 <b>true</b>。




</p><p>
</p><hr><h3><a name="pdf-coroutine.status"><code>coroutine.status (co)</code></a></h3>


<p>
以字符串形式返回协程 <code>co</code> 的状态：
<code>"running"</code>，
如果协程正在运行（也就是说，它是调用 <code>status</code> 的协程）；
<code>"suspended"</code>，如果协程在对 <code>yield</code> 的调用中挂起，
或者如果它还没有开始运行；
<code>"normal"</code>，如果协程是活动的但没有运行
（也就是说，它已经恢复了另一个协程）；
以及 <code>"dead"</code>，如果协程已经完成其主体函数，
或者如果它已经因错误而停止。




</p><p>
</p><hr><h3><a name="pdf-coroutine.wrap"><code>coroutine.wrap (f)</code></a></h3>


<p>
创建一个新的协程，主体为 <code>f</code>；
<code>f</code> 必须是一个函数。
返回一个函数，每次调用该函数时都会恢复协程。
传递给此函数的任何参数的行为与 <code>resume</code> 的额外参数相同。
该函数返回与 <code>resume</code> 返回的相同值，
除了第一个布尔值。
在出错的情况下，
函数关闭协程并传播错误。




</p><p>
</p><hr><h3><a name="pdf-coroutine.yield"><code>coroutine.yield (···)</code></a></h3>


<p>
挂起调用协程的执行。
<code>yield</code> 的任何参数都作为额外结果传递给 <code>resume</code>。







</p><h2>6.3 – <a name="6.3">模块</a></h2>

<p>
包库为在 Lua 中加载模块提供基本功能。
它在全局环境中直接导出一个函数：
<a href="#pdf-require"><code>require</code></a>。
其他所有内容都导出在表 <a name="pdf-package"><code>package</code></a> 中。


</p><p>
</p><hr><h3><a name="pdf-require"><code>require (modname)</code></a></h3>


<p>
加载给定的模块。
该函数首先查看 <a href="#pdf-package.loaded"><code>package.loaded</code></a> 表
以确定 <code>modname</code> 是否已加载。
如果已加载，那么 <code>require</code> 返回存储在 <code>package.loaded[modname]</code> 中的值。
（在这种情况下缺少第二个结果表示此调用不必加载模块。）
否则，它会尝试为模块找到<em>加载器</em>。


</p><p>
要找到加载器，
<code>require</code> 由表 <a href="#pdf-package.searchers"><code>package.searchers</code></a> 引导。
此表中的每个项都是一个搜索函数，
以特定方式搜索模块。
通过更改此表，
我们可以更改 <code>require</code> 查找模块的方式。
以下说明基于 <a href="#pdf-package.searchers"><code>package.searchers</code></a> 的默认配置。


</p><p>
首先 <code>require</code> 查询 <code>package.preload[modname]</code>。
如果它有值，
此值（必须是函数）就是加载器。
否则 <code>require</code> 使用存储在 <a href="#pdf-package.path"><code>package.path</code></a> 中的路径搜索 Lua 加载器。
如果那也失败了，它使用存储在 <a href="#pdf-package.cpath"><code>package.cpath</code></a> 中的路径搜索 C 加载器。
如果那也失败了，
它会尝试<em>全合一</em>加载器（参见 <a href="#pdf-package.searchers"><code>package.searchers</code></a>）。


</p><p>
一旦找到加载器，
<code>require</code> 使用两个参数调用加载器：
<code>modname</code> 和一个额外值，
一个<em>加载器数据</em>，
也由搜索器返回。
加载器数据可以是对模块有用的任何值；
对于默认搜索器，
它指示找到加载器的位置。
（例如，如果加载器来自文件，
此额外值就是文件路径。）
如果加载器返回任何非 nil 值，
<code>require</code> 将返回的值分配给 <code>package.loaded[modname]</code>。
如果加载器不返回非 nil 值并且未向 <code>package.loaded[modname]</code> 分配任何值，
那么 <code>require</code> 将 <b>true</b> 分配给此条目。
无论哪种情况，<code>require</code> 都返回 <code>package.loaded[modname]</code> 的最终值。
除了该值之外，<code>require</code> 还将搜索器返回的加载器数据作为第二个结果返回，
它指示 <code>require</code> 如何找到模块。


</p><p>
如果在加载或运行模块时有任何错误，
或者如果它找不到该模块的任何加载器，
那么 <code>require</code> 会引发错误。




</p><p>
</p><hr><h3><a name="pdf-package.config"><code>package.config</code></a></h3>


<p>
描述包的一些编译时配置的字符串。
此字符串是一系列行：

</p><ul>

<li>第一行是目录分隔符字符串。
对于 Windows，默认为'<code>\</code>'，对于所有其他系统默认为'<code>/</code>'。</li>

<li>第二行是在路径中分隔模板的字符。
默认为'<code>;</code>'。</li>

<li>第三行是标记模板中替换点的字符串。
默认为'<code>?</code>'。</li>

<li>第四行是在 Windows 的路径中被可执行文件目录替换的字符串。
默认为'<code>!</code>'。</li>

<li>第五行是构建 <code>luaopen_</code> 函数名时忽略其后所有文本的标记。
默认为'<code>-</code>'。</li>

</ul>



<p>
</p><hr><h3><a name="pdf-package.cpath"><code>package.cpath</code></a></h3>


<p>
<a href="#pdf-require"><code>require</code></a> 用于搜索 C 加载器的路径字符串。


</p><p>
Lua 以与初始化 Lua 路径 <a href="#pdf-package.path"><code>package.path</code></a> 相同的方式初始化 C 路径 <a href="#pdf-package.cpath"><code>package.cpath</code></a>，
使用环境变量 <a name="pdf-LUA_CPATH_5_4"><code>LUA_CPATH_5_4</code></a>，
或环境变量 <a name="pdf-LUA_CPATH"><code>LUA_CPATH</code></a>，
或 <code>luaconf.h</code> 中定义的默认路径。




</p><p>
</p><hr><h3><a name="pdf-package.loaded"><code>package.loaded</code></a></h3>


<p>
<a href="#pdf-require"><code>require</code></a> 用于控制哪些模块已加载的表。
当你请求模块 <code>modname</code> 并且 <code>package.loaded[modname]</code> 不为假时，
<a href="#pdf-require"><code>require</code></a> 只是返回存储在那里的值。


</p><p>
此变量只是对实际表的引用；
对此变量的赋值不会更改 <a href="#pdf-require"><code>require</code></a> 使用的表。
实际表存储在 C 注册表中（参见 <a href="#4.3">§4.3</a>），
由键 <a name="pdf-LUA_LOADED_TABLE"><code>LUA_LOADED_TABLE</code></a>（一个字符串）索引。




</p><p>
</p><hr><h3><a name="pdf-package.loadlib"><code>package.loadlib (libname, funcname)</code></a></h3>


<p>
动态链接宿主程序与 C 库 <code>libname</code>。


</p><p>
如果 <code>funcname</code> 是"<code>*</code>"，
那么它只与库链接，
使库导出的符号对其他动态链接库可用。
否则，
它在库中查找函数 <code>funcname</code>
并将此函数作为 C 函数返回。
因此，<code>funcname</code> 必须遵循 <a href="#lua_CFunction"><code>lua_CFunction</code></a> 原型
（参见 <a href="#lua_CFunction"><code>lua_CFunction</code></a>）。


</p><p>
这是一个低级函数。
它完全绕过包和模块系统。
与 <a href="#pdf-require"><code>require</code></a> 不同，
它不执行任何路径搜索并且不自动添加扩展名。
<code>libname</code> 必须是 C 库的完整文件名，
必要时包括路径和扩展名。
<code>funcname</code> 必须是 C 库导出的确切名称
（这可能取决于使用的 C 编译器和链接器）。


</p><p>
此功能不受 ISO C 支持。
因此，它仅在某些平台上可用
（Windows、Linux、Mac OS X、Solaris、BSD，
以及其他支持 <code>dlfcn</code> 标准的 Unix 系统）。


</p><p>
此函数本质上是不安全的，
因为它允许 Lua 在系统中任何可读的动态库中调用任何函数。
（Lua 调用任何函数时都假定该函数具有正确的原型并遵守正确的协议
（参见 <a href="#lua_CFunction"><code>lua_CFunction</code></a>）。
因此，
在任意动态库中调用任意函数往往会导致访问冲突。）




</p><p>
</p><hr><h3><a name="pdf-package.path"><code>package.path</code></a></h3>


<p>
<a href="#pdf-require"><code>require</code></a> 用于搜索 Lua 加载器的路径字符串。


</p><p>
启动时，Lua 使用环境变量 <a name="pdf-LUA_PATH_5_4"><code>LUA_PATH_5_4</code></a> 的值
或环境变量 <a name="pdf-LUA_PATH"><code>LUA_PATH</code></a> 的值
或 <code>luaconf.h</code> 中定义的默认路径初始化此变量，
如果这些环境变量未定义。
环境变量值中的"<code>;;</code>"
会被默认路径替换。




</p><p>
</p><hr><h3><a name="pdf-package.preload"><code>package.preload</code></a></h3>


<p>
用于存储特定模块的加载器的表
（参见 <a href="#pdf-require"><code>require</code></a>）。


</p><p>
此变量只是对实际表的引用；
对此变量的赋值不会更改 <a href="#pdf-require"><code>require</code></a> 使用的表。
实际表存储在 C 注册表中（参见 <a href="#4.3">§4.3</a>），
由键 <a name="pdf-LUA_PRELOAD_TABLE"><code>LUA_PRELOAD_TABLE</code></a>（一个字符串）索引。




</p><p>
</p><hr><h3><a name="pdf-package.searchers"><code>package.searchers</code></a></h3>


<p>
<a href="#pdf-require"><code>require</code></a> 用于控制如何查找模块的表。


</p><p>
此表中的每个条目都是一个<em>搜索器函数</em>。
在查找模块时，
<a href="#pdf-require"><code>require</code></a> 以升序调用每个搜索器，
将模块名（给 <a href="#pdf-require"><code>require</code></a> 的参数）作为其唯一参数。
如果搜索器找到模块，
它返回另一个函数，模块<em>加载器</em>，
加上一个额外值，一个<em>加载器数据</em>，
该数据将传递给该加载器并作为 <a href="#pdf-require"><code>require</code></a> 的第二个结果返回。
如果它找不到模块，
它返回一个解释原因的字符串
（如果它无话可说则返回 <b>nil</b>）。


</p><p>
Lua 用四个搜索器函数初始化此表。


</p><p>
第一个搜索器只是在 <a href="#pdf-package.preload"><code>package.preload</code></a> 表中查找加载器。


</p><p>
第二个搜索器使用存储在 <a href="#pdf-package.path"><code>package.path</code></a> 中的路径查找 Lua 库的加载器。
搜索按函数 <a href="#pdf-package.searchpath"><code>package.searchpath</code></a> 中描述的方式进行。


</p><p>
第三个搜索器使用变量 <a href="#pdf-package.cpath"><code>package.cpath</code></a> 给定的路径查找 C 库的加载器。
同样，
搜索按函数 <a href="#pdf-package.searchpath"><code>package.searchpath</code></a> 中描述的方式进行。
例如，
如果 C 路径是字符串

</p><pre>     "./?.so;./?.dll;/usr/local/?/init.so"
</pre><p>
模块 <code>foo</code> 的搜索器将按该顺序尝试打开文件 <code>./foo.so</code>、<code>./foo.dll</code>
和 <code>/usr/local/foo/init.so</code>。
一旦找到 C 库，
此搜索器首先使用动态链接设施将应用程序与库链接。
然后它尝试在库中找到一个 C 函数作为加载器使用。
此 C 函数的名称是字符串"<code>luaopen_</code>"
连接模块名的副本，其中每个点都被下划线替换。
此外，如果模块名有连字符，
其（包括）第一个连字符之后的后缀会被移除。
例如，如果模块名是 <code>a.b.c-v2.1</code>，
函数名将是 <code>luaopen_a_b_c</code>。


</p><p>
第四个搜索器尝试<em>全合一加载器</em>。
它在 C 路径中搜索给定模块的根名称的库。
例如，在请求 <code>a.b.c</code> 时，
它将搜索 <code>a</code> 的 C 库。
如果找到，它会在其中查找子模块的打开函数；
在我们的例子中，那将是 <code>luaopen_a_b_c</code>。
有了这个功能，包可以将多个 C 子模块打包到一个库中，
每个子模块保持其原始打开函数。


</p><p>
除第一个（预加载）之外的所有搜索器都将找到模块的文件路径作为额外值返回，
由 <a href="#pdf-package.searchpath"><code>package.searchpath</code></a> 返回。
第一个搜索器总是返回字符串"<code>:preload:</code>"。


</p><p>
搜索器不应引发错误且在 Lua 中不应有副作用。
（它们可能在 C 中有副作用，
例如通过将应用程序与库链接。）




</p><p>
</p><hr><h3><a name="pdf-package.searchpath"><code>package.searchpath (name, path [, sep [, rep]])</code></a></h3>


<p>
在给定的 <code>path</code> 中搜索给定的 <code>name</code>。


</p><p>
路径是包含由分号分隔的<em>模板</em>序列的字符串。
对于每个模板，
函数将模板中的每个问号（如果有）
替换为 <code>name</code> 的副本，
其中所有出现的 <code>sep</code>（默认为点）
都被 <code>rep</code>（默认为系统的目录分隔符）替换，
然后尝试打开结果文件名。


</p><p>
例如，如果路径是字符串

</p><pre>     "./?.lua;./?.lc;/usr/local/?/init.lua"
</pre><p>
对名称 <code>foo.a</code> 的搜索
将按该顺序尝试打开文件
<code>./foo/a.lua</code>、<code>./foo/a.lc</code> 和
<code>/usr/local/foo/a/init.lua</code>。


</p><p>
返回它可以在读取模式下打开的第一个文件的结果名称（在关闭文件之后），
如果都不成功则返回 <b>fail</b> 加上错误消息。
（此错误消息列出了它尝试打开的所有文件名。）







</p><h2>6.4 – <a name="6.4">字符串操作</a></h2>



<p>
此库提供字符串操作的通用函数，
例如查找和提取子字符串以及模式匹配。
在 Lua 中索引字符串时，第一个字符在位置 1
（不在 0，如 C 中）。
索引允许为负数，并被解释为从字符串末尾向后索引。
因此，最后一个字符在位置 -1，依此类推。


</p><p>
<!-- slice ends -->

<!-- slice index: 6 -->
<!-- lines 7479–8973 / total 11964 -->
<!-- title: 6 – The Standard Libraries -->
<p>
完成对缓冲区 <code>B</code> 的使用，将最终字符串留在栈顶。





</p><hr><h3><a name="luaL_pushresultsize"><code>luaL_pushresultsize</code></a></h3><p>
<span class="apii">[-?, +1, <em>m</em>]</span>
</p><pre>void luaL_pushresultsize (luaL_Buffer *B, size_t sz);</pre>

<p>
等价于序列 <a href="#luaL_addsize"><code>luaL_addsize</code></a>, <a href="#luaL_pushresult"><code>luaL_pushresult</code></a>。





</p><hr><h3><a name="luaL_ref"><code>luaL_ref</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>
</p><pre>int luaL_ref (lua_State *L, int t);</pre>

<p>
在索引 <code>t</code> 处的表中，为栈顶的对象创建并返回一个<em>引用</em>（并弹出该对象）。


</p><p>
引用是一个唯一的整数键。
只要你不手动向表 <code>t</code> 中添加整数键，
<a href="#luaL_ref"><code>luaL_ref</code></a> 就能确保它返回的键的唯一性。
你可以通过调用 <code>lua_rawgeti(L, t, r)</code> 来检索引用 <code>r</code> 所指向的对象。
函数 <a href="#luaL_unref"><code>luaL_unref</code></a> 用于释放引用。


</p><p>
如果栈顶的对象是 <b>nil</b>，
<a href="#luaL_ref"><code>luaL_ref</code></a> 返回常量 <a name="pdf-LUA_REFNIL"><code>LUA_REFNIL</code></a>。
常量 <a name="pdf-LUA_NOREF"><code>LUA_NOREF</code></a> 保证与 <a href="#luaL_ref"><code>luaL_ref</code></a> 返回的任何引用都不同。





</p><hr><h3><a name="luaL_Reg"><code>luaL_Reg</code></a></h3>
<pre>typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;</pre>

<p>
用于由 <a href="#luaL_setfuncs"><code>luaL_setfuncs</code></a> 注册的函数数组的类型。
<code>name</code> 是函数名，<code>func</code> 是指向函数的指针。
任何 <a href="#luaL_Reg"><code>luaL_Reg</code></a> 数组必须以一个哨兵条目结束，
其中 <code>name</code> 和 <code>func</code> 都是 <code>NULL</code>。





</p><hr><h3><a name="luaL_requiref"><code>luaL_requiref</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
</p><pre>void luaL_requiref (lua_State *L, const char *modname,
                    lua_CFunction openf, int glb);</pre>

<p>
如果 <code>package.loaded[modname]</code> 不为真，
则以字符串 <code>modname</code> 作为参数调用函数 <code>openf</code>，
并将调用结果设置到 <code>package.loaded[modname]</code>，
就像该函数是通过 <a href="#pdf-require"><code>require</code></a> 调用的一样。


</p><p>
如果 <code>glb</code> 为真，
还会将模块存储到全局变量 <code>modname</code> 中。


</p><p>
在栈上留下模块的副本。





</p><hr><h3><a name="luaL_setfuncs"><code>luaL_setfuncs</code></a></h3><p>
<span class="apii">[-nup, +0, <em>m</em>]</span>
</p><pre>void luaL_setfuncs (lua_State *L, const luaL_Reg *l, int nup);</pre>

<p>
将数组 <code>l</code> 中的所有函数（参见 <a href="#luaL_Reg"><code>luaL_Reg</code></a>）注册到栈顶的表中
（位于可选的上值下方，见下文）。


</p><p>
当 <code>nup</code> 不为零时，
所有函数都会创建 <code>nup</code> 个上值，
这些上值用之前在库表之上压入栈的 <code>nup</code> 个值的副本初始化。
这些值在注册后会从栈中弹出。


</p><p>
值为 <code>NULL</code> 的函数表示一个占位符，
会被填充为 <b>false</b>。





</p><hr><h3><a name="luaL_setmetatable"><code>luaL_setmetatable</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void luaL_setmetatable (lua_State *L, const char *tname);</pre>

<p>
将栈顶对象的元表设置为在注册表中与名称 <code>tname</code> 关联的元表
（参见 <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>）。





</p><hr><h3><a name="luaL_Stream"><code>luaL_Stream</code></a></h3>
<pre>typedef struct luaL_Stream {
  FILE *f;
  lua_CFunction closef;
} luaL_Stream;</pre>

<p>
标准 I/O 库使用的文件句柄的标准表示。


</p><p>
文件句柄实现为完全用户数据，
具有名为 <code>LUA_FILEHANDLE</code> 的元表
（其中 <code>LUA_FILEHANDLE</code> 是包含实际元表名称的宏）。
该元表由 I/O 库创建（参见 <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>）。


</p><p>
该用户数据必须以结构 <code>luaL_Stream</code> 开头；
它可以在此初始结构之后包含其他数据。
字段 <code>f</code> 指向相应的 C 流
（或者它可以是 <code>NULL</code> 以表示一个未完全创建的句柄）。
字段 <code>closef</code> 指向一个 Lua 函数，
当句柄关闭或被收集时，该函数将被调用以关闭流；
此函数接收文件句柄作为其唯一参数，
并且必须在成功时返回真值，
或在出错时返回假值加上错误消息。
一旦 Lua 调用了此字段，
它会将字段值更改为 <code>NULL</code>
以表示句柄已关闭。





</p><hr><h3><a name="luaL_testudata"><code>luaL_testudata</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
</p><pre>void *luaL_testudata (lua_State *L, int arg, const char *tname);</pre>

<p>
此函数的工作方式类似于 <a href="#luaL_checkudata"><code>luaL_checkudata</code></a>，
但是当测试失败时，
它返回 <code>NULL</code> 而不是引发错误。





</p><hr><h3><a name="luaL_tolstring"><code>luaL_tolstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
</p><pre>const char *luaL_tolstring (lua_State *L, int idx, size_t *len);</pre>

<p>
以合理的格式将给定索引处的任何 Lua 值转换为 C 字符串。
结果字符串被压入栈并且也由函数返回（参见 <a href="#4.1.3">§4.1.3</a>）。
如果 <code>len</code> 不是 <code>NULL</code>，
函数还会将 <code>*len</code> 设置为字符串长度。


</p><p>
如果值具有带 <code>__tostring</code> 字段的元表，
那么 <code>luaL_tolstring</code> 会以该值作为参数调用相应的元方法，
并使用调用的结果作为其结果。





</p><hr><h3><a name="luaL_traceback"><code>luaL_traceback</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>void luaL_traceback (lua_State *L, lua_State *L1, const char *msg,
                     int level);</pre>

<p>
创建并压入栈 <code>L1</code> 的回溯。
如果 <code>msg</code> 不是 <code>NULL</code>，它会被附加在回溯的开头。
<code>level</code> 参数指示从哪个级别开始回溯。





</p><hr><h3><a name="luaL_typeerror"><code>luaL_typeerror</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>int luaL_typeerror (lua_State *L, int arg, const char *tname);</pre>

<p>
为调用它的 C 函数的参数 <code>arg</code> 引发类型错误，
使用标准消息；
<code>tname</code> 是预期类型的"名称"。
此函数永不返回。





</p><hr><h3><a name="luaL_typename"><code>luaL_typename</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>const char *luaL_typename (lua_State *L, int index);</pre>

<p>
返回给定索引处值的类型名称。





</p><hr><h3><a name="luaL_unref"><code>luaL_unref</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void luaL_unref (lua_State *L, int t, int ref);</pre>

<p>
从索引 <code>t</code> 处的表中释放引用 <code>ref</code>
（参见 <a href="#luaL_ref"><code>luaL_ref</code></a>）。
该条目从表中移除，
以便引用的对象可以被收集。
引用 <code>ref</code> 也被释放以便再次使用。


</p><p>
如果 <code>ref</code> 是 <a href="#pdf-LUA_NOREF"><code>LUA_NOREF</code></a> 或 <a href="#pdf-LUA_REFNIL"><code>LUA_REFNIL</code></a>，
<a href="#luaL_unref"><code>luaL_unref</code></a> 不做任何操作。





</p><hr><h3><a name="luaL_where"><code>luaL_where</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>void luaL_where (lua_State *L, int lvl);</pre>

<p>
将一个字符串压入栈，该字符串标识调用栈中级别 <code>lvl</code> 处的控制位置。
通常此字符串具有以下格式：

</p><pre>     <em>chunkname</em>:<em>currentline</em>:
</pre><p>
级别 0 是正在运行的函数，
级别 1 是调用正在运行的函数的函数，
依此类推。


</p><p>
此函数用于为错误消息构建前缀。







</p><h1>6 – <a name="6">标准库</a></h1>



<p>
标准 Lua 库提供了通过 C API 在 C 中实现的有用函数。
其中一些函数为语言提供基本服务
（例如 <a href="#pdf-type"><code>type</code></a> 和 <a href="#pdf-getmetatable"><code>getmetatable</code></a>）；
另一些提供对外部服务的访问（例如 I/O）；
还有一些本可以在 Lua 中实现，
但由于不同原因值得用 C 实现（例如 <a href="#pdf-table.sort"><code>table.sort</code></a>）。


</p><p>
所有库都是通过官方 C API 实现的，
并作为独立的 C 模块提供。
除非另有说明，
这些库函数不会将其参数数量调整为其预期参数。
例如，文档记载为 <code>foo(arg)</code> 的函数不应在没有参数的情况下调用。


</p><p>
符号 <b>fail</b> 表示代表某种失败的假值。
（目前，<b>fail</b> 等于 <b>nil</b>，
但这可能在未来版本中改变。
建议始终使用 <code>(not status)</code> 测试这些函数的成功，
而不是 <code>(status == nil)</code>。）


</p><p>
目前，Lua 具有以下标准库：

</p><ul>

<li>基础库（<a href="#6.1">§6.1</a>）；</li>

<li>协程库（<a href="#6.2">§6.2</a>）；</li>

<li>包库（<a href="#6.3">§6.3</a>）；</li>

<li>字符串操作（<a href="#6.4">§6.4</a>）；</li>

<li>基本 UTF-8 支持（<a href="#6.5">§6.5</a>）；</li>

<li>表操作（<a href="#6.6">§6.6</a>）；</li>

<li>数学函数（<a href="#6.7">§6.7</a>）（sin、log 等）；</li>

<li>输入和输出（<a href="#6.8">§6.8</a>）；</li>

<li>操作系统设施（<a href="#6.9">§6.9</a>）；</li>

<li>调试设施（<a href="#6.10">§6.10</a>）。</li>

</ul><p>
除了基础库和包库，
每个库都将其所有函数作为全局表的字段或其对象的方法提供。


</p><p>
要访问这些库，
C 宿主程序应调用 <a href="#luaL_openlibs"><code>luaL_openlibs</code></a> 函数，
它会打开所有标准库。
或者，
宿主程序可以通过使用 <a href="#luaL_requiref"><code>luaL_requiref</code></a> 
单独打开它们，调用
<a name="pdf-luaopen_base"><code>luaopen_base</code></a>（用于基础库），
<a name="pdf-luaopen_package"><code>luaopen_package</code></a>（用于包库），
<a name="pdf-luaopen_coroutine"><code>luaopen_coroutine</code></a>（用于协程库），
<a name="pdf-luaopen_string"><code>luaopen_string</code></a>（用于字符串库），
<a name="pdf-luaopen_utf8"><code>luaopen_utf8</code></a>（用于 UTF-8 库），
<a name="pdf-luaopen_table"><code>luaopen_table</code></a>（用于表库），
<a name="pdf-luaopen_math"><code>luaopen_math</code></a>（用于数学库），
<a name="pdf-luaopen_io"><code>luaopen_io</code></a>（用于 I/O 库），
<a name="pdf-luaopen_os"><code>luaopen_os</code></a>（用于操作系统库），
以及 <a name="pdf-luaopen_debug"><code>luaopen_debug</code></a>（用于调试库）。
这些函数在 <a name="pdf-lualib.h"><code>lualib.h</code></a> 中声明。





</p><h2>6.1 – <a name="6.1">基础函数</a></h2>

<p>
基础库为 Lua 提供核心函数。
如果你的应用程序中不包含此库，
你应该仔细检查是否需要为其某些功能提供实现。


</p><p>
</p><hr><h3><a name="pdf-assert"><code>assert (v [, message])</code></a></h3>


<p>
如果其参数 <code>v</code> 的值为假（即 <b>nil</b> 或 <b>false</b>），则引发错误；
否则，返回其所有参数。
在出错的情况下，
<code>message</code> 是错误对象；
当缺省时，它默认为"<code>assertion failed!</code>"




</p><p>
</p><hr><h3><a name="pdf-collectgarbage"><code>collectgarbage ([opt [, arg]])</code></a></h3>


<p>
此函数是垃圾收集器的通用接口。
它根据其第一个参数 <code>opt</code> 执行不同的函数：

</p><ul>

<li><b>"<code>collect</code>"：</b>
执行完整的垃圾收集周期。
这是默认选项。
</li>

<li><b>"<code>stop</code>"：</b>
停止垃圾收集器的自动执行。
收集器仅在显式调用时运行，
直到重新启动它的调用。
</li>

<li><b>"<code>restart</code>"：</b>
重新启动垃圾收集器的自动执行。
</li>

<li><b>"<code>count</code>"：</b>
以 Kbytes 为单位返回 Lua 使用的总内存。
该值有小数部分，
因此乘以 1024 可得到 Lua 使用的确切字节数。
</li>

<li><b>"<code>step</code>"：</b>
执行垃圾收集步骤。
步骤"大小"由 <code>arg</code> 控制。
值为零时，
收集器将执行一个基本（不可分割）步骤。
对于非零值，
收集器将像 Lua 分配了那么多内存（以 Kbytes 为单位）一样执行。
如果步骤完成了收集周期，则返回 <b>true</b>。
</li>

<li><b>"<code>isrunning</code>"：</b>
返回一个布尔值，指示收集器是否正在运行（即未停止）。
</li>

<li><b>"<code>incremental</code>"：</b>
将收集器模式更改为增量模式。
此选项后面可以跟三个数字：
垃圾收集器暂停、
步进乘数
和步长（参见 <a href="#2.5.1">§2.5.1</a>）。
零表示不更改该值。
</li>

<li><b>"<code>generational</code>"：</b>
将收集器模式更改为分代模式。
此选项后面可以跟两个数字：
垃圾收集器次要乘数
和主要乘数（参见 <a href="#2.5.2">§2.5.2</a>）。
零表示不更改该值。
</li>

</ul><p>
有关垃圾收集和其中一些选项的更多详细信息，请参见 <a href="#2.5">§2.5</a>。


</p><p>
此函数不应被析构器调用。




</p><p>
</p><hr><h3><a name="pdf-dofile"><code>dofile ([filename])</code></a></h3>
打开指定文件并将其内容作为 Lua 代码块执行。
当不带参数调用时，
<code>dofile</code> 执行标准输入（<code>stdin</code>）的内容。
返回代码块返回的所有值。
在出错的情况下，<code>dofile</code> 将错误传播给其调用者。
（也就是说，<code>dofile</code> 不在保护模式下运行。）




<p>
</p><hr><h3><a name="pdf-error"><code>error (message [, level])</code></a></h3>
以 <code>message</code> 作为错误对象引发错误（参见 <a href="#2.3">§2.3</a>）。
此函数永不返回。


<p>
通常，<code>error</code> 会在消息开头添加一些关于错误位置的信息，
如果消息是字符串的话。
<code>level</code> 参数指定如何获取错误位置。
对于级别 1（默认值），错误位置是调用 <code>error</code> 函数的地方。
级别 2 将错误指向调用 <code>error</code> 的函数被调用的地方；
依此类推。
传递级别 0 可避免向消息添加错误位置信息。




</p><p>
</p><hr><h3><a name="pdf-_G"><code>_G</code></a></h3>
一个全局变量（不是函数），
保存全局环境（参见 <a href="#2.2">§2.2</a>）。
Lua 本身不使用此变量；
更改其值不会影响任何环境，
反之亦然。




<p>
</p><hr><h3><a name="pdf-getmetatable"><code>getmetatable (object)</code></a></h3>


<p>
如果 <code>object</code> 没有元表，则返回 <b>nil</b>。
否则，
如果对象的元表具有 <code>__metatable</code> 字段，
则返回关联的值。
否则，返回给定对象的元表。




</p><p>
</p><hr><h3><a name="pdf-ipairs"><code>ipairs (t)</code></a></h3>


<p>
返回三个值（一个迭代器函数、表 <code>t</code> 和 0），
以便构造

</p><pre>     for i,v in ipairs(t) do <em>body</em> end
</pre><p>
将迭代键值对
(<code>1,t[1]</code>)、(<code>2,t[2]</code>)、...，
直到第一个缺失的索引。




</p><p>
</p><hr><h3><a name="pdf-load"><code>load (chunk [, chunkname [, mode [, env]]])</code></a></h3>


<p>
加载一个代码块。


</p><p>
如果 <code>chunk</code> 是一个字符串，则代码块就是这个字符串。
如果 <code>chunk</code> 是一个函数，
<code>load</code> 重复调用它以获取代码块片段。
每次调用 <code>chunk</code> 必须返回一个字符串，该字符串与之前的结果连接。
返回空字符串、<b>nil</b> 或无值表示代码块结束。


</p><p>
如果没有语法错误，
<code>load</code> 将编译后的代码块作为函数返回；
否则，它返回 <b>fail</b> 加上错误消息。


</p><p>
当你加载一个主代码块时，
结果函数将始终恰好有一个上值，
即 <code>_ENV</code> 变量（参见 <a href="#2.2">§2.2</a>）。
然而，
当你加载从函数创建的二进制代码块时（参见 <a href="#pdf-string.dump"><code>string.dump</code></a>），
结果函数可以有任意数量的上值，
并且不保证其第一个上值是 <code>_ENV</code> 变量。
（非主函数甚至可能没有 <code>_ENV</code> 上值。）


</p><p>
无论如何，如果结果函数有任何上值，
其第一个上值设置为 <code>env</code> 的值，
如果给定了该参数，
或者设置为全局环境的值。
其他上值用 <b>nil</b> 初始化。
所有上值都是新鲜的，也就是说，
它们不与任何其他函数共享。


</p><p>
<code>chunkname</code> 用作错误消息和调试信息的代码块名称（参见 <a href="#4.7">§4.7</a>）。
当缺省时，
如果 <code>chunk</code> 是字符串，它默认为 <code>chunk</code>，
否则为"<code>=(load)</code>"。


</p><p>
字符串 <code>mode</code> 控制代码块是文本还是二进制（即预编译的代码块）。
它可以是字符串"<code>b</code>"（仅二进制代码块）、
"<code>t</code>"（仅文本代码块）
或"<code>bt</code>"（二进制和文本）。
默认为"<code>bt</code>"。


</p><p>
加载格式错误的二进制代码块是安全的；
<code>load</code> 会发出适当的错误信号。
然而，
Lua 不会检查二进制代码块内代码的一致性；
运行恶意制作的字节码可能会使解释器崩溃。




</p><p>
</p><hr><h3><a name="pdf-loadfile"><code>loadfile ([filename [, mode [, env]]])</code></a></h3>


<p>
类似于 <a href="#pdf-load"><code>load</code></a>，
但从文件 <code>filename</code> 获取代码块，
或如果未给定文件名，则从标准输入获取。




</p><p>
</p><hr><h3><a name="pdf-next"><code>next (table [, index])</code></a></h3>


<p>
允许程序遍历表的所有字段。
其第一个参数是一个表，其第二个参数是此表中的索引。
调用 <code>next</code> 返回表的下一个索引及其关联的值。
当以 <b>nil</b> 作为其第二个参数调用时，
<code>next</code> 返回初始索引及其关联的值。
当以最后一个索引调用，
或在空表中以 <b>nil</b> 调用时，
<code>next</code> 返回 <b>nil</b>。
如果第二个参数缺失，则解释为 <b>nil</b>。
特别地，
你可以使用 <code>next(t)</code> 来检查表是否为空。


</p><p>
枚举索引的顺序未指定，
<em>即使对于数字索引也是如此</em>。
（要按数字顺序遍历表，请使用数字 <b>for</b>。）


</p><p>
在遍历表期间，你不应向表中的不存在字段分配任何值。
但是，你可以修改现有字段。
特别是，你可以将现有字段设置为 nil。




</p><p>
</p><hr><h3><a name="pdf-pairs"><code>pairs (t)</code></a></h3>


<p>
如果 <code>t</code> 有元方法 <code>__pairs</code>，
则以 <code>t</code> 作为参数调用它，并从调用中返回前三个结果。


</p><p>
否则，
返回三个值：<a href="#pdf-next"><code>next</code></a> 函数、表 <code>t</code> 和 <b>nil</b>，
以便构造

</p><pre>     for k,v in pairs(t) do <em>body</em> end
</pre><p>
将迭代表 <code>t</code> 的所有键值对。


</p><p>
有关在遍历期间修改表的注意事项，请参见函数 <a href="#pdf-next"><code>next</code></a>。




</p><p>
</p><hr><h3><a name="pdf-pcall"><code>pcall (f [, arg1, ···])</code></a></h3>


<p>
在<em>保护模式</em>下使用给定参数调用函数 <code>f</code>。
这意味着 <code>f</code> 内的任何错误都不会传播；
相反，<code>pcall</code> 捕获错误并返回状态码。
其第一个结果是状态码（布尔值），
如果调用成功且没有错误，则为 <b>true</b>。
在这种情况下，<code>pcall</code> 还会在此第一个结果之后返回调用的所有结果。
在出现任何错误的情况下，<code>pcall</code> 返回 <b>false</b> 加上错误对象。
请注意，<code>pcall</code> 捕获的错误不会调用消息处理程序。




</p><p>
</p><hr><h3><a name="pdf-print"><code>print (···)</code></a></h3>
接收任意数量的参数
并将其值打印到 <code>stdout</code>，
将每个参数转换为字符串，
遵循与 <a href="#pdf-tostring"><code>tostring</code></a> 相同的规则。


<p>
函数 <code>print</code> 不用于格式化输出，
而只是作为快速显示值的方法，
例如用于调试。
要完全控制输出，
请使用 <a href="#pdf-string.format"><code>string.format</code></a> 和 <a href="#pdf-io.write"><code>io.write</code></a>。




</p><p>
</p><hr><h3><a name="pdf-rawequal"><code>rawequal (v1, v2)</code></a></h3>
检查 <code>v1</code> 是否等于 <code>v2</code>，
不调用 <code>__eq</code> 元方法。
返回布尔值。




<p>
</p><hr><h3><a name="pdf-rawget"><code>rawget (table, index)</code></a></h3>
获取 <code>table[index]</code> 的实际值，
不使用 <code>__index</code> 元值。
<code>table</code> 必须是一个表；
<code>index</code> 可以是任何值。




<p>
</p><hr><h3><a name="pdf-rawlen"><code>rawlen (v)</code></a></h3>
返回对象 <code>v</code> 的长度，
它必须是表或字符串，
不调用 <code>__len</code> 元方法。
返回整数。




<p>
</p><hr><h3><a name="pdf-rawset"><code>rawset (table, index, value)</code></a></h3>
将 <code>table[index]</code> 的实际值设置为 <code>value</code>，
不使用 <code>__newindex</code> 元值。
<code>table</code> 必须是一个表，
<code>index</code> 是不同于 <b>nil</b> 和 NaN 的任何值，
<code>value</code> 是任何 Lua 值。


<p>
此函数返回 <code>table</code>。




</p><p>
</p><hr><h3><a name="pdf-select"><code>select (index, ···)</code></a></h3>


<p>
如果 <code>index</code> 是数字，
则返回参数编号 <code>index</code> 之后的所有参数；
负数从末尾开始索引（-1 是最后一个参数）。
否则，<code>index</code> 必须是字符串 <code>"#"</code>，
<code>select</code> 返回它接收的额外参数总数。




</p><p>
</p><hr><h3><a name="pdf-setmetatable"><code>setmetatable (table, metatable)</code></a></h3>


<p>
为给定表设置元表。
如果 <code>metatable</code> 是 <b>nil</b>，
则移除给定表的元表。
如果原始元表具有 <code>__metatable</code> 字段，
则引发错误。


</p><p>
此函数返回 <code>table</code>。


</p><p>
要从 Lua 代码更改其他类型的元表，
你必须使用调试库（<a href="#6.10">§6.10</a>）。




</p><p>
</p><hr><h3><a name="pdf-tonumber"><code>tonumber (e [, base])</code></a></h3>


<p>
当不带 <code>base</code> 调用时，
<code>tonumber</code> 尝试将其参数转换为数字。
如果参数已经是数字或可转换为数字的字符串，
那么 <code>tonumber</code> 返回此数字；
否则，它返回 <b>fail</b>。


</p><p>
字符串的转换可以产生整数或浮点数，
根据 Lua 的词法约定（参见 <a href="#3.1">§3.1</a>）。
字符串可以有前导和尾随空格以及符号。


</p><p>
当带 <code>base</code> 调用时，
那么 <code>e</code> 必须是一个字符串，被解释为该基数的整数数字。
基数可以是 2 到 36 之间的任何整数（包括 2 和 36）。
在大于 10 的基数中，字母'<code>A</code>'（大写或小写）
表示 10，'<code>B</code>' 表示 11，依此类推，
'<code>Z</code>' 表示 35。
如果字符串 <code>e</code> 在给定基数中不是有效的数字，
函数返回 <b>fail</b>。




</p><p>
</p><hr><h3><a name="pdf-tostring"><code>tostring (v)</code></a></h3>


<p>
接收任何类型的值并以人类可读的格式将其转换为字符串。


</p><p>
如果 <code>v</code> 的元表具有 <code>__tostring</code> 字段，
那么 <code>tostring</code> 以 <code>v</code> 作为参数调用相应的值，
并使用调用的结果作为其结果。
否则，如果 <code>v</code> 的元表具有带字符串值的 <code>__name</code> 字段，
<code>tostring</code> 可能在其最终结果中使用该字符串。


</p><p>
要完全控制数字的转换方式，
请使用 <a href="#pdf-string.format"><code>string.format</code></a>。




</p><p>
</p><hr><h3><a name="pdf-type"><code>type (v)</code></a></h3>


<p>
返回其唯一参数的类型，编码为字符串。
此函数的可能结果是
"<code>nil</code>"（一个字符串，不是值 <b>nil</b>）、
"<code>number</code>"、
"<code>string</code>"、
"<code>boolean</code>"、
"<code>table</code>"、
"<code>function</code>"、
"<code>thread</code>"
和"<code>userdata</code>"。




</p><p>
</p><hr><h3><a name="pdf-_VERSION"><code>_VERSION</code></a></h3>


<p>
一个全局变量（不是函数），
保存包含正在运行的 Lua 版本的字符串。
此变量的当前值是"<code>Lua 5.4</code>"。




</p><p>
</p><hr><h3><a name="pdf-warn"><code>warn (msg1, ···)</code></a></h3>


<p>
发出一个警告，其消息由其所有参数的连接组成（这些参数应该是字符串）。


</p><p>
按照惯例，
以'<code>@</code>'开头的单段消息旨在作为<em>控制消息</em>，
这是发给警告系统本身的消息。
特别是，Lua 中的标准警告函数识别控制消息"<code>@off</code>"
以停止发出警告，
以及"<code>@on</code>"以（重新）开始发出警告；
它忽略未知的控制消息。




</p><p>
</p><hr><h3><a name="pdf-xpcall"><code>xpcall (f, msgh [, arg1, ···])</code></a></h3>


<p>
此函数类似于 <a href="#pdf-pcall"><code>pcall</code></a>，
只是它设置了一个新的消息处理程序 <code>msgh</code>。







</p><h2>6.2 – <a name="6.2">协程操作</a></h2>

<p>
此库包含操作协程的操作，
这些操作位于表 <a name="pdf-coroutine"><code>coroutine</code></a> 中。
有关协程的一般描述，请参见 <a href="#2.6">§2.6</a>。


</p><p>
</p><hr><h3><a name="pdf-coroutine.close"><code>coroutine.close (co)</code></a></h3>


<p>
关闭协程 <code>co</code>，
也就是说，
关闭其所有待关闭的变量并将协程置于死亡状态。
给定的协程必须是死亡或挂起的。
在出错的情况下
（无论是停止协程的原始错误还是关闭方法中的错误），
返回 <b>false</b> 加上错误对象；
否则返回 <b>true</b>。




</p><p>
</p><hr><h3><a name="pdf-coroutine.create"><code>coroutine.create (f)</code></a></h3>


<p>
创建一个新的协程，主体为 <code>f</code>。
<code>f</code> 必须是一个函数。
返回这个新协程，
一个类型为 <code>"thread"</code> 的对象。




</p><p>
</p><hr><h3><a name="pdf-coroutine.isyieldable"><code>coroutine.isyieldable ([co])</code></a></h3>


<p>
当协程 <code>co</code> 可以让出时返回 <b>true</b>。
<code>co</code> 的默认值是正在运行的协程。


</p><p>
如果协程不是主线程并且不在不可让出的 C 函数内，则协程是可让出的。




</p><p>
</p><hr><h3><a name="pdf-coroutine.resume"><code>coroutine.resume (co [, val1, ···])</code></a></h3>


<p>
启动或继续执行协程 <code>co</code>。
第一次恢复协程时，
它开始运行其主体。
值 <code>val1</code>、... 作为参数传递给主体函数。
如果协程已让出，
<code>resume</code> 重新启动它；
值 <code>val1</code>、... 作为 yield 的结果传递。


</p><p>
如果协程运行没有任何错误，
<code>resume</code> 返回 <b>true</b> 加上传递给 <code>yield</code> 的任何值
（当协程让出时）或主体函数返回的任何值（当协程终止时）。
如果有任何错误，
<code>resume</code> 返回 <b>false</b> 加上错误消息。




</p><p>
</p><hr><h3><a name="pdf-coroutine.running"><code>coroutine.running ()</code></a></h3>


<p>
返回正在运行的协程加上一个布尔值，
当正在运行的协程是主协程时为 <b>true</b>。




</p><p>
</p><hr><h3><a name="pdf-coroutine.status"><code>coroutine.status (co)</code></a></h3>


<p>
以字符串形式返回协程 <code>co</code> 的状态：
<code>"running"</code>，
如果协程正在运行（也就是说，它是调用 <code>status</code> 的协程）；
<code>"suspended"</code>，如果协程在对 <code>yield</code> 的调用中挂起，
或者如果它还没有开始运行；
<code>"normal"</code>，如果协程是活动的但没有运行
（也就是说，它已经恢复了另一个协程）；
以及 <code>"dead"</code>，如果协程已经完成其主体函数，
或者如果它已经因错误而停止。




</p><p>
</p><hr><h3><a name="pdf-coroutine.wrap"><code>coroutine.wrap (f)</code></a></h3>


<p>
创建一个新的协程，主体为 <code>f</code>；
<code>f</code> 必须是一个函数。
返回一个函数，每次调用该函数时都会恢复协程。
传递给此函数的任何参数的行为与 <code>resume</code> 的额外参数相同。
该函数返回与 <code>resume</code> 返回的相同值，
除了第一个布尔值。
在出错的情况下，
函数关闭协程并传播错误。




</p><p>
</p><hr><h3><a name="pdf-coroutine.yield"><code>coroutine.yield (···)</code></a></h3>


<p>
挂起调用协程的执行。
<code>yield</code> 的任何参数都作为额外结果传递给 <code>resume</code>。







</p><h2>6.3 – <a name="6.3">模块</a></h2>

<p>
包库为在 Lua 中加载模块提供基本功能。
它在全局环境中直接导出一个函数：
<a href="#pdf-require"><code>require</code></a>。
其他所有内容都导出在表 <a name="pdf-package"><code>package</code></a> 中。


</p><p>
</p><hr><h3><a name="pdf-require"><code>require (modname)</code></a></h3>


<p>
加载给定的模块。
该函数首先查看 <a href="#pdf-package.loaded"><code>package.loaded</code></a> 表
以确定 <code>modname</code> 是否已加载。
如果已加载，那么 <code>require</code> 返回存储在 <code>package.loaded[modname]</code> 中的值。
（在这种情况下缺少第二个结果表示此调用不必加载模块。）
否则，它会尝试为模块找到<em>加载器</em>。


</p><p>
要找到加载器，
<code>require</code> 由表 <a href="#pdf-package.searchers"><code>package.searchers</code></a> 引导。
此表中的每个项都是一个搜索函数，
以特定方式搜索模块。
通过更改此表，
我们可以更改 <code>require</code> 查找模块的方式。
以下说明基于 <a href="#pdf-package.searchers"><code>package.searchers</code></a> 的默认配置。


</p><p>
首先 <code>require</code> 查询 <code>package.preload[modname]</code>。
如果它有值，
此值（必须是函数）就是加载器。
否则 <code>require</code> 使用存储在 <a href="#pdf-package.path"><code>package.path</code></a> 中的路径搜索 Lua 加载器。
如果那也失败了，它使用存储在 <a href="#pdf-package.cpath"><code>package.cpath</code></a> 中的路径搜索 C 加载器。
如果那也失败了，
它会尝试<em>全合一</em>加载器（参见 <a href="#pdf-package.searchers"><code>package.searchers</code></a>）。


</p><p>
一旦找到加载器，
<code>require</code> 使用两个参数调用加载器：
<code>modname</code> 和一个额外值，
一个<em>加载器数据</em>，
也由搜索器返回。
加载器数据可以是对模块有用的任何值；
对于默认搜索器，
它指示找到加载器的位置。
（例如，如果加载器来自文件，
此额外值就是文件路径。）
如果加载器返回任何非 nil 值，
<code>require</code> 将返回的值分配给 <code>package.loaded[modname]</code>。
如果加载器不返回非 nil 值并且未向 <code>package.loaded[modname]</code> 分配任何值，
那么 <code>require</code> 将 <b>true</b> 分配给此条目。
无论哪种情况，<code>require</code> 都返回 <code>package.loaded[modname]</code> 的最终值。
除了该值之外，<code>require</code> 还将搜索器返回的加载器数据作为第二个结果返回，
它指示 <code>require</code> 如何找到模块。


</p><p>
如果在加载或运行模块时有任何错误，
或者如果它找不到该模块的任何加载器，
那么 <code>require</code> 会引发错误。




</p><p>
</p><hr><h3><a name="pdf-package.config"><code>package.config</code></a></h3>


<p>
描述包的一些编译时配置的字符串。
此字符串是一系列行：

</p><ul>

<li>第一行是目录分隔符字符串。
对于 Windows，默认为'<code>\</code>'，对于所有其他系统默认为'<code>/</code>'。</li>

<li>第二行是在路径中分隔模板的字符。
默认为'<code>;</code>'。</li>

<li>第三行是标记模板中替换点的字符串。
默认为'<code>?</code>'。</li>

<li>第四行是在 Windows 的路径中被可执行文件目录替换的字符串。
默认为'<code>!</code>'。</li>

<li>第五行是构建 <code>luaopen_</code> 函数名时忽略其后所有文本的标记。
默认为'<code>-</code>'。</li>

</ul>



<p>
</p><hr><h3><a name="pdf-package.cpath"><code>package.cpath</code></a></h3>


<p>
<a href="#pdf-require"><code>require</code></a> 用于搜索 C 加载器的路径字符串。


</p><p>
Lua 以与初始化 Lua 路径 <a href="#pdf-package.path"><code>package.path</code></a> 相同的方式初始化 C 路径 <a href="#pdf-package.cpath"><code>package.cpath</code></a>，
使用环境变量 <a name="pdf-LUA_CPATH_5_4"><code>LUA_CPATH_5_4</code></a>，
或环境变量 <a name="pdf-LUA_CPATH"><code>LUA_CPATH</code></a>，
或 <code>luaconf.h</code> 中定义的默认路径。




</p><p>
</p><hr><h3><a name="pdf-package.loaded"><code>package.loaded</code></a></h3>


<p>
<a href="#pdf-require"><code>require</code></a> 用于控制哪些模块已加载的表。
当你请求模块 <code>modname</code> 并且 <code>package.loaded[modname]</code> 不为假时，
<a href="#pdf-require"><code>require</code></a> 只是返回存储在那里的值。


</p><p>
此变量只是对实际表的引用；
对此变量的赋值不会更改 <a href="#pdf-require"><code>require</code></a> 使用的表。
实际表存储在 C 注册表中（参见 <a href="#4.3">§4.3</a>），
由键 <a name="pdf-LUA_LOADED_TABLE"><code>LUA_LOADED_TABLE</code></a>（一个字符串）索引。




</p><p>
</p><hr><h3><a name="pdf-package.loadlib"><code>package.loadlib (libname, funcname)</code></a></h3>


<p>
动态链接宿主程序与 C 库 <code>libname</code>。


</p><p>
如果 <code>funcname</code> 是"<code>*</code>"，
那么它只与库链接，
使库导出的符号对其他动态链接库可用。
否则，
它在库中查找函数 <code>funcname</code>
并将此函数作为 C 函数返回。
因此，<code>funcname</code> 必须遵循 <a href="#lua_CFunction"><code>lua_CFunction</code></a> 原型
（参见 <a href="#lua_CFunction"><code>lua_CFunction</code></a>）。


</p><p>
这是一个低级函数。
它完全绕过包和模块系统。
与 <a href="#pdf-require"><code>require</code></a> 不同，
它不执行任何路径搜索并且不自动添加扩展名。
<code>libname</code> 必须是 C 库的完整文件名，
必要时包括路径和扩展名。
<code>funcname</code> 必须是 C 库导出的确切名称
（这可能取决于使用的 C 编译器和链接器）。


</p><p>
此功能不受 ISO C 支持。
因此，它仅在某些平台上可用
（Windows、Linux、Mac OS X、Solaris、BSD，
以及其他支持 <code>dlfcn</code> 标准的 Unix 系统）。


</p><p>
此函数本质上是不安全的，
因为它允许 Lua 在系统中任何可读的动态库中调用任何函数。
（Lua 调用任何函数时都假定该函数具有正确的原型并遵守正确的协议
（参见 <a href="#lua_CFunction"><code>lua_CFunction</code></a>）。
因此，
在任意动态库中调用任意函数往往会导致访问冲突。）




</p><p>
</p><hr><h3><a name="pdf-package.path"><code>package.path</code></a></h3>


<p>
<a href="#pdf-require"><code>require</code></a> 用于搜索 Lua 加载器的路径字符串。


</p><p>
启动时，Lua 使用环境变量 <a name="pdf-LUA_PATH_5_4"><code>LUA_PATH_5_4</code></a> 的值
或环境变量 <a name="pdf-LUA_PATH"><code>LUA_PATH</code></a> 的值
或 <code>luaconf.h</code> 中定义的默认路径初始化此变量，
如果这些环境变量未定义。
环境变量值中的"<code>;;</code>"
会被默认路径替换。




</p><p>
</p><hr><h3><a name="pdf-package.preload"><code>package.preload</code></a></h3>


<p>
用于存储特定模块的加载器的表
（参见 <a href="#pdf-require"><code>require</code></a>）。


</p><p>
此变量只是对实际表的引用；
对此变量的赋值不会更改 <a href="#pdf-require"><code>require</code></a> 使用的表。
实际表存储在 C 注册表中（参见 <a href="#4.3">§4.3</a>），
由键 <a name="pdf-LUA_PRELOAD_TABLE"><code>LUA_PRELOAD_TABLE</code></a>（一个字符串）索引。




</p><p>
</p><hr><h3><a name="pdf-package.searchers"><code>package.searchers</code></a></h3>


<p>
<a href="#pdf-require"><code>require</code></a> 用于控制如何查找模块的表。


</p><p>
此表中的每个条目都是一个<em>搜索器函数</em>。
在查找模块时，
<a href="#pdf-require"><code>require</code></a> 以升序调用每个搜索器，
将模块名（给 <a href="#pdf-require"><code>require</code></a> 的参数）作为其唯一参数。
如果搜索器找到模块，
它返回另一个函数，模块<em>加载器</em>，
加上一个额外值，一个<em>加载器数据</em>，
该数据将传递给该加载器并作为 <a href="#pdf-require"><code>require</code></a> 的第二个结果返回。
如果它找不到模块，
它返回一个解释原因的字符串
（如果它无话可说则返回 <b>nil</b>）。


</p><p>
Lua 用四个搜索器函数初始化此表。


</p><p>
第一个搜索器只是在 <a href="#pdf-package.preload"><code>package.preload</code></a> 表中查找加载器。


</p><p>
第二个搜索器使用存储在 <a href="#pdf-package.path"><code>package.path</code></a> 中的路径查找 Lua 库的加载器。
搜索按函数 <a href="#pdf-package.searchpath"><code>package.searchpath</code></a> 中描述的方式进行。


</p><p>
第三个搜索器使用变量 <a href="#pdf-package.cpath"><code>package.cpath</code></a> 给定的路径查找 C 库的加载器。
同样，
搜索按函数 <a href="#pdf-package.searchpath"><code>package.searchpath</code></a> 中描述的方式进行。
例如，
如果 C 路径是字符串

</p><pre>     "./?.so;./?.dll;/usr/local/?/init.so"
</pre><p>
模块 <code>foo</code> 的搜索器将按该顺序尝试打开文件 <code>./foo.so</code>、<code>./foo.dll</code>
和 <code>/usr/local/foo/init.so</code>。
一旦找到 C 库，
此搜索器首先使用动态链接设施将应用程序与库链接。
然后它尝试在库中找到一个 C 函数作为加载器使用。
此 C 函数的名称是字符串"<code>luaopen_</code>"
连接模块名的副本，其中每个点都被下划线替换。
此外，如果模块名有连字符，
其（包括）第一个连字符之后的后缀会被移除。
例如，如果模块名是 <code>a.b.c-v2.1</code>，
函数名将是 <code>luaopen_a_b_c</code>。


</p><p>
第四个搜索器尝试<em>全合一加载器</em>。
它在 C 路径中搜索给定模块的根名称的库。
例如，在请求 <code>a.b.c</code> 时，
它将搜索 <code>a</code> 的 C 库。
如果找到，它会在其中查找子模块的打开函数；
在我们的例子中，那将是 <code>luaopen_a_b_c</code>。
有了这个功能，包可以将多个 C 子模块打包到一个库中，
每个子模块保持其原始打开函数。


</p><p>
除第一个（预加载）之外的所有搜索器都将找到模块的文件路径作为额外值返回，
由 <a href="#pdf-package.searchpath"><code>package.searchpath</code></a> 返回。
第一个搜索器总是返回字符串"<code>:preload:</code>"。


</p><p>
搜索器不应引发错误且在 Lua 中不应有副作用。
（它们可能在 C 中有副作用，
例如通过将应用程序与库链接。）




</p><p>
</p><hr><h3><a name="pdf-package.searchpath"><code>package.searchpath (name, path [, sep [, rep]])</code></a></h3>


<p>
在给定的 <code>path</code> 中搜索给定的 <code>name</code>。


</p><p>
路径是包含由分号分隔的<em>模板</em>序列的字符串。
对于每个模板，
函数将模板中的每个问号（如果有）
替换为 <code>name</code> 的副本，
其中所有出现的 <code>sep</code>（默认为点）
都被 <code>rep</code>（默认为系统的目录分隔符）替换，
然后尝试打开结果文件名。


</p><p>
例如，如果路径是字符串

</p><pre>     "./?.lua;./?.lc;/usr/local/?/init.lua"
</pre><p>
对名称 <code>foo.a</code> 的搜索
将按该顺序尝试打开文件
<code>./foo/a.lua</code>、<code>./foo/a.lc</code> 和
<code>/usr/local/foo/a/init.lua</code>。


</p><p>
返回它可以在读取模式下打开的第一个文件的结果名称（在关闭文件之后），
如果都不成功则返回 <b>fail</b> 加上错误消息。
（此错误消息列出了它尝试打开的所有文件名。）







</p><h2>6.4 – <a name="6.4">字符串操作</a></h2>



<p>
此库提供字符串操作的通用函数，
例如查找和提取子字符串以及模式匹配。
在 Lua 中索引字符串时，第一个字符在位置 1
（不在 0，如 C 中）。
索引允许为负数，并被解释为从字符串末尾向后索引。
因此，最后一个字符在位置 -1，依此类推。


</p><p>
<!-- slice ends -->

<!-- slice index: 8 -->
<!-- lines 10470–11964 / total 11964 -->
<!-- title: 6.9 – Operating System Facilities -->
<p>
当使用文件名调用时，它以文本模式打开指定的文件，
并将其句柄设置为默认输入文件。
当使用文件句柄调用时，
它只是将此文件句柄设置为默认输入文件。
当不带参数调用时，
它返回当前的默认输入文件。


</p><p>
如果出错，此函数会抛出错误，
而不是返回错误代码。




</p><p>
</p><hr><h3><a name="pdf-io.lines"><code>io.lines ([filename, ···])</code></a></h3>


<p>
以读取模式打开给定的文件名，
并返回一个迭代器函数，
该函数的工作方式类似于对打开的文件使用 <code>file:lines(···)</code>。
当迭代器函数无法读取任何值时，
它会自动关闭文件。
除了迭代器函数外，
<code>io.lines</code> 还返回另外三个值：
两个 <b>nil</b> 值作为占位符，
加上创建的文件句柄。
因此，当在泛型 <b>for</b> 循环中使用时，
如果循环被错误或 <b>break</b> 中断，文件也会被关闭。


</p><p>
调用 <code>io.lines()</code>（不带文件名）等效于
<code>io.input():lines("l")</code>；
也就是说，它遍历默认输入文件的行。
在这种情况下，当循环结束时迭代器不会关闭文件。


</p><p>
如果打开文件时出错，
此函数会抛出错误，
而不是返回错误代码。




</p><p>
</p><hr><h3><a name="pdf-io.open"><code>io.open (filename [, mode])</code></a></h3>


<p>
此函数以字符串 <code>mode</code> 中指定的模式打开文件。
如果成功，
它返回一个新的文件句柄。


</p><p>
<code>mode</code> 字符串可以是以下任意值：

</p><ul>
<li><b>"<code>r</code>"：</b> 读取模式（默认）；</li>
<li><b>"<code>w</code>"：</b> 写入模式；</li>
<li><b>"<code>a</code>"：</b> 追加模式；</li>
<li><b>"<code>r+</code>"：</b> 更新模式，保留所有先前数据；</li>
<li><b>"<code>w+</code>"：</b> 更新模式，清除所有先前数据；</li>
<li><b>"<code>a+</code>"：</b> 追加更新模式，保留先前数据，
  只允许在文件末尾写入。</li>
</ul><p>
<code>mode</code> 字符串末尾还可以有一个 '<code>b</code>'，
在某些系统中需要它来以二进制模式打开文件。




</p><p>
</p><hr><h3><a name="pdf-io.output"><code>io.output ([file])</code></a></h3>


<p>
类似于 <a href="#pdf-io.input"><code>io.input</code></a>，但操作默认输出文件。




</p><p>
</p><hr><h3><a name="pdf-io.popen"><code>io.popen (prog [, mode])</code></a></h3>


<p>
此函数依赖于系统，并非在所有平台上都可用。


</p><p>
在独立的进程中启动程序 <code>prog</code>，并返回
一个文件句柄，您可以使用它从该程序读取数据
（如果 <code>mode</code> 是 <code>"r"</code>，默认值）
或向该程序写入数据
（如果 <code>mode</code> 是 <code>"w"</code>）。




</p><p>
</p><hr><h3><a name="pdf-io.read"><code>io.read (···)</code></a></h3>


<p>
等效于 <code>io.input():read(···)</code>。




</p><p>
</p><hr><h3><a name="pdf-io.tmpfile"><code>io.tmpfile ()</code></a></h3>


<p>
如果成功，
返回一个临时文件的句柄。
此文件以更新模式打开，
并在程序结束时自动删除。




</p><p>
</p><hr><h3><a name="pdf-io.type"><code>io.type (obj)</code></a></h3>


<p>
检查 <code>obj</code> 是否为有效的文件句柄。
如果 <code>obj</code> 是打开的文件句柄，返回字符串 <code>"file"</code>，
如果 <code>obj</code> 是关闭的文件句柄，返回 <code>"closed file"</code>，
如果 <code>obj</code> 不是文件句柄，返回 <b>fail</b>。




</p><p>
</p><hr><h3><a name="pdf-io.write"><code>io.write (···)</code></a></h3>


<p>
等效于 <code>io.output():write(···)</code>。




</p><p>
</p><hr><h3><a name="pdf-file:close"><code>file:close ()</code></a></h3>


<p>
关闭 <code>file</code>。
请注意，当文件句柄被垃圾回收时会自动关闭文件，
但这需要不可预测的时间才会发生。


</p><p>
当关闭由 <a href="#pdf-io.popen"><code>io.popen</code></a> 创建的文件句柄时，
<a href="#pdf-file:close"><code>file:close</code></a> 返回与
<a href="#pdf-os.execute"><code>os.execute</code></a> 相同的值。




</p><p>
</p><hr><h3><a name="pdf-file:flush"><code>file:flush ()</code></a></h3>


<p>
将所有写入的数据保存到 <code>file</code>。




</p><p>
</p><hr><h3><a name="pdf-file:lines"><code>file:lines (···)</code></a></h3>


<p>
返回一个迭代器函数，
每次调用时，
根据给定的格式读取文件。
当未给出格式时，
使用 "<code>l</code>" 作为默认值。
例如，构造

</p><pre>     for c in file:lines(1) do <em>body</em> end
</pre><p>
将遍历文件的所有字符，
从当前位置开始。
与 <a href="#pdf-io.lines"><code>io.lines</code></a> 不同，此函数在循环结束时不会关闭文件。




</p><p>
</p><hr><h3><a name="pdf-file:read"><code>file:read (···)</code></a></h3>


<p>
读取文件 <code>file</code>，
根据给定的格式，指定要读取的内容。
对于每种格式，
函数返回一个字符串或数字，包含读取的字符，
或者如果无法以指定格式读取数据，则返回 <b>fail</b>。
（在后一种情况下，
函数不会读取后续格式。）
当不带参数调用时，
它使用默认格式读取下一行
（见下文）。


</p><p>
可用的格式有：

</p><ul>

<li><b>"<code>n</code>"：</b>
读取一个数字并将其作为浮点数或整数返回，
遵循 Lua 的词法约定。
（数字可能有前导空格和符号。）
此格式总是读取作为有效数字前缀的最长输入序列；
如果该前缀不构成有效数字
（例如，空字符串、"<code>0x</code>" 或 "<code>3.4e-</code>"）
或太长（超过 200 个字符），
它将被丢弃，格式返回 <b>fail</b>。
</li>

<li><b>"<code>a</code>"：</b>
从当前位置开始读取整个文件。
在文件末尾，它返回空字符串；
此格式永不失败。
</li>

<li><b>"<code>l</code>"：</b>
读取下一行，跳过行尾，
在文件末尾返回 <b>fail</b>。
这是默认格式。
</li>

<li><b>"<code>L</code>"：</b>
读取下一行，保留行尾字符（如果存在），
在文件末尾返回 <b>fail</b>。
</li>

<li><b><em>number</em>：</b>
读取最多这个数量字节的字符串，
在文件末尾返回 <b>fail</b>。
如果 <code>number</code> 为零，
它不读取任何内容并返回空字符串，
或在文件末尾返回 <b>fail</b>。
</li>

</ul><p>
格式 "<code>l</code>" 和 "<code>L</code>" 应仅用于文本文件。




</p><p>
</p><hr><h3><a name="pdf-file:seek"><code>file:seek ([whence [, offset]])</code></a></h3>


<p>
设置并获取文件位置，
从文件开头测量，
到由 <code>offset</code> 加上由字符串 <code>whence</code> 指定的基准给出的位置，如下所示：

</p><ul>
<li><b>"<code>set</code>"：</b> 基准是位置 0（文件开头）；</li>
<li><b>"<code>cur</code>"：</b> 基准是当前位置；</li>
<li><b>"<code>end</code>"：</b> 基准是文件末尾；</li>
</ul><p>
如果成功，<code>seek</code> 返回最终的文件位置，
从文件开头以字节为单位测量。
如果 <code>seek</code> 失败，它返回 <b>fail</b>，
加上描述错误的字符串。


</p><p>
<code>whence</code> 的默认值是 <code>"cur"</code>，
<code>offset</code> 的默认值是 0。
因此，调用 <code>file:seek()</code> 返回当前
文件位置，而不改变它；
调用 <code>file:seek("set")</code> 将位置设置到
文件开头（并返回 0）；
调用 <code>file:seek("end")</code> 将位置设置到
文件末尾，并返回其大小。




</p><p>
</p><hr><h3><a name="pdf-file:setvbuf"><code>file:setvbuf (mode [, size])</code></a></h3>


<p>
设置文件的缓冲模式。
有三种可用模式：

</p><ul>
<li><b>"<code>no</code>"：</b> 无缓冲。</li>
<li><b>"<code>full</code>"：</b> 全缓冲。</li>
<li><b>"<code>line</code>"：</b> 行缓冲。</li>
</ul>

<p>
对于后两种情况，
<code>size</code> 是缓冲区大小的提示，以字节为单位。
默认值是适当的大小。


</p><p>
每种模式的具体行为不可移植；
请查看您平台上的底层 ISO&nbsp;C 函数 <code>setvbuf</code> 以获取
更多详细信息。




</p><p>
</p><hr><h3><a name="pdf-file:write"><code>file:write (···)</code></a></h3>


<p>
将每个参数的值写入 <code>file</code>。
参数必须是字符串或数字。


</p><p>
如果成功，此函数返回 <code>file</code>。







</p><h2>6.9 – <a name="6.9">操作系统功能</a></h2>

<p>
此库通过表 <a name="pdf-os"><code>os</code></a> 实现。


</p><p>
</p><hr><h3><a name="pdf-os.clock"><code>os.clock ()</code></a></h3>


<p>
返回程序使用的 CPU 时间量的近似值（以秒为单位），
由底层 ISO&nbsp;C 函数 <code>clock</code> 返回。




</p><p>
</p><hr><h3><a name="pdf-os.date"><code>os.date ([format [, time]])</code></a></h3>


<p>
返回包含日期和时间的字符串或表，
根据给定的字符串 <code>format</code> 格式化。


</p><p>
如果存在 <code>time</code> 参数，
这是要格式化的时间
（有关此值的描述，请参见 <a href="#pdf-os.time"><code>os.time</code></a> 函数）。
否则，<code>date</code> 格式化当前时间。


</p><p>
如果 <code>format</code> 以 '<code>!</code>' 开头，
则日期以协调世界时格式化。
在这个可选字符之后，
如果 <code>format</code> 是字符串 "<code>*t</code>"，
那么 <code>date</code> 返回一个包含以下字段的表：
<code>year</code>、<code>month</code>（1–12）、<code>day</code>（1–31）、
<code>hour</code>（0–23）、<code>min</code>（0–59）、
<code>sec</code>（0–61，由于闰秒）、
<code>wday</code>（星期几，1–7，星期日是&nbsp;1）、
<code>yday</code>（一年中的第几天，1–366）、
和 <code>isdst</code>（夏令时标志，布尔值）。
如果信息不可用，最后一个字段可能不存在。


</p><p>
如果 <code>format</code> 不是 "<code>*t</code>"，
则 <code>date</code> 将日期作为字符串返回，
根据与 ISO&nbsp;C 函数 <code>strftime</code> 相同的规则格式化。


</p><p>
如果 <code>format</code> 不存在，默认为 "<code>%c</code>"，
它使用当前区域设置给出人类可读的日期和时间表示。


</p><p>
在非 POSIX 系统上，
此函数可能不是线程安全的，
因为它依赖于 C&nbsp;函数 <code>gmtime</code> 和 C&nbsp;函数 <code>localtime</code>。




</p><p>
</p><hr><h3><a name="pdf-os.difftime"><code>os.difftime (t2, t1)</code></a></h3>


<p>
返回从时间 <code>t1</code> 到时间 <code>t2</code> 的差值（以秒为单位）
（其中时间是由 <a href="#pdf-os.time"><code>os.time</code></a> 返回的值）。
在 POSIX、Windows 和一些其他系统中，
此值正好是 <code>t2</code><em>-</em><code>t1</code>。




</p><p>
</p><hr><h3><a name="pdf-os.execute"><code>os.execute ([command])</code></a></h3>


<p>
此函数等效于 ISO&nbsp;C 函数 <code>system</code>。
它将 <code>command</code> 传递给操作系统外壳执行。
如果命令成功终止，其第一个结果是 <b>true</b>，
否则为 <b>fail</b>。
在第一个结果之后，
函数返回一个字符串加上一个数字，
如下所示：

</p><ul>

<li><b>"<code>exit</code>"：</b>
命令正常终止；
后面的数字是命令的退出状态。
</li>

<li><b>"<code>signal</code>"：</b>
命令被信号终止；
后面的数字是终止命令的信号。
</li>

</ul>

<p>
当不带 <code>command</code> 调用时，
<code>os.execute</code> 返回一个布尔值，如果有外壳可用，则为 true。




</p><p>
</p><hr><h3><a name="pdf-os.exit"><code>os.exit ([code [, close]])</code></a></h3>


<p>
调用 ISO&nbsp;C 函数 <code>exit</code> 终止宿主程序。
如果 <code>code</code> 是 <b>true</b>，
返回的状态是 <code>EXIT_SUCCESS</code>；
如果 <code>code</code> 是 <b>false</b>，
返回的状态是 <code>EXIT_FAILURE</code>；
如果 <code>code</code> 是数字，
返回的状态是这个数字。
<code>code</code> 的默认值是 <b>true</b>。


</p><p>
如果可选的第二个参数 <code>close</code> 为 true，
函数在退出前关闭 Lua 状态（参见 <a href="#lua_close"><code>lua_close</code></a>）。




</p><p>
</p><hr><h3><a name="pdf-os.getenv"><code>os.getenv (varname)</code></a></h3>


<p>
返回进程环境变量 <code>varname</code> 的值，
如果变量未定义，则返回 <b>fail</b>。




</p><p>
</p><hr><h3><a name="pdf-os.remove"><code>os.remove (filename)</code></a></h3>


<p>
删除具有给定名称的文件（或在 POSIX 系统上删除空目录）。
如果此函数失败，它返回 <b>fail</b>
加上描述错误的字符串和错误代码。
否则，它返回 true。




</p><p>
</p><hr><h3><a name="pdf-os.rename"><code>os.rename (oldname, newname)</code></a></h3>


<p>
将名为 <code>oldname</code> 的文件或目录重命名为 <code>newname</code>。
如果此函数失败，它返回 <b>fail</b>，
加上描述错误的字符串和错误代码。
否则，它返回 true。




</p><p>
</p><hr><h3><a name="pdf-os.setlocale"><code>os.setlocale (locale [, category])</code></a></h3>


<p>
设置程序的当前区域设置。
<code>locale</code> 是指定区域设置的系统相关字符串；
<code>category</code> 是描述要更改的类别的可选字符串：
<code>"all"</code>、<code>"collate"</code>、<code>"ctype"</code>、
<code>"monetary"</code>、<code>"numeric"</code> 或 <code>"time"</code>；
默认类别是 <code>"all"</code>。
函数返回新区域设置的名称，
如果无法满足请求，则返回 <b>fail</b>。


</p><p>
如果 <code>locale</code> 是空字符串，
当前区域设置设置为实现定义的本地区域设置。
如果 <code>locale</code> 是字符串 "<code>C</code>"，
当前区域设置设置为标准 C 区域设置。


</p><p>
当以 <b>nil</b> 作为第一个参数调用时，
此函数仅返回给定类别的当前区域设置的名称。


</p><p>
此函数可能不是线程安全的，
因为它依赖于 C&nbsp;函数 <code>setlocale</code>。




</p><p>
</p><hr><h3><a name="pdf-os.time"><code>os.time ([table])</code></a></h3>


<p>
当不带参数调用时，返回当前时间，
或返回表示由给定表指定的本地日期和时间的时间。
此表必须有字段 <code>year</code>、<code>month</code> 和 <code>day</code>，
并且可能有字段
<code>hour</code>（默认为 12）、
<code>min</code>（默认为 0）、
<code>sec</code>（默认为 0）、
和 <code>isdst</code>（默认为 <b>nil</b>）。
其他字段将被忽略。
有关这些字段的描述，请参见 <a href="#pdf-os.date"><code>os.date</code></a> 函数。


</p><p>
调用函数时，
这些字段中的值不需要在其有效范围内。
例如，如果 <code>sec</code> 是 -10，
表示由其他字段指定的时间之前 10 秒；
如果 <code>hour</code> 是 1000，
表示由其他字段指定的时间之后 1000 小时。


</p><p>
返回的值是一个数字，其含义取决于您的系统。
在 POSIX、Windows 和一些其他系统中，
此数字计算自某个给定起始时间（"纪元"）以来的
秒数。
在其他系统中，含义未指定，
<code>time</code> 返回的数字只能用作
<a href="#pdf-os.date"><code>os.date</code></a> 和 <a href="#pdf-os.difftime"><code>os.difftime</code></a> 的参数。


</p><p>
当使用表调用时，
<code>os.time</code> 还会规范化 <a href="#pdf-os.date"><code>os.date</code></a> 函数中记录的所有字段，
使它们表示与调用前相同的时间，
但值在其有效范围内。




</p><p>
</p><hr><h3><a name="pdf-os.tmpname"><code>os.tmpname ()</code></a></h3>


<p>
返回一个可用于临时文件的文件名字符串。
必须在使用前显式打开文件，
并在不再需要时显式删除。


</p><p>
在 POSIX 系统上，
此函数还会创建一个具有该名称的文件，
以避免安全风险。
（其他人可能在获取名称和创建文件之间的时间内使用错误的权限创建文件。）
您仍然需要打开文件才能使用它，
并删除它（即使您不使用它）。


</p><p>
如果可能，
您可能更喜欢使用 <a href="#pdf-io.tmpfile"><code>io.tmpfile</code></a>，
它在程序结束时自动删除文件。







</p><h2>6.10 – <a name="6.10">调试库</a></h2>

<p>
此库提供调试接口（<a href="#4.7">§4.7</a>）的功能给 Lua 程序。
使用此库时应小心。
其中几个函数违反了关于 Lua 代码的基本假设
（例如，函数的局部变量无法从外部访问；
userdata 元表不能被 Lua 代码更改；
Lua 程序不会崩溃），
因此可能会危及原本安全的代码。
此外，此库中的某些函数可能很慢。


</p><p>
此库中的所有函数都在 <a name="pdf-debug"><code>debug</code></a> 表中提供。
所有对线程进行操作的函数都有一个可选的第一个参数，
该参数是要操作的线程。
默认始终是当前线程。


</p><p>
</p><hr><h3><a name="pdf-debug.debug"><code>debug.debug ()</code></a></h3>


<p>
进入与用户的交互模式，
运行用户输入的每个字符串。
使用简单的命令和其他调试设施，
用户可以检查全局和局部变量、
更改它们的值、计算表达式等。
仅包含单词 <code>cont</code> 的行完成此函数，
使调用者继续执行。


</p><p>
请注意，<code>debug.debug</code> 的命令在词法上不嵌套
在任何函数中，因此无法直接访问局部变量。




</p><p>
</p><hr><h3><a name="pdf-debug.gethook"><code>debug.gethook ([thread])</code></a></h3>


<p>
返回线程的当前钩子设置，作为三个值：
当前钩子函数、当前钩子掩码
和当前钩子计数，
由 <a href="#pdf-debug.sethook"><code>debug.sethook</code></a> 函数设置。


</p><p>
如果没有活动钩子，返回 <b>fail</b>。




</p><p>
</p><hr><h3><a name="pdf-debug.getinfo"><code>debug.getinfo ([thread,] f [, what])</code></a></h3>


<p>
返回包含函数信息的表。
您可以直接给出函数，
或者可以将数字作为 <code>f</code> 的值，
这意味着在给定线程的调用栈的级别 <code>f</code> 处运行的函数：
级别&nbsp;0 是当前函数（<code>getinfo</code> 本身）；
级别&nbsp;1 是调用 <code>getinfo</code> 的函数
（尾调用除外，它不计入栈中）；
依此类推。
如果 <code>f</code> 是大于活动函数数量的数字，
则 <code>getinfo</code> 返回 <b>fail</b>。


</p><p>
返回的表可以包含 <a href="#lua_getinfo"><code>lua_getinfo</code></a> 返回的所有字段，
字符串 <code>what</code> 描述要填充哪些字段。
<code>what</code> 的默认值是获取所有可用信息，
除了有效行表。
选项 '<code>f</code>' 添加一个名为 <code>func</code> 的字段，包含函数本身。
选项 '<code>L</code>' 添加一个名为 <code>activelines</code> 的字段，
包含有效行表，
前提是函数是 Lua 函数。
如果函数没有调试信息，
表为空。


</p><p>
例如，表达式 <code>debug.getinfo(1,"n").name</code> 返回
当前函数的名称，
如果能找到合理的名称，
表达式 <code>debug.getinfo(print)</code>
返回包含关于 <a href="#pdf-print"><code>print</code></a> 函数的所有可用信息的表。




</p><p>
</p><hr><h3><a name="pdf-debug.getlocal"><code>debug.getlocal ([thread,] f, local)</code></a></h3>


<p>
此函数返回栈级别 <code>f</code> 处函数的
索引为 <code>local</code> 的局部变量的名称和值。
此函数不仅访问显式局部变量，
还访问参数和临时值。


</p><p>
第一个参数或局部变量的索引为&nbsp;1，依此类推，
按照它们在代码中声明的顺序，
仅计算在函数当前作用域中活动的变量。
如果编译器优化掉了编译时常量，它们可能不会出现在此列表中。
负索引指可变参数；
-1 是第一个可变参数。
如果没有具有给定索引的变量，函数返回 <b>fail</b>，
并在使用超出范围的级别调用时抛出错误。
（您可以调用 <a href="#pdf-debug.getinfo"><code>debug.getinfo</code></a> 来检查级别是否有效。）


</p><p>
以 '<code>(</code>'（左括号）开头的变量名
表示没有已知名称的变量
（内部变量，如循环控制变量，
以及保存时没有调试信息的块中的变量）。


</p><p>
参数 <code>f</code> 也可以是函数。
在这种情况下，<code>getlocal</code> 只返回函数参数的名称。




</p><p>
</p><hr><h3><a name="pdf-debug.getmetatable"><code>debug.getmetatable (value)</code></a></h3>


<p>
返回给定 <code>value</code> 的元表，
如果它没有元表，则返回 <b>nil</b>。




</p><p>
</p><hr><h3><a name="pdf-debug.getregistry"><code>debug.getregistry ()</code></a></h3>


<p>
返回注册表表（参见 <a href="#4.3">§4.3</a>）。




</p><p>
</p><hr><h3><a name="pdf-debug.getupvalue"><code>debug.getupvalue (f, up)</code></a></h3>


<p>
此函数返回函数 <code>f</code> 的
索引为 <code>up</code> 的上值的名称和值。
如果没有具有给定索引的上值，函数返回 <b>fail</b>。


</p><p>
（对于 Lua 函数，
上值是函数使用的外部局部变量，
因此包含在其闭包中。）


</p><p>
对于 C&nbsp;函数，此函数对所有上值使用空字符串 <code>""</code> 作为名称。


</p><p>
变量名 '<code>?</code>'（问号）
表示没有已知名称的变量
（保存时没有调试信息的块中的变量）。




</p><p>
</p><hr><h3><a name="pdf-debug.getuservalue"><code>debug.getuservalue (u, n)</code></a></h3>


<p>
返回与 userdata <code>u</code> 关联的第 <code>n</code> 个用户值，
加上一个布尔值，
如果 userdata 没有该值，则为 <b>false</b>。




</p><p>
</p><hr><h3><a name="pdf-debug.sethook"><code>debug.sethook ([thread,] hook, mask [, count])</code></a></h3>


<p>
将给定函数设置为调试钩子。
字符串 <code>mask</code> 和数字 <code>count</code> 描述
何时调用钩子。
字符串掩码可以具有以下字符的任意组合，
具有给定含义：

</p><ul>
<li><b>'<code>c</code>'：</b> 每次 Lua 调用函数时调用钩子；</li>
<li><b>'<code>r</code>'：</b> 每次 Lua 从函数返回时调用钩子；</li>
<li><b>'<code>l</code>'：</b> 每次 Lua 进入新代码行时调用钩子。</li>
</ul><p>
此外，
当 <code>count</code> 不为零时，
每执行 <code>count</code> 条指令后也会调用钩子。


</p><p>
当不带参数调用时，
<a href="#pdf-debug.sethook"><code>debug.sethook</code></a> 关闭钩子。


</p><p>
当调用钩子时，其第一个参数是描述触发其调用的事件的字符串：
<code>"call"</code>、<code>"tail call"</code>、<code>"return"</code>、
<code>"line"</code> 和 <code>"count"</code>。
对于行事件，
钩子还将新行号作为其第二个参数获取。
在钩子内部，
您可以使用级别&nbsp;2 调用 <code>getinfo</code> 以获取有关
正在运行的函数的更多信息。
（级别&nbsp;0 是 <code>getinfo</code> 函数，
级别&nbsp;1 是钩子函数。）




</p><p>
</p><hr><h3><a name="pdf-debug.setlocal"><code>debug.setlocal ([thread,] level, local, value)</code></a></h3>


<p>
此函数将值 <code>value</code> 赋给栈级别 <code>level</code> 处函数的
索引为 <code>local</code> 的局部变量。
如果没有具有给定索引的局部变量，函数返回 <b>fail</b>，
并在使用超出范围的 <code>level</code> 调用时抛出错误。
（您可以调用 <code>getinfo</code> 来检查级别是否有效。）
否则，它返回局部变量的名称。


</p><p>
有关变量索引和名称的更多信息，请参见 <a href="#pdf-debug.getlocal"><code>debug.getlocal</code></a>。




</p><p>
</p><hr><h3><a name="pdf-debug.setmetatable"><code>debug.setmetatable (value, table)</code></a></h3>


<p>
将给定 <code>value</code> 的元表设置为给定 <code>table</code>
（可以是 <b>nil</b>）。
返回 <code>value</code>。




</p><p>
</p><hr><h3><a name="pdf-debug.setupvalue"><code>debug.setupvalue (f, up, value)</code></a></h3>


<p>
此函数将值 <code>value</code> 赋给函数 <code>f</code> 的
索引为 <code>up</code> 的上值。
如果没有具有给定索引的上值，函数返回 <b>fail</b>。
否则，它返回上值的名称。


</p><p>
有关上值的更多信息，请参见 <a href="#pdf-debug.getupvalue"><code>debug.getupvalue</code></a>。




</p><p>
</p><hr><h3><a name="pdf-debug.setuservalue"><code>debug.setuservalue (udata, value, n)</code></a></h3>


<p>
将给定 <code>value</code> 设置为与给定 <code>udata</code> 关联的第 <code>n</code> 个用户值。
<code>udata</code> 必须是完整 userdata。


</p><p>
返回 <code>udata</code>，
如果 userdata 没有该值，则返回 <b>fail</b>。




</p><p>
</p><hr><h3><a name="pdf-debug.traceback"><code>debug.traceback ([thread,] [message [, level]])</code></a></h3>


<p>
如果 <code>message</code> 存在但既不是字符串也不是 <b>nil</b>，
此函数返回 <code>message</code> 而不进行进一步处理。
否则，
它返回包含调用栈回溯的字符串。
可选的 <code>message</code> 字符串附加在回溯的开头。
可选的 <code>level</code> 数字指示从哪个级别
开始回溯
（默认为 1，调用 <code>traceback</code> 的函数）。




</p><p>
</p><hr><h3><a name="pdf-debug.upvalueid"><code>debug.upvalueid (f, n)</code></a></h3>


<p>
返回给定函数的
编号为 <code>n</code> 的上值的唯一标识符（作为轻量 userdata）。


</p><p>
这些唯一标识符允许程序检查不同的闭包是否共享上值。
共享上值的 Lua 闭包
（即，访问相同外部局部变量的闭包）
将为这些上值索引返回相同的 ID。




</p><p>
</p><hr><h3><a name="pdf-debug.upvaluejoin"><code>debug.upvaluejoin (f1, n1, f2, n2)</code></a></h3>


<p>
使 Lua 闭包 <code>f1</code> 的第 <code>n1</code> 个上值
引用 Lua 闭包 <code>f2</code> 的第 <code>n2</code> 个上值。







</p><h1>7 – <a name="7">Lua 独立解释器</a></h1>

<p>
尽管 Lua 被设计为扩展语言，
要嵌入到宿主 C&nbsp;程序中，
但它也经常用作独立语言。
Lua 作为独立语言的解释器，
简称为 <code>lua</code>，
随标准发行版一起提供。
独立解释器包括所有标准库。
其用法是：

</p><pre>     lua [options] [script [args]]
</pre><p>
选项有：

</p><ul>
<li><b><code>-e <em>stat</em></code>：</b> 执行字符串 <em>stat</em>；</li>
<li><b><code>-i</code>：</b> 运行 <em>script</em> 后进入交互模式；</li>
<li><b><code>-l <em>mod</em></code>：</b> "require" <em>mod</em> 并将
  结果赋给全局变量 <em>mod</em>；</li>
<li><b><code>-l <em>g=mod</em></code>：</b> "require" <em>mod</em> 并将
  结果赋给全局变量 <em>g</em>；</li>
<li><b><code>-v</code>：</b> 打印版本信息；</li>
<li><b><code>-E</code>：</b> 忽略环境变量；</li>
<li><b><code>-W</code>：</b> 打开警告；</li>
<li><b><code>--</code>：</b> 停止处理选项；</li>
<li><b><code>-</code>：</b> 将 <code>stdin</code> 作为文件执行并停止处理选项。</li>
</ul><p>
（形式 <code>-l <em>g=mod</em></code> 在版本&nbsp;5.4.4 中引入。）


</p><p>
处理完选项后，<code>lua</code> 运行给定的 <em>script</em>。
当不带参数调用时，
当标准输入（<code>stdin</code>）是终端时，<code>lua</code> 的行为类似于 <code>lua -v -i</code>，
否则类似于 <code>lua -</code>。


</p><p>
当不使用选项 <code>-E</code> 调用时，
解释器在运行任何参数之前检查环境变量 <a name="pdf-LUA_INIT_5_4"><code>LUA_INIT_5_4</code></a>
（如果未定义版本化名称，则检查 <a name="pdf-LUA_INIT"><code>LUA_INIT</code></a>）。
如果变量内容的格式为 <code>@<em>filename</em></code>，
则 <code>lua</code> 执行该文件。
否则，<code>lua</code> 执行字符串本身。


</p><p>
当使用选项 <code>-E</code> 调用时，
Lua 不查询任何环境变量。
特别是，
<a href="#pdf-package.path"><code>package.path</code></a> 和 <a href="#pdf-package.cpath"><code>package.cpath</code></a> 的值
使用 <code>luaconf.h</code> 中定义的默认路径设置。
为了向库发出此选项已启用的信号，
独立解释器在注册表中将字段
<code>"LUA_NOENV"</code> 设置为 true 值。
其他库可以为相同目的查询此字段。


</p><p>
选项 <code>-e</code>、<code>-l</code> 和 <code>-W</code> 按
它们出现的顺序处理。
例如，调用如下：

</p><pre>     $ lua -e 'a=1' -llib1 script.lua
</pre><p>
将首先将 <code>a</code> 设置为 1，然后 require 库 <code>lib1</code>，
最后不带参数运行文件 <code>script.lua</code>。
（这里 <code>$</code> 是 shell 提示符。您的提示符可能不同。）


</p><p>
在运行任何代码之前，
<code>lua</code> 在名为 <code>arg</code> 的全局表中收集所有命令行参数。
脚本名称位于索引 0，
脚本名称后的第一个参数位于索引 1，
依此类推。
脚本名称之前的任何参数
（即解释器名称及其选项）
位于负索引处。
例如，在调用中

</p><pre>     $ lua -la b.lua t1 t2
</pre><p>
表如下：

</p><pre>     arg = { [-2] = "lua", [-1] = "-la",
             [0] = "b.lua",
             [1] = "t1", [2] = "t2" }
</pre><p>
如果调用中没有脚本，
解释器名称位于索引 0，
后跟其他参数。
例如，调用

</p><pre>     $ lua -e "print(arg[1])"
</pre><p>
将打印 "<code>-e</code>"。
如果有脚本，
脚本将使用参数
<code>arg[1]</code>, ···, <code>arg[#arg]</code> 调用。
像 Lua 中的所有块一样，
脚本被编译为可变参数函数。


</p><p>
在交互模式下，
Lua 重复提示并等待一行。
读取一行后，
Lua 首先尝试将该行解释为表达式。
如果成功，它将打印其值。
否则，它将该行解释为语句。
如果您编写不完整的语句，
解释器通过发出不同的提示等待其完成。


</p><p>
如果全局变量 <a name="pdf-_PROMPT"><code>_PROMPT</code></a> 包含字符串，
则其值将用作提示符。
类似地，如果全局变量 <a name="pdf-_PROMPT2"><code>_PROMPT2</code></a> 包含字符串，
其值将用作辅助提示符
（在不完整语句期间发出）。


</p><p>
如果脚本中出现未保护的错误，
解释器将错误报告到标准错误流。
如果错误对象不是字符串但
具有元方法 <code>__tostring</code>，
解释器调用此元方法以生成最终消息。
否则，解释器将错误对象转换为字符串
并向其添加栈回溯。
当打开警告时，
它们只是打印到标准错误输出中。


</p><p>
正常结束时，
解释器关闭其主 Lua 状态
（参见 <a href="#lua_close"><code>lua_close</code></a>）。
脚本可以通过调用 <a href="#pdf-os.exit"><code>os.exit</code></a> 来终止，从而避免此步骤。


</p><p>
为了允许在 Unix 系统中将 Lua 用作脚本解释器，
如果文件块的第一行以 <code>#</code> 开头，Lua 会跳过它。
因此，可以使用 <code>chmod +x</code> 和&nbsp;<code>#!</code> 形式
将 Lua 脚本制作成可执行程序，
如

</p><pre>     #!/usr/local/bin/lua
</pre><p>
当然，
Lua 解释器在您的机器上的位置可能不同。
如果 <code>lua</code> 在您的 <code>PATH</code> 中，
那么

</p><pre>     #!/usr/bin/env lua
</pre><p>
是更可移植的解决方案。



</p><h1>8 – <a name="8">与前一版本的不兼容性</a></h1>



<p>
这里我们列出了将程序从 Lua&nbsp;5.3 迁移到 Lua&nbsp;5.4 时可能遇到的不兼容性。


</p><p>
您可以通过使用适当的选项编译 Lua 来避免某些不兼容性（参见文件 <code>luaconf.h</code>）。
但是，
所有这些兼容性选项将来都会被删除。
通常情况下，
当删除这些兼容性选项时会出现兼容性问题。
因此，只要有机会，
您应该尝试使用关闭所有兼容性选项编译的 Lua 版本测试您的代码。
这将简化向更新版本 Lua 的过渡。


</p><p>
Lua 版本总是可以以不意味着程序源代码更改的方式更改 C API，
例如常量的数值
或函数作为宏的实现。
因此，
您永远不应该假设二进制文件在不同 Lua 版本之间是兼容的。
使用新版本时，始终重新编译 Lua API 的客户端。


</p><p>
类似地，Lua 版本总是可以更改预编译块的内部表示；
预编译块在不同 Lua 版本之间不兼容。


</p><p>
官方发行版中的标准路径可能在版本之间更改。





</p><h2>8.1 – <a name="8.1">语言中的不兼容性</a></h2>
<ul>

<li>
算术和按位运算中字符串到数字的强制转换已从核心语言中删除。
字符串库使用字符串元方法为算术（但不是按位）运算执行类似的工作。
但是，与以前的版本不同，
新实现保留了字符串中数字的隐式类型。
例如，<code>"1" + "2"</code> 的结果现在是整数，
而不是浮点数。
</li>

<li>
溢出的字面十进制整数常量被读取为浮点数，
而不是环绕。
如果您想要旧行为，可以为此类常量使用十六进制表示法
（将它们作为整数读取并环绕）。
</li>

<li>
使用 <code>__lt</code> 元方法模拟 <code>__le</code> 已被删除。
需要时，必须显式定义此元方法。
</li>

<li>
整数上的数值 <b>for</b> 循环的语义在某些细节上发生了变化。
特别是，控制变量永远不会环绕。
</li>

<li>
即使在封闭块中声明了具有相同名称的标签，也不能在可见该标签的地方声明 <b>goto</b> 的标签。
</li>

<li>
最终化对象时，
Lua 不会忽略不是函数的 <code>__gc</code> 元方法。
任何值都将被调用（如果存在）。
（不可调用的值将生成警告，
就像调用终结器时的任何其他错误一样。）
</li>

</ul>




<h2>8.2 – <a name="8.2">库中的不兼容性</a></h2>
<ul>

<li>
函数 <a href="#pdf-print"><code>print</code></a> 不调用 <a href="#pdf-tostring"><code>tostring</code></a>
来格式化其参数；
相反，它将此功能硬编码。
您应该使用 <code>__tostring</code> 来修改值的打印方式。
</li>

<li>
函数 <a href="#pdf-math.random"><code>math.random</code></a> 使用的伪随机数生成器
现在以某个随机种子开始。
此外，它使用不同的算法。
</li>

<li>
默认情况下，<a href="#pdf-utf8"><code>utf8</code></a> 库中的解码函数
不接受代理项作为有效代码点。
这些函数中的额外参数使它们更宽松。
</li>

<li>
函数 <a href="#pdf-collectgarbage"><code>collectgarbage</code></a> 的选项 "<code>setpause</code>" 和 "<code>setstepmul</code>"
已弃用。
您应该使用新选项 "<code>incremental</code>" 来设置它们。
</li>

<li>
函数 <a href="#pdf-io.lines"><code>io.lines</code></a> 现在返回四个值，
而不仅仅是一个。
当它用作另一个具有可选参数的函数的唯一参数时，这可能会成为问题，
例如在 <code>load(io.lines(filename, "L"))</code> 中。
要解决此问题，
您可以将调用包装在括号中，
以将其结果数量调整为一个。
</li>

</ul>




<h2>8.3 – <a name="8.3">API 中的不兼容性</a></h2>


<ul>

<li>
完整 userdata 现在具有任意数量的关联用户值。
因此，函数 <code>lua_newuserdata</code>、
<code>lua_setuservalue</code> 和 <code>lua_getuservalue</code> 被
<a href="#lua_newuserdatauv"><code>lua_newuserdatauv</code></a>、
<a href="#lua_setiuservalue"><code>lua_setiuservalue</code></a> 和 <a href="#lua_getiuservalue"><code>lua_getiuservalue</code></a> 取代，
它们有一个额外的参数。


<p>
为了兼容性，旧名称仍然作为宏工作，假设有一个用户值。
但是请注意，具有零个用户值的 userdata
在内存方面更高效。
</p></li>

<li>
函数 <a href="#lua_resume"><code>lua_resume</code></a> 有一个额外的参数。
此输出参数返回协程让出或返回的
栈顶值的数量。
（在以前的版本中，
这些值是整个栈。）
</li>

<li>
函数 <a href="#lua_version"><code>lua_version</code></a> 返回版本号，
而不是版本号的地址。
Lua 核心应该与使用相同核心的自己静态副本的库正确工作，
因此不需要检查它们是否使用相同的地址空间。
</li>

<li>
常量 <code>LUA_ERRGCMM</code> 已被删除。
终结器中的错误永远不会传播；
相反，它们会生成警告。
</li>

<li>
函数 <a href="#lua_gc"><code>lua_gc</code></a> 的选项 <code>LUA_GCSETPAUSE</code> 和 <code>LUA_GCSETSTEPMUL</code>
已弃用。
您应该使用新选项 <code>LUA_GCINC</code> 来设置它们。
</li>

</ul>




<h1>9 – <a name="9">Lua 的完整语法</a></h1>

<p>
这是扩展 BNF 中 Lua 的完整语法。
像扩展 BNF 中通常一样，
{A} 表示 0 个或多个 A，
[A] 表示可选的 A。
（有关运算符优先级，请参见 <a href="#3.4.8">§3.4.8</a>；
有关终结符
Name、Numeral
和 LiteralString 的描述，请参见 <a href="#3.1">§3.1</a>。）




</p><pre>
	chunk ::= block

	block ::= {stat} [retstat]

	stat ::=  '<b>;</b>' | 
		 varlist '<b>=</b>' explist | 
		 functioncall | 
		 label | 
		 <b>break</b> | 
		 <b>goto</b> Name | 
		 <b>do</b> block <b>end</b> | 
		 <b>while</b> exp <b>do</b> block <b>end</b> | 
		 <b>repeat</b> block <b>until</b> exp | 
		 <b>if</b> exp <b>then</b> block {<b>elseif</b> exp <b>then</b> block} [<b>else</b> block] <b>end</b> | 
		 <b>for</b> Name '<b>=</b>' exp '<b>,</b>' exp ['<b>,</b>' exp] <b>do</b> block <b>end</b> | 
		 <b>for</b> namelist <b>in</b> explist <b>do</b> block <b>end</b> | 
		 <b>function</b> funcname funcbody | 
		 <b>local</b> <b>function</b> Name funcbody | 
		 <b>local</b> attnamelist ['<b>=</b>' explist] 

	attnamelist ::=  Name attrib {'<b>,</b>' Name attrib}

	attrib ::= ['<b>&lt;</b>' Name '<b>&gt;</b>']

	retstat ::= <b>return</b> [explist] ['<b>;</b>']

	label ::= '<b>::</b>' Name '<b>::</b>'

	funcname ::= Name {'<b>.</b>' Name} ['<b>:</b>' Name]

	varlist ::= var {'<b>,</b>' var}

	var ::=  Name | prefixexp '<b>[</b>' exp '<b>]</b>' | prefixexp '<b>.</b>' Name 

	namelist ::= Name {'<b>,</b>' Name}

	explist ::= exp {'<b>,</b>' exp}

	exp ::=  <b>nil</b> | <b>false</b> | <b>true</b> | Numeral | LiteralString | '<b>...</b>' | functiondef | 
		 prefixexp | tableconstructor | exp binop exp | unop exp 

	prefixexp ::= var | functioncall | '<b>(</b>' exp '<b>)</b>'

	functioncall ::=  prefixexp args | prefixexp '<b>:</b>' Name args 

	args ::=  '<b>(</b>' [explist] '<b>)</b>' | tableconstructor | LiteralString 

	functiondef ::= <b>function</b> funcbody

	funcbody ::= '<b>(</b>' [parlist] '<b>)</b>' block <b>end</b>

	parlist ::= namelist ['<b>,</b>' '<b>...</b>'] | '<b>...</b>'

	tableconstructor ::= '<b>{</b>' [fieldlist] '<b>}</b>'

	fieldlist ::= field {fieldsep field} [fieldsep]

	field ::= '<b>[</b>' exp '<b>]</b>' '<b>=</b>' exp | Name '<b>=</b>' exp | exp

	fieldsep ::= '<b>,</b>' | '<b>;</b>'

	binop ::=  '<b>+</b>' | '<b>-</b>' | '<b>*</b>' | '<b>/</b>' | '<b>//</b>' | '<b>^</b>' | '<b>%</b>' | 
		 '<b>&amp;</b>' | '<b>~</b>' | '<b>|</b>' | '<b>&gt;&gt;</b>' | '<b>&lt;&lt;</b>' | '<b>..</b>' | 
		 '<b>&lt;</b>' | '<b>&lt;=</b>' | '<b>&gt;</b>' | '<b>&gt;=</b>' | '<b>==</b>' | '<b>~=</b>' | 
		 <b>and</b> | <b>or</b>

	unop ::= '<b>-</b>' | <b>not</b> | '<b>#</b>' | '<b>~</b>'

</pre>

<p>






</p><p class="footer">
Last update:
Wed May 21 21:09:59 UTC 2025
</p>
<!--
Last change: revised for Lua 5.4.8
-->



</body></html>
<!-- slice ends -->
