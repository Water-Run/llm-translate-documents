<!-- slice index: 8 -->
<!-- lines 10470–11964 / total 11964 -->
<!-- title: 6.9 – Operating System Facilities -->
<p>
When called with a file name, it opens the named file (in text mode),
and sets its handle as the default input file.
When called with a file handle,
it simply sets this file handle as the default input file.
When called without arguments,
it returns the current default input file.


</p><p>
In case of errors this function raises the error,
instead of returning an error code.




</p><p>
</p><hr><h3><a name="pdf-io.lines"><code>io.lines ([filename, ···])</code></a></h3>


<p>
Opens the given file name in read mode
and returns an iterator function that
works like <code>file:lines(···)</code> over the opened file.
When the iterator function fails to read any value,
it automatically closes the file.
Besides the iterator function,
<code>io.lines</code> returns three other values:
two <b>nil</b> values as placeholders,
plus the created file handle.
Therefore, when used in a generic <b>for</b> loop,
the file is closed also if the loop is interrupted by an
error or a <b>break</b>.


</p><p>
The call <code>io.lines()</code> (with no file name) is equivalent
to <code>io.input():lines("l")</code>;
that is, it iterates over the lines of the default input file.
In this case, the iterator does not close the file when the loop ends.


</p><p>
In case of errors opening the file,
this function raises the error,
instead of returning an error code.




</p><p>
</p><hr><h3><a name="pdf-io.open"><code>io.open (filename [, mode])</code></a></h3>


<p>
This function opens a file,
in the mode specified in the string <code>mode</code>.
In case of success,
it returns a new file handle.


</p><p>
The <code>mode</code> string can be any of the following:

</p><ul>
<li><b>"<code>r</code>": </b> read mode (the default);</li>
<li><b>"<code>w</code>": </b> write mode;</li>
<li><b>"<code>a</code>": </b> append mode;</li>
<li><b>"<code>r+</code>": </b> update mode, all previous data is preserved;</li>
<li><b>"<code>w+</code>": </b> update mode, all previous data is erased;</li>
<li><b>"<code>a+</code>": </b> append update mode, previous data is preserved,
  writing is only allowed at the end of file.</li>
</ul><p>
The <code>mode</code> string can also have a '<code>b</code>' at the end,
which is needed in some systems to open the file in binary mode.




</p><p>
</p><hr><h3><a name="pdf-io.output"><code>io.output ([file])</code></a></h3>


<p>
Similar to <a href="#pdf-io.input"><code>io.input</code></a>, but operates over the default output file.




</p><p>
</p><hr><h3><a name="pdf-io.popen"><code>io.popen (prog [, mode])</code></a></h3>


<p>
This function is system dependent and is not available
on all platforms.


</p><p>
Starts the program <code>prog</code> in a separated process and returns
a file handle that you can use to read data from this program
(if <code>mode</code> is <code>"r"</code>, the default)
or to write data to this program
(if <code>mode</code> is <code>"w"</code>).




</p><p>
</p><hr><h3><a name="pdf-io.read"><code>io.read (···)</code></a></h3>


<p>
Equivalent to <code>io.input():read(···)</code>.




</p><p>
</p><hr><h3><a name="pdf-io.tmpfile"><code>io.tmpfile ()</code></a></h3>


<p>
In case of success,
returns a handle for a temporary file.
This file is opened in update mode
and it is automatically removed when the program ends.




</p><p>
</p><hr><h3><a name="pdf-io.type"><code>io.type (obj)</code></a></h3>


<p>
Checks whether <code>obj</code> is a valid file handle.
Returns the string <code>"file"</code> if <code>obj</code> is an open file handle,
<code>"closed file"</code> if <code>obj</code> is a closed file handle,
or <b>fail</b> if <code>obj</code> is not a file handle.




</p><p>
</p><hr><h3><a name="pdf-io.write"><code>io.write (···)</code></a></h3>


<p>
Equivalent to <code>io.output():write(···)</code>.




</p><p>
</p><hr><h3><a name="pdf-file:close"><code>file:close ()</code></a></h3>


<p>
Closes <code>file</code>.
Note that files are automatically closed when
their handles are garbage collected,
but that takes an unpredictable amount of time to happen.


</p><p>
When closing a file handle created with <a href="#pdf-io.popen"><code>io.popen</code></a>,
<a href="#pdf-file:close"><code>file:close</code></a> returns the same values
returned by <a href="#pdf-os.execute"><code>os.execute</code></a>.




</p><p>
</p><hr><h3><a name="pdf-file:flush"><code>file:flush ()</code></a></h3>


<p>
Saves any written data to <code>file</code>.




</p><p>
</p><hr><h3><a name="pdf-file:lines"><code>file:lines (···)</code></a></h3>


<p>
Returns an iterator function that,
each time it is called,
reads the file according to the given formats.
When no format is given,
uses "<code>l</code>" as a default.
As an example, the construction

</p><pre>     for c in file:lines(1) do <em>body</em> end
</pre><p>
will iterate over all characters of the file,
starting at the current position.
Unlike <a href="#pdf-io.lines"><code>io.lines</code></a>, this function does not close the file
when the loop ends.




</p><p>
</p><hr><h3><a name="pdf-file:read"><code>file:read (···)</code></a></h3>


<p>
Reads the file <code>file</code>,
according to the given formats, which specify what to read.
For each format,
the function returns a string or a number with the characters read,
or <b>fail</b> if it cannot read data with the specified format.
(In this latter case,
the function does not read subsequent formats.)
When called without arguments,
it uses a default format that reads the next line
(see below).


</p><p>
The available formats are

</p><ul>

<li><b>"<code>n</code>": </b>
reads a numeral and returns it as a float or an integer,
following the lexical conventions of Lua.
(The numeral may have leading whitespaces and a sign.)
This format always reads the longest input sequence that
is a valid prefix for a numeral;
if that prefix does not form a valid numeral
(e.g., an empty string, "<code>0x</code>", or "<code>3.4e-</code>")
or it is too long (more than 200 characters),
it is discarded and the format returns <b>fail</b>.
</li>

<li><b>"<code>a</code>": </b>
reads the whole file, starting at the current position.
On end of file, it returns the empty string;
this format never fails.
</li>

<li><b>"<code>l</code>": </b>
reads the next line skipping the end of line,
returning <b>fail</b> on end of file.
This is the default format.
</li>

<li><b>"<code>L</code>": </b>
reads the next line keeping the end-of-line character (if present),
returning <b>fail</b> on end of file.
</li>

<li><b><em>number</em>: </b>
reads a string with up to this number of bytes,
returning <b>fail</b> on end of file.
If <code>number</code> is zero,
it reads nothing and returns an empty string,
or <b>fail</b> on end of file.
</li>

</ul><p>
The formats "<code>l</code>" and "<code>L</code>" should be used only for text files.




</p><p>
</p><hr><h3><a name="pdf-file:seek"><code>file:seek ([whence [, offset]])</code></a></h3>


<p>
Sets and gets the file position,
measured from the beginning of the file,
to the position given by <code>offset</code> plus a base
specified by the string <code>whence</code>, as follows:

</p><ul>
<li><b>"<code>set</code>": </b> base is position 0 (beginning of the file);</li>
<li><b>"<code>cur</code>": </b> base is current position;</li>
<li><b>"<code>end</code>": </b> base is end of file;</li>
</ul><p>
In case of success, <code>seek</code> returns the final file position,
measured in bytes from the beginning of the file.
If <code>seek</code> fails, it returns <b>fail</b>,
plus a string describing the error.


</p><p>
The default value for <code>whence</code> is <code>"cur"</code>,
and for <code>offset</code> is 0.
Therefore, the call <code>file:seek()</code> returns the current
file position, without changing it;
the call <code>file:seek("set")</code> sets the position to the
beginning of the file (and returns 0);
and the call <code>file:seek("end")</code> sets the position to the
end of the file, and returns its size.




</p><p>
</p><hr><h3><a name="pdf-file:setvbuf"><code>file:setvbuf (mode [, size])</code></a></h3>


<p>
Sets the buffering mode for a file.
There are three available modes:

</p><ul>
<li><b>"<code>no</code>": </b> no buffering.</li>
<li><b>"<code>full</code>": </b> full buffering.</li>
<li><b>"<code>line</code>": </b> line buffering.</li>
</ul>

<p>
For the last two cases,
<code>size</code> is a hint for the size of the buffer, in bytes.
The default is an appropriate size.


</p><p>
The specific behavior of each mode is non portable;
check the underlying ISO&nbsp;C function <code>setvbuf</code> in your platform for
more details.




</p><p>
</p><hr><h3><a name="pdf-file:write"><code>file:write (···)</code></a></h3>


<p>
Writes the value of each of its arguments to <code>file</code>.
The arguments must be strings or numbers.


</p><p>
In case of success, this function returns <code>file</code>.







</p><h2>6.9 – <a name="6.9">Operating System Facilities</a></h2>

<p>
This library is implemented through table <a name="pdf-os"><code>os</code></a>.


</p><p>
</p><hr><h3><a name="pdf-os.clock"><code>os.clock ()</code></a></h3>


<p>
Returns an approximation of the amount in seconds of CPU time
used by the program,
as returned by the underlying ISO&nbsp;C function <code>clock</code>.




</p><p>
</p><hr><h3><a name="pdf-os.date"><code>os.date ([format [, time]])</code></a></h3>


<p>
Returns a string or a table containing date and time,
formatted according to the given string <code>format</code>.


</p><p>
If the <code>time</code> argument is present,
this is the time to be formatted
(see the <a href="#pdf-os.time"><code>os.time</code></a> function for a description of this value).
Otherwise, <code>date</code> formats the current time.


</p><p>
If <code>format</code> starts with '<code>!</code>',
then the date is formatted in Coordinated Universal Time.
After this optional character,
if <code>format</code> is the string "<code>*t</code>",
then <code>date</code> returns a table with the following fields:
<code>year</code>, <code>month</code> (1–12), <code>day</code> (1–31),
<code>hour</code> (0–23), <code>min</code> (0–59),
<code>sec</code> (0–61, due to leap seconds),
<code>wday</code> (weekday, 1–7, Sunday is&nbsp;1),
<code>yday</code> (day of the year, 1–366),
and <code>isdst</code> (daylight saving flag, a boolean).
This last field may be absent
if the information is not available.


</p><p>
If <code>format</code> is not "<code>*t</code>",
then <code>date</code> returns the date as a string,
formatted according to the same rules as the ISO&nbsp;C function <code>strftime</code>.


</p><p>
If <code>format</code> is absent, it defaults to "<code>%c</code>",
which gives a human-readable date and time representation
using the current locale.


</p><p>
On non-POSIX systems,
this function may be not thread safe
because of its reliance on C&nbsp;function <code>gmtime</code> and C&nbsp;function <code>localtime</code>.




</p><p>
</p><hr><h3><a name="pdf-os.difftime"><code>os.difftime (t2, t1)</code></a></h3>


<p>
Returns the difference, in seconds,
from time <code>t1</code> to time <code>t2</code>
(where the times are values returned by <a href="#pdf-os.time"><code>os.time</code></a>).
In POSIX, Windows, and some other systems,
this value is exactly <code>t2</code><em>-</em><code>t1</code>.




</p><p>
</p><hr><h3><a name="pdf-os.execute"><code>os.execute ([command])</code></a></h3>


<p>
This function is equivalent to the ISO&nbsp;C function <code>system</code>.
It passes <code>command</code> to be executed by an operating system shell.
Its first result is <b>true</b>
if the command terminated successfully,
or <b>fail</b> otherwise.
After this first result
the function returns a string plus a number,
as follows:

</p><ul>

<li><b>"<code>exit</code>": </b>
the command terminated normally;
the following number is the exit status of the command.
</li>

<li><b>"<code>signal</code>": </b>
the command was terminated by a signal;
the following number is the signal that terminated the command.
</li>

</ul>

<p>
When called without a <code>command</code>,
<code>os.execute</code> returns a boolean that is true if a shell is available.




</p><p>
</p><hr><h3><a name="pdf-os.exit"><code>os.exit ([code [, close]])</code></a></h3>


<p>
Calls the ISO&nbsp;C function <code>exit</code> to terminate the host program.
If <code>code</code> is <b>true</b>,
the returned status is <code>EXIT_SUCCESS</code>;
if <code>code</code> is <b>false</b>,
the returned status is <code>EXIT_FAILURE</code>;
if <code>code</code> is a number,
the returned status is this number.
The default value for <code>code</code> is <b>true</b>.


</p><p>
If the optional second argument <code>close</code> is true,
the function closes the Lua state before exiting (see <a href="#lua_close"><code>lua_close</code></a>).




</p><p>
</p><hr><h3><a name="pdf-os.getenv"><code>os.getenv (varname)</code></a></h3>


<p>
Returns the value of the process environment variable <code>varname</code>
or <b>fail</b> if the variable is not defined.




</p><p>
</p><hr><h3><a name="pdf-os.remove"><code>os.remove (filename)</code></a></h3>


<p>
Deletes the file (or empty directory, on POSIX systems)
with the given name.
If this function fails, it returns <b>fail</b>
plus a string describing the error and the error code.
Otherwise, it returns true.




</p><p>
</p><hr><h3><a name="pdf-os.rename"><code>os.rename (oldname, newname)</code></a></h3>


<p>
Renames the file or directory named <code>oldname</code> to <code>newname</code>.
If this function fails, it returns <b>fail</b>,
plus a string describing the error and the error code.
Otherwise, it returns true.




</p><p>
</p><hr><h3><a name="pdf-os.setlocale"><code>os.setlocale (locale [, category])</code></a></h3>


<p>
Sets the current locale of the program.
<code>locale</code> is a system-dependent string specifying a locale;
<code>category</code> is an optional string describing which category to change:
<code>"all"</code>, <code>"collate"</code>, <code>"ctype"</code>,
<code>"monetary"</code>, <code>"numeric"</code>, or <code>"time"</code>;
the default category is <code>"all"</code>.
The function returns the name of the new locale,
or <b>fail</b> if the request cannot be honored.


</p><p>
If <code>locale</code> is the empty string,
the current locale is set to an implementation-defined native locale.
If <code>locale</code> is the string "<code>C</code>",
the current locale is set to the standard C locale.


</p><p>
When called with <b>nil</b> as the first argument,
this function only returns the name of the current locale
for the given category.


</p><p>
This function may be not thread safe
because of its reliance on C&nbsp;function <code>setlocale</code>.




</p><p>
</p><hr><h3><a name="pdf-os.time"><code>os.time ([table])</code></a></h3>


<p>
Returns the current time when called without arguments,
or a time representing the local date and time specified by the given table.
This table must have fields <code>year</code>, <code>month</code>, and <code>day</code>,
and may have fields
<code>hour</code> (default is 12),
<code>min</code> (default is 0),
<code>sec</code> (default is 0),
and <code>isdst</code> (default is <b>nil</b>).
Other fields are ignored.
For a description of these fields, see the <a href="#pdf-os.date"><code>os.date</code></a> function.


</p><p>
When the function is called,
the values in these fields do not need to be inside their valid ranges.
For instance, if <code>sec</code> is -10,
it means 10 seconds before the time specified by the other fields;
if <code>hour</code> is 1000,
it means 1000 hours after the time specified by the other fields.


</p><p>
The returned value is a number, whose meaning depends on your system.
In POSIX, Windows, and some other systems,
this number counts the number
of seconds since some given start time (the "epoch").
In other systems, the meaning is not specified,
and the number returned by <code>time</code> can be used only as an argument to
<a href="#pdf-os.date"><code>os.date</code></a> and <a href="#pdf-os.difftime"><code>os.difftime</code></a>.


</p><p>
When called with a table,
<code>os.time</code> also normalizes all the fields
documented in the <a href="#pdf-os.date"><code>os.date</code></a> function,
so that they represent the same time as before the call
but with values inside their valid ranges.




</p><p>
</p><hr><h3><a name="pdf-os.tmpname"><code>os.tmpname ()</code></a></h3>


<p>
Returns a string with a file name that can
be used for a temporary file.
The file must be explicitly opened before its use
and explicitly removed when no longer needed.


</p><p>
In POSIX systems,
this function also creates a file with that name,
to avoid security risks.
(Someone else might create the file with wrong permissions
in the time between getting the name and creating the file.)
You still have to open the file to use it
and to remove it (even if you do not use it).


</p><p>
When possible,
you may prefer to use <a href="#pdf-io.tmpfile"><code>io.tmpfile</code></a>,
which automatically removes the file when the program ends.







</p><h2>6.10 – <a name="6.10">The Debug Library</a></h2>

<p>
This library provides
the functionality of the debug interface (<a href="#4.7">§4.7</a>) to Lua programs.
You should exert care when using this library.
Several of its functions
violate basic assumptions about Lua code
(e.g., that variables local to a function
cannot be accessed from outside;
that userdata metatables cannot be changed by Lua code;
that Lua programs do not crash)
and therefore can compromise otherwise secure code.
Moreover, some functions in this library may be slow.


</p><p>
All functions in this library are provided
inside the <a name="pdf-debug"><code>debug</code></a> table.
All functions that operate over a thread
have an optional first argument which is the
thread to operate over.
The default is always the current thread.


</p><p>
</p><hr><h3><a name="pdf-debug.debug"><code>debug.debug ()</code></a></h3>


<p>
Enters an interactive mode with the user,
running each string that the user enters.
Using simple commands and other debug facilities,
the user can inspect global and local variables,
change their values, evaluate expressions, and so on.
A line containing only the word <code>cont</code> finishes this function,
so that the caller continues its execution.


</p><p>
Note that commands for <code>debug.debug</code> are not lexically nested
within any function and so have no direct access to local variables.




</p><p>
</p><hr><h3><a name="pdf-debug.gethook"><code>debug.gethook ([thread])</code></a></h3>


<p>
Returns the current hook settings of the thread, as three values:
the current hook function, the current hook mask,
and the current hook count,
as set by the <a href="#pdf-debug.sethook"><code>debug.sethook</code></a> function.


</p><p>
Returns <b>fail</b> if there is no active hook.




</p><p>
</p><hr><h3><a name="pdf-debug.getinfo"><code>debug.getinfo ([thread,] f [, what])</code></a></h3>


<p>
Returns a table with information about a function.
You can give the function directly
or you can give a number as the value of <code>f</code>,
which means the function running at level <code>f</code> of the call stack
of the given thread:
level&nbsp;0 is the current function (<code>getinfo</code> itself);
level&nbsp;1 is the function that called <code>getinfo</code>
(except for tail calls, which do not count in the stack);
and so on.
If <code>f</code> is a number greater than the number of active functions,
then <code>getinfo</code> returns <b>fail</b>.


</p><p>
The returned table can contain all the fields returned by <a href="#lua_getinfo"><code>lua_getinfo</code></a>,
with the string <code>what</code> describing which fields to fill in.
The default for <code>what</code> is to get all information available,
except the table of valid lines.
The option '<code>f</code>'
adds a field named <code>func</code> with the function itself.
The option '<code>L</code>' adds a field named <code>activelines</code>
with the table of valid lines,
provided the function is a Lua function.
If the function has no debug information,
the table is empty.


</p><p>
For instance, the expression <code>debug.getinfo(1,"n").name</code> returns
a name for the current function,
if a reasonable name can be found,
and the expression <code>debug.getinfo(print)</code>
returns a table with all available information
about the <a href="#pdf-print"><code>print</code></a> function.




</p><p>
</p><hr><h3><a name="pdf-debug.getlocal"><code>debug.getlocal ([thread,] f, local)</code></a></h3>


<p>
This function returns the name and the value of the local variable
with index <code>local</code> of the function at level <code>f</code> of the stack.
This function accesses not only explicit local variables,
but also parameters and temporary values.


</p><p>
The first parameter or local variable has index&nbsp;1, and so on,
following the order that they are declared in the code,
counting only the variables that are active
in the current scope of the function.
Compile-time constants may not appear in this listing,
if they were optimized away by the compiler.
Negative indices refer to vararg arguments;
-1 is the first vararg argument.
The function returns <b>fail</b>
if there is no variable with the given index,
and raises an error when called with a level out of range.
(You can call <a href="#pdf-debug.getinfo"><code>debug.getinfo</code></a> to check whether the level is valid.)


</p><p>
Variable names starting with '<code>(</code>' (open parenthesis) 
represent variables with no known names
(internal variables such as loop control variables,
and variables from chunks saved without debug information).


</p><p>
The parameter <code>f</code> may also be a function.
In that case, <code>getlocal</code> returns only the name of function parameters.




</p><p>
</p><hr><h3><a name="pdf-debug.getmetatable"><code>debug.getmetatable (value)</code></a></h3>


<p>
Returns the metatable of the given <code>value</code>
or <b>nil</b> if it does not have a metatable.




</p><p>
</p><hr><h3><a name="pdf-debug.getregistry"><code>debug.getregistry ()</code></a></h3>


<p>
Returns the registry table (see <a href="#4.3">§4.3</a>).




</p><p>
</p><hr><h3><a name="pdf-debug.getupvalue"><code>debug.getupvalue (f, up)</code></a></h3>


<p>
This function returns the name and the value of the upvalue
with index <code>up</code> of the function <code>f</code>.
The function returns <b>fail</b>
if there is no upvalue with the given index.


</p><p>
(For Lua functions,
upvalues are the external local variables that the function uses,
and that are consequently included in its closure.)


</p><p>
For C&nbsp;functions, this function uses the empty string <code>""</code>
as a name for all upvalues.


</p><p>
Variable name '<code>?</code>' (interrogation mark)
represents variables with no known names
(variables from chunks saved without debug information).




</p><p>
</p><hr><h3><a name="pdf-debug.getuservalue"><code>debug.getuservalue (u, n)</code></a></h3>


<p>
Returns the <code>n</code>-th user value associated
to the userdata <code>u</code> plus a boolean,
<b>false</b> if the userdata does not have that value.




</p><p>
</p><hr><h3><a name="pdf-debug.sethook"><code>debug.sethook ([thread,] hook, mask [, count])</code></a></h3>


<p>
Sets the given function as the debug hook.
The string <code>mask</code> and the number <code>count</code> describe
when the hook will be called.
The string mask may have any combination of the following characters,
with the given meaning:

</p><ul>
<li><b>'<code>c</code>': </b> the hook is called every time Lua calls a function;</li>
<li><b>'<code>r</code>': </b> the hook is called every time Lua returns from a function;</li>
<li><b>'<code>l</code>': </b> the hook is called every time Lua enters a new line of code.</li>
</ul><p>
Moreover,
with a <code>count</code> different from zero,
the hook is called also after every <code>count</code> instructions.


</p><p>
When called without arguments,
<a href="#pdf-debug.sethook"><code>debug.sethook</code></a> turns off the hook.


</p><p>
When the hook is called, its first parameter is a string
describing the event that has triggered its call:
<code>"call"</code>, <code>"tail call"</code>, <code>"return"</code>,
<code>"line"</code>, and <code>"count"</code>.
For line events,
the hook also gets the new line number as its second parameter.
Inside a hook,
you can call <code>getinfo</code> with level&nbsp;2 to get more information about
the running function.
(Level&nbsp;0 is the <code>getinfo</code> function,
and level&nbsp;1 is the hook function.)




</p><p>
</p><hr><h3><a name="pdf-debug.setlocal"><code>debug.setlocal ([thread,] level, local, value)</code></a></h3>


<p>
This function assigns the value <code>value</code> to the local variable
with index <code>local</code> of the function at level <code>level</code> of the stack.
The function returns <b>fail</b> if there is no local
variable with the given index,
and raises an error when called with a <code>level</code> out of range.
(You can call <code>getinfo</code> to check whether the level is valid.)
Otherwise, it returns the name of the local variable.


</p><p>
See <a href="#pdf-debug.getlocal"><code>debug.getlocal</code></a> for more information about
variable indices and names.




</p><p>
</p><hr><h3><a name="pdf-debug.setmetatable"><code>debug.setmetatable (value, table)</code></a></h3>


<p>
Sets the metatable for the given <code>value</code> to the given <code>table</code>
(which can be <b>nil</b>).
Returns <code>value</code>.




</p><p>
</p><hr><h3><a name="pdf-debug.setupvalue"><code>debug.setupvalue (f, up, value)</code></a></h3>


<p>
This function assigns the value <code>value</code> to the upvalue
with index <code>up</code> of the function <code>f</code>.
The function returns <b>fail</b> if there is no upvalue
with the given index.
Otherwise, it returns the name of the upvalue.


</p><p>
See <a href="#pdf-debug.getupvalue"><code>debug.getupvalue</code></a> for more information about upvalues.




</p><p>
</p><hr><h3><a name="pdf-debug.setuservalue"><code>debug.setuservalue (udata, value, n)</code></a></h3>


<p>
Sets the given <code>value</code> as
the <code>n</code>-th user value associated to the given <code>udata</code>.
<code>udata</code> must be a full userdata.


</p><p>
Returns <code>udata</code>,
or <b>fail</b> if the userdata does not have that value.




</p><p>
</p><hr><h3><a name="pdf-debug.traceback"><code>debug.traceback ([thread,] [message [, level]])</code></a></h3>


<p>
If <code>message</code> is present but is neither a string nor <b>nil</b>,
this function returns <code>message</code> without further processing.
Otherwise,
it returns a string with a traceback of the call stack.
The optional <code>message</code> string is appended
at the beginning of the traceback.
An optional <code>level</code> number tells at which level
to start the traceback
(default is 1, the function calling <code>traceback</code>).




</p><p>
</p><hr><h3><a name="pdf-debug.upvalueid"><code>debug.upvalueid (f, n)</code></a></h3>


<p>
Returns a unique identifier (as a light userdata)
for the upvalue numbered <code>n</code>
from the given function.


</p><p>
These unique identifiers allow a program to check whether different
closures share upvalues.
Lua closures that share an upvalue
(that is, that access a same external local variable)
will return identical ids for those upvalue indices.




</p><p>
</p><hr><h3><a name="pdf-debug.upvaluejoin"><code>debug.upvaluejoin (f1, n1, f2, n2)</code></a></h3>


<p>
Make the <code>n1</code>-th upvalue of the Lua closure <code>f1</code>
refer to the <code>n2</code>-th upvalue of the Lua closure <code>f2</code>.







</p><h1>7 – <a name="7">Lua Standalone</a></h1>

<p>
Although Lua has been designed as an extension language,
to be embedded in a host C&nbsp;program,
it is also frequently used as a standalone language.
An interpreter for Lua as a standalone language,
called simply <code>lua</code>,
is provided with the standard distribution.
The standalone interpreter includes
all standard libraries.
Its usage is:

</p><pre>     lua [options] [script [args]]
</pre><p>
The options are:

</p><ul>
<li><b><code>-e <em>stat</em></code>: </b> execute string <em>stat</em>;</li>
<li><b><code>-i</code>: </b> enter interactive mode after running <em>script</em>;</li>
<li><b><code>-l <em>mod</em></code>: </b> "require" <em>mod</em> and assign the
  result to global <em>mod</em>;</li>
<li><b><code>-l <em>g=mod</em></code>: </b> "require" <em>mod</em> and assign the
  result to global <em>g</em>;</li>
<li><b><code>-v</code>: </b> print version information;</li>
<li><b><code>-E</code>: </b> ignore environment variables;</li>
<li><b><code>-W</code>: </b> turn warnings on;</li>
<li><b><code>--</code>: </b> stop handling options;</li>
<li><b><code>-</code>: </b> execute <code>stdin</code> as a file and stop handling options.</li>
</ul><p>
(The form <code>-l <em>g=mod</em></code> was introduced in release&nbsp;5.4.4.)


</p><p>
After handling its options, <code>lua</code> runs the given <em>script</em>.
When called without arguments,
<code>lua</code> behaves as <code>lua -v -i</code>
when the standard input (<code>stdin</code>) is a terminal,
and as <code>lua -</code> otherwise.


</p><p>
When called without the option <code>-E</code>,
the interpreter checks for an environment variable <a name="pdf-LUA_INIT_5_4"><code>LUA_INIT_5_4</code></a>
(or <a name="pdf-LUA_INIT"><code>LUA_INIT</code></a> if the versioned name is not defined)
before running any argument.
If the variable content has the format <code>@<em>filename</em></code>,
then <code>lua</code> executes the file.
Otherwise, <code>lua</code> executes the string itself.


</p><p>
When called with the option <code>-E</code>,
Lua does not consult any environment variables.
In particular,
the values of <a href="#pdf-package.path"><code>package.path</code></a> and <a href="#pdf-package.cpath"><code>package.cpath</code></a>
are set with the default paths defined in <code>luaconf.h</code>.
To signal to the libraries that this option is on,
the stand-alone interpreter sets the field
<code>"LUA_NOENV"</code> in the registry to a true value.
Other libraries may consult this field for the same purpose.


</p><p>
The options <code>-e</code>, <code>-l</code>, and <code>-W</code> are handled in
the order they appear.
For instance, an invocation like

</p><pre>     $ lua -e 'a=1' -llib1 script.lua
</pre><p>
will first set <code>a</code> to 1, then require the library <code>lib1</code>,
and finally run the file <code>script.lua</code> with no arguments.
(Here <code>$</code> is the shell prompt. Your prompt may be different.)


</p><p>
Before running any code,
<code>lua</code> collects all command-line arguments
in a global table called <code>arg</code>.
The script name goes to index 0,
the first argument after the script name goes to index 1,
and so on.
Any arguments before the script name
(that is, the interpreter name plus its options)
go to negative indices.
For instance, in the call

</p><pre>     $ lua -la b.lua t1 t2
</pre><p>
the table is like this:

</p><pre>     arg = { [-2] = "lua", [-1] = "-la",
             [0] = "b.lua",
             [1] = "t1", [2] = "t2" }
</pre><p>
If there is no script in the call,
the interpreter name goes to index 0,
followed by the other arguments.
For instance, the call

</p><pre>     $ lua -e "print(arg[1])"
</pre><p>
will print "<code>-e</code>".
If there is a script,
the script is called with arguments
<code>arg[1]</code>, ···, <code>arg[#arg]</code>.
Like all chunks in Lua,
the script is compiled as a variadic function.


</p><p>
In interactive mode,
Lua repeatedly prompts and waits for a line.
After reading a line,
Lua first try to interpret the line as an expression.
If it succeeds, it prints its value.
Otherwise, it interprets the line as a statement.
If you write an incomplete statement,
the interpreter waits for its completion
by issuing a different prompt.


</p><p>
If the global variable <a name="pdf-_PROMPT"><code>_PROMPT</code></a> contains a string,
then its value is used as the prompt.
Similarly, if the global variable <a name="pdf-_PROMPT2"><code>_PROMPT2</code></a> contains a string,
its value is used as the secondary prompt
(issued during incomplete statements).


</p><p>
In case of unprotected errors in the script,
the interpreter reports the error to the standard error stream.
If the error object is not a string but
has a metamethod <code>__tostring</code>,
the interpreter calls this metamethod to produce the final message.
Otherwise, the interpreter converts the error object to a string
and adds a stack traceback to it.
When warnings are on,
they are simply printed in the standard error output.


</p><p>
When finishing normally,
the interpreter closes its main Lua state
(see <a href="#lua_close"><code>lua_close</code></a>).
The script can avoid this step by
calling <a href="#pdf-os.exit"><code>os.exit</code></a> to terminate.


</p><p>
To allow the use of Lua as a
script interpreter in Unix systems,
Lua skips the first line of a file chunk if it starts with <code>#</code>.
Therefore, Lua scripts can be made into executable programs
by using <code>chmod +x</code> and the&nbsp;<code>#!</code> form,
as in

</p><pre>     #!/usr/local/bin/lua
</pre><p>
Of course,
the location of the Lua interpreter may be different in your machine.
If <code>lua</code> is in your <code>PATH</code>,
then

</p><pre>     #!/usr/bin/env lua
</pre><p>
is a more portable solution.



</p><h1>8 – <a name="8">Incompatibilities with the Previous Version</a></h1>



<p>
Here we list the incompatibilities that you may find when moving a program
from Lua&nbsp;5.3 to Lua&nbsp;5.4.


</p><p>
You can avoid some incompatibilities by compiling Lua with
appropriate options (see file <code>luaconf.h</code>).
However,
all these compatibility options will be removed in the future.
More often than not,
compatibility issues arise when these compatibility options
are removed.
So, whenever you have the chance,
you should try to test your code with a version of Lua compiled
with all compatibility options turned off.
That will ease transitions to newer versions of Lua.


</p><p>
Lua versions can always change the C API in ways that
do not imply source-code changes in a program,
such as the numeric values for constants
or the implementation of functions as macros.
Therefore,
you should never assume that binaries are compatible between
different Lua versions.
Always recompile clients of the Lua API when
using a new version.


</p><p>
Similarly, Lua versions can always change the internal representation
of precompiled chunks;
precompiled chunks are not compatible between different Lua versions.


</p><p>
The standard paths in the official distribution may
change between versions.





</p><h2>8.1 – <a name="8.1">Incompatibilities in the Language</a></h2>
<ul>

<li>
The coercion of strings to numbers in
arithmetic and bitwise operations
has been removed from the core language.
The string library does a similar job
for arithmetic (but not for bitwise) operations
using the string metamethods.
However, unlike in previous versions,
the new implementation preserves the implicit type of the numeral
in the string.
For instance, the result of <code>"1" + "2"</code> now is an integer,
not a float.
</li>

<li>
Literal decimal integer constants that overflow are read as floats,
instead of wrapping around.
You can use hexadecimal notation for such constants if you
want the old behavior
(reading them as integers with wrap around).
</li>

<li>
The use of the <code>__lt</code> metamethod to emulate <code>__le</code>
has been removed.
When needed, this metamethod must be explicitly defined.
</li>

<li>
The semantics of the numerical <b>for</b> loop
over integers changed in some details.
In particular, the control variable never wraps around.
</li>

<li>
A label for a <b>goto</b> cannot be declared where a label with the same
name is visible, even if this other label is declared in an enclosing
block.
</li>

<li>
When finalizing an object,
Lua does not ignore <code>__gc</code> metamethods that are not functions.
Any value will be called, if present.
(Non-callable values will generate a warning,
like any other error when calling a finalizer.)
</li>

</ul>




<h2>8.2 – <a name="8.2">Incompatibilities in the Libraries</a></h2>
<ul>

<li>
The function <a href="#pdf-print"><code>print</code></a> does not call <a href="#pdf-tostring"><code>tostring</code></a>
to format its arguments;
instead, it has this functionality hardwired.
You should use <code>__tostring</code> to modify how values are printed.
</li>

<li>
The pseudo-random number generator used by the function <a href="#pdf-math.random"><code>math.random</code></a>
now starts with a somewhat random seed.
Moreover, it uses a different algorithm.
</li>

<li>
By default, the decoding functions in the <a href="#pdf-utf8"><code>utf8</code></a> library
do not accept surrogates as valid code points.
An extra parameter in these functions makes them more permissive.
</li>

<li>
The options "<code>setpause</code>" and "<code>setstepmul</code>"
of the function <a href="#pdf-collectgarbage"><code>collectgarbage</code></a> are deprecated.
You should use the new option "<code>incremental</code>" to set them.
</li>

<li>
The function <a href="#pdf-io.lines"><code>io.lines</code></a> now returns four values,
instead of just one.
That can be a problem when it is used as the sole
argument to another function that has optional parameters,
such as in <code>load(io.lines(filename, "L"))</code>.
To fix that issue,
you can wrap the call into parentheses,
to adjust its number of results to one.
</li>

</ul>




<h2>8.3 – <a name="8.3">Incompatibilities in the API</a></h2>


<ul>

<li>
Full userdata now has an arbitrary number of associated user values.
Therefore, the functions <code>lua_newuserdata</code>,
<code>lua_setuservalue</code>, and <code>lua_getuservalue</code> were
replaced by <a href="#lua_newuserdatauv"><code>lua_newuserdatauv</code></a>,
<a href="#lua_setiuservalue"><code>lua_setiuservalue</code></a>, and <a href="#lua_getiuservalue"><code>lua_getiuservalue</code></a>,
which have an extra argument.


<p>
For compatibility, the old names still work as macros assuming
one single user value.
Note, however, that userdata with zero user values
are more efficient memory-wise.
</p></li>

<li>
The function <a href="#lua_resume"><code>lua_resume</code></a> has an extra parameter.
This out parameter returns the number of values on
the top of the stack that were yielded or returned by the coroutine.
(In previous versions,
those values were the entire stack.)
</li>

<li>
The function <a href="#lua_version"><code>lua_version</code></a> returns the version number,
instead of an address of the version number.
The Lua core should work correctly with libraries using their
own static copies of the same core,
so there is no need to check whether they are using the same
address space.
</li>

<li>
The constant <code>LUA_ERRGCMM</code> was removed.
Errors in finalizers are never propagated;
instead, they generate a warning.
</li>

<li>
The options <code>LUA_GCSETPAUSE</code> and <code>LUA_GCSETSTEPMUL</code>
of the function <a href="#lua_gc"><code>lua_gc</code></a> are deprecated.
You should use the new option <code>LUA_GCINC</code> to set them.
</li>

</ul>




<h1>9 – <a name="9">The Complete Syntax of Lua</a></h1>

<p>
Here is the complete syntax of Lua in extended BNF.
As usual in extended BNF,
{A} means 0 or more As,
and [A] means an optional A.
(For operator precedences, see <a href="#3.4.8">§3.4.8</a>;
for a description of the terminals
Name, Numeral,
and LiteralString, see <a href="#3.1">§3.1</a>.)




</p><pre>
	chunk ::= block

	block ::= {stat} [retstat]

	stat ::=  ‘<b>;</b>’ | 
		 varlist ‘<b>=</b>’ explist | 
		 functioncall | 
		 label | 
		 <b>break</b> | 
		 <b>goto</b> Name | 
		 <b>do</b> block <b>end</b> | 
		 <b>while</b> exp <b>do</b> block <b>end</b> | 
		 <b>repeat</b> block <b>until</b> exp | 
		 <b>if</b> exp <b>then</b> block {<b>elseif</b> exp <b>then</b> block} [<b>else</b> block] <b>end</b> | 
		 <b>for</b> Name ‘<b>=</b>’ exp ‘<b>,</b>’ exp [‘<b>,</b>’ exp] <b>do</b> block <b>end</b> | 
		 <b>for</b> namelist <b>in</b> explist <b>do</b> block <b>end</b> | 
		 <b>function</b> funcname funcbody | 
		 <b>local</b> <b>function</b> Name funcbody | 
		 <b>local</b> attnamelist [‘<b>=</b>’ explist] 

	attnamelist ::=  Name attrib {‘<b>,</b>’ Name attrib}

	attrib ::= [‘<b>&lt;</b>’ Name ‘<b>&gt;</b>’]

	retstat ::= <b>return</b> [explist] [‘<b>;</b>’]

	label ::= ‘<b>::</b>’ Name ‘<b>::</b>’

	funcname ::= Name {‘<b>.</b>’ Name} [‘<b>:</b>’ Name]

	varlist ::= var {‘<b>,</b>’ var}

	var ::=  Name | prefixexp ‘<b>[</b>’ exp ‘<b>]</b>’ | prefixexp ‘<b>.</b>’ Name 

	namelist ::= Name {‘<b>,</b>’ Name}

	explist ::= exp {‘<b>,</b>’ exp}

	exp ::=  <b>nil</b> | <b>false</b> | <b>true</b> | Numeral | LiteralString | ‘<b>...</b>’ | functiondef | 
		 prefixexp | tableconstructor | exp binop exp | unop exp 

	prefixexp ::= var | functioncall | ‘<b>(</b>’ exp ‘<b>)</b>’

	functioncall ::=  prefixexp args | prefixexp ‘<b>:</b>’ Name args 

	args ::=  ‘<b>(</b>’ [explist] ‘<b>)</b>’ | tableconstructor | LiteralString 

	functiondef ::= <b>function</b> funcbody

	funcbody ::= ‘<b>(</b>’ [parlist] ‘<b>)</b>’ block <b>end</b>

	parlist ::= namelist [‘<b>,</b>’ ‘<b>...</b>’] | ‘<b>...</b>’

	tableconstructor ::= ‘<b>{</b>’ [fieldlist] ‘<b>}</b>’

	fieldlist ::= field {fieldsep field} [fieldsep]

	field ::= ‘<b>[</b>’ exp ‘<b>]</b>’ ‘<b>=</b>’ exp | Name ‘<b>=</b>’ exp | exp

	fieldsep ::= ‘<b>,</b>’ | ‘<b>;</b>’

	binop ::=  ‘<b>+</b>’ | ‘<b>-</b>’ | ‘<b>*</b>’ | ‘<b>/</b>’ | ‘<b>//</b>’ | ‘<b>^</b>’ | ‘<b>%</b>’ | 
		 ‘<b>&amp;</b>’ | ‘<b>~</b>’ | ‘<b>|</b>’ | ‘<b>&gt;&gt;</b>’ | ‘<b>&lt;&lt;</b>’ | ‘<b>..</b>’ | 
		 ‘<b>&lt;</b>’ | ‘<b>&lt;=</b>’ | ‘<b>&gt;</b>’ | ‘<b>&gt;=</b>’ | ‘<b>==</b>’ | ‘<b>~=</b>’ | 
		 <b>and</b> | <b>or</b>

	unop ::= ‘<b>-</b>’ | <b>not</b> | ‘<b>#</b>’ | ‘<b>~</b>’

</pre>

<p>






</p><p class="footer">
Last update:
Wed May 21 21:09:59 UTC 2025
</p>
<!--
Last change: revised for Lua 5.4.8
-->



</body></html>
<!-- slice ends -->
