<!-- slice index: 5 -->
<!-- lines 5979–7479 / total 11964 -->
<!-- title: 5 – The Auxiliary Library -->
<li><b><code>source</code>: </b>
the source of the chunk that created the function.
If <code>source</code> starts with a '<code>@</code>',
it means that the function was defined in a file where
the file name follows the '<code>@</code>'.
If <code>source</code> starts with a '<code>=</code>',
the remainder of its contents describes the source in a user-dependent manner.
Otherwise,
the function was defined in a string where
<code>source</code> is that string.
</li>

<li><b><code>srclen</code>: </b>
The length of the string <code>source</code>.
</li>

<li><b><code>short_src</code>: </b>
a "printable" version of <code>source</code>, to be used in error messages.
</li>

<li><b><code>linedefined</code>: </b>
the line number where the definition of the function starts.
</li>

<li><b><code>lastlinedefined</code>: </b>
the line number where the definition of the function ends.
</li>

<li><b><code>what</code>: </b>
the string <code>"Lua"</code> if the function is a Lua function,
<code>"C"</code> if it is a C&nbsp;function,
<code>"main"</code> if it is the main part of a chunk.
</li>

<li><b><code>currentline</code>: </b>
the current line where the given function is executing.
When no line information is available,
<code>currentline</code> is set to -1.
</li>

<li><b><code>name</code>: </b>
a reasonable name for the given function.
Because functions in Lua are first-class values,
they do not have a fixed name:
some functions can be the value of multiple global variables,
while others can be stored only in a table field.
The <code>lua_getinfo</code> function checks how the function was
called to find a suitable name.
If it cannot find a name,
then <code>name</code> is set to <code>NULL</code>.
</li>

<li><b><code>namewhat</code>: </b>
explains the <code>name</code> field.
The value of <code>namewhat</code> can be
<code>"global"</code>, <code>"local"</code>, <code>"method"</code>,
<code>"field"</code>, <code>"upvalue"</code>, or <code>""</code> (the empty string),
according to how the function was called.
(Lua uses the empty string when no other option seems to apply.)
</li>

<li><b><code>istailcall</code>: </b>
true if this function invocation was called by a tail call.
In this case, the caller of this level is not in the stack.
</li>

<li><b><code>nups</code>: </b>
the number of upvalues of the function.
</li>

<li><b><code>nparams</code>: </b>
the number of parameters of the function
(always 0&nbsp;for C&nbsp;functions).
</li>

<li><b><code>isvararg</code>: </b>
true if the function is a variadic function
(always true for C&nbsp;functions).
</li>

<li><b><code>ftransfer</code>: </b>
the index in the stack of the first value being "transferred",
that is, parameters in a call or return values in a return.
(The other values are in consecutive indices.)
Using this index, you can access and modify these values
through <a href="#lua_getlocal"><code>lua_getlocal</code></a> and <a href="#lua_setlocal"><code>lua_setlocal</code></a>.
This field is only meaningful during a
call hook, denoting the first parameter,
or a return hook, denoting the first value being returned.
(For call hooks, this value is always 1.)
</li>

<li><b><code>ntransfer</code>: </b>
The number of values being transferred (see previous item).
(For calls of Lua functions,
this value is always equal to <code>nparams</code>.)
</li>

</ul>




<hr><h3><a name="lua_gethook"><code>lua_gethook</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_Hook lua_gethook (lua_State *L);</pre>

<p>
Returns the current hook function.





</p><hr><h3><a name="lua_gethookcount"><code>lua_gethookcount</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_gethookcount (lua_State *L);</pre>

<p>
Returns the current hook count.





</p><hr><h3><a name="lua_gethookmask"><code>lua_gethookmask</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_gethookmask (lua_State *L);</pre>

<p>
Returns the current hook mask.





</p><hr><h3><a name="lua_getinfo"><code>lua_getinfo</code></a></h3><p>
<span class="apii">[-(0|1), +(0|1|2), <em>m</em>]</span>
</p><pre>int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);</pre>

<p>
Gets information about a specific function or function invocation.


</p><p>
To get information about a function invocation,
the parameter <code>ar</code> must be a valid activation record that was
filled by a previous call to <a href="#lua_getstack"><code>lua_getstack</code></a> or
given as argument to a hook (see <a href="#lua_Hook"><code>lua_Hook</code></a>).


</p><p>
To get information about a function, you push it onto the stack
and start the <code>what</code> string with the character '<code>&gt;</code>'.
(In that case,
<code>lua_getinfo</code> pops the function from the top of the stack.)
For instance, to know in which line a function <code>f</code> was defined,
you can write the following code:

</p><pre>     lua_Debug ar;
     lua_getglobal(L, "f");  /* get global 'f' */
     lua_getinfo(L, "&gt;S", &amp;ar);
     printf("%d\n", ar.linedefined);
</pre>

<p>
Each character in the string <code>what</code>
selects some fields of the structure <code>ar</code> to be filled or
a value to be pushed on the stack.
(These characters are also documented in the declaration of
the structure <a href="#lua_Debug"><code>lua_Debug</code></a>,
between parentheses in the comments following each field.)

</p><ul>

<li><b>'<code>f</code>': </b>
pushes onto the stack the function that is
running at the given level;
</li>

<li><b>'<code>l</code>': </b> fills in the field <code>currentline</code>;
</li>

<li><b>'<code>n</code>': </b> fills in the fields <code>name</code> and <code>namewhat</code>;
</li>

<li><b>'<code>r</code>': </b> fills in the fields <code>ftransfer</code> and <code>ntransfer</code>;
</li>

<li><b>'<code>S</code>': </b>
fills in the fields <code>source</code>, <code>short_src</code>,
<code>linedefined</code>, <code>lastlinedefined</code>, and <code>what</code>;
</li>

<li><b>'<code>t</code>': </b> fills in the field <code>istailcall</code>;
</li>

<li><b>'<code>u</code>': </b> fills in the fields
<code>nups</code>, <code>nparams</code>, and <code>isvararg</code>;
</li>

<li><b>'<code>L</code>': </b>
pushes onto the stack a table whose indices are
the lines on the function with some associated code,
that is, the lines where you can put a break point.
(Lines with no code include empty lines and comments.)
If this option is given together with option '<code>f</code>',
its table is pushed after the function.
This is the only option that can raise a memory error.
</li>

</ul>

<p>
This function returns 0 to signal an invalid option in <code>what</code>;
even then the valid options are handled correctly.





</p><hr><h3><a name="lua_getlocal"><code>lua_getlocal</code></a></h3><p>
<span class="apii">[-0, +(0|1), –]</span>
</p><pre>const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n);</pre>

<p>
Gets information about a local variable or a temporary value
of a given activation record or a given function.


</p><p>
In the first case,
the parameter <code>ar</code> must be a valid activation record that was
filled by a previous call to <a href="#lua_getstack"><code>lua_getstack</code></a> or
given as argument to a hook (see <a href="#lua_Hook"><code>lua_Hook</code></a>).
The index <code>n</code> selects which local variable to inspect;
see <a href="#pdf-debug.getlocal"><code>debug.getlocal</code></a> for details about variable indices
and names.


</p><p>
<a href="#lua_getlocal"><code>lua_getlocal</code></a> pushes the variable's value onto the stack
and returns its name.


</p><p>
In the second case, <code>ar</code> must be <code>NULL</code> and the function
to be inspected must be on the top of the stack.
In this case, only parameters of Lua functions are visible
(as there is no information about what variables are active)
and no values are pushed onto the stack.


</p><p>
Returns <code>NULL</code> (and pushes nothing)
when the index is greater than
the number of active local variables.





</p><hr><h3><a name="lua_getstack"><code>lua_getstack</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_getstack (lua_State *L, int level, lua_Debug *ar);</pre>

<p>
Gets information about the interpreter runtime stack.


</p><p>
This function fills parts of a <a href="#lua_Debug"><code>lua_Debug</code></a> structure with
an identification of the <em>activation record</em>
of the function executing at a given level.
Level&nbsp;0 is the current running function,
whereas level <em>n+1</em> is the function that has called level <em>n</em>
(except for tail calls, which do not count in the stack).
When called with a level greater than the stack depth,
<a href="#lua_getstack"><code>lua_getstack</code></a> returns 0;
otherwise it returns 1.





</p><hr><h3><a name="lua_getupvalue"><code>lua_getupvalue</code></a></h3><p>
<span class="apii">[-0, +(0|1), –]</span>
</p><pre>const char *lua_getupvalue (lua_State *L, int funcindex, int n);</pre>

<p>
Gets information about the <code>n</code>-th upvalue
of the closure at index <code>funcindex</code>.
It pushes the upvalue's value onto the stack
and returns its name.
Returns <code>NULL</code> (and pushes nothing)
when the index <code>n</code> is greater than the number of upvalues.


</p><p>
See <a href="#pdf-debug.getupvalue"><code>debug.getupvalue</code></a> for more information about upvalues.





</p><hr><h3><a name="lua_Hook"><code>lua_Hook</code></a></h3>
<pre>typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);</pre>

<p>
Type for debugging hook functions.


</p><p>
Whenever a hook is called, its <code>ar</code> argument has its field
<code>event</code> set to the specific event that triggered the hook.
Lua identifies these events with the following constants:
<a name="pdf-LUA_HOOKCALL"><code>LUA_HOOKCALL</code></a>, <a name="pdf-LUA_HOOKRET"><code>LUA_HOOKRET</code></a>,
<a name="pdf-LUA_HOOKTAILCALL"><code>LUA_HOOKTAILCALL</code></a>, <a name="pdf-LUA_HOOKLINE"><code>LUA_HOOKLINE</code></a>,
and <a name="pdf-LUA_HOOKCOUNT"><code>LUA_HOOKCOUNT</code></a>.
Moreover, for line events, the field <code>currentline</code> is also set.
To get the value of any other field in <code>ar</code>,
the hook must call <a href="#lua_getinfo"><code>lua_getinfo</code></a>.


</p><p>
For call events, <code>event</code> can be <code>LUA_HOOKCALL</code>,
the normal value, or <code>LUA_HOOKTAILCALL</code>, for a tail call;
in this case, there will be no corresponding return event.


</p><p>
While Lua is running a hook, it disables other calls to hooks.
Therefore, if a hook calls back Lua to execute a function or a chunk,
this execution occurs without any calls to hooks.


</p><p>
Hook functions cannot have continuations,
that is, they cannot call <a href="#lua_yieldk"><code>lua_yieldk</code></a>,
<a href="#lua_pcallk"><code>lua_pcallk</code></a>, or <a href="#lua_callk"><code>lua_callk</code></a> with a non-null <code>k</code>.


</p><p>
Hook functions can yield under the following conditions:
Only count and line events can yield;
to yield, a hook function must finish its execution
calling <a href="#lua_yield"><code>lua_yield</code></a> with <code>nresults</code> equal to zero
(that is, with no values).





</p><hr><h3><a name="lua_sethook"><code>lua_sethook</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void lua_sethook (lua_State *L, lua_Hook f, int mask, int count);</pre>

<p>
Sets the debugging hook function.


</p><p>
Argument <code>f</code> is the hook function.
<code>mask</code> specifies on which events the hook will be called:
it is formed by a bitwise OR of the constants
<a name="pdf-LUA_MASKCALL"><code>LUA_MASKCALL</code></a>,
<a name="pdf-LUA_MASKRET"><code>LUA_MASKRET</code></a>,
<a name="pdf-LUA_MASKLINE"><code>LUA_MASKLINE</code></a>,
and <a name="pdf-LUA_MASKCOUNT"><code>LUA_MASKCOUNT</code></a>.
The <code>count</code> argument is only meaningful when the mask
includes <code>LUA_MASKCOUNT</code>.
For each event, the hook is called as explained below:

</p><ul>

<li><b>The call hook: </b> is called when the interpreter calls a function.
The hook is called just after Lua enters the new function.
</li>

<li><b>The return hook: </b> is called when the interpreter returns from a function.
The hook is called just before Lua leaves the function.
</li>

<li><b>The line hook: </b> is called when the interpreter is about to
start the execution of a new line of code,
or when it jumps back in the code (even to the same line).
This event only happens while Lua is executing a Lua function.
</li>

<li><b>The count hook: </b> is called after the interpreter executes every
<code>count</code> instructions.
This event only happens while Lua is executing a Lua function.
</li>

</ul>

<p>
Hooks are disabled by setting <code>mask</code> to zero.





</p><hr><h3><a name="lua_setlocal"><code>lua_setlocal</code></a></h3><p>
<span class="apii">[-(0|1), +0, –]</span>
</p><pre>const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n);</pre>

<p>
Sets the value of a local variable of a given activation record.
It assigns the value on the top of the stack
to the variable and returns its name.
It also pops the value from the stack.


</p><p>
Returns <code>NULL</code> (and pops nothing)
when the index is greater than
the number of active local variables.


</p><p>
Parameters <code>ar</code> and <code>n</code> are as in the function <a href="#lua_getlocal"><code>lua_getlocal</code></a>.





</p><hr><h3><a name="lua_setupvalue"><code>lua_setupvalue</code></a></h3><p>
<span class="apii">[-(0|1), +0, –]</span>
</p><pre>const char *lua_setupvalue (lua_State *L, int funcindex, int n);</pre>

<p>
Sets the value of a closure's upvalue.
It assigns the value on the top of the stack
to the upvalue and returns its name.
It also pops the value from the stack.


</p><p>
Returns <code>NULL</code> (and pops nothing)
when the index <code>n</code> is greater than the number of upvalues.


</p><p>
Parameters <code>funcindex</code> and <code>n</code> are as in
the function <a href="#lua_getupvalue"><code>lua_getupvalue</code></a>.





</p><hr><h3><a name="lua_upvalueid"><code>lua_upvalueid</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void *lua_upvalueid (lua_State *L, int funcindex, int n);</pre>

<p>
Returns a unique identifier for the upvalue numbered <code>n</code>
from the closure at index <code>funcindex</code>.


</p><p>
These unique identifiers allow a program to check whether different
closures share upvalues.
Lua closures that share an upvalue
(that is, that access a same external local variable)
will return identical ids for those upvalue indices.


</p><p>
Parameters <code>funcindex</code> and <code>n</code> are as in
the function <a href="#lua_getupvalue"><code>lua_getupvalue</code></a>,
but <code>n</code> cannot be greater than the number of upvalues.





</p><hr><h3><a name="lua_upvaluejoin"><code>lua_upvaluejoin</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void lua_upvaluejoin (lua_State *L, int funcindex1, int n1,
                                    int funcindex2, int n2);</pre>

<p>
Make the <code>n1</code>-th upvalue of the Lua closure at index <code>funcindex1</code>
refer to the <code>n2</code>-th upvalue of the Lua closure at index <code>funcindex2</code>.







</p><h1>5 – <a name="5">The Auxiliary Library</a></h1>



<p>

The <em>auxiliary library</em> provides several convenient functions
to interface C with Lua.
While the basic API provides the primitive functions for all
interactions between C and Lua,
the auxiliary library provides higher-level functions for some
common tasks.


</p><p>
All functions and types from the auxiliary library
are defined in header file <code>lauxlib.h</code> and
have a prefix <code>luaL_</code>.


</p><p>
All functions in the auxiliary library are built on
top of the basic API,
and so they provide nothing that cannot be done with that API.
Nevertheless, the use of the auxiliary library ensures
more consistency to your code.


</p><p>
Several functions in the auxiliary library use internally some
extra stack slots.
When a function in the auxiliary library uses less than five slots,
it does not check the stack size;
it simply assumes that there are enough slots.


</p><p>
Several functions in the auxiliary library are used to
check C&nbsp;function arguments.
Because the error message is formatted for arguments
(e.g., "<code>bad argument #1</code>"),
you should not use these functions for other stack values.


</p><p>
Functions called <code>luaL_check*</code>
always raise an error if the check is not satisfied.





</p><h2>5.1 – <a name="5.1">Functions and Types</a></h2>

<p>
Here we list all functions and types from the auxiliary library
in alphabetical order.



</p><hr><h3><a name="luaL_addchar"><code>luaL_addchar</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
</p><pre>void luaL_addchar (luaL_Buffer *B, char c);</pre>

<p>
Adds the byte <code>c</code> to the buffer <code>B</code>
(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).





</p><hr><h3><a name="luaL_addgsub"><code>luaL_addgsub</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
</p><pre>const void luaL_addgsub (luaL_Buffer *B, const char *s,
                         const char *p, const char *r);</pre>

<p>
Adds a copy of the string <code>s</code> to the buffer <code>B</code> (see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>),
replacing any occurrence of the string <code>p</code>
with the string <code>r</code>.





</p><hr><h3><a name="luaL_addlstring"><code>luaL_addlstring</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
</p><pre>void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l);</pre>

<p>
Adds the string pointed to by <code>s</code> with length <code>l</code> to
the buffer <code>B</code>
(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).
The string can contain embedded zeros.





</p><hr><h3><a name="luaL_addsize"><code>luaL_addsize</code></a></h3><p>
<span class="apii">[-?, +?, –]</span>
</p><pre>void luaL_addsize (luaL_Buffer *B, size_t n);</pre>

<p>
Adds to the buffer <code>B</code>
a string of length <code>n</code> previously copied to the
buffer area (see <a href="#luaL_prepbuffer"><code>luaL_prepbuffer</code></a>).





</p><hr><h3><a name="luaL_addstring"><code>luaL_addstring</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
</p><pre>void luaL_addstring (luaL_Buffer *B, const char *s);</pre>

<p>
Adds the zero-terminated string pointed to by <code>s</code>
to the buffer <code>B</code>
(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).





</p><hr><h3><a name="luaL_addvalue"><code>luaL_addvalue</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
</p><pre>void luaL_addvalue (luaL_Buffer *B);</pre>

<p>
Adds the value on the top of the stack
to the buffer <code>B</code>
(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).
Pops the value.


</p><p>
This is the only function on string buffers that can (and must)
be called with an extra element on the stack,
which is the value to be added to the buffer.





</p><hr><h3><a name="luaL_argcheck"><code>luaL_argcheck</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>void luaL_argcheck (lua_State *L,
                    int cond,
                    int arg,
                    const char *extramsg);</pre>

<p>
Checks whether <code>cond</code> is true.
If it is not, raises an error with a standard message (see <a href="#luaL_argerror"><code>luaL_argerror</code></a>).





</p><hr><h3><a name="luaL_argerror"><code>luaL_argerror</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>int luaL_argerror (lua_State *L, int arg, const char *extramsg);</pre>

<p>
Raises an error reporting a problem with argument <code>arg</code>
of the C&nbsp;function that called it,
using a standard message
that includes <code>extramsg</code> as a comment:

</p><pre>     bad argument #<em>arg</em> to '<em>funcname</em>' (<em>extramsg</em>)
</pre><p>
This function never returns.





</p><hr><h3><a name="luaL_argexpected"><code>luaL_argexpected</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>void luaL_argexpected (lua_State *L,
                       int cond,
                       int arg,
                       const char *tname);</pre>

<p>
Checks whether <code>cond</code> is true.
If it is not, raises an error about the type of the argument <code>arg</code>
with a standard message (see <a href="#luaL_typeerror"><code>luaL_typeerror</code></a>).





</p><hr><h3><a name="luaL_Buffer"><code>luaL_Buffer</code></a></h3>
<pre>typedef struct luaL_Buffer luaL_Buffer;</pre>

<p>
Type for a <em>string buffer</em>.


</p><p>
A string buffer allows C&nbsp;code to build Lua strings piecemeal.
Its pattern of use is as follows:

</p><ul>

<li>First declare a variable <code>b</code> of type <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>.</li>

<li>Then initialize it with a call <code>luaL_buffinit(L, &amp;b)</code>.</li>

<li>
Then add string pieces to the buffer calling any of
the <code>luaL_add*</code> functions.
</li>

<li>
Finish by calling <code>luaL_pushresult(&amp;b)</code>.
This call leaves the final string on the top of the stack.
</li>

</ul>

<p>
If you know beforehand the maximum size of the resulting string,
you can use the buffer like this:

</p><ul>

<li>First declare a variable <code>b</code> of type <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>.</li>

<li>Then initialize it and preallocate a space of
size <code>sz</code> with a call <code>luaL_buffinitsize(L, &amp;b, sz)</code>.</li>

<li>Then produce the string into that space.</li>

<li>
Finish by calling <code>luaL_pushresultsize(&amp;b, sz)</code>,
where <code>sz</code> is the total size of the resulting string
copied into that space (which may be less than or
equal to the preallocated size).
</li>

</ul>

<p>
During its normal operation,
a string buffer uses a variable number of stack slots.
So, while using a buffer, you cannot assume that you know where
the top of the stack is.
You can use the stack between successive calls to buffer operations
as long as that use is balanced;
that is,
when you call a buffer operation,
the stack is at the same level
it was immediately after the previous buffer operation.
(The only exception to this rule is <a href="#luaL_addvalue"><code>luaL_addvalue</code></a>.)
After calling <a href="#luaL_pushresult"><code>luaL_pushresult</code></a>,
the stack is back to its level when the buffer was initialized,
plus the final string on its top.





</p><hr><h3><a name="luaL_buffaddr"><code>luaL_buffaddr</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>char *luaL_buffaddr (luaL_Buffer *B);</pre>

<p>
Returns the address of the current content of buffer <code>B</code>
(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).
Note that any addition to the buffer may invalidate this address.





</p><hr><h3><a name="luaL_buffinit"><code>luaL_buffinit</code></a></h3><p>
<span class="apii">[-0, +?, –]</span>
</p><pre>void luaL_buffinit (lua_State *L, luaL_Buffer *B);</pre>

<p>
Initializes a buffer <code>B</code>
(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).
This function does not allocate any space;
the buffer must be declared as a variable.





</p><hr><h3><a name="luaL_bufflen"><code>luaL_bufflen</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>size_t luaL_bufflen (luaL_Buffer *B);</pre>

<p>
Returns the length of the current content of buffer <code>B</code>
(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).





</p><hr><h3><a name="luaL_buffinitsize"><code>luaL_buffinitsize</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
</p><pre>char *luaL_buffinitsize (lua_State *L, luaL_Buffer *B, size_t sz);</pre>

<p>
Equivalent to the sequence
<a href="#luaL_buffinit"><code>luaL_buffinit</code></a>, <a href="#luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a>.





</p><hr><h3><a name="luaL_buffsub"><code>luaL_buffsub</code></a></h3><p>
<span class="apii">[-?, +?, –]</span>
</p><pre>void luaL_buffsub (luaL_Buffer *B, int n);</pre>

<p>
Removes <code>n</code> bytes from the buffer <code>B</code>
(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).
The buffer must have at least that many bytes.





</p><hr><h3><a name="luaL_callmeta"><code>luaL_callmeta</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>e</em>]</span>
</p><pre>int luaL_callmeta (lua_State *L, int obj, const char *e);</pre>

<p>
Calls a metamethod.


</p><p>
If the object at index <code>obj</code> has a metatable and this
metatable has a field <code>e</code>,
this function calls this field passing the object as its only argument.
In this case this function returns true and pushes onto the
stack the value returned by the call.
If there is no metatable or no metamethod,
this function returns false without pushing any value on the stack.





</p><hr><h3><a name="luaL_checkany"><code>luaL_checkany</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>void luaL_checkany (lua_State *L, int arg);</pre>

<p>
Checks whether the function has an argument
of any type (including <b>nil</b>) at position <code>arg</code>.





</p><hr><h3><a name="luaL_checkinteger"><code>luaL_checkinteger</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>lua_Integer luaL_checkinteger (lua_State *L, int arg);</pre>

<p>
Checks whether the function argument <code>arg</code> is an integer
(or can be converted to an integer)
and returns this integer.





</p><hr><h3><a name="luaL_checklstring"><code>luaL_checklstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>const char *luaL_checklstring (lua_State *L, int arg, size_t *l);</pre>

<p>
Checks whether the function argument <code>arg</code> is a string
and returns this string;
if <code>l</code> is not <code>NULL</code> fills its referent
with the string's length.


</p><p>
This function uses <a href="#lua_tolstring"><code>lua_tolstring</code></a> to get its result,
so all conversions and caveats of that function apply here.





</p><hr><h3><a name="luaL_checknumber"><code>luaL_checknumber</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>lua_Number luaL_checknumber (lua_State *L, int arg);</pre>

<p>
Checks whether the function argument <code>arg</code> is a number
and returns this number converted to a <code>lua_Number</code>.





</p><hr><h3><a name="luaL_checkoption"><code>luaL_checkoption</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>int luaL_checkoption (lua_State *L,
                      int arg,
                      const char *def,
                      const char *const lst[]);</pre>

<p>
Checks whether the function argument <code>arg</code> is a string and
searches for this string in the array <code>lst</code>
(which must be NULL-terminated).
Returns the index in the array where the string was found.
Raises an error if the argument is not a string or
if the string cannot be found.


</p><p>
If <code>def</code> is not <code>NULL</code>,
the function uses <code>def</code> as a default value when
there is no argument <code>arg</code> or when this argument is <b>nil</b>.


</p><p>
This is a useful function for mapping strings to C&nbsp;enums.
(The usual convention in Lua libraries is
to use strings instead of numbers to select options.)





</p><hr><h3><a name="luaL_checkstack"><code>luaL_checkstack</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>void luaL_checkstack (lua_State *L, int sz, const char *msg);</pre>

<p>
Grows the stack size to <code>top + sz</code> elements,
raising an error if the stack cannot grow to that size.
<code>msg</code> is an additional text to go into the error message
(or <code>NULL</code> for no additional text).





</p><hr><h3><a name="luaL_checkstring"><code>luaL_checkstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>const char *luaL_checkstring (lua_State *L, int arg);</pre>

<p>
Checks whether the function argument <code>arg</code> is a string
and returns this string.


</p><p>
This function uses <a href="#lua_tolstring"><code>lua_tolstring</code></a> to get its result,
so all conversions and caveats of that function apply here.





</p><hr><h3><a name="luaL_checktype"><code>luaL_checktype</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>void luaL_checktype (lua_State *L, int arg, int t);</pre>

<p>
Checks whether the function argument <code>arg</code> has type <code>t</code>.
See <a href="#lua_type"><code>lua_type</code></a> for the encoding of types for <code>t</code>.





</p><hr><h3><a name="luaL_checkudata"><code>luaL_checkudata</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>void *luaL_checkudata (lua_State *L, int arg, const char *tname);</pre>

<p>
Checks whether the function argument <code>arg</code> is a userdata
of the type <code>tname</code> (see <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>) and
returns the userdata's memory-block address (see <a href="#lua_touserdata"><code>lua_touserdata</code></a>).





</p><hr><h3><a name="luaL_checkversion"><code>luaL_checkversion</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>void luaL_checkversion (lua_State *L);</pre>

<p>
Checks whether the code making the call and the Lua library being called
are using the same version of Lua and the same numeric types.





</p><hr><h3><a name="luaL_dofile"><code>luaL_dofile</code></a></h3><p>
<span class="apii">[-0, +?, <em>m</em>]</span>
</p><pre>int luaL_dofile (lua_State *L, const char *filename);</pre>

<p>
Loads and runs the given file.
It is defined as the following macro:

</p><pre>     (luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0))
</pre><p>
It returns&nbsp;0 (<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>) if there are no errors,
or 1 in case of errors.





</p><hr><h3><a name="luaL_dostring"><code>luaL_dostring</code></a></h3><p>
<span class="apii">[-0, +?, –]</span>
</p><pre>int luaL_dostring (lua_State *L, const char *str);</pre>

<p>
Loads and runs the given string.
It is defined as the following macro:

</p><pre>     (luaL_loadstring(L, str) || lua_pcall(L, 0, LUA_MULTRET, 0))
</pre><p>
It returns&nbsp;0 (<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>) if there are no errors,
or 1 in case of errors.





</p><hr><h3><a name="luaL_error"><code>luaL_error</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>int luaL_error (lua_State *L, const char *fmt, ...);</pre>

<p>
Raises an error.
The error message format is given by <code>fmt</code>
plus any extra arguments,
following the same rules of <a href="#lua_pushfstring"><code>lua_pushfstring</code></a>.
It also adds at the beginning of the message the file name and
the line number where the error occurred,
if this information is available.


</p><p>
This function never returns,
but it is an idiom to use it in C&nbsp;functions
as <code>return luaL_error(<em>args</em>)</code>.





</p><hr><h3><a name="luaL_execresult"><code>luaL_execresult</code></a></h3><p>
<span class="apii">[-0, +3, <em>m</em>]</span>
</p><pre>int luaL_execresult (lua_State *L, int stat);</pre>

<p>
This function produces the return values for
process-related functions in the standard library
(<a href="#pdf-os.execute"><code>os.execute</code></a> and <a href="#pdf-io.close"><code>io.close</code></a>).





</p><hr><h3><a name="luaL_fileresult"><code>luaL_fileresult</code></a></h3><p>
<span class="apii">[-0, +(1|3), <em>m</em>]</span>
</p><pre>int luaL_fileresult (lua_State *L, int stat, const char *fname);</pre>

<p>
This function produces the return values for
file-related functions in the standard library
(<a href="#pdf-io.open"><code>io.open</code></a>, <a href="#pdf-os.rename"><code>os.rename</code></a>, <a href="#pdf-file:seek"><code>file:seek</code></a>, etc.).





</p><hr><h3><a name="luaL_getmetafield"><code>luaL_getmetafield</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>m</em>]</span>
</p><pre>int luaL_getmetafield (lua_State *L, int obj, const char *e);</pre>

<p>
Pushes onto the stack the field <code>e</code> from the metatable
of the object at index <code>obj</code> and returns the type of the pushed value.
If the object does not have a metatable,
or if the metatable does not have this field,
pushes nothing and returns <code>LUA_TNIL</code>.





</p><hr><h3><a name="luaL_getmetatable"><code>luaL_getmetatable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>int luaL_getmetatable (lua_State *L, const char *tname);</pre>

<p>
Pushes onto the stack the metatable associated with the name <code>tname</code>
in the registry (see <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>),
or <b>nil</b> if there is no metatable associated with that name.
Returns the type of the pushed value.





</p><hr><h3><a name="luaL_getsubtable"><code>luaL_getsubtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
</p><pre>int luaL_getsubtable (lua_State *L, int idx, const char *fname);</pre>

<p>
Ensures that the value <code>t[fname]</code>,
where <code>t</code> is the value at index <code>idx</code>,
is a table,
and pushes that table onto the stack.
Returns true if it finds a previous table there
and false if it creates a new table.





</p><hr><h3><a name="luaL_gsub"><code>luaL_gsub</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>const char *luaL_gsub (lua_State *L,
                       const char *s,
                       const char *p,
                       const char *r);</pre>

<p>
Creates a copy of string <code>s</code>,
replacing any occurrence of the string <code>p</code>
with the string <code>r</code>.
Pushes the resulting string on the stack and returns it.





</p><hr><h3><a name="luaL_len"><code>luaL_len</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
</p><pre>lua_Integer luaL_len (lua_State *L, int index);</pre>

<p>
Returns the "length" of the value at the given index
as a number;
it is equivalent to the '<code>#</code>' operator in Lua (see <a href="#3.4.7">§3.4.7</a>).
Raises an error if the result of the operation is not an integer.
(This case can only happen through metamethods.)





</p><hr><h3><a name="luaL_loadbuffer"><code>luaL_loadbuffer</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>int luaL_loadbuffer (lua_State *L,
                     const char *buff,
                     size_t sz,
                     const char *name);</pre>

<p>
Equivalent to <a href="#luaL_loadbufferx"><code>luaL_loadbufferx</code></a> with <code>mode</code> equal to <code>NULL</code>.





</p><hr><h3><a name="luaL_loadbufferx"><code>luaL_loadbufferx</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>int luaL_loadbufferx (lua_State *L,
                      const char *buff,
                      size_t sz,
                      const char *name,
                      const char *mode);</pre>

<p>
Loads a buffer as a Lua chunk.
This function uses <a href="#lua_load"><code>lua_load</code></a> to load the chunk in the
buffer pointed to by <code>buff</code> with size <code>sz</code>.


</p><p>
This function returns the same results as <a href="#lua_load"><code>lua_load</code></a>.
<code>name</code> is the chunk name,
used for debug information and error messages.
The string <code>mode</code> works as in the function <a href="#lua_load"><code>lua_load</code></a>.





</p><hr><h3><a name="luaL_loadfile"><code>luaL_loadfile</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>int luaL_loadfile (lua_State *L, const char *filename);</pre>

<p>
Equivalent to <a href="#luaL_loadfilex"><code>luaL_loadfilex</code></a> with <code>mode</code> equal to <code>NULL</code>.





</p><hr><h3><a name="luaL_loadfilex"><code>luaL_loadfilex</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>int luaL_loadfilex (lua_State *L, const char *filename,
                                            const char *mode);</pre>

<p>
Loads a file as a Lua chunk.
This function uses <a href="#lua_load"><code>lua_load</code></a> to load the chunk in the file
named <code>filename</code>.
If <code>filename</code> is <code>NULL</code>,
then it loads from the standard input.
The first line in the file is ignored if it starts with a <code>#</code>.


</p><p>
The string <code>mode</code> works as in the function <a href="#lua_load"><code>lua_load</code></a>.


</p><p>
This function returns the same results as <a href="#lua_load"><code>lua_load</code></a>
or <a href="#pdf-LUA_ERRFILE"><code>LUA_ERRFILE</code></a> for file-related errors.


</p><p>
As <a href="#lua_load"><code>lua_load</code></a>, this function only loads the chunk;
it does not run it.





</p><hr><h3><a name="luaL_loadstring"><code>luaL_loadstring</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>int luaL_loadstring (lua_State *L, const char *s);</pre>

<p>
Loads a string as a Lua chunk.
This function uses <a href="#lua_load"><code>lua_load</code></a> to load the chunk in
the zero-terminated string <code>s</code>.


</p><p>
This function returns the same results as <a href="#lua_load"><code>lua_load</code></a>.


</p><p>
Also as <a href="#lua_load"><code>lua_load</code></a>, this function only loads the chunk;
it does not run it.





</p><hr><h3><a name="luaL_newlib"><code>luaL_newlib</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>void luaL_newlib (lua_State *L, const luaL_Reg l[]);</pre>

<p>
Creates a new table and registers there
the functions in the list <code>l</code>.


</p><p>
It is implemented as the following macro:

</p><pre>     (luaL_newlibtable(L,l), luaL_setfuncs(L,l,0))
</pre><p>
The array <code>l</code> must be the actual array,
not a pointer to it.





</p><hr><h3><a name="luaL_newlibtable"><code>luaL_newlibtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>void luaL_newlibtable (lua_State *L, const luaL_Reg l[]);</pre>

<p>
Creates a new table with a size optimized
to store all entries in the array <code>l</code>
(but does not actually store them).
It is intended to be used in conjunction with <a href="#luaL_setfuncs"><code>luaL_setfuncs</code></a>
(see <a href="#luaL_newlib"><code>luaL_newlib</code></a>).


</p><p>
It is implemented as a macro.
The array <code>l</code> must be the actual array,
not a pointer to it.





</p><hr><h3><a name="luaL_newmetatable"><code>luaL_newmetatable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>int luaL_newmetatable (lua_State *L, const char *tname);</pre>

<p>
If the registry already has the key <code>tname</code>,
returns 0.
Otherwise,
creates a new table to be used as a metatable for userdata,
adds to this new table the pair <code>__name = tname</code>,
adds to the registry the pair <code>[tname] = new table</code>,
and returns 1.


</p><p>
In both cases,
the function pushes onto the stack the final value associated
with <code>tname</code> in the registry.





</p><hr><h3><a name="luaL_newstate"><code>luaL_newstate</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_State *luaL_newstate (void);</pre>

<p>
Creates a new Lua state.
It calls <a href="#lua_newstate"><code>lua_newstate</code></a> with an
allocator based on the ISO&nbsp;C allocation functions
and then sets a warning function and a panic function (see <a href="#4.4">§4.4</a>)
that print messages to the standard error output.


</p><p>
Returns the new state,
or <code>NULL</code> if there is a memory allocation error.





</p><hr><h3><a name="luaL_openlibs"><code>luaL_openlibs</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
</p><pre>void luaL_openlibs (lua_State *L);</pre>

<p>
Opens all standard Lua libraries into the given state.





</p><hr><h3><a name="luaL_opt"><code>luaL_opt</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>T luaL_opt (L, func, arg, dflt);</pre>

<p>
This macro is defined as follows:

</p><pre>     (lua_isnoneornil(L,(arg)) ? (dflt) : func(L,(arg)))
</pre><p>
In words, if the argument <code>arg</code> is nil or absent,
the macro results in the default <code>dflt</code>.
Otherwise, it results in the result of calling <code>func</code>
with the state <code>L</code> and the argument index <code>arg</code> as
arguments.
Note that it evaluates the expression <code>dflt</code> only if needed.





</p><hr><h3><a name="luaL_optinteger"><code>luaL_optinteger</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>lua_Integer luaL_optinteger (lua_State *L,
                             int arg,
                             lua_Integer d);</pre>

<p>
If the function argument <code>arg</code> is an integer
(or it is convertible to an integer),
returns this integer.
If this argument is absent or is <b>nil</b>,
returns <code>d</code>.
Otherwise, raises an error.





</p><hr><h3><a name="luaL_optlstring"><code>luaL_optlstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>const char *luaL_optlstring (lua_State *L,
                             int arg,
                             const char *d,
                             size_t *l);</pre>

<p>
If the function argument <code>arg</code> is a string,
returns this string.
If this argument is absent or is <b>nil</b>,
returns <code>d</code>.
Otherwise, raises an error.


</p><p>
If <code>l</code> is not <code>NULL</code>,
fills its referent with the result's length.
If the result is <code>NULL</code>
(only possible when returning <code>d</code> and <code>d == NULL</code>),
its length is considered zero.


</p><p>
This function uses <a href="#lua_tolstring"><code>lua_tolstring</code></a> to get its result,
so all conversions and caveats of that function apply here.





</p><hr><h3><a name="luaL_optnumber"><code>luaL_optnumber</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>lua_Number luaL_optnumber (lua_State *L, int arg, lua_Number d);</pre>

<p>
If the function argument <code>arg</code> is a number,
returns this number as a <code>lua_Number</code>.
If this argument is absent or is <b>nil</b>,
returns <code>d</code>.
Otherwise, raises an error.





</p><hr><h3><a name="luaL_optstring"><code>luaL_optstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>const char *luaL_optstring (lua_State *L,
                            int arg,
                            const char *d);</pre>

<p>
If the function argument <code>arg</code> is a string,
returns this string.
If this argument is absent or is <b>nil</b>,
returns <code>d</code>.
Otherwise, raises an error.





</p><hr><h3><a name="luaL_prepbuffer"><code>luaL_prepbuffer</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
</p><pre>char *luaL_prepbuffer (luaL_Buffer *B);</pre>

<p>
Equivalent to <a href="#luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a>
with the predefined size <a name="pdf-LUAL_BUFFERSIZE"><code>LUAL_BUFFERSIZE</code></a>.





</p><hr><h3><a name="luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
</p><pre>char *luaL_prepbuffsize (luaL_Buffer *B, size_t sz);</pre>

<p>
Returns an address to a space of size <code>sz</code>
where you can copy a string to be added to buffer <code>B</code>
(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).
After copying the string into this space you must call
<a href="#luaL_addsize"><code>luaL_addsize</code></a> with the size of the string to actually add
it to the buffer.





</p><hr><h3><a name="luaL_pushfail"><code>luaL_pushfail</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void luaL_pushfail (lua_State *L);</pre>

<p>
Pushes the <b>fail</b> value onto the stack (see <a href="#6">§6</a>).





</p><hr><h3><a name="luaL_pushresult"><code>luaL_pushresult</code></a></h3><p>
<span class="apii">[-?, +1, <em>m</em>]</span>
</p><pre>void luaL_pushresult (luaL_Buffer *B);</pre>
<!-- slice ends -->
