<!-- slice index: 4 -->
<!-- lines 4481–5979 / total 11964 -->
<!-- title: 4.7 – The Debug Interface -->
<p>
Creates a new independent state and returns its main thread.
Returns <code>NULL</code> if it cannot create the state
(due to lack of memory).
The argument <code>f</code> is the allocator function;
Lua will do all memory allocation for this state
through this function (see <a href="#lua_Alloc"><code>lua_Alloc</code></a>).
The second argument, <code>ud</code>, is an opaque pointer that Lua
passes to the allocator in every call.





</p><hr><h3><a name="lua_newtable"><code>lua_newtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>void lua_newtable (lua_State *L);</pre>

<p>
Creates a new empty table and pushes it onto the stack.
It is equivalent to <code>lua_createtable(L, 0, 0)</code>.





</p><hr><h3><a name="lua_newthread"><code>lua_newthread</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>lua_State *lua_newthread (lua_State *L);</pre>

<p>
Creates a new thread, pushes it on the stack,
and returns a pointer to a <a href="#lua_State"><code>lua_State</code></a> that represents this new thread.
The new thread returned by this function shares with the original thread
its global environment,
but has an independent execution stack.


</p><p>
Threads are subject to garbage collection,
like any Lua object.





</p><hr><h3><a name="lua_newuserdatauv"><code>lua_newuserdatauv</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>void *lua_newuserdatauv (lua_State *L, size_t size, int nuvalue);</pre>

<p>
This function creates and pushes on the stack a new full userdata,
with <code>nuvalue</code> associated Lua values, called <code>user values</code>,
plus an associated block of raw memory with <code>size</code> bytes.
(The user values can be set and read with the functions
<a href="#lua_setiuservalue"><code>lua_setiuservalue</code></a> and <a href="#lua_getiuservalue"><code>lua_getiuservalue</code></a>.)


</p><p>
The function returns the address of the block of memory.
Lua ensures that this address is valid as long as
the corresponding userdata is alive (see <a href="#2.5">§2.5</a>).
Moreover, if the userdata is marked for finalization (see <a href="#2.5.3">§2.5.3</a>),
its address is valid at least until the call to its finalizer.





</p><hr><h3><a name="lua_next"><code>lua_next</code></a></h3><p>
<span class="apii">[-1, +(2|0), <em>v</em>]</span>
</p><pre>int lua_next (lua_State *L, int index);</pre>

<p>
Pops a key from the stack,
and pushes a key–value pair from the table at the given index,
the "next" pair after the given key.
If there are no more elements in the table,
then <a href="#lua_next"><code>lua_next</code></a> returns&nbsp;0 and pushes nothing.


</p><p>
A typical table traversal looks like this:

</p><pre>     /* table is in the stack at index 't' */
     lua_pushnil(L);  /* first key */
     while (lua_next(L, t) != 0) {
       /* uses 'key' (at index -2) and 'value' (at index -1) */
       printf("%s - %s\n",
              lua_typename(L, lua_type(L, -2)),
              lua_typename(L, lua_type(L, -1)));
       /* removes 'value'; keeps 'key' for next iteration */
       lua_pop(L, 1);
     }
</pre>

<p>
While traversing a table,
avoid calling <a href="#lua_tolstring"><code>lua_tolstring</code></a> directly on a key,
unless you know that the key is actually a string.
Recall that <a href="#lua_tolstring"><code>lua_tolstring</code></a> may change
the value at the given index;
this confuses the next call to <a href="#lua_next"><code>lua_next</code></a>.


</p><p>
This function may raise an error if the given key
is neither <b>nil</b> nor present in the table.
See function <a href="#pdf-next"><code>next</code></a> for the caveats of modifying
the table during its traversal.





</p><hr><h3><a name="lua_Number"><code>lua_Number</code></a></h3>
<pre>typedef ... lua_Number;</pre>

<p>
The type of floats in Lua.


</p><p>
By default this type is double,
but that can be changed to a single float or a long double.
(See <code>LUA_FLOAT_TYPE</code> in <code>luaconf.h</code>.)





</p><hr><h3><a name="lua_numbertointeger"><code>lua_numbertointeger</code></a></h3>
<pre>int lua_numbertointeger (lua_Number n, lua_Integer *p);</pre>

<p>
Tries to convert a Lua float to a Lua integer;
the float <code>n</code> must have an integral value.
If that value is within the range of Lua integers,
it is converted to an integer and assigned to <code>*p</code>.
The macro results in a boolean indicating whether the
conversion was successful.
(Note that this range test can be tricky to do
correctly without this macro, due to rounding.)


</p><p>
This macro may evaluate its arguments more than once.





</p><hr><h3><a name="lua_pcall"><code>lua_pcall</code></a></h3><p>
<span class="apii">[-(nargs + 1), +(nresults|1), –]</span>
</p><pre>int lua_pcall (lua_State *L, int nargs, int nresults, int msgh);</pre>

<p>
Calls a function (or a callable object) in protected mode.


</p><p>
Both <code>nargs</code> and <code>nresults</code> have the same meaning as
in <a href="#lua_call"><code>lua_call</code></a>.
If there are no errors during the call,
<a href="#lua_pcall"><code>lua_pcall</code></a> behaves exactly like <a href="#lua_call"><code>lua_call</code></a>.
However, if there is any error,
<a href="#lua_pcall"><code>lua_pcall</code></a> catches it,
pushes a single value on the stack (the error object),
and returns an error code.
Like <a href="#lua_call"><code>lua_call</code></a>,
<a href="#lua_pcall"><code>lua_pcall</code></a> always removes the function
and its arguments from the stack.


</p><p>
If <code>msgh</code> is 0,
then the error object returned on the stack
is exactly the original error object.
Otherwise, <code>msgh</code> is the stack index of a
<em>message handler</em>.
(This index cannot be a pseudo-index.)
In case of runtime errors,
this handler will be called with the error object
and its return value will be the object
returned on the stack by <a href="#lua_pcall"><code>lua_pcall</code></a>.


</p><p>
Typically, the message handler is used to add more debug
information to the error object, such as a stack traceback.
Such information cannot be gathered after the return of <a href="#lua_pcall"><code>lua_pcall</code></a>,
since by then the stack has unwound.


</p><p>
The <a href="#lua_pcall"><code>lua_pcall</code></a> function returns one of the following status codes:
<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>, <a href="#pdf-LUA_ERRRUN"><code>LUA_ERRRUN</code></a>, <a href="#pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>, or <a href="#pdf-LUA_ERRERR"><code>LUA_ERRERR</code></a>.





</p><hr><h3><a name="lua_pcallk"><code>lua_pcallk</code></a></h3><p>
<span class="apii">[-(nargs + 1), +(nresults|1), –]</span>
</p><pre>int lua_pcallk (lua_State *L,
                int nargs,
                int nresults,
                int msgh,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>
This function behaves exactly like <a href="#lua_pcall"><code>lua_pcall</code></a>,
except that it allows the called function to yield (see <a href="#4.5">§4.5</a>).





</p><hr><h3><a name="lua_pop"><code>lua_pop</code></a></h3><p>
<span class="apii">[-n, +0, <em>e</em>]</span>
</p><pre>void lua_pop (lua_State *L, int n);</pre>

<p>
Pops <code>n</code> elements from the stack.
It is implemented as a macro over <a href="#lua_settop"><code>lua_settop</code></a>.





</p><hr><h3><a name="lua_pushboolean"><code>lua_pushboolean</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void lua_pushboolean (lua_State *L, int b);</pre>

<p>
Pushes a boolean value with value <code>b</code> onto the stack.





</p><hr><h3><a name="lua_pushcclosure"><code>lua_pushcclosure</code></a></h3><p>
<span class="apii">[-n, +1, <em>m</em>]</span>
</p><pre>void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);</pre>

<p>
Pushes a new C&nbsp;closure onto the stack.
This function receives a pointer to a C&nbsp;function
and pushes onto the stack a Lua value of type <code>function</code> that,
when called, invokes the corresponding C&nbsp;function.
The parameter <code>n</code> tells how many upvalues this function will have
(see <a href="#4.2">§4.2</a>).


</p><p>
Any function to be callable by Lua must
follow the correct protocol to receive its parameters
and return its results (see <a href="#lua_CFunction"><code>lua_CFunction</code></a>).


</p><p>
When a C&nbsp;function is created,
it is possible to associate some values with it,
the so called upvalues;
these upvalues are then accessible to the function whenever it is called.
This association is called a C&nbsp;closure (see <a href="#4.2">§4.2</a>).
To create a C&nbsp;closure,
first the initial values for its upvalues must be pushed onto the stack.
(When there are multiple upvalues, the first value is pushed first.)
Then <a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a>
is called to create and push the C&nbsp;function onto the stack,
with the argument <code>n</code> telling how many values will be
associated with the function.
<a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a> also pops these values from the stack.


</p><p>
The maximum value for <code>n</code> is 255.


</p><p>
When <code>n</code> is zero,
this function creates a <em>light C&nbsp;function</em>,
which is just a pointer to the C&nbsp;function.
In that case, it never raises a memory error.





</p><hr><h3><a name="lua_pushcfunction"><code>lua_pushcfunction</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void lua_pushcfunction (lua_State *L, lua_CFunction f);</pre>

<p>
Pushes a C&nbsp;function onto the stack.
This function is equivalent to <a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a> with no upvalues.





</p><hr><h3><a name="lua_pushfstring"><code>lua_pushfstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>v</em>]</span>
</p><pre>const char *lua_pushfstring (lua_State *L, const char *fmt, ...);</pre>

<p>
Pushes onto the stack a formatted string
and returns a pointer to this string (see <a href="#4.1.3">§4.1.3</a>).
It is similar to the ISO&nbsp;C function <code>sprintf</code>,
but has two important differences.
First,
you do not have to allocate space for the result;
the result is a Lua string and Lua takes care of memory allocation
(and deallocation, through garbage collection).
Second,
the conversion specifiers are quite restricted.
There are no flags, widths, or precisions.
The conversion specifiers can only be
'<code>%%</code>' (inserts the character '<code>%</code>'),
'<code>%s</code>' (inserts a zero-terminated string, with no size restrictions),
'<code>%f</code>' (inserts a <a href="#lua_Number"><code>lua_Number</code></a>),
'<code>%I</code>' (inserts a <a href="#lua_Integer"><code>lua_Integer</code></a>),
'<code>%p</code>' (inserts a pointer),
'<code>%d</code>' (inserts an <code>int</code>),
'<code>%c</code>' (inserts an <code>int</code> as a one-byte character), and
'<code>%U</code>' (inserts a <code>long int</code> as a UTF-8 byte sequence).


</p><p>
This function may raise errors due to memory overflow
or an invalid conversion specifier.





</p><hr><h3><a name="lua_pushglobaltable"><code>lua_pushglobaltable</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void lua_pushglobaltable (lua_State *L);</pre>

<p>
Pushes the global environment onto the stack.





</p><hr><h3><a name="lua_pushinteger"><code>lua_pushinteger</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void lua_pushinteger (lua_State *L, lua_Integer n);</pre>

<p>
Pushes an integer with value <code>n</code> onto the stack.





</p><hr><h3><a name="lua_pushlightuserdata"><code>lua_pushlightuserdata</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void lua_pushlightuserdata (lua_State *L, void *p);</pre>

<p>
Pushes a light userdata onto the stack.


</p><p>
Userdata represent C&nbsp;values in Lua.
A <em>light userdata</em> represents a pointer, a <code>void*</code>.
It is a value (like a number):
you do not create it, it has no individual metatable,
and it is not collected (as it was never created).
A light userdata is equal to "any"
light userdata with the same C&nbsp;address.





</p><hr><h3><a name="lua_pushliteral"><code>lua_pushliteral</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>const char *lua_pushliteral (lua_State *L, const char *s);</pre>

<p>
This macro is equivalent to <a href="#lua_pushstring"><code>lua_pushstring</code></a>,
but should be used only when <code>s</code> is a literal string.
(Lua may optimize this case.)





</p><hr><h3><a name="lua_pushlstring"><code>lua_pushlstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>const char *lua_pushlstring (lua_State *L, const char *s, size_t len);</pre>

<p>
Pushes the string pointed to by <code>s</code> with size <code>len</code>
onto the stack.
Lua will make or reuse an internal copy of the given string,
so the memory at <code>s</code> can be freed or reused immediately after
the function returns.
The string can contain any binary data,
including embedded zeros.


</p><p>
Returns a pointer to the internal copy of the string (see <a href="#4.1.3">§4.1.3</a>).





</p><hr><h3><a name="lua_pushnil"><code>lua_pushnil</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void lua_pushnil (lua_State *L);</pre>

<p>
Pushes a nil value onto the stack.





</p><hr><h3><a name="lua_pushnumber"><code>lua_pushnumber</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void lua_pushnumber (lua_State *L, lua_Number n);</pre>

<p>
Pushes a float with value <code>n</code> onto the stack.





</p><hr><h3><a name="lua_pushstring"><code>lua_pushstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>const char *lua_pushstring (lua_State *L, const char *s);</pre>

<p>
Pushes the zero-terminated string pointed to by <code>s</code>
onto the stack.
Lua will make or reuse an internal copy of the given string,
so the memory at <code>s</code> can be freed or reused immediately after
the function returns.


</p><p>
Returns a pointer to the internal copy of the string (see <a href="#4.1.3">§4.1.3</a>).


</p><p>
If <code>s</code> is <code>NULL</code>, pushes <b>nil</b> and returns <code>NULL</code>.





</p><hr><h3><a name="lua_pushthread"><code>lua_pushthread</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>int lua_pushthread (lua_State *L);</pre>

<p>
Pushes the thread represented by <code>L</code> onto the stack.
Returns 1 if this thread is the main thread of its state.





</p><hr><h3><a name="lua_pushvalue"><code>lua_pushvalue</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void lua_pushvalue (lua_State *L, int index);</pre>

<p>
Pushes a copy of the element at the given index
onto the stack.





</p><hr><h3><a name="lua_pushvfstring"><code>lua_pushvfstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>v</em>]</span>
</p><pre>const char *lua_pushvfstring (lua_State *L,
                              const char *fmt,
                              va_list argp);</pre>

<p>
Equivalent to <a href="#lua_pushfstring"><code>lua_pushfstring</code></a>, except that it receives a <code>va_list</code>
instead of a variable number of arguments.





</p><hr><h3><a name="lua_rawequal"><code>lua_rawequal</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_rawequal (lua_State *L, int index1, int index2);</pre>

<p>
Returns 1 if the two values in indices <code>index1</code> and
<code>index2</code> are primitively equal
(that is, equal without calling the <code>__eq</code> metamethod).
Otherwise returns&nbsp;0.
Also returns&nbsp;0 if any of the indices are not valid.





</p><hr><h3><a name="lua_rawget"><code>lua_rawget</code></a></h3><p>
<span class="apii">[-1, +1, –]</span>
</p><pre>int lua_rawget (lua_State *L, int index);</pre>

<p>
Similar to <a href="#lua_gettable"><code>lua_gettable</code></a>, but does a raw access
(i.e., without metamethods).
The value at <code>index</code> must be a table.





</p><hr><h3><a name="lua_rawgeti"><code>lua_rawgeti</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>int lua_rawgeti (lua_State *L, int index, lua_Integer n);</pre>

<p>
Pushes onto the stack the value <code>t[n]</code>,
where <code>t</code> is the table at the given index.
The access is raw,
that is, it does not use the <code>__index</code> metavalue.


</p><p>
Returns the type of the pushed value.





</p><hr><h3><a name="lua_rawgetp"><code>lua_rawgetp</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>int lua_rawgetp (lua_State *L, int index, const void *p);</pre>

<p>
Pushes onto the stack the value <code>t[k]</code>,
where <code>t</code> is the table at the given index and
<code>k</code> is the pointer <code>p</code> represented as a light userdata.
The access is raw;
that is, it does not use the <code>__index</code> metavalue.


</p><p>
Returns the type of the pushed value.





</p><hr><h3><a name="lua_rawlen"><code>lua_rawlen</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_Unsigned lua_rawlen (lua_State *L, int index);</pre>

<p>
Returns the raw "length" of the value at the given index:
for strings, this is the string length;
for tables, this is the result of the length operator ('<code>#</code>')
with no metamethods;
for userdata, this is the size of the block of memory allocated
for the userdata.
For other values, this call returns&nbsp;0.





</p><hr><h3><a name="lua_rawset"><code>lua_rawset</code></a></h3><p>
<span class="apii">[-2, +0, <em>m</em>]</span>
</p><pre>void lua_rawset (lua_State *L, int index);</pre>

<p>
Similar to <a href="#lua_settable"><code>lua_settable</code></a>, but does a raw assignment
(i.e., without metamethods).
The value at <code>index</code> must be a table.





</p><hr><h3><a name="lua_rawseti"><code>lua_rawseti</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>
</p><pre>void lua_rawseti (lua_State *L, int index, lua_Integer i);</pre>

<p>
Does the equivalent of <code>t[i] = v</code>,
where <code>t</code> is the table at the given index
and <code>v</code> is the value on the top of the stack.


</p><p>
This function pops the value from the stack.
The assignment is raw,
that is, it does not use the <code>__newindex</code> metavalue.





</p><hr><h3><a name="lua_rawsetp"><code>lua_rawsetp</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>
</p><pre>void lua_rawsetp (lua_State *L, int index, const void *p);</pre>

<p>
Does the equivalent of <code>t[p] = v</code>,
where <code>t</code> is the table at the given index,
<code>p</code> is encoded as a light userdata,
and <code>v</code> is the value on the top of the stack.


</p><p>
This function pops the value from the stack.
The assignment is raw,
that is, it does not use the <code>__newindex</code> metavalue.





</p><hr><h3><a name="lua_Reader"><code>lua_Reader</code></a></h3>
<pre>typedef const char * (*lua_Reader) (lua_State *L,
                                    void *data,
                                    size_t *size);</pre>

<p>
The reader function used by <a href="#lua_load"><code>lua_load</code></a>.
Every time <a href="#lua_load"><code>lua_load</code></a> needs another piece of the chunk,
it calls the reader,
passing along its <code>data</code> parameter.
The reader must return a pointer to a block of memory
with a new piece of the chunk
and set <code>size</code> to the block size.
The block must exist until the reader function is called again.
To signal the end of the chunk,
the reader must return <code>NULL</code> or set <code>size</code> to zero.
The reader function may return pieces of any size greater than zero.





</p><hr><h3><a name="lua_register"><code>lua_register</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
</p><pre>void lua_register (lua_State *L, const char *name, lua_CFunction f);</pre>

<p>
Sets the C&nbsp;function <code>f</code> as the new value of global <code>name</code>.
It is defined as a macro:

</p><pre>     #define lua_register(L,n,f) \
            (lua_pushcfunction(L, f), lua_setglobal(L, n))
</pre>




<hr><h3><a name="lua_remove"><code>lua_remove</code></a></h3><p>
<span class="apii">[-1, +0, –]</span>
</p><pre>void lua_remove (lua_State *L, int index);</pre>

<p>
Removes the element at the given valid index,
shifting down the elements above this index to fill the gap.
This function cannot be called with a pseudo-index,
because a pseudo-index is not an actual stack position.





</p><hr><h3><a name="lua_replace"><code>lua_replace</code></a></h3><p>
<span class="apii">[-1, +0, –]</span>
</p><pre>void lua_replace (lua_State *L, int index);</pre>

<p>
Moves the top element into the given valid index
without shifting any element
(therefore replacing the value at that given index),
and then pops the top element.





</p><hr><h3><a name="lua_resetthread"><code>lua_resetthread</code></a></h3><p>
<span class="apii">[-0, +?, –]</span>
</p><pre>int lua_resetthread (lua_State *L);</pre>

<p>
This function is deprecated;
it is equivalent to <a href="#lua_closethread"><code>lua_closethread</code></a> with
<code>from</code> being <code>NULL</code>.





</p><hr><h3><a name="lua_resume"><code>lua_resume</code></a></h3><p>
<span class="apii">[-?, +?, –]</span>
</p><pre>int lua_resume (lua_State *L, lua_State *from, int nargs,
                          int *nresults);</pre>

<p>
Starts and resumes a coroutine in the given thread <code>L</code>.


</p><p>
To start a coroutine,
you push the main function plus any arguments
onto the empty stack of the thread.
then you call <a href="#lua_resume"><code>lua_resume</code></a>,
with <code>nargs</code> being the number of arguments.
This call returns when the coroutine suspends or finishes its execution.
When it returns,
<code>*nresults</code> is updated and
the top of the stack contains
the <code>*nresults</code> values passed to <a href="#lua_yield"><code>lua_yield</code></a>
or returned by the body function.
<a href="#lua_resume"><code>lua_resume</code></a> returns
<a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a> if the coroutine yields,
<a href="#pdf-LUA_OK"><code>LUA_OK</code></a> if the coroutine finishes its execution
without errors,
or an error code in case of errors (see <a href="#4.4.1">§4.4.1</a>).
In case of errors,
the error object is on the top of the stack.


</p><p>
To resume a coroutine,
you remove the <code>*nresults</code> yielded values from its stack,
push the values to be passed as results from <code>yield</code>,
and then call <a href="#lua_resume"><code>lua_resume</code></a>.


</p><p>
The parameter <code>from</code> represents the coroutine that is resuming <code>L</code>.
If there is no such coroutine,
this parameter can be <code>NULL</code>.





</p><hr><h3><a name="lua_rotate"><code>lua_rotate</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void lua_rotate (lua_State *L, int idx, int n);</pre>

<p>
Rotates the stack elements between the valid index <code>idx</code>
and the top of the stack.
The elements are rotated <code>n</code> positions in the direction of the top,
for a positive <code>n</code>,
or <code>-n</code> positions in the direction of the bottom,
for a negative <code>n</code>.
The absolute value of <code>n</code> must not be greater than the size
of the slice being rotated.
This function cannot be called with a pseudo-index,
because a pseudo-index is not an actual stack position.





</p><hr><h3><a name="lua_setallocf"><code>lua_setallocf</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);</pre>

<p>
Changes the allocator function of a given state to <code>f</code>
with user data <code>ud</code>.





</p><hr><h3><a name="lua_setfield"><code>lua_setfield</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
</p><pre>void lua_setfield (lua_State *L, int index, const char *k);</pre>

<p>
Does the equivalent to <code>t[k] = v</code>,
where <code>t</code> is the value at the given index
and <code>v</code> is the value on the top of the stack.


</p><p>
This function pops the value from the stack.
As in Lua, this function may trigger a metamethod
for the "newindex" event (see <a href="#2.4">§2.4</a>).





</p><hr><h3><a name="lua_setglobal"><code>lua_setglobal</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
</p><pre>void lua_setglobal (lua_State *L, const char *name);</pre>

<p>
Pops a value from the stack and
sets it as the new value of global <code>name</code>.





</p><hr><h3><a name="lua_seti"><code>lua_seti</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
</p><pre>void lua_seti (lua_State *L, int index, lua_Integer n);</pre>

<p>
Does the equivalent to <code>t[n] = v</code>,
where <code>t</code> is the value at the given index
and <code>v</code> is the value on the top of the stack.


</p><p>
This function pops the value from the stack.
As in Lua, this function may trigger a metamethod
for the "newindex" event (see <a href="#2.4">§2.4</a>).





</p><hr><h3><a name="lua_setiuservalue"><code>lua_setiuservalue</code></a></h3><p>
<span class="apii">[-1, +0, –]</span>
</p><pre>int lua_setiuservalue (lua_State *L, int index, int n);</pre>

<p>
Pops a value from the stack and sets it as
the new <code>n</code>-th user value associated to the
full userdata at the given index.
Returns 0 if the userdata does not have that value.





</p><hr><h3><a name="lua_setmetatable"><code>lua_setmetatable</code></a></h3><p>
<span class="apii">[-1, +0, –]</span>
</p><pre>int lua_setmetatable (lua_State *L, int index);</pre>

<p>
Pops a table or <b>nil</b> from the stack and
sets that value as the new metatable for the value at the given index.
(<b>nil</b> means no metatable.)


</p><p>
(For historical reasons, this function returns an <code>int</code>,
which now is always 1.)





</p><hr><h3><a name="lua_settable"><code>lua_settable</code></a></h3><p>
<span class="apii">[-2, +0, <em>e</em>]</span>
</p><pre>void lua_settable (lua_State *L, int index);</pre>

<p>
Does the equivalent to <code>t[k] = v</code>,
where <code>t</code> is the value at the given index,
<code>v</code> is the value on the top of the stack,
and <code>k</code> is the value just below the top.


</p><p>
This function pops both the key and the value from the stack.
As in Lua, this function may trigger a metamethod
for the "newindex" event (see <a href="#2.4">§2.4</a>).





</p><hr><h3><a name="lua_settop"><code>lua_settop</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
</p><pre>void lua_settop (lua_State *L, int index);</pre>

<p>
Accepts any index, or&nbsp;0,
and sets the stack top to this index.
If the new top is greater than the old one,
then the new elements are filled with <b>nil</b>.
If <code>index</code> is&nbsp;0, then all stack elements are removed.


</p><p>
This function can run arbitrary code when removing an index
marked as to-be-closed from the stack.





</p><hr><h3><a name="lua_setwarnf"><code>lua_setwarnf</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void lua_setwarnf (lua_State *L, lua_WarnFunction f, void *ud);</pre>

<p>
Sets the warning function to be used by Lua to emit warnings
(see <a href="#lua_WarnFunction"><code>lua_WarnFunction</code></a>).
The <code>ud</code> parameter sets the value <code>ud</code> passed to
the warning function.





</p><hr><h3><a name="lua_State"><code>lua_State</code></a></h3>
<pre>typedef struct lua_State lua_State;</pre>

<p>
An opaque structure that points to a thread and indirectly
(through the thread) to the whole state of a Lua interpreter.
The Lua library is fully reentrant:
it has no global variables.
All information about a state is accessible through this structure.


</p><p>
A pointer to this structure must be passed as the first argument to
every function in the library, except to <a href="#lua_newstate"><code>lua_newstate</code></a>,
which creates a Lua state from scratch.





</p><hr><h3><a name="lua_status"><code>lua_status</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_status (lua_State *L);</pre>

<p>
Returns the status of the thread <code>L</code>.


</p><p>
The status can be <a href="#pdf-LUA_OK"><code>LUA_OK</code></a> for a normal thread,
an error code if the thread finished the execution
of a <a href="#lua_resume"><code>lua_resume</code></a> with an error,
or <a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a> if the thread is suspended.


</p><p>
You can call functions only in threads with status <a href="#pdf-LUA_OK"><code>LUA_OK</code></a>.
You can resume threads with status <a href="#pdf-LUA_OK"><code>LUA_OK</code></a>
(to start a new coroutine) or <a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>
(to resume a coroutine).





</p><hr><h3><a name="lua_stringtonumber"><code>lua_stringtonumber</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>size_t lua_stringtonumber (lua_State *L, const char *s);</pre>

<p>
Converts the zero-terminated string <code>s</code> to a number,
pushes that number into the stack,
and returns the total size of the string,
that is, its length plus one.
The conversion can result in an integer or a float,
according to the lexical conventions of Lua (see <a href="#3.1">§3.1</a>).
The string may have leading and trailing whitespaces and a sign.
If the string is not a valid numeral,
returns 0 and pushes nothing.
(Note that the result can be used as a boolean,
true if the conversion succeeds.)





</p><hr><h3><a name="lua_toboolean"><code>lua_toboolean</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_toboolean (lua_State *L, int index);</pre>

<p>
Converts the Lua value at the given index to a C&nbsp;boolean
value (0&nbsp;or&nbsp;1).
Like all tests in Lua,
<a href="#lua_toboolean"><code>lua_toboolean</code></a> returns true for any Lua value
different from <b>false</b> and <b>nil</b>;
otherwise it returns false.
(If you want to accept only actual boolean values,
use <a href="#lua_isboolean"><code>lua_isboolean</code></a> to test the value's type.)





</p><hr><h3><a name="lua_tocfunction"><code>lua_tocfunction</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_CFunction lua_tocfunction (lua_State *L, int index);</pre>

<p>
Converts a value at the given index to a C&nbsp;function.
That value must be a C&nbsp;function;
otherwise, returns <code>NULL</code>.





</p><hr><h3><a name="lua_toclose"><code>lua_toclose</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>void lua_toclose (lua_State *L, int index);</pre>

<p>
Marks the given index in the stack as a
to-be-closed slot (see <a href="#3.3.8">§3.3.8</a>).
Like a to-be-closed variable in Lua,
the value at that slot in the stack will be closed
when it goes out of scope.
Here, in the context of a C function,
to go out of scope means that the running function returns to Lua,
or there is an error,
or the slot is removed from the stack through
<a href="#lua_settop"><code>lua_settop</code></a> or <a href="#lua_pop"><code>lua_pop</code></a>,
or there is a call to <a href="#lua_closeslot"><code>lua_closeslot</code></a>.
A slot marked as to-be-closed should not be removed from the stack
by any other function in the API except <a href="#lua_settop"><code>lua_settop</code></a> or <a href="#lua_pop"><code>lua_pop</code></a>,
unless previously deactivated by <a href="#lua_closeslot"><code>lua_closeslot</code></a>.


</p><p>
This function raises an error if the value at the given slot
neither has a <code>__close</code> metamethod nor is a false value.


</p><p>
This function should not be called for an index
that is equal to or below an active to-be-closed slot.


</p><p>
Note that, both in case of errors and of a regular return,
by the time the <code>__close</code> metamethod runs,
the C&nbsp;stack was already unwound,
so that any automatic C&nbsp;variable declared in the calling function
(e.g., a buffer) will be out of scope.





</p><hr><h3><a name="lua_tointeger"><code>lua_tointeger</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_Integer lua_tointeger (lua_State *L, int index);</pre>

<p>
Equivalent to <a href="#lua_tointegerx"><code>lua_tointegerx</code></a> with <code>isnum</code> equal to <code>NULL</code>.





</p><hr><h3><a name="lua_tointegerx"><code>lua_tointegerx</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_Integer lua_tointegerx (lua_State *L, int index, int *isnum);</pre>

<p>
Converts the Lua value at the given index
to the signed integral type <a href="#lua_Integer"><code>lua_Integer</code></a>.
The Lua value must be an integer,
or a number or string convertible to an integer (see <a href="#3.4.3">§3.4.3</a>);
otherwise, <code>lua_tointegerx</code> returns&nbsp;0.


</p><p>
If <code>isnum</code> is not <code>NULL</code>,
its referent is assigned a boolean value that
indicates whether the operation succeeded.





</p><hr><h3><a name="lua_tolstring"><code>lua_tolstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
</p><pre>const char *lua_tolstring (lua_State *L, int index, size_t *len);</pre>

<p>
Converts the Lua value at the given index to a C&nbsp;string.
If <code>len</code> is not <code>NULL</code>,
it sets <code>*len</code> with the string length.
The Lua value must be a string or a number;
otherwise, the function returns <code>NULL</code>.
If the value is a number,
then <code>lua_tolstring</code> also
<em>changes the actual value in the stack to a string</em>.
(This change confuses <a href="#lua_next"><code>lua_next</code></a>
when <code>lua_tolstring</code> is applied to keys during a table traversal.)


</p><p>
<code>lua_tolstring</code> returns a pointer
to a string inside the Lua state (see <a href="#4.1.3">§4.1.3</a>).
This string always has a zero ('<code>\0</code>')
after its last character (as in&nbsp;C),
but can contain other zeros in its body.


</p><p>
This function can raise memory errors only
when converting a number to a string
(as then it may create a new string).





</p><hr><h3><a name="lua_tonumber"><code>lua_tonumber</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_Number lua_tonumber (lua_State *L, int index);</pre>

<p>
Equivalent to <a href="#lua_tonumberx"><code>lua_tonumberx</code></a> with <code>isnum</code> equal to <code>NULL</code>.





</p><hr><h3><a name="lua_tonumberx"><code>lua_tonumberx</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_Number lua_tonumberx (lua_State *L, int index, int *isnum);</pre>

<p>
Converts the Lua value at the given index
to the C&nbsp;type <a href="#lua_Number"><code>lua_Number</code></a> (see <a href="#lua_Number"><code>lua_Number</code></a>).
The Lua value must be a number or a string convertible to a number
(see <a href="#3.4.3">§3.4.3</a>);
otherwise, <a href="#lua_tonumberx"><code>lua_tonumberx</code></a> returns&nbsp;0.


</p><p>
If <code>isnum</code> is not <code>NULL</code>,
its referent is assigned a boolean value that
indicates whether the operation succeeded.





</p><hr><h3><a name="lua_topointer"><code>lua_topointer</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>const void *lua_topointer (lua_State *L, int index);</pre>

<p>
Converts the value at the given index to a generic
C&nbsp;pointer (<code>void*</code>).
The value can be a userdata, a table, a thread, a string, or a function;
otherwise, <code>lua_topointer</code> returns <code>NULL</code>.
Different objects will give different pointers.
There is no way to convert the pointer back to its original value.


</p><p>
Typically this function is used only for hashing and debug information.





</p><hr><h3><a name="lua_tostring"><code>lua_tostring</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
</p><pre>const char *lua_tostring (lua_State *L, int index);</pre>

<p>
Equivalent to <a href="#lua_tolstring"><code>lua_tolstring</code></a> with <code>len</code> equal to <code>NULL</code>.





</p><hr><h3><a name="lua_tothread"><code>lua_tothread</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_State *lua_tothread (lua_State *L, int index);</pre>

<p>
Converts the value at the given index to a Lua thread
(represented as <code>lua_State*</code>).
This value must be a thread;
otherwise, the function returns <code>NULL</code>.





</p><hr><h3><a name="lua_touserdata"><code>lua_touserdata</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void *lua_touserdata (lua_State *L, int index);</pre>

<p>
If the value at the given index is a full userdata,
returns its memory-block address.
If the value is a light userdata,
returns its value (a pointer).
Otherwise, returns <code>NULL</code>.





</p><hr><h3><a name="lua_type"><code>lua_type</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_type (lua_State *L, int index);</pre>

<p>
Returns the type of the value in the given valid index,
or <code>LUA_TNONE</code> for a non-valid but acceptable index.
The types returned by <a href="#lua_type"><code>lua_type</code></a> are coded by the following constants
defined in <code>lua.h</code>:
<a name="pdf-LUA_TNIL"><code>LUA_TNIL</code></a>,
<a name="pdf-LUA_TNUMBER"><code>LUA_TNUMBER</code></a>,
<a name="pdf-LUA_TBOOLEAN"><code>LUA_TBOOLEAN</code></a>,
<a name="pdf-LUA_TSTRING"><code>LUA_TSTRING</code></a>,
<a name="pdf-LUA_TTABLE"><code>LUA_TTABLE</code></a>,
<a name="pdf-LUA_TFUNCTION"><code>LUA_TFUNCTION</code></a>,
<a name="pdf-LUA_TUSERDATA"><code>LUA_TUSERDATA</code></a>,
<a name="pdf-LUA_TTHREAD"><code>LUA_TTHREAD</code></a>,
and
<a name="pdf-LUA_TLIGHTUSERDATA"><code>LUA_TLIGHTUSERDATA</code></a>.





</p><hr><h3><a name="lua_typename"><code>lua_typename</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>const char *lua_typename (lua_State *L, int tp);</pre>

<p>
Returns the name of the type encoded by the value <code>tp</code>,
which must be one the values returned by <a href="#lua_type"><code>lua_type</code></a>.





</p><hr><h3><a name="lua_Unsigned"><code>lua_Unsigned</code></a></h3>
<pre>typedef ... lua_Unsigned;</pre>

<p>
The unsigned version of <a href="#lua_Integer"><code>lua_Integer</code></a>.





</p><hr><h3><a name="lua_upvalueindex"><code>lua_upvalueindex</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_upvalueindex (int i);</pre>

<p>
Returns the pseudo-index that represents the <code>i</code>-th upvalue of
the running function (see <a href="#4.2">§4.2</a>).
<code>i</code> must be in the range <em>[1,256]</em>.





</p><hr><h3><a name="lua_version"><code>lua_version</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_Number lua_version (lua_State *L);</pre>

<p>
Returns the version number of this core.





</p><hr><h3><a name="lua_WarnFunction"><code>lua_WarnFunction</code></a></h3>
<pre>typedef void (*lua_WarnFunction) (void *ud, const char *msg, int tocont);</pre>

<p>
The type of warning functions, called by Lua to emit warnings.
The first parameter is an opaque pointer
set by <a href="#lua_setwarnf"><code>lua_setwarnf</code></a>.
The second parameter is the warning message.
The third parameter is a boolean that
indicates whether the message is
to be continued by the message in the next call.


</p><p>
See <a href="#pdf-warn"><code>warn</code></a> for more details about warnings.





</p><hr><h3><a name="lua_warning"><code>lua_warning</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void lua_warning (lua_State *L, const char *msg, int tocont);</pre>

<p>
Emits a warning with the given message.
A message in a call with <code>tocont</code> true should be
continued in another call to this function.


</p><p>
See <a href="#pdf-warn"><code>warn</code></a> for more details about warnings.





</p><hr><h3><a name="lua_Writer"><code>lua_Writer</code></a></h3>
<pre>typedef int (*lua_Writer) (lua_State *L,
                           const void* p,
                           size_t sz,
                           void* ud);</pre>

<p>
The type of the writer function used by <a href="#lua_dump"><code>lua_dump</code></a>.
Every time <a href="#lua_dump"><code>lua_dump</code></a> produces another piece of chunk,
it calls the writer,
passing along the buffer to be written (<code>p</code>),
its size (<code>sz</code>),
and the <code>ud</code> parameter supplied to <a href="#lua_dump"><code>lua_dump</code></a>.


</p><p>
The writer returns an error code:
0&nbsp;means no errors;
any other value means an error and stops <a href="#lua_dump"><code>lua_dump</code></a> from
calling the writer again.





</p><hr><h3><a name="lua_xmove"><code>lua_xmove</code></a></h3><p>
<span class="apii">[-?, +?, –]</span>
</p><pre>void lua_xmove (lua_State *from, lua_State *to, int n);</pre>

<p>
Exchange values between different threads of the same state.


</p><p>
This function pops <code>n</code> values from the stack <code>from</code>,
and pushes them onto the stack <code>to</code>.





</p><hr><h3><a name="lua_yield"><code>lua_yield</code></a></h3><p>
<span class="apii">[-?, +?, <em>v</em>]</span>
</p><pre>int lua_yield (lua_State *L, int nresults);</pre>

<p>
This function is equivalent to <a href="#lua_yieldk"><code>lua_yieldk</code></a>,
but it has no continuation (see <a href="#4.5">§4.5</a>).
Therefore, when the thread resumes,
it continues the function that called
the function calling <code>lua_yield</code>.
To avoid surprises,
this function should be called only in a tail call.





</p><hr><h3><a name="lua_yieldk"><code>lua_yieldk</code></a></h3><p>
<span class="apii">[-?, +?, <em>v</em>]</span>
</p><pre>int lua_yieldk (lua_State *L,
                int nresults,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>
Yields a coroutine (thread).


</p><p>
When a C&nbsp;function calls <a href="#lua_yieldk"><code>lua_yieldk</code></a>,
the running coroutine suspends its execution,
and the call to <a href="#lua_resume"><code>lua_resume</code></a> that started this coroutine returns.
The parameter <code>nresults</code> is the number of values from the stack
that will be passed as results to <a href="#lua_resume"><code>lua_resume</code></a>.


</p><p>
When the coroutine is resumed again,
Lua calls the given continuation function <code>k</code> to continue
the execution of the C&nbsp;function that yielded (see <a href="#4.5">§4.5</a>).
This continuation function receives the same stack
from the previous function,
with the <code>n</code> results removed and
replaced by the arguments passed to <a href="#lua_resume"><code>lua_resume</code></a>.
Moreover,
the continuation function receives the value <code>ctx</code>
that was passed to <a href="#lua_yieldk"><code>lua_yieldk</code></a>.


</p><p>
Usually, this function does not return;
when the coroutine eventually resumes,
it continues executing the continuation function.
However, there is one special case,
which is when this function is called
from inside a line or a count hook (see <a href="#4.7">§4.7</a>).
In that case, <code>lua_yieldk</code> should be called with no continuation
(probably in the form of <a href="#lua_yield"><code>lua_yield</code></a>) and no results,
and the hook should return immediately after the call.
Lua will yield and,
when the coroutine resumes again,
it will continue the normal execution
of the (Lua) function that triggered the hook.


</p><p>
This function can raise an error if it is called from a thread
with a pending C call with no continuation function
(what is called a <em>C-call boundary</em>),
or it is called from a thread that is not running inside a resume
(typically the main thread).







</p><h2>4.7 – <a name="4.7">The Debug Interface</a></h2>

<p>
Lua has no built-in debugging facilities.
Instead, it offers a special interface
by means of functions and <em>hooks</em>.
This interface allows the construction of different
kinds of debuggers, profilers, and other tools
that need "inside information" from the interpreter.



</p><hr><h3><a name="lua_Debug"><code>lua_Debug</code></a></h3>
<pre>typedef struct lua_Debug {
  int event;
  const char *name;           /* (n) */
  const char *namewhat;       /* (n) */
  const char *what;           /* (S) */
  const char *source;         /* (S) */
  size_t srclen;              /* (S) */
  int currentline;            /* (l) */
  int linedefined;            /* (S) */
  int lastlinedefined;        /* (S) */
  unsigned char nups;         /* (u) number of upvalues */
  unsigned char nparams;      /* (u) number of parameters */
  char isvararg;              /* (u) */
  char istailcall;            /* (t) */
  unsigned short ftransfer;   /* (r) index of first value transferred */
  unsigned short ntransfer;   /* (r) number of transferred values */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* private part */
  <em>other fields</em>
} lua_Debug;</pre>

<p>
A structure used to carry different pieces of
information about a function or an activation record.
<a href="#lua_getstack"><code>lua_getstack</code></a> fills only the private part
of this structure, for later use.
To fill the other fields of <a href="#lua_Debug"><code>lua_Debug</code></a> with useful information,
you must call <a href="#lua_getinfo"><code>lua_getinfo</code></a> with an appropriate parameter.
(Specifically, to get a field,
you must add the letter between parentheses in the field's comment
to the parameter <code>what</code> of <a href="#lua_getinfo"><code>lua_getinfo</code></a>.)


</p><p>
The fields of <a href="#lua_Debug"><code>lua_Debug</code></a> have the following meaning:

</p><ul>
<!-- slice ends -->
