      <p>
        Arrays can be destructured:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">destructuring_arrays.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;

<span class="tok-kw">fn</span> <span class="tok-fn">swizzleRgbaToBgra</span>(rgba: [<span class="tok-number">4</span>]<span class="tok-type">u8</span>) [<span class="tok-number">4</span>]<span class="tok-type">u8</span> {
    <span class="tok-comment">// readable swizzling by destructuring</span>
    <span class="tok-kw">const</span> r, <span class="tok-kw">const</span> g, <span class="tok-kw">const</span> b, <span class="tok-kw">const</span> a = rgba;
    <span class="tok-kw">return</span> .{ b, g, r, a };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> pos = [_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span> };
    <span class="tok-kw">const</span> x, <span class="tok-kw">const</span> y = pos;
    print(<span class="tok-str">"x = {}, y = {}\n"</span>, .{x, y});

    <span class="tok-kw">const</span> orange: [<span class="tok-number">4</span>]<span class="tok-type">u8</span> = .{ <span class="tok-number">255</span>, <span class="tok-number">165</span>, <span class="tok-number">0</span>, <span class="tok-number">255</span> };
    print(<span class="tok-str">"{any}\n"</span>, .{swizzleRgbaToBgra(orange)});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe destructuring_arrays.zig</kbd>
$ <kbd>./destructuring_arrays</kbd>
x = 1, y = 2
{ 0, 165, 255, 255 }
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Destructuring">Destructuring</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Destructuring-Tuples">Destructuring Tuples</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Destructuring-Vectors">Destructuring Vectors</a></li>
</ul>

      
      

      <h2 id="Vectors"><a href="https://ziglang.org/documentation/0.15.2/#toc-Vectors">Vectors</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Vectors">§</a></h2>

      <p>
      A vector is a group of booleans, <a href="https://ziglang.org/documentation/0.15.2/#Integers">Integers</a>, <a href="https://ziglang.org/documentation/0.15.2/#Floats">Floats</a>, or
      <a href="https://ziglang.org/documentation/0.15.2/#Pointers">Pointers</a> which are operated on in parallel, using SIMD instructions if possible.
      Vector types are created with the builtin function <a href="https://ziglang.org/documentation/0.15.2/#Vector">@Vector</a>.
      </p>
      <p>
      Vectors generally support the same builtin operators as their underlying base types.
      The only exception to this is the keywords `and` and `or` on vectors of bools, since
      these operators affect control flow, which is not allowed for vectors.
      All other operations are performed element-wise, and return a vector of the same length
      as the input vectors. This includes:
      </p>
      <ul>
          <li>Arithmetic (<code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>,
                         <code><span class="tok-builtin">@divFloor</span></code>, <code><span class="tok-builtin">@sqrt</span></code>, <code><span class="tok-builtin">@ceil</span></code>,
                         <code><span class="tok-builtin">@log</span></code>, etc.)</li>
          <li>Bitwise operators (<code>&gt;&gt;</code>, <code>&lt;&lt;</code>, <code>&amp;</code>,
                                 <code>|</code>, <code>~</code>, etc.)</li>
          <li>Comparison operators (<code>&lt;</code>, <code>&gt;</code>, <code>==</code>, etc.)</li>
          <li>Boolean not (<code>!</code>)</li>
      </ul>
      <p>
      It is prohibited to use a math operator on a mixture of scalars (individual numbers)
      and vectors. Zig provides the <a href="https://ziglang.org/documentation/0.15.2/#splat">@splat</a> builtin to easily convert from scalars
      to vectors, and it supports <a href="https://ziglang.org/documentation/0.15.2/#reduce">@reduce</a> and array indexing syntax to convert
      from vectors to scalars. Vectors also support assignment to and from fixed-length
      arrays with comptime-known length.
      </p>
      <p>
      For rearranging elements within and between vectors, Zig provides the <a href="https://ziglang.org/documentation/0.15.2/#shuffle">@shuffle</a> and <a href="https://ziglang.org/documentation/0.15.2/#select">@select</a> functions.
      </p>
      <p>
      Operations on vectors shorter than the target machine's native SIMD size will typically compile to single SIMD
      instructions, while vectors longer than the target machine's native SIMD size will compile to multiple SIMD
      instructions. If a given operation doesn't have SIMD support on the target architecture, the compiler will default
      to operating on each vector element one at a time. Zig supports any comptime-known vector length up to 2^32-1,
      although small powers of two (2-64) are most typical. Note that excessively long vector lengths (e.g. 2^20) may
      result in compiler crashes on current versions of Zig.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_vector.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expectEqual = std.testing.expectEqual;

<span class="tok-kw">test</span> <span class="tok-str">"Basic vector usage"</span> {
    <span class="tok-comment">// Vectors have a compile-time known length and base type.</span>
    <span class="tok-kw">const</span> a = <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">i32</span>){ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };
    <span class="tok-kw">const</span> b = <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">i32</span>){ <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span> };

    <span class="tok-comment">// Math operations take place element-wise.</span>
    <span class="tok-kw">const</span> c = a + b;

    <span class="tok-comment">// Individual vector elements can be accessed using array indexing syntax.</span>
    <span class="tok-kw">try</span> expectEqual(<span class="tok-number">6</span>, c[<span class="tok-number">0</span>]);
    <span class="tok-kw">try</span> expectEqual(<span class="tok-number">8</span>, c[<span class="tok-number">1</span>]);
    <span class="tok-kw">try</span> expectEqual(<span class="tok-number">10</span>, c[<span class="tok-number">2</span>]);
    <span class="tok-kw">try</span> expectEqual(<span class="tok-number">12</span>, c[<span class="tok-number">3</span>]);
}

<span class="tok-kw">test</span> <span class="tok-str">"Conversion between vectors, arrays, and slices"</span> {
    <span class="tok-comment">// Vectors and fixed-length arrays can be automatically assigned back and forth</span>
    <span class="tok-kw">const</span> arr1: [<span class="tok-number">4</span>]<span class="tok-type">f32</span> = [_]<span class="tok-type">f32</span>{ <span class="tok-number">1.1</span>, <span class="tok-number">3.2</span>, <span class="tok-number">4.5</span>, <span class="tok-number">5.6</span> };
    <span class="tok-kw">const</span> vec: <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">f32</span>) = arr1;
    <span class="tok-kw">const</span> arr2: [<span class="tok-number">4</span>]<span class="tok-type">f32</span> = vec;
    <span class="tok-kw">try</span> expectEqual(arr1, arr2);

    <span class="tok-comment">// You can also assign from a slice with comptime-known length to a vector using .*</span>
    <span class="tok-kw">const</span> vec2: <span class="tok-builtin">@Vector</span>(<span class="tok-number">2</span>, <span class="tok-type">f32</span>) = arr1[<span class="tok-number">1</span>..<span class="tok-number">3</span>].*;

    <span class="tok-kw">const</span> slice: []<span class="tok-kw">const</span> <span class="tok-type">f32</span> = &amp;arr1;
    <span class="tok-kw">var</span> offset: <span class="tok-type">u32</span> = <span class="tok-number">1</span>; <span class="tok-comment">// var to make it runtime-known</span>
    _ = &amp;offset; <span class="tok-comment">// suppress 'var is never mutated' error</span>
    <span class="tok-comment">// To extract a comptime-known length from a runtime-known offset,</span>
    <span class="tok-comment">// first extract a new slice from the starting offset, then an array of</span>
    <span class="tok-comment">// comptime-known length</span>
    <span class="tok-kw">const</span> vec3: <span class="tok-builtin">@Vector</span>(<span class="tok-number">2</span>, <span class="tok-type">f32</span>) = slice[offset..][<span class="tok-number">0</span>..<span class="tok-number">2</span>].*;
    <span class="tok-kw">try</span> expectEqual(slice[offset], vec2[<span class="tok-number">0</span>]);
    <span class="tok-kw">try</span> expectEqual(slice[offset + <span class="tok-number">1</span>], vec2[<span class="tok-number">1</span>]);
    <span class="tok-kw">try</span> expectEqual(vec2, vec3);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_vector.zig</kbd>
1/2 test_vector.test.Basic vector usage...OK
2/2 test_vector.test.Conversion between vectors, arrays, and slices...OK
All 2 tests passed.
</samp></pre></figure>

      <p>
      TODO talk about C ABI interop<br>
      TODO consider suggesting std.MultiArrayList
      </p>
      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#splat">@splat</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#shuffle">@shuffle</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#select">@select</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#reduce">@reduce</a></li>
</ul>


      <h3 id="Destructuring-Vectors"><a href="https://ziglang.org/documentation/0.15.2/#toc-Destructuring-Vectors">Destructuring Vectors</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Destructuring-Vectors">§</a></h3>

      <p>
        Vectors can be destructured:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">destructuring_vectors.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;

<span class="tok-comment">// emulate punpckldq</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unpack</span>(x: <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">f32</span>), y: <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">f32</span>)) <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">f32</span>) {
    <span class="tok-kw">const</span> a, <span class="tok-kw">const</span> c, _, _ = x;
    <span class="tok-kw">const</span> b, <span class="tok-kw">const</span> d, _, _ = y;
    <span class="tok-kw">return</span> .{ a, b, c, d };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> x: <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">f32</span>) = .{ <span class="tok-number">1.0</span>, <span class="tok-number">2.0</span>, <span class="tok-number">3.0</span>, <span class="tok-number">4.0</span> };
    <span class="tok-kw">const</span> y: <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">f32</span>) = .{ <span class="tok-number">5.0</span>, <span class="tok-number">6.0</span>, <span class="tok-number">7.0</span>, <span class="tok-number">8.0</span> };
    print(<span class="tok-str">"{}"</span>, .{unpack(x, y)});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe destructuring_vectors.zig</kbd>
$ <kbd>./destructuring_vectors</kbd>
{ 1, 5, 2, 6 }
</samp></pre></figure>
      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Destructuring">Destructuring</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Destructuring-Tuples">Destructuring Tuples</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Destructuring-Arrays">Destructuring Arrays</a></li>
</ul>

      

      

      <h2 id="Pointers"><a href="https://ziglang.org/documentation/0.15.2/#toc-Pointers">Pointers</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Pointers">§</a></h2>

      <p>
      Zig has two kinds of pointers: single-item and many-item.
      </p>
      <ul>
          <li><code>*T</code> - single-item pointer to exactly one item.
            <ul>
              <li>Supports deref syntax: <code>ptr.*</code></li>
              <li>Supports slice syntax: <code>ptr[<span class="tok-number">0</span>..<span class="tok-number">1</span>]</code></li>
              <li>Supports pointer subtraction: <code>ptr - ptr</code></li>
            </ul>
          </li>
          <li><code>[*]T</code> - many-item pointer to unknown number of items.
            <ul>
              <li>Supports index syntax: <code>ptr[i]</code></li>
              <li>Supports slice syntax: <code>ptr[start..end]</code> and <code>ptr[start..]</code></li>
              <li>Supports pointer-integer arithmetic: <code>ptr + int</code>, <code>ptr - int</code></li>
              <li>Supports pointer subtraction: <code>ptr - ptr</code></li>
            </ul>
            <code>T</code> must have a known size, which means that it cannot be
            <code><span class="tok-type">anyopaque</span></code> or any other <a href="https://ziglang.org/documentation/0.15.2/#opaque">opaque type</a>.
          </li>
      </ul>
      <p>These types are closely related to <a href="https://ziglang.org/documentation/0.15.2/#Arrays">Arrays</a> and <a href="https://ziglang.org/documentation/0.15.2/#Slices">Slices</a>:</p>
        <ul>
            <li><code>*[N]T</code> - pointer to N items, same as single-item pointer to an array.
            <ul>
                <li>Supports index syntax: <code>array_ptr[i]</code></li>
                <li>Supports slice syntax: <code>array_ptr[start..end]</code></li>
                <li>Supports len property: <code>array_ptr.len</code></li>
                <li>Supports pointer subtraction: <code>array_ptr - array_ptr</code></li>
            </ul>
            </li>
        </ul>
        <ul>
            <li><code>[]T</code> - is a slice (a fat pointer, which contains a pointer of type <code>[*]T</code> and a length).
            <ul>
                <li>Supports index syntax: <code>slice[i]</code></li>
                <li>Supports slice syntax: <code>slice[start..end]</code></li>
                <li>Supports len property: <code>slice.len</code></li>
            </ul>
            </li>
        </ul>
        <p>Use <code>&amp;x</code> to obtain a single-item pointer:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_single_item_pointer.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"address of syntax"</span> {
    <span class="tok-comment">// Get the address of a variable:</span>
    <span class="tok-kw">const</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    <span class="tok-kw">const</span> x_ptr = &amp;x;

    <span class="tok-comment">// Dereference a pointer:</span>
    <span class="tok-kw">try</span> expect(x_ptr.* == <span class="tok-number">1234</span>);

    <span class="tok-comment">// When you get the address of a const variable, you get a const single-item pointer.</span>
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(x_ptr) == *<span class="tok-kw">const</span> <span class="tok-type">i32</span>);

    <span class="tok-comment">// If you want to mutate the value, you'd need an address of a mutable variable:</span>
    <span class="tok-kw">var</span> y: <span class="tok-type">i32</span> = <span class="tok-number">5678</span>;
    <span class="tok-kw">const</span> y_ptr = &amp;y;
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(y_ptr) == *<span class="tok-type">i32</span>);
    y_ptr.* += <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> expect(y_ptr.* == <span class="tok-number">5679</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"pointer array access"</span> {
    <span class="tok-comment">// Taking an address of an individual element gives a</span>
    <span class="tok-comment">// single-item pointer. This kind of pointer</span>
    <span class="tok-comment">// does not support pointer arithmetic.</span>
    <span class="tok-kw">var</span> array = [_]<span class="tok-type">u8</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span>, <span class="tok-number">9</span>, <span class="tok-number">10</span> };
    <span class="tok-kw">const</span> ptr = &amp;array[<span class="tok-number">2</span>];
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(ptr) == *<span class="tok-type">u8</span>);

    <span class="tok-kw">try</span> expect(array[<span class="tok-number">2</span>] == <span class="tok-number">3</span>);
    ptr.* += <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> expect(array[<span class="tok-number">2</span>] == <span class="tok-number">4</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"slice syntax"</span> {
    <span class="tok-comment">// Get a pointer to a variable:</span>
    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    <span class="tok-kw">const</span> x_ptr = &amp;x;

    <span class="tok-comment">// Convert to array pointer using slice syntax:</span>
    <span class="tok-kw">const</span> x_array_ptr = x_ptr[<span class="tok-number">0</span>..<span class="tok-number">1</span>];
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(x_array_ptr) == *[<span class="tok-number">1</span>]<span class="tok-type">i32</span>);

    <span class="tok-comment">// Coerce to many-item pointer:</span>
    <span class="tok-kw">const</span> x_many_ptr: [*]<span class="tok-type">i32</span> = x_array_ptr;
    <span class="tok-kw">try</span> expect(x_many_ptr[<span class="tok-number">0</span>] == <span class="tok-number">1234</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_single_item_pointer.zig</kbd>
1/3 test_single_item_pointer.test.address of syntax...OK
2/3 test_single_item_pointer.test.pointer array access...OK
3/3 test_single_item_pointer.test.slice syntax...OK
All 3 tests passed.
</samp></pre></figure>

      <p>
       Zig supports pointer arithmetic. It's better to assign the pointer to <code>[*]T</code> and increment that variable. For example, directly incrementing the pointer from a slice will corrupt it.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_pointer_arithmetic.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"pointer arithmetic with many-item pointer"</span> {
    <span class="tok-kw">const</span> array = [_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };
    <span class="tok-kw">var</span> ptr: [*]<span class="tok-kw">const</span> <span class="tok-type">i32</span> = &amp;array;

    <span class="tok-kw">try</span> expect(ptr[<span class="tok-number">0</span>] == <span class="tok-number">1</span>);
    ptr += <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> expect(ptr[<span class="tok-number">0</span>] == <span class="tok-number">2</span>);

    <span class="tok-comment">// slicing a many-item pointer without an end is equivalent to</span>
    <span class="tok-comment">// pointer arithmetic: `ptr[start..] == ptr + start`</span>
    <span class="tok-kw">try</span> expect(ptr[<span class="tok-number">1</span>..] == ptr + <span class="tok-number">1</span>);

    <span class="tok-comment">// subtraction between any two pointers except slices based on element size is supported</span>
    <span class="tok-kw">try</span> expect(&amp;ptr[<span class="tok-number">1</span>] - &amp;ptr[<span class="tok-number">0</span>] == <span class="tok-number">1</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"pointer arithmetic with slices"</span> {
    <span class="tok-kw">var</span> array = [_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };
    <span class="tok-kw">var</span> length: <span class="tok-type">usize</span> = <span class="tok-number">0</span>; <span class="tok-comment">// var to make it runtime-known</span>
    _ = &amp;length; <span class="tok-comment">// suppress 'var is never mutated' error</span>
    <span class="tok-kw">var</span> slice = array[length..array.len];

    <span class="tok-kw">try</span> expect(slice[<span class="tok-number">0</span>] == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> expect(slice.len == <span class="tok-number">4</span>);

    slice.ptr += <span class="tok-number">1</span>;
    <span class="tok-comment">// now the slice is in an bad state since len has not been updated</span>

    <span class="tok-kw">try</span> expect(slice[<span class="tok-number">0</span>] == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> expect(slice.len == <span class="tok-number">4</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_pointer_arithmetic.zig</kbd>
1/2 test_pointer_arithmetic.test.pointer arithmetic with many-item pointer...OK
2/2 test_pointer_arithmetic.test.pointer arithmetic with slices...OK
All 2 tests passed.
</samp></pre></figure>

      <p>
        In Zig, we generally prefer <a href="https://ziglang.org/documentation/0.15.2/#Slices">Slices</a> rather than <a href="https://ziglang.org/documentation/0.15.2/#Sentinel-Terminated-Pointers">Sentinel-Terminated Pointers</a>.
        You can turn an array or pointer into a slice using slice syntax.
      </p>
      <p>
        Slices have bounds checking and are therefore protected
        against this kind of Illegal Behavior. This is one reason
        we prefer slices to pointers.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_slice_bounds.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"pointer slicing"</span> {
    <span class="tok-kw">var</span> array = [_]<span class="tok-type">u8</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span>, <span class="tok-number">9</span>, <span class="tok-number">10</span> };
    <span class="tok-kw">var</span> start: <span class="tok-type">usize</span> = <span class="tok-number">2</span>; <span class="tok-comment">// var to make it runtime-known</span>
    _ = &amp;start; <span class="tok-comment">// suppress 'var is never mutated' error</span>
    <span class="tok-kw">const</span> slice = array[start..<span class="tok-number">4</span>];
    <span class="tok-kw">try</span> expect(slice.len == <span class="tok-number">2</span>);

    <span class="tok-kw">try</span> expect(array[<span class="tok-number">3</span>] == <span class="tok-number">4</span>);
    slice[<span class="tok-number">1</span>] += <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> expect(array[<span class="tok-number">3</span>] == <span class="tok-number">5</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_slice_bounds.zig</kbd>
1/1 test_slice_bounds.test.pointer slicing...OK
All 1 tests passed.
</samp></pre></figure>

      <p>Pointers work at compile-time too, as long as the code does not depend on
      an undefined memory layout:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_pointers.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"comptime pointers"</span> {
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
        <span class="tok-kw">const</span> ptr = &amp;x;
        ptr.* += <span class="tok-number">1</span>;
        x += <span class="tok-number">1</span>;
        <span class="tok-kw">try</span> expect(ptr.* == <span class="tok-number">3</span>);
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_pointers.zig</kbd>
1/1 test_comptime_pointers.test.comptime pointers...OK
All 1 tests passed.
</samp></pre></figure>

      <p>To convert an integer address into a pointer, use <code><span class="tok-builtin">@ptrFromInt</span></code>.
      To convert a pointer to an integer, use <code><span class="tok-builtin">@intFromPtr</span></code>:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_integer_pointer_conversion.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"@intFromPtr and @ptrFromInt"</span> {
    <span class="tok-kw">const</span> ptr: *<span class="tok-type">i32</span> = <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-number">0xdeadbee0</span>);
    <span class="tok-kw">const</span> addr = <span class="tok-builtin">@intFromPtr</span>(ptr);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(addr) == <span class="tok-type">usize</span>);
    <span class="tok-kw">try</span> expect(addr == <span class="tok-number">0xdeadbee0</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_integer_pointer_conversion.zig</kbd>
1/1 test_integer_pointer_conversion.test.@intFromPtr and @ptrFromInt...OK
All 1 tests passed.
</samp></pre></figure>

      <p>Zig is able to preserve memory addresses in comptime code, as long as
      the pointer is never dereferenced:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_pointer_conversion.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"comptime @ptrFromInt"</span> {
    <span class="tok-kw">comptime</span> {
        <span class="tok-comment">// Zig is able to do this at compile-time, as long as</span>
        <span class="tok-comment">// ptr is never dereferenced.</span>
        <span class="tok-kw">const</span> ptr: *<span class="tok-type">i32</span> = <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-number">0xdeadbee0</span>);
        <span class="tok-kw">const</span> addr = <span class="tok-builtin">@intFromPtr</span>(ptr);
        <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(addr) == <span class="tok-type">usize</span>);
        <span class="tok-kw">try</span> expect(addr == <span class="tok-number">0xdeadbee0</span>);
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_pointer_conversion.zig</kbd>
1/1 test_comptime_pointer_conversion.test.comptime @ptrFromInt...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      <a href="https://ziglang.org/documentation/0.15.2/#ptrCast">@ptrCast</a> converts a pointer's element type to another. This
      creates a new pointer that can cause undetectable Illegal Behavior
      depending on the loads and stores that pass through it. Generally, other
      kinds of type conversions are preferable to
      <code><span class="tok-builtin">@ptrCast</span></code> if possible.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_pointer_casting.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"pointer casting"</span> {
    <span class="tok-kw">const</span> bytes <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<span class="tok-type">u32</span>)) = [_]<span class="tok-type">u8</span>{ <span class="tok-number">0x12</span>, <span class="tok-number">0x12</span>, <span class="tok-number">0x12</span>, <span class="tok-number">0x12</span> };
    <span class="tok-kw">const</span> u32_ptr: *<span class="tok-kw">const</span> <span class="tok-type">u32</span> = <span class="tok-builtin">@ptrCast</span>(&amp;bytes);
    <span class="tok-kw">try</span> expect(u32_ptr.* == <span class="tok-number">0x12121212</span>);

    <span class="tok-comment">// Even this example is contrived - there are better ways to do the above than</span>
    <span class="tok-comment">// pointer casting. For example, using a slice narrowing cast:</span>
    <span class="tok-kw">const</span> u32_value = std.mem.bytesAsSlice(<span class="tok-type">u32</span>, bytes[<span class="tok-number">0</span>..])[<span class="tok-number">0</span>];
    <span class="tok-kw">try</span> expect(u32_value == <span class="tok-number">0x12121212</span>);

    <span class="tok-comment">// And even another way, the most straightforward way to do it:</span>
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@bitCast</span>(bytes)) == <span class="tok-number">0x12121212</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"pointer child type"</span> {
    <span class="tok-comment">// pointer types have a `child` field which tells you the type they point to.</span>
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@typeInfo</span>(*<span class="tok-type">u32</span>).pointer.child == <span class="tok-type">u32</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_pointer_casting.zig</kbd>
1/2 test_pointer_casting.test.pointer casting...OK
2/2 test_pointer_casting.test.pointer child type...OK
All 2 tests passed.
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Optional-Pointers">Optional Pointers</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#ptrFromInt">@ptrFromInt</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#intFromPtr">@intFromPtr</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#C-Pointers">C Pointers</a></li>
</ul>

      <h3 id="volatile"><a href="https://ziglang.org/documentation/0.15.2/#toc-volatile">volatile</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#volatile">§</a></h3>

      <p>Loads and stores are assumed to not have side effects. If a given load or store
      should have side effects, such as Memory Mapped Input/Output (MMIO), use <code><span class="tok-kw">volatile</span></code>.
      In the following code, loads and stores with <code>mmio_ptr</code> are guaranteed to all happen
      and in the same order as in source code:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_volatile.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"volatile"</span> {
    <span class="tok-kw">const</span> mmio_ptr: *<span class="tok-kw">volatile</span> <span class="tok-type">u8</span> = <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-number">0x12345678</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(mmio_ptr) == *<span class="tok-kw">volatile</span> <span class="tok-type">u8</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_volatile.zig</kbd>
1/1 test_volatile.test.volatile...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      Note that <code><span class="tok-kw">volatile</span></code> is unrelated to concurrency and <a href="https://ziglang.org/documentation/0.15.2/#Atomics">Atomics</a>.
      If you see code that is using <code><span class="tok-kw">volatile</span></code> for something other than Memory Mapped
      Input/Output, it is probably a bug.
      </p>
      

      <h3 id="Alignment"><a href="https://ziglang.org/documentation/0.15.2/#toc-Alignment">Alignment</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Alignment">§</a></h3>

      <p>
      Each type has an <strong>alignment</strong> - a number of bytes such that,
      when a value of the type is loaded from or stored to memory,
      the memory address must be evenly divisible by this number. You can use
      <a href="https://ziglang.org/documentation/0.15.2/#alignOf">@alignOf</a> to find out this value for any type.
      </p>
      <p>
      Alignment depends on the CPU architecture, but is always a power of two, and
      less than <code><span class="tok-number">1</span> &lt;&lt; <span class="tok-number">29</span></code>.
      </p>
      <p>
      In Zig, a pointer type has an alignment value. If the value is equal to the
      alignment of the underlying type, it can be omitted from the type:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_variable_alignment.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">"builtin"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"variable alignment"</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    <span class="tok-kw">const</span> align_of_i32 = <span class="tok-builtin">@alignOf</span>(<span class="tok-builtin">@TypeOf</span>(x));
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(&amp;x) == *<span class="tok-type">i32</span>);
    <span class="tok-kw">try</span> expect(*<span class="tok-type">i32</span> == *<span class="tok-kw">align</span>(align_of_i32) <span class="tok-type">i32</span>);
    <span class="tok-kw">if</span> (builtin.target.cpu.arch == .x86_64) {
        <span class="tok-kw">try</span> expect(<span class="tok-builtin">@typeInfo</span>(*<span class="tok-type">i32</span>).pointer.alignment == <span class="tok-number">4</span>);
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_variable_alignment.zig</kbd>
1/1 test_variable_alignment.test.variable alignment...OK
All 1 tests passed.
</samp></pre></figure>

      <p>In the same way that a <code>*<span class="tok-type">i32</span></code> can be <a href="https://ziglang.org/documentation/0.15.2/#Type-Coercion">coerced</a> to a
          <code>*<span class="tok-kw">const</span> <span class="tok-type">i32</span></code>, a pointer with a larger alignment can be implicitly
      cast to a pointer with a smaller alignment, but not vice versa.
      </p>
      <p>
      You can specify alignment on variables and functions. If you do this, then
      pointers to them get the specified alignment:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_variable_func_alignment.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">var</span> foo: <span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-number">4</span>) = <span class="tok-number">100</span>;

<span class="tok-kw">test</span> <span class="tok-str">"global variable alignment"</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(&amp;foo)).pointer.alignment == <span class="tok-number">4</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(&amp;foo) == *<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">u8</span>);
    <span class="tok-kw">const</span> as_pointer_to_array: *<span class="tok-kw">align</span>(<span class="tok-number">4</span>) [<span class="tok-number">1</span>]<span class="tok-type">u8</span> = &amp;foo;
    <span class="tok-kw">const</span> as_slice: []<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">u8</span> = as_pointer_to_array;
    <span class="tok-kw">const</span> as_unaligned_slice: []<span class="tok-type">u8</span> = as_slice;
    <span class="tok-kw">try</span> expect(as_unaligned_slice[<span class="tok-number">0</span>] == <span class="tok-number">100</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">derp</span>() <span class="tok-kw">align</span>(<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) * <span class="tok-number">2</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> <span class="tok-number">1234</span>;
}
<span class="tok-kw">fn</span> <span class="tok-fn">noop1</span>() <span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-type">void</span> {}
<span class="tok-kw">fn</span> <span class="tok-fn">noop4</span>() <span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">void</span> {}

<span class="tok-kw">test</span> <span class="tok-str">"function alignment"</span> {
    <span class="tok-kw">try</span> expect(derp() == <span class="tok-number">1234</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(derp) == <span class="tok-kw">fn</span> () <span class="tok-type">i32</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(&amp;derp) == *<span class="tok-kw">align</span>(<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) * <span class="tok-number">2</span>) <span class="tok-kw">const</span> <span class="tok-kw">fn</span> () <span class="tok-type">i32</span>);

    noop1();
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(noop1) == <span class="tok-kw">fn</span> () <span class="tok-type">void</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(&amp;noop1) == *<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> <span class="tok-kw">fn</span> () <span class="tok-type">void</span>);

    noop4();
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(noop4) == <span class="tok-kw">fn</span> () <span class="tok-type">void</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(&amp;noop4) == *<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-kw">const</span> <span class="tok-kw">fn</span> () <span class="tok-type">void</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_variable_func_alignment.zig</kbd>
1/2 test_variable_func_alignment.test.global variable alignment...OK
2/2 test_variable_func_alignment.test.function alignment...OK
All 2 tests passed.
</samp></pre></figure>

      <p>
      If you have a pointer or a slice that has a small alignment, but you know that it actually
      has a bigger alignment, use <a href="https://ziglang.org/documentation/0.15.2/#alignCast">@alignCast</a> to change the
      pointer into a more aligned pointer. This is a no-op at runtime, but inserts a
      <a href="https://ziglang.org/documentation/0.15.2/#Incorrect-Pointer-Alignment">safety check</a>:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_incorrect_pointer_alignment.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">test</span> <span class="tok-str">"pointer alignment safety"</span> {
    <span class="tok-kw">var</span> array <span class="tok-kw">align</span>(<span class="tok-number">4</span>) = [_]<span class="tok-type">u32</span>{ <span class="tok-number">0x11111111</span>, <span class="tok-number">0x11111111</span> };
    <span class="tok-kw">const</span> bytes = std.mem.sliceAsBytes(array[<span class="tok-number">0</span>..]);
    <span class="tok-kw">try</span> std.testing.expect(foo(bytes) == <span class="tok-number">0x11111111</span>);
}
<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(bytes: []<span class="tok-type">u8</span>) <span class="tok-type">u32</span> {
    <span class="tok-kw">const</span> slice4 = bytes[<span class="tok-number">1</span>..<span class="tok-number">5</span>];
    <span class="tok-kw">const</span> int_slice = std.mem.bytesAsSlice(<span class="tok-type">u32</span>, <span class="tok-builtin">@as</span>([]<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">u8</span>, <span class="tok-builtin">@alignCast</span>(slice4)));
    <span class="tok-kw">return</span> int_slice[<span class="tok-number">0</span>];
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_incorrect_pointer_alignment.zig</kbd>
1/1 test_incorrect_pointer_alignment.test.pointer alignment safety...thread 2895819 panic: incorrect alignment
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_incorrect_pointer_alignment.zig:10:68</span>: <span class="sgr-2m">0x102c2a8 in foo (test_incorrect_pointer_alignment.zig)</span>
    const int_slice = std.mem.bytesAsSlice(u32, @as([]align(4) u8, @alignCast(slice4)));
                                                                   <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_incorrect_pointer_alignment.zig:6:31</span>: <span class="sgr-2m">0x102c0d2 in test.pointer alignment safety (test_incorrect_pointer_alignment.zig)</span>
    try std.testing.expect(foo(bytes) == 0x11111111);
                              <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:218:25</span>: <span class="sgr-2m">0x115cf30 in mainTerminal (test_runner.zig)</span>
        if (test_fn.func()) |_| {
                        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:66:28</span>: <span class="sgr-2m">0x1156151 in main (test_runner.zig)</span>
        return mainTerminal();
                           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x114feed in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x114f781 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
error: the following test command crashed:
/home/andy/dev/zig/.zig-cache/o/9cb7896b3cdf812f518129da5e21dc23/test --seed=0x441e5edd
</samp></pre></figure>

      

      <h3 id="allowzero"><a href="https://ziglang.org/documentation/0.15.2/#toc-allowzero">allowzero</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#allowzero">§</a></h3>

      <p>
      This pointer attribute allows a pointer to have address zero. This is only ever needed on the
      freestanding OS target, where the address zero is mappable. If you want to represent null pointers, use
      <a href="https://ziglang.org/documentation/0.15.2/#Optional-Pointers">Optional Pointers</a> instead. <a href="https://ziglang.org/documentation/0.15.2/#Optional-Pointers">Optional Pointers</a> with <code><span class="tok-kw">allowzero</span></code>
      are not the same size as pointers. In this code example, if the pointer
      did not have the <code><span class="tok-kw">allowzero</span></code> attribute, this would be a
      <a href="https://ziglang.org/documentation/0.15.2/#Pointer-Cast-Invalid-Null">Pointer Cast Invalid Null</a> panic:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_allowzero.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"allowzero"</span> {
    <span class="tok-kw">var</span> zero: <span class="tok-type">usize</span> = <span class="tok-number">0</span>; <span class="tok-comment">// var to make to runtime-known</span>
    _ = &amp;zero; <span class="tok-comment">// suppress 'var is never mutated' error</span>
    <span class="tok-kw">const</span> ptr: *<span class="tok-kw">allowzero</span> <span class="tok-type">i32</span> = <span class="tok-builtin">@ptrFromInt</span>(zero);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromPtr</span>(ptr) == <span class="tok-number">0</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_allowzero.zig</kbd>
1/1 test_allowzero.test.allowzero...OK
All 1 tests passed.
</samp></pre></figure>

      

      <h3 id="Sentinel-Terminated-Pointers"><a href="https://ziglang.org/documentation/0.15.2/#toc-Sentinel-Terminated-Pointers">Sentinel-Terminated Pointers</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Sentinel-Terminated-Pointers">§</a></h3>

      <p>
      The syntax <code>[*:x]T</code> describes a pointer that
      has a length determined by a sentinel value. This provides protection
      against buffer overflow and overreads.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">sentinel-terminated_pointer.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-comment">// This is also available as `std.c.printf`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">extern</span> <span class="tok-str">"c"</span> <span class="tok-kw">fn</span> <span class="tok-fn">printf</span>(format: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ...) <span class="tok-type">c_int</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {
    _ = printf(<span class="tok-str">"Hello, world!\n"</span>); <span class="tok-comment">// OK</span>

    <span class="tok-kw">const</span> msg = <span class="tok-str">"Hello, world!\n"</span>;
    <span class="tok-kw">const</span> non_null_terminated_msg: [msg.len]<span class="tok-type">u8</span> = msg.*;
    _ = printf(&amp;non_null_terminated_msg);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe sentinel-terminated_pointer.zig -lc</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/sentinel-terminated_pointer.zig:11:16: </span><span class="sgr-31m">error: </span><span class="sgr-1m">expected type '[*:0]const u8', found '*const [14]u8'
</span>    _ = printf(&amp;non_null_terminated_msg);
               <span class="sgr-32m">^~~~~~~~~~~~~~~~~~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/sentinel-terminated_pointer.zig:11:16: </span><span class="sgr-36m">note: </span><span class="sgr-1m">destination pointer requires '0' sentinel
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/sentinel-terminated_pointer.zig:4:34: </span><span class="sgr-36m">note: </span><span class="sgr-1m">parameter type declared here
</span>pub extern "c" fn printf(format: [*:0]const u8, ...) c_int;
                                 <span class="sgr-32m">^~~~~~~~~~~~~
</span><span class="sgr-2m">referenced by:
    callMain [inlined]: /home/andy/dev/zig/lib/std/start.zig:627:37
    callMainWithArgs [inlined]: /home/andy/dev/zig/lib/std/start.zig:587:20
    main: /home/andy/dev/zig/lib/std/start.zig:602:28
    1 reference(s) hidden; use '-freference-trace=4' to see all references
</span>
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Sentinel-Terminated-Slices">Sentinel-Terminated Slices</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Sentinel-Terminated-Arrays">Sentinel-Terminated Arrays</a></li>
</ul>

      
      

      <h2 id="Slices"><a href="https://ziglang.org/documentation/0.15.2/#toc-Slices">Slices</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Slices">§</a></h2>

      <p>
      A slice is a pointer and a length. The difference between an array and
      a slice is that the array's length is part of the type and known at
      compile-time, whereas the slice's length is known at runtime.
      Both can be accessed with the <code>len</code> field.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_basic_slices.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;
<span class="tok-kw">const</span> expectEqualSlices = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expectEqualSlices;

<span class="tok-kw">test</span> <span class="tok-str">"basic slices"</span> {
    <span class="tok-kw">var</span> array = [_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };
    <span class="tok-kw">var</span> known_at_runtime_zero: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    _ = &amp;known_at_runtime_zero;
    <span class="tok-kw">const</span> slice = array[known_at_runtime_zero..array.len];

    <span class="tok-comment">// alternative initialization using result location</span>
    <span class="tok-kw">const</span> alt_slice: []<span class="tok-kw">const</span> <span class="tok-type">i32</span> = &amp;.{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };

    <span class="tok-kw">try</span> expectEqualSlices(<span class="tok-type">i32</span>, slice, alt_slice);

    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(slice) == []<span class="tok-type">i32</span>);
    <span class="tok-kw">try</span> expect(&amp;slice[<span class="tok-number">0</span>] == &amp;array[<span class="tok-number">0</span>]);
    <span class="tok-kw">try</span> expect(slice.len == array.len);

    <span class="tok-comment">// If you slice with comptime-known start and end positions, the result is</span>
    <span class="tok-comment">// a pointer to an array, rather than a slice.</span>
    <span class="tok-kw">const</span> array_ptr = array[<span class="tok-number">0</span>..array.len];
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(array_ptr) == *[array.len]<span class="tok-type">i32</span>);

    <span class="tok-comment">// You can perform a slice-by-length by slicing twice. This allows the compiler</span>
    <span class="tok-comment">// to perform some optimisations like recognising a comptime-known length when</span>
    <span class="tok-comment">// the start position is only known at runtime.</span>
    <span class="tok-kw">var</span> runtime_start: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;
    _ = &amp;runtime_start;
    <span class="tok-kw">const</span> length = <span class="tok-number">2</span>;
    <span class="tok-kw">const</span> array_ptr_len = array[runtime_start..][<span class="tok-number">0</span>..length];
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(array_ptr_len) == *[length]<span class="tok-type">i32</span>);

    <span class="tok-comment">// Using the address-of operator on a slice gives a single-item pointer.</span>
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(&amp;slice[<span class="tok-number">0</span>]) == *<span class="tok-type">i32</span>);
    <span class="tok-comment">// Using the `ptr` field gives a many-item pointer.</span>
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(slice.ptr) == [*]<span class="tok-type">i32</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromPtr</span>(slice.ptr) == <span class="tok-builtin">@intFromPtr</span>(&amp;slice[<span class="tok-number">0</span>]));

    <span class="tok-comment">// Slices have array bounds checking. If you try to access something out</span>
    <span class="tok-comment">// of bounds, you'll get a safety check failure:</span>
    slice[<span class="tok-number">10</span>] += <span class="tok-number">1</span>;

    <span class="tok-comment">// Note that `slice.ptr` does not invoke safety checking, while `&amp;slice[0]`</span>
    <span class="tok-comment">// asserts that the slice has len &gt; 0.</span>

    <span class="tok-comment">// Empty slices can be created like this:</span>
    <span class="tok-kw">const</span> empty1 = &amp;[<span class="tok-number">0</span>]<span class="tok-type">u8</span>{};
    <span class="tok-comment">// If the type is known you can use this short hand:</span>
    <span class="tok-kw">const</span> empty2: []<span class="tok-type">u8</span> = &amp;.{};
    <span class="tok-kw">try</span> expect(empty1.len == <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> expect(empty2.len == <span class="tok-number">0</span>);

    <span class="tok-comment">// A zero-length initialization can always be used to create an empty slice, even if the slice is mutable.</span>
    <span class="tok-comment">// This is because the pointed-to data is zero bits long, so its immutability is irrelevant.</span>
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_basic_slices.zig</kbd>
1/1 test_basic_slices.test.basic slices...thread 2902466 panic: index out of bounds: index 10, len 4
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_basic_slices.zig:41:10</span>: <span class="sgr-2m">0x102e3c0 in test.basic slices (test_basic_slices.zig)</span>
    slice[10] += 1;
         <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:218:25</span>: <span class="sgr-2m">0x1160b60 in mainTerminal (test_runner.zig)</span>
        if (test_fn.func()) |_| {
                        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:66:28</span>: <span class="sgr-2m">0x1159d81 in main (test_runner.zig)</span>
        return mainTerminal();
                           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x1153b1d in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x11533b1 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
error: the following test command crashed:
/home/andy/dev/zig/.zig-cache/o/0e584e3dac6333a0b2d5158992704660/test --seed=0x665d12a2
</samp></pre></figure>

      <p>This is one reason we prefer slices to pointers.</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_slices.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;
<span class="tok-kw">const</span> mem = std.mem;
<span class="tok-kw">const</span> fmt = std.fmt;

<span class="tok-kw">test</span> <span class="tok-str">"using slices for strings"</span> {
    <span class="tok-comment">// Zig has no concept of strings. String literals are const pointers</span>
    <span class="tok-comment">// to null-terminated arrays of u8, and by convention parameters</span>
    <span class="tok-comment">// that are "strings" are expected to be UTF-8 encoded slices of u8.</span>
    <span class="tok-comment">// Here we coerce *const [5:0]u8 and *const [6:0]u8 to []const u8</span>
    <span class="tok-kw">const</span> hello: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">"hello"</span>;
    <span class="tok-kw">const</span> world: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">"世界"</span>;

    <span class="tok-kw">var</span> all_together: [<span class="tok-number">100</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-comment">// You can use slice syntax with at least one runtime-known index on an</span>
    <span class="tok-comment">// array to convert an array into a slice.</span>
    <span class="tok-kw">var</span> start: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    _ = &amp;start;
    <span class="tok-kw">const</span> all_together_slice = all_together[start..];
    <span class="tok-comment">// String concatenation example.</span>
    <span class="tok-kw">const</span> hello_world = <span class="tok-kw">try</span> fmt.bufPrint(all_together_slice, <span class="tok-str">"{s} {s}"</span>, .{ hello, world });

    <span class="tok-comment">// Generally, you can use UTF-8 and not worry about whether something is a</span>
    <span class="tok-comment">// string. If you don't need to deal with individual characters, no need</span>
    <span class="tok-comment">// to decode.</span>
    <span class="tok-kw">try</span> expect(mem.eql(<span class="tok-type">u8</span>, hello_world, <span class="tok-str">"hello 世界"</span>));
}

<span class="tok-kw">test</span> <span class="tok-str">"slice pointer"</span> {
    <span class="tok-kw">var</span> array: [<span class="tok-number">10</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> ptr = &amp;array;
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(ptr) == *[<span class="tok-number">10</span>]<span class="tok-type">u8</span>);

    <span class="tok-comment">// A pointer to an array can be sliced just like an array:</span>
    <span class="tok-kw">var</span> start: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> end: <span class="tok-type">usize</span> = <span class="tok-number">5</span>;
    _ = .{ &amp;start, &amp;end };
    <span class="tok-kw">const</span> slice = ptr[start..end];
    <span class="tok-comment">// The slice is mutable because we sliced a mutable pointer.</span>
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(slice) == []<span class="tok-type">u8</span>);
    slice[<span class="tok-number">2</span>] = <span class="tok-number">3</span>;
    <span class="tok-kw">try</span> expect(array[<span class="tok-number">2</span>] == <span class="tok-number">3</span>);

    <span class="tok-comment">// Again, slicing with comptime-known indexes will produce another pointer</span>
    <span class="tok-comment">// to an array:</span>
    <span class="tok-kw">const</span> ptr2 = slice[<span class="tok-number">2</span>..<span class="tok-number">3</span>];
    <span class="tok-kw">try</span> expect(ptr2.len == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> expect(ptr2[<span class="tok-number">0</span>] == <span class="tok-number">3</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(ptr2) == *[<span class="tok-number">1</span>]<span class="tok-type">u8</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_slices.zig</kbd>
1/2 test_slices.test.using slices for strings...OK
2/2 test_slices.test.slice pointer...OK
All 2 tests passed.
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Pointers">Pointers</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#for">for</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Arrays">Arrays</a></li>
</ul>


      <h3 id="Sentinel-Terminated-Slices"><a href="https://ziglang.org/documentation/0.15.2/#toc-Sentinel-Terminated-Slices">Sentinel-Terminated Slices</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Sentinel-Terminated-Slices">§</a></h3>

      <p>
      The syntax <code>[:x]T</code> is a slice which has a runtime-known length
      and also guarantees a sentinel value at the element indexed by the length. The type does not
      guarantee that there are no sentinel elements before that. Sentinel-terminated slices allow element
      access to the <code>len</code> index.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_null_terminated_slice.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"0-terminated slice"</span> {
    <span class="tok-kw">const</span> slice: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">"hello"</span>;

    <span class="tok-kw">try</span> expect(slice.len == <span class="tok-number">5</span>);
    <span class="tok-kw">try</span> expect(slice[<span class="tok-number">5</span>] == <span class="tok-number">0</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_null_terminated_slice.zig</kbd>
1/1 test_null_terminated_slice.test.0-terminated slice...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      Sentinel-terminated slices can also be created using a variation of the slice syntax
      <code>data[start..end :x]</code>, where <code>data</code> is a many-item pointer,
      array or slice and <code>x</code> is the sentinel value.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_null_terminated_slicing.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"0-terminated slicing"</span> {
    <span class="tok-kw">var</span> array = [_]<span class="tok-type">u8</span>{ <span class="tok-number">3</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span>, <span class="tok-number">3</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span> };
    <span class="tok-kw">var</span> runtime_length: <span class="tok-type">usize</span> = <span class="tok-number">3</span>;
    _ = &amp;runtime_length;
    <span class="tok-kw">const</span> slice = array[<span class="tok-number">0</span>..runtime_length :<span class="tok-number">0</span>];

    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(slice) == [:<span class="tok-number">0</span>]<span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> expect(slice.len == <span class="tok-number">3</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_null_terminated_slicing.zig</kbd>
1/1 test_null_terminated_slicing.test.0-terminated slicing...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      Sentinel-terminated slicing asserts that the element in the sentinel position of the backing data is
      actually the sentinel value. If this is not the case, safety-checked <a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">Illegal Behavior</a> results.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_sentinel_mismatch.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"sentinel mismatch"</span> {
    <span class="tok-kw">var</span> array = [_]<span class="tok-type">u8</span>{ <span class="tok-number">3</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span> };

    <span class="tok-comment">// Creating a sentinel-terminated slice from the array with a length of 2</span>
    <span class="tok-comment">// will result in the value `1` occupying the sentinel element position.</span>
    <span class="tok-comment">// This does not match the indicated sentinel value of `0` and will lead</span>
    <span class="tok-comment">// to a runtime panic.</span>
    <span class="tok-kw">var</span> runtime_length: <span class="tok-type">usize</span> = <span class="tok-number">2</span>;
    _ = &amp;runtime_length;
    <span class="tok-kw">const</span> slice = array[<span class="tok-number">0</span>..runtime_length :<span class="tok-number">0</span>];

    _ = slice;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_sentinel_mismatch.zig</kbd>
1/1 test_sentinel_mismatch.test.sentinel mismatch...thread 2902472 panic: sentinel mismatch: expected 0, found 1
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_sentinel_mismatch.zig:13:24</span>: <span class="sgr-2m">0x102c117 in test.sentinel mismatch (test_sentinel_mismatch.zig)</span>
    const slice = array[0..runtime_length :0];
                       <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:218:25</span>: <span class="sgr-2m">0x115cc90 in mainTerminal (test_runner.zig)</span>
        if (test_fn.func()) |_| {
                        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:66:28</span>: <span class="sgr-2m">0x1155eb1 in main (test_runner.zig)</span>
        return mainTerminal();
                           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x114fc4d in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x114f4e1 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
error: the following test command crashed:
/home/andy/dev/zig/.zig-cache/o/12c6cfa0971ea7c724c8448a09f20f6b/test --seed=0xb506c876
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Sentinel-Terminated-Pointers">Sentinel-Terminated Pointers</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Sentinel-Terminated-Arrays">Sentinel-Terminated Arrays</a></li>
</ul>

      
      

      <h2 id="struct"><a href="https://ziglang.org/documentation/0.15.2/#toc-struct">struct</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#struct">§</a></h2>

      <figure><figcaption class="zig-cap"><cite class="file">test_structs.zig</cite></figcaption><pre><code><span class="tok-comment">// Declare a struct.</span>
<span class="tok-comment">// Zig gives no guarantees about the order of fields and the size of</span>
<span class="tok-comment">// the struct but the fields are guaranteed to be ABI-aligned.</span>
<span class="tok-kw">const</span> Point = <span class="tok-kw">struct</span> {
    x: <span class="tok-type">f32</span>,
    y: <span class="tok-type">f32</span>,
};

<span class="tok-comment">// Declare an instance of a struct.</span>
<span class="tok-kw">const</span> p: Point = .{
    .x = <span class="tok-number">0.12</span>,
    .y = <span class="tok-number">0.34</span>,
};

<span class="tok-comment">// Functions in the struct's namespace can be called with dot syntax.</span>
<span class="tok-kw">const</span> Vec3 = <span class="tok-kw">struct</span> {
    x: <span class="tok-type">f32</span>,
    y: <span class="tok-type">f32</span>,
    z: <span class="tok-type">f32</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(x: <span class="tok-type">f32</span>, y: <span class="tok-type">f32</span>, z: <span class="tok-type">f32</span>) Vec3 {
        <span class="tok-kw">return</span> Vec3{
            .x = x,
            .y = y,
            .z = z,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dot</span>(self: Vec3, other: Vec3) <span class="tok-type">f32</span> {
        <span class="tok-kw">return</span> self.x * other.x + self.y * other.y + self.z * other.z;
    }
};

<span class="tok-kw">test</span> <span class="tok-str">"dot product"</span> {
    <span class="tok-kw">const</span> v1 = Vec3.init(<span class="tok-number">1.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">0.0</span>);
    <span class="tok-kw">const</span> v2 = Vec3.init(<span class="tok-number">0.0</span>, <span class="tok-number">1.0</span>, <span class="tok-number">0.0</span>);
    <span class="tok-kw">try</span> expect(v1.dot(v2) == <span class="tok-number">0.0</span>);

    <span class="tok-comment">// Other than being available to call with dot syntax, struct methods are</span>
    <span class="tok-comment">// not special. You can reference them as any other declaration inside</span>
    <span class="tok-comment">// the struct:</span>
    <span class="tok-kw">try</span> expect(Vec3.dot(v1, v2) == <span class="tok-number">0.0</span>);
}

<span class="tok-comment">// Structs can have declarations.</span>
<span class="tok-comment">// Structs can have 0 fields.</span>
<span class="tok-kw">const</span> Empty = <span class="tok-kw">struct</span> {
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> PI = <span class="tok-number">3.14</span>;
};
<span class="tok-kw">test</span> <span class="tok-str">"struct namespaced variable"</span> {
    <span class="tok-kw">try</span> expect(Empty.PI == <span class="tok-number">3.14</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@sizeOf</span>(Empty) == <span class="tok-number">0</span>);

    <span class="tok-comment">// Empty structs can be instantiated the same as usual.</span>
    <span class="tok-kw">const</span> does_nothing: Empty = .{};

    _ = does_nothing;
}

<span class="tok-comment">// Struct field order is determined by the compiler, however, a base pointer</span>
<span class="tok-comment">// can be computed from a field pointer:</span>
<span class="tok-kw">fn</span> <span class="tok-fn">setYBasedOnX</span>(x: *<span class="tok-type">f32</span>, y: <span class="tok-type">f32</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> point: *Point = <span class="tok-builtin">@fieldParentPtr</span>(<span class="tok-str">"x"</span>, x);
    point.y = y;
}
<span class="tok-kw">test</span> <span class="tok-str">"field parent pointer"</span> {
    <span class="tok-kw">var</span> point = Point{
        .x = <span class="tok-number">0.1234</span>,
        .y = <span class="tok-number">0.5678</span>,
    };
    setYBasedOnX(&amp;point.x, <span class="tok-number">0.9</span>);
    <span class="tok-kw">try</span> expect(point.y == <span class="tok-number">0.9</span>);
}

<span class="tok-comment">// Structs can be returned from functions.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">LinkedList</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Node = <span class="tok-kw">struct</span> {
            prev: ?*Node,
            next: ?*Node,
            data: T,
        };

        first: ?*Node,
        last: ?*Node,
        len: <span class="tok-type">usize</span>,
    };
}

<span class="tok-kw">test</span> <span class="tok-str">"linked list"</span> {
    <span class="tok-comment">// Functions called at compile-time are memoized.</span>
    <span class="tok-kw">try</span> expect(LinkedList(<span class="tok-type">i32</span>) == LinkedList(<span class="tok-type">i32</span>));

    <span class="tok-kw">const</span> list = LinkedList(<span class="tok-type">i32</span>){
        .first = <span class="tok-null">null</span>,
        .last = <span class="tok-null">null</span>,
        .len = <span class="tok-number">0</span>,
    };
    <span class="tok-kw">try</span> expect(list.len == <span class="tok-number">0</span>);

    <span class="tok-comment">// Since types are first class values you can instantiate the type</span>
    <span class="tok-comment">// by assigning it to a variable:</span>
    <span class="tok-kw">const</span> ListOfInts = LinkedList(<span class="tok-type">i32</span>);
    <span class="tok-kw">try</span> expect(ListOfInts == LinkedList(<span class="tok-type">i32</span>));

    <span class="tok-kw">var</span> node = ListOfInts.Node{
        .prev = <span class="tok-null">null</span>,
        .next = <span class="tok-null">null</span>,
        .data = <span class="tok-number">1234</span>,
    };
    <span class="tok-kw">const</span> list2 = LinkedList(<span class="tok-type">i32</span>){
        .first = &amp;node,
        .last = &amp;node,
        .len = <span class="tok-number">1</span>,
    };

    <span class="tok-comment">// When using a pointer to a struct, fields can be accessed directly,</span>
    <span class="tok-comment">// without explicitly dereferencing the pointer.</span>
    <span class="tok-comment">// So you can do</span>
    <span class="tok-kw">try</span> expect(list2.first.?.data == <span class="tok-number">1234</span>);
    <span class="tok-comment">// instead of try expect(list2.first.?.*.data == 1234);</span>
}

<span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_structs.zig</kbd>
1/4 test_structs.test.dot product...OK
2/4 test_structs.test.struct namespaced variable...OK
3/4 test_structs.test.field parent pointer...OK
4/4 test_structs.test.linked list...OK
All 4 tests passed.
</samp></pre></figure>


      <h3 id="Default-Field-Values"><a href="https://ziglang.org/documentation/0.15.2/#toc-Default-Field-Values">Default Field Values</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Default-Field-Values">§</a></h3>

      <p>
      Each struct field may have an expression indicating the default field
      value. Such expressions are executed at <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a>, and allow the
      field to be omitted in a struct literal expression:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">struct_default_field_values.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Foo = <span class="tok-kw">struct</span> {
    a: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>,
    b: <span class="tok-type">i32</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">"default struct initialization fields"</span> {
    <span class="tok-kw">const</span> x: Foo = .{
        .b = <span class="tok-number">5</span>,
    };
    <span class="tok-kw">if</span> (x.a + x.b != <span class="tok-number">1239</span>) {
        <span class="tok-kw">comptime</span> <span class="tok-kw">unreachable</span>;
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test struct_default_field_values.zig</kbd>
1/1 struct_default_field_values.test.default struct initialization fields...OK
All 1 tests passed.
</samp></pre></figure>

      <h4 id="Faulty-Default-Field-Values"><a href="https://ziglang.org/documentation/0.15.2/#toc-Faulty-Default-Field-Values">Faulty Default Field Values</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Faulty-Default-Field-Values">§</a></h4>

      <p>
      Default field values are only appropriate when the data invariants of a struct
      cannot be violated by omitting that field from an initialization.
      </p>
      <p>
      For example, here is an inappropriate use of default struct field initialization:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">bad_default_value.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Threshold = <span class="tok-kw">struct</span> {
    minimum: <span class="tok-type">f32</span> = <span class="tok-number">0.25</span>,
    maximum: <span class="tok-type">f32</span> = <span class="tok-number">0.75</span>,

    <span class="tok-kw">const</span> Category = <span class="tok-kw">enum</span> { low, medium, high };

    <span class="tok-kw">fn</span> <span class="tok-fn">categorize</span>(t: Threshold, value: <span class="tok-type">f32</span>) Category {
        assert(t.maximum &gt;= t.minimum);
        <span class="tok-kw">if</span> (value &lt; t.minimum) <span class="tok-kw">return</span> .low;
        <span class="tok-kw">if</span> (value &gt; t.maximum) <span class="tok-kw">return</span> .high;
        <span class="tok-kw">return</span> .medium;
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> threshold: Threshold = .{
        .maximum = <span class="tok-number">0.20</span>,
    };
    <span class="tok-kw">const</span> category = threshold.categorize(<span class="tok-number">0.90</span>);
    <span class="tok-kw">try</span> std.fs.File.stdout().writeAll(<span class="tok-builtin">@tagName</span>(category));
}

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> assert = std.debug.assert;</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe bad_default_value.zig</kbd>
$ <kbd>./bad_default_value</kbd>
thread 2895237 panic: reached unreachable code
<span class="sgr-1m">/home/andy/dev/zig/lib/std/debug.zig:559:14</span>: <span class="sgr-2m">0x1044179 in assert (std.zig)</span>
    if (!ok) unreachable; // assertion failure
             <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/bad_default_value.zig:8:15</span>: <span class="sgr-2m">0x113ec54 in categorize (bad_default_value.zig)</span>
        assert(t.maximum &gt;= t.minimum);
              <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/bad_default_value.zig:19:42</span>: <span class="sgr-2m">0x113d444 in main (bad_default_value.zig)</span>
    const category = threshold.categorize(0.90);
                                         <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:627:37</span>: <span class="sgr-2m">0x113dca9 in posixCallMainAndExit (std.zig)</span>
            const result = root.main() catch |err| {
                                    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      <p>
      Above you can see the danger of ignoring this principle. The default
      field values caused the data invariant to be violated, causing illegal
      behavior.
      </p>
      <p>
      To fix this, remove the default values from all the struct fields, and provide
      a named default value:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">struct_default_value.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Threshold = <span class="tok-kw">struct</span> {
    minimum: <span class="tok-type">f32</span>,
    maximum: <span class="tok-type">f32</span>,

    <span class="tok-kw">const</span> default: Threshold = .{
        .minimum = <span class="tok-number">0.25</span>,
        .maximum = <span class="tok-number">0.75</span>,
    };
};</code></pre></figure>

      <p>If a struct value requires a runtime-known value in order to be initialized
      without violating data invariants, then use an initialization method that accepts
      those runtime values, and populates the remaining fields.</p>
      
      

      <h3 id="extern-struct"><a href="https://ziglang.org/documentation/0.15.2/#toc-extern-struct">extern struct</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#extern-struct">§</a></h3>

      <p>An <code><span class="tok-kw">extern</span> <span class="tok-kw">struct</span></code> has in-memory layout matching
      the C ABI for the target.</p>
      <p>If well-defined in-memory layout is not required, <a href="https://ziglang.org/documentation/0.15.2/#struct">struct</a> is a better choice
      because it places fewer restrictions on the compiler.</p>
      <p>See <a href="https://ziglang.org/documentation/0.15.2/#packed-struct">packed struct</a> for a struct that has the ABI of its backing integer,
      which can be useful for modeling flags.</p>
      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#extern-union">extern union</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#extern-enum">extern enum</a></li>
</ul>

      

      <h3 id="packed-struct"><a href="https://ziglang.org/documentation/0.15.2/#toc-packed-struct">packed struct</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#packed-struct">§</a></h3>

      <p>
      <code><span class="tok-kw">packed</span></code> structs, like <code><span class="tok-kw">enum</span></code>, are based on the concept
      of interpreting integers differently. All packed structs have a <strong>backing integer</strong>,
      which is implicitly determined by the total bit count of fields, or explicitly specified.
      Packed structs have well-defined memory layout - exactly the same ABI as their backing integer.
      </p>
      <p>
      Each field of a packed struct is interpreted as a logical sequence of bits, arranged from
      least to most significant. Allowed field types:
      </p>
      <ul>
        <li>An <a href="https://ziglang.org/documentation/0.15.2/#Integers">integer</a> field uses exactly as many bits as its
        bit width. For example, a <code><span class="tok-type">u5</span></code> will use 5 bits of
        the backing integer.</li>
        <li>A <a href="https://ziglang.org/documentation/0.15.2/#Primitive-Types">bool</a> field uses exactly 1 bit.</li>
        <li>An <a href="https://ziglang.org/documentation/0.15.2/#enum">enum</a> field uses exactly the bit width of its integer tag type.</li>
        <li>A <a href="https://ziglang.org/documentation/0.15.2/#packed-union">packed union</a> field uses exactly the bit width of the union field with
        the largest bit width.</li>
        <li>A <code><span class="tok-kw">packed</span> <span class="tok-kw">struct</span></code> field uses the bits of its backing integer.</li>
      </ul>
      <p>
      This means that a <code><span class="tok-kw">packed</span> <span class="tok-kw">struct</span></code> can participate
      in a <a href="https://ziglang.org/documentation/0.15.2/#bitCast">@bitCast</a> or a <a href="https://ziglang.org/documentation/0.15.2/#ptrCast">@ptrCast</a> to reinterpret memory.
      This even works at <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a>:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_packed_structs.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> native_endian = <span class="tok-builtin">@import</span>(<span class="tok-str">"builtin"</span>).target.cpu.arch.endian();
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Full = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    number: <span class="tok-type">u16</span>,
};
<span class="tok-kw">const</span> Divided = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    half1: <span class="tok-type">u8</span>,
    quarter3: <span class="tok-type">u4</span>,
    quarter4: <span class="tok-type">u4</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">"@bitCast between packed structs"</span> {
    <span class="tok-kw">try</span> doTheTest();
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> doTheTest();
}

<span class="tok-kw">fn</span> <span class="tok-fn">doTheTest</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@sizeOf</span>(Full) == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@sizeOf</span>(Divided) == <span class="tok-number">2</span>);
    <span class="tok-kw">const</span> full = Full{ .number = <span class="tok-number">0x1234</span> };
    <span class="tok-kw">const</span> divided: Divided = <span class="tok-builtin">@bitCast</span>(full);
    <span class="tok-kw">try</span> expect(divided.half1 == <span class="tok-number">0x34</span>);
    <span class="tok-kw">try</span> expect(divided.quarter3 == <span class="tok-number">0x2</span>);
    <span class="tok-kw">try</span> expect(divided.quarter4 == <span class="tok-number">0x1</span>);

    <span class="tok-kw">const</span> ordered: [<span class="tok-number">2</span>]<span class="tok-type">u8</span> = <span class="tok-builtin">@bitCast</span>(full);
    <span class="tok-kw">switch</span> (native_endian) {
        .big =&gt; {
            <span class="tok-kw">try</span> expect(ordered[<span class="tok-number">0</span>] == <span class="tok-number">0x12</span>);
            <span class="tok-kw">try</span> expect(ordered[<span class="tok-number">1</span>] == <span class="tok-number">0x34</span>);
        },
        .little =&gt; {
            <span class="tok-kw">try</span> expect(ordered[<span class="tok-number">0</span>] == <span class="tok-number">0x34</span>);
            <span class="tok-kw">try</span> expect(ordered[<span class="tok-number">1</span>] == <span class="tok-number">0x12</span>);
        },
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_packed_structs.zig</kbd>
1/1 test_packed_structs.test.@bitCast between packed structs...OK
All 1 tests passed.
</samp></pre></figure>
      <p>
      The backing integer can be inferred or explicitly provided. When
      inferred, it will be unsigned. When explicitly provided, its bit width
      will be enforced at compile time to exactly match the total bit width of
      the fields:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_missized_packed_struct.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">"missized packed struct"</span> {
    <span class="tok-kw">const</span> S = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u32</span>) { a: <span class="tok-type">u16</span>, b: <span class="tok-type">u8</span> };
    _ = S{ .a = <span class="tok-number">4</span>, .b = <span class="tok-number">2</span> };
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_missized_packed_struct.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_missized_packed_struct.zig:2:29: </span><span class="sgr-31m">error: </span><span class="sgr-1m">backing integer type 'u32' has bit size 32 but the struct fields have a total bit size of 24
</span>    const S = packed struct(u32) { a: u16, b: u8 };
                            <span class="sgr-32m">^~~
</span><span class="sgr-2m">referenced by:
    test.missized packed struct: /home/andy/dev/zig/doc/langref/test_missized_packed_struct.zig:2:22
</span>
</samp></pre></figure>

      <p>
      Zig allows the address to be taken of a non-byte-aligned field:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_pointer_to_non-byte_aligned_field.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> BitField = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    a: <span class="tok-type">u3</span>,
    b: <span class="tok-type">u3</span>,
    c: <span class="tok-type">u2</span>,
};

<span class="tok-kw">var</span> foo = BitField{
    .a = <span class="tok-number">1</span>,
    .b = <span class="tok-number">2</span>,
    .c = <span class="tok-number">3</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">"pointer to non-byte-aligned field"</span> {
    <span class="tok-kw">const</span> ptr = &amp;foo.b;
    <span class="tok-kw">try</span> expect(ptr.* == <span class="tok-number">2</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_pointer_to_non-byte_aligned_field.zig</kbd>
1/1 test_pointer_to_non-byte_aligned_field.test.pointer to non-byte-aligned field...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      However, the pointer to a non-byte-aligned field has special properties and cannot
      be passed when a normal pointer is expected:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_misaligned_pointer.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> BitField = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    a: <span class="tok-type">u3</span>,
    b: <span class="tok-type">u3</span>,
    c: <span class="tok-type">u2</span>,
};

<span class="tok-kw">var</span> bit_field = BitField{
    .a = <span class="tok-number">1</span>,
    .b = <span class="tok-number">2</span>,
    .c = <span class="tok-number">3</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">"pointer to non-byte-aligned field"</span> {
    <span class="tok-kw">try</span> expect(bar(&amp;bit_field.b) == <span class="tok-number">2</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>(x: *<span class="tok-kw">const</span> <span class="tok-type">u3</span>) <span class="tok-type">u3</span> {
    <span class="tok-kw">return</span> x.*;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_misaligned_pointer.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_misaligned_pointer.zig:17:20: </span><span class="sgr-31m">error: </span><span class="sgr-1m">expected type '*const u3', found '*align(1:3:1) u3'
</span>    try expect(bar(&amp;bit_field.b) == 2);
                   <span class="sgr-32m">^~~~~~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_misaligned_pointer.zig:17:20: </span><span class="sgr-36m">note: </span><span class="sgr-1m">pointer host size '1' cannot cast into pointer host size '0'
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_misaligned_pointer.zig:17:20: </span><span class="sgr-36m">note: </span><span class="sgr-1m">pointer bit offset '3' cannot cast into pointer bit offset '0'
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_misaligned_pointer.zig:20:11: </span><span class="sgr-36m">note: </span><span class="sgr-1m">parameter type declared here
</span>fn bar(x: *const u3) u3 {
          <span class="sgr-32m">^~~~~~~~~
</span>
</samp></pre></figure>

      <p>
      In this case, the function <code>bar</code> cannot be called because the pointer
      to the non-ABI-aligned field mentions the bit offset, but the function expects an ABI-aligned pointer.
      </p>
      <p>
      Pointers to non-ABI-aligned fields share the same address as the other fields within their host integer:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_packed_struct_field_address.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> BitField = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    a: <span class="tok-type">u3</span>,
    b: <span class="tok-type">u3</span>,
    c: <span class="tok-type">u2</span>,
};

<span class="tok-kw">var</span> bit_field = BitField{
    .a = <span class="tok-number">1</span>,
    .b = <span class="tok-number">2</span>,
    .c = <span class="tok-number">3</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">"pointers of sub-byte-aligned fields share addresses"</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromPtr</span>(&amp;bit_field.a) == <span class="tok-builtin">@intFromPtr</span>(&amp;bit_field.b));
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromPtr</span>(&amp;bit_field.a) == <span class="tok-builtin">@intFromPtr</span>(&amp;bit_field.c));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_packed_struct_field_address.zig</kbd>
1/1 test_packed_struct_field_address.test.pointers of sub-byte-aligned fields share addresses...OK
All 1 tests passed.
</samp></pre></figure>

