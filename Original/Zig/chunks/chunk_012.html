      <figure><figcaption class="zig-cap"><cite class="file">test_illegal_behavior.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">"safety check"</span> {
    <span class="tok-kw">unreachable</span>;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_illegal_behavior.zig</kbd>
1/1 test_illegal_behavior.test.safety check...thread 2892891 panic: reached unreachable code
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_illegal_behavior.zig:2:5</span>: <span class="sgr-2m">0x102c00c in test.safety check (test_illegal_behavior.zig)</span>
    unreachable;
    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:218:25</span>: <span class="sgr-2m">0x115cb20 in mainTerminal (test_runner.zig)</span>
        if (test_fn.func()) |_| {
                        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:66:28</span>: <span class="sgr-2m">0x1155d41 in main (test_runner.zig)</span>
        return mainTerminal();
                           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x114fadd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x114f371 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
error: the following test command crashed:
/home/andy/dev/zig/.zig-cache/o/e72b27fd3a681a218f2215fb6e7fd433/test --seed=0xeebe2201
</samp></pre></figure>

      <h3 id="Reaching-Unreachable-Code"><a href="https://ziglang.org/documentation/0.15.2/#toc-Reaching-Unreachable-Code">Reaching Unreachable Code</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Reaching-Unreachable-Code">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_reaching_unreachable.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    assert(<span class="tok-null">false</span>);
}
<span class="tok-kw">fn</span> <span class="tok-fn">assert</span>(ok: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!ok) <span class="tok-kw">unreachable</span>; <span class="tok-comment">// assertion failure</span>
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_reaching_unreachable.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_reaching_unreachable.zig:5:14: </span><span class="sgr-31m">error: </span><span class="sgr-1m">reached unreachable code
</span>    if (!ok) unreachable; // assertion failure
             <span class="sgr-32m">^~~~~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_reaching_unreachable.zig:2:11: </span><span class="sgr-36m">note: </span><span class="sgr-1m">called at comptime here
</span>    assert(false);
    <span class="sgr-32m">~~~~~~^~~~~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_reaching_unreachable.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    std.debug.assert(<span class="tok-null">false</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_reaching_unreachable.zig</kbd>
$ <kbd>./runtime_reaching_unreachable</kbd>
thread 2897013 panic: reached unreachable code
<span class="sgr-1m">/home/andy/dev/zig/lib/std/debug.zig:559:14</span>: <span class="sgr-2m">0x1044179 in assert (std.zig)</span>
    if (!ok) unreachable; // assertion failure
             <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_reaching_unreachable.zig:4:21</span>: <span class="sgr-2m">0x113e86e in main (runtime_reaching_unreachable.zig)</span>
    std.debug.assert(false);
                    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      
      <h3 id="Index-out-of-Bounds"><a href="https://ziglang.org/documentation/0.15.2/#toc-Index-out-of-Bounds">Index out of Bounds</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Index-out-of-Bounds">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_index_out_of_bounds.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> array: [<span class="tok-number">5</span>]<span class="tok-type">u8</span> = <span class="tok-str">"hello"</span>.*;
    <span class="tok-kw">const</span> garbage = array[<span class="tok-number">5</span>];
    _ = garbage;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_index_out_of_bounds.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_index_out_of_bounds.zig:3:27: </span><span class="sgr-31m">error: </span><span class="sgr-1m">index 5 outside array of length 5
</span>    const garbage = array[5];
                          <span class="sgr-32m">^
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_index_out_of_bounds.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> x = foo(<span class="tok-str">"hello"</span>);
    _ = x;
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(x: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> x[<span class="tok-number">5</span>];
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_index_out_of_bounds.zig</kbd>
$ <kbd>./runtime_index_out_of_bounds</kbd>
thread 2893998 panic: index out of bounds: index 5, len 5
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_index_out_of_bounds.zig:7:13</span>: <span class="sgr-2m">0x113fae6 in foo (runtime_index_out_of_bounds.zig)</span>
    return x[5];
            <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_index_out_of_bounds.zig:2:18</span>: <span class="sgr-2m">0x113e87a in main (runtime_index_out_of_bounds.zig)</span>
    const x = foo("hello");
                 <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      
      <h3 id="Cast-Negative-Number-to-Unsigned-Integer"><a href="https://ziglang.org/documentation/0.15.2/#toc-Cast-Negative-Number-to-Unsigned-Integer">Cast Negative Number to Unsigned Integer</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Cast-Negative-Number-to-Unsigned-Integer">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_invalid_cast.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> value: <span class="tok-type">i32</span> = -<span class="tok-number">1</span>;
    <span class="tok-kw">const</span> unsigned: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(value);
    _ = unsigned;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_invalid_cast.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_invalid_cast.zig:3:36: </span><span class="sgr-31m">error: </span><span class="sgr-1m">type 'u32' cannot represent integer value '-1'
</span>    const unsigned: u32 = @intCast(value);
                                   <span class="sgr-32m">^~~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_invalid_cast.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> value: <span class="tok-type">i32</span> = -<span class="tok-number">1</span>; <span class="tok-comment">// runtime-known</span>
    _ = &amp;value;
    <span class="tok-kw">const</span> unsigned: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(value);
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{unsigned});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_invalid_cast.zig</kbd>
$ <kbd>./runtime_invalid_cast</kbd>
thread 2899906 panic: integer does not fit in destination type
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_invalid_cast.zig:6:27</span>: <span class="sgr-2m">0x113e87f in main (runtime_invalid_cast.zig)</span>
    const unsigned: u32 = @intCast(value);
                          <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      <p>
      To obtain the maximum value of an unsigned integer, use <code>std.math.maxInt</code>.
      </p>
      
      <h3 id="Cast-Truncates-Data"><a href="https://ziglang.org/documentation/0.15.2/#toc-Cast-Truncates-Data">Cast Truncates Data</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Cast-Truncates-Data">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_invalid_cast_truncate.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> spartan_count: <span class="tok-type">u16</span> = <span class="tok-number">300</span>;
    <span class="tok-kw">const</span> byte: <span class="tok-type">u8</span> = <span class="tok-builtin">@intCast</span>(spartan_count);
    _ = byte;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_invalid_cast_truncate.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_invalid_cast_truncate.zig:3:31: </span><span class="sgr-31m">error: </span><span class="sgr-1m">type 'u8' cannot represent integer value '300'
</span>    const byte: u8 = @intCast(spartan_count);
                              <span class="sgr-32m">^~~~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_invalid_cast_truncate.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> spartan_count: <span class="tok-type">u16</span> = <span class="tok-number">300</span>; <span class="tok-comment">// runtime-known</span>
    _ = &amp;spartan_count;
    <span class="tok-kw">const</span> byte: <span class="tok-type">u8</span> = <span class="tok-builtin">@intCast</span>(spartan_count);
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{byte});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_invalid_cast_truncate.zig</kbd>
$ <kbd>./runtime_invalid_cast_truncate</kbd>
thread 2899317 panic: integer does not fit in destination type
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_invalid_cast_truncate.zig:6:22</span>: <span class="sgr-2m">0x113e880 in main (runtime_invalid_cast_truncate.zig)</span>
    const byte: u8 = @intCast(spartan_count);
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      <p>
      To truncate bits, use <a href="https://ziglang.org/documentation/0.15.2/#truncate">@truncate</a>.
      </p>
      
      <h3 id="Integer-Overflow"><a href="https://ziglang.org/documentation/0.15.2/#toc-Integer-Overflow">Integer Overflow</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Integer-Overflow">§</a></h3>

      <h4 id="Default-Operations"><a href="https://ziglang.org/documentation/0.15.2/#toc-Default-Operations">Default Operations</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Default-Operations">§</a></h4>

      <p>The following operators can cause integer overflow:</p>
      <ul>
          <li><code>+</code> (addition)</li>
          <li><code>-</code> (subtraction)</li>
          <li><code>-</code> (negation)</li>
          <li><code>*</code> (multiplication)</li>
          <li><code>/</code> (division)</li>
        <li><a href="https://ziglang.org/documentation/0.15.2/#divTrunc">@divTrunc</a> (division)</li>
        <li><a href="https://ziglang.org/documentation/0.15.2/#divFloor">@divFloor</a> (division)</li>
        <li><a href="https://ziglang.org/documentation/0.15.2/#divExact">@divExact</a> (division)</li>
      </ul>
      <p>Example with addition at compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_overflow.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">var</span> byte: <span class="tok-type">u8</span> = <span class="tok-number">255</span>;
    byte += <span class="tok-number">1</span>;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_overflow.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_overflow.zig:3:10: </span><span class="sgr-31m">error: </span><span class="sgr-1m">overflow of integer type 'u8' with value '256'
</span>    byte += 1;
    <span class="sgr-32m">~~~~~^~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_overflow.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> byte: <span class="tok-type">u8</span> = <span class="tok-number">255</span>;
    byte += <span class="tok-number">1</span>;
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{byte});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_overflow.zig</kbd>
$ <kbd>./runtime_overflow</kbd>
thread 2892886 panic: integer overflow
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_overflow.zig:5:10</span>: <span class="sgr-2m">0x113e895 in main (runtime_overflow.zig)</span>
    byte += 1;
         <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      
      <h4 id="Standard-Library-Math-Functions"><a href="https://ziglang.org/documentation/0.15.2/#toc-Standard-Library-Math-Functions">Standard Library Math Functions</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Standard-Library-Math-Functions">§</a></h4>

      <p>These functions provided by the standard library return possible errors.</p>
      <ul>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).math.add</code></li>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).math.sub</code></li>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).math.mul</code></li>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).math.divTrunc</code></li>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).math.divFloor</code></li>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).math.divExact</code></li>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).math.shl</code></li>
      </ul>
      <p>Example of catching an overflow for addition:</p>
      <figure><figcaption class="zig-cap"><cite class="file">math_add.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> math = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).math;
<span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> byte: <span class="tok-type">u8</span> = <span class="tok-number">255</span>;

    byte = <span class="tok-kw">if</span> (math.add(<span class="tok-type">u8</span>, byte, <span class="tok-number">1</span>)) |result| result <span class="tok-kw">else</span> |err| {
        print(<span class="tok-str">"unable to add one: {s}\n"</span>, .{<span class="tok-builtin">@errorName</span>(err)});
        <span class="tok-kw">return</span> err;
    };

    print(<span class="tok-str">"result: {}\n"</span>, .{byte});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe math_add.zig</kbd>
$ <kbd>./math_add</kbd>
unable to add one: Overflow
error: Overflow
<span class="sgr-1m">/home/andy/dev/zig/lib/std/math.zig:570:21</span>: <span class="sgr-2m">0x113ebae in add__anon_22552 (std.zig)</span>
    if (ov[1] != 0) return error.Overflow;
                    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/math_add.zig:8:9</span>: <span class="sgr-2m">0x113d422 in main (math_add.zig)</span>
        return err;
        <span class="sgr-32m">^</span>
</samp></pre></figure>

      
      <h4 id="Builtin-Overflow-Functions"><a href="https://ziglang.org/documentation/0.15.2/#toc-Builtin-Overflow-Functions">Builtin Overflow Functions</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Builtin-Overflow-Functions">§</a></h4>

      <p>
      These builtins return a tuple containing whether there was an overflow
      (as a <code><span class="tok-type">u1</span></code>) and the possibly overflowed bits of the operation:
      </p>
      <ul>
          <li><a href="https://ziglang.org/documentation/0.15.2/#addWithOverflow">@addWithOverflow</a></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#subWithOverflow">@subWithOverflow</a></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#mulWithOverflow">@mulWithOverflow</a></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#shlWithOverflow">@shlWithOverflow</a></li>
      </ul>
      <p>
      Example of <a href="https://ziglang.org/documentation/0.15.2/#addWithOverflow">@addWithOverflow</a>:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">addWithOverflow_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> byte: <span class="tok-type">u8</span> = <span class="tok-number">255</span>;

    <span class="tok-kw">const</span> ov = <span class="tok-builtin">@addWithOverflow</span>(byte, <span class="tok-number">10</span>);
    <span class="tok-kw">if</span> (ov[<span class="tok-number">1</span>] != <span class="tok-number">0</span>) {
        print(<span class="tok-str">"overflowed result: {}\n"</span>, .{ov[<span class="tok-number">0</span>]});
    } <span class="tok-kw">else</span> {
        print(<span class="tok-str">"result: {}\n"</span>, .{ov[<span class="tok-number">0</span>]});
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe addWithOverflow_builtin.zig</kbd>
$ <kbd>./addWithOverflow_builtin</kbd>
overflowed result: 9
</samp></pre></figure>

      
      <h4 id="Wrapping-Operations"><a href="https://ziglang.org/documentation/0.15.2/#toc-Wrapping-Operations">Wrapping Operations</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Wrapping-Operations">§</a></h4>

      <p>
      These operations have guaranteed wraparound semantics.
      </p>
      <ul>
          <li><code>+%</code> (wraparound addition)</li>
          <li><code>-%</code> (wraparound subtraction)</li>
          <li><code>-%</code> (wraparound negation)</li>
          <li><code>*%</code> (wraparound multiplication)</li>
      </ul>
      <figure><figcaption class="zig-cap"><cite class="file">test_wraparound_semantics.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;
<span class="tok-kw">const</span> minInt = std.math.minInt;
<span class="tok-kw">const</span> maxInt = std.math.maxInt;

<span class="tok-kw">test</span> <span class="tok-str">"wraparound addition and subtraction"</span> {
    <span class="tok-kw">const</span> x: <span class="tok-type">i32</span> = maxInt(<span class="tok-type">i32</span>);
    <span class="tok-kw">const</span> min_val = x +% <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> expect(min_val == minInt(<span class="tok-type">i32</span>));
    <span class="tok-kw">const</span> max_val = min_val -% <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> expect(max_val == maxInt(<span class="tok-type">i32</span>));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_wraparound_semantics.zig</kbd>
1/1 test_wraparound_semantics.test.wraparound addition and subtraction...OK
All 1 tests passed.
</samp></pre></figure>

      
      
      <h3 id="Exact-Left-Shift-Overflow"><a href="https://ziglang.org/documentation/0.15.2/#toc-Exact-Left-Shift-Overflow">Exact Left Shift Overflow</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Exact-Left-Shift-Overflow">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_shlExact_overflow.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> x = <span class="tok-builtin">@shlExact</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0b01010101</span>), <span class="tok-number">2</span>);
    _ = x;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_shlExact_overflow.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_shlExact_overflow.zig:2:15: </span><span class="sgr-31m">error: </span><span class="sgr-1m">overflow of integer type 'u8' with value '340'
</span>    const x = @shlExact(@as(u8, 0b01010101), 2);
              <span class="sgr-32m">^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_shlExact_overflow.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">u8</span> = <span class="tok-number">0b01010101</span>; <span class="tok-comment">// runtime-known</span>
    _ = &amp;x;
    <span class="tok-kw">const</span> y = <span class="tok-builtin">@shlExact</span>(x, <span class="tok-number">2</span>);
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{y});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_shlExact_overflow.zig</kbd>
$ <kbd>./runtime_shlExact_overflow</kbd>
thread 2896313 panic: left shift overflowed bits
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_shlExact_overflow.zig:6:5</span>: <span class="sgr-2m">0x113e8a1 in main (runtime_shlExact_overflow.zig)</span>
    const y = @shlExact(x, 2);
    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      
      <h3 id="Exact-Right-Shift-Overflow"><a href="https://ziglang.org/documentation/0.15.2/#toc-Exact-Right-Shift-Overflow">Exact Right Shift Overflow</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Exact-Right-Shift-Overflow">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_shrExact_overflow.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> x = <span class="tok-builtin">@shrExact</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0b10101010</span>), <span class="tok-number">2</span>);
    _ = x;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_shrExact_overflow.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_shrExact_overflow.zig:2:15: </span><span class="sgr-31m">error: </span><span class="sgr-1m">exact shift shifted out 1 bits
</span>    const x = @shrExact(@as(u8, 0b10101010), 2);
              <span class="sgr-32m">^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_shrExact_overflow.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">"builtin"</span>);
<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">u8</span> = <span class="tok-number">0b10101010</span>; <span class="tok-comment">// runtime-known</span>
    _ = &amp;x;
    <span class="tok-kw">const</span> y = <span class="tok-builtin">@shrExact</span>(x, <span class="tok-number">2</span>);
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{y});

    <span class="tok-kw">if</span> (builtin.cpu.arch.isRISCV() <span class="tok-kw">and</span> builtin.zig_backend == .stage2_llvm) <span class="tok-builtin">@panic</span>(<span class="tok-str">"https://github.com/ziglang/zig/issues/24304"</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_shrExact_overflow.zig</kbd>
$ <kbd>./runtime_shrExact_overflow</kbd>
thread 2897712 panic: right shift overflowed bits
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_shrExact_overflow.zig:7:5</span>: <span class="sgr-2m">0x113e88a in main (runtime_shrExact_overflow.zig)</span>
    const y = @shrExact(x, 2);
    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      
      <h3 id="Division-by-Zero"><a href="https://ziglang.org/documentation/0.15.2/#toc-Division-by-Zero">Division by Zero</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Division-by-Zero">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_division_by_zero.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> c = a / b;
    _ = c;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_division_by_zero.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_division_by_zero.zig:4:19: </span><span class="sgr-31m">error: </span><span class="sgr-1m">division by zero here causes illegal behavior
</span>    const c = a / b;
                  <span class="sgr-32m">^
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_division_by_zero.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u32</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">var</span> b: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    _ = .{ &amp;a, &amp;b };
    <span class="tok-kw">const</span> c = a / b;
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{c});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_division_by_zero.zig</kbd>
$ <kbd>./runtime_division_by_zero</kbd>
thread 2902461 panic: division by zero
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_division_by_zero.zig:7:17</span>: <span class="sgr-2m">0x113e890 in main (runtime_division_by_zero.zig)</span>
    const c = a / b;
                <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      
      <h3 id="Remainder-Division-by-Zero"><a href="https://ziglang.org/documentation/0.15.2/#toc-Remainder-Division-by-Zero">Remainder Division by Zero</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Remainder-Division-by-Zero">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_remainder_division_by_zero.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">i32</span> = <span class="tok-number">10</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> c = a % b;
    _ = c;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_remainder_division_by_zero.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_remainder_division_by_zero.zig:4:19: </span><span class="sgr-31m">error: </span><span class="sgr-1m">division by zero here causes illegal behavior
</span>    const c = a % b;
                  <span class="sgr-32m">^
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_remainder_division_by_zero.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u32</span> = <span class="tok-number">10</span>;
    <span class="tok-kw">var</span> b: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    _ = .{ &amp;a, &amp;b };
    <span class="tok-kw">const</span> c = a % b;
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{c});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_remainder_division_by_zero.zig</kbd>
$ <kbd>./runtime_remainder_division_by_zero</kbd>
thread 2899727 panic: division by zero
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_remainder_division_by_zero.zig:7:17</span>: <span class="sgr-2m">0x113e890 in main (runtime_remainder_division_by_zero.zig)</span>
    const c = a % b;
                <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      
      <h3 id="Exact-Division-Remainder"><a href="https://ziglang.org/documentation/0.15.2/#toc-Exact-Division-Remainder">Exact Division Remainder</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Exact-Division-Remainder">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_divExact_remainder.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">u32</span> = <span class="tok-number">10</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">u32</span> = <span class="tok-number">3</span>;
    <span class="tok-kw">const</span> c = <span class="tok-builtin">@divExact</span>(a, b);
    _ = c;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_divExact_remainder.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_divExact_remainder.zig:4:15: </span><span class="sgr-31m">error: </span><span class="sgr-1m">exact division produced remainder
</span>    const c = @divExact(a, b);
              <span class="sgr-32m">^~~~~~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_divExact_remainder.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u32</span> = <span class="tok-number">10</span>;
    <span class="tok-kw">var</span> b: <span class="tok-type">u32</span> = <span class="tok-number">3</span>;
    _ = .{ &amp;a, &amp;b };
    <span class="tok-kw">const</span> c = <span class="tok-builtin">@divExact</span>(a, b);
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{c});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_divExact_remainder.zig</kbd>
$ <kbd>./runtime_divExact_remainder</kbd>
thread 2901529 panic: exact division produced remainder
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_divExact_remainder.zig:7:15</span>: <span class="sgr-2m">0x113e8c7 in main (runtime_divExact_remainder.zig)</span>
    const c = @divExact(a, b);
              <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      
      <h3 id="Attempt-to-Unwrap-Null"><a href="https://ziglang.org/documentation/0.15.2/#toc-Attempt-to-Unwrap-Null">Attempt to Unwrap Null</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Attempt-to-Unwrap-Null">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_unwrap_null.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> optional_number: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> number = optional_number.?;
    _ = number;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_unwrap_null.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_unwrap_null.zig:3:35: </span><span class="sgr-31m">error: </span><span class="sgr-1m">unable to unwrap null
</span>    const number = optional_number.?;
                   <span class="sgr-32m">~~~~~~~~~~~~~~~^~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_unwrap_null.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> optional_number: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>;
    _ = &amp;optional_number;
    <span class="tok-kw">const</span> number = optional_number.?;
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{number});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_unwrap_null.zig</kbd>
$ <kbd>./runtime_unwrap_null</kbd>
thread 2892887 panic: attempt to use null value
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_unwrap_null.zig:6:35</span>: <span class="sgr-2m">0x113e8b4 in main (runtime_unwrap_null.zig)</span>
    const number = optional_number.?;
                                  <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      <p>One way to avoid this crash is to test for null instead of assuming non-null, with
      the <code><span class="tok-kw">if</span></code> expression:</p>
      <figure><figcaption class="zig-cap"><cite class="file">testing_null_with_if.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> optional_number: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>;

    <span class="tok-kw">if</span> (optional_number) |number| {
        print(<span class="tok-str">"got number: {}\n"</span>, .{number});
    } <span class="tok-kw">else</span> {
        print(<span class="tok-str">"it's null\n"</span>, .{});
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe testing_null_with_if.zig</kbd>
$ <kbd>./testing_null_with_if</kbd>
it's null
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Optionals">Optionals</a></li>
</ul>

      
      <h3 id="Attempt-to-Unwrap-Error"><a href="https://ziglang.org/documentation/0.15.2/#toc-Attempt-to-Unwrap-Error">Attempt to Unwrap Error</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Attempt-to-Unwrap-Error">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_unwrap_error.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> number = getNumberOrFail() <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    _ = number;
}

<span class="tok-kw">fn</span> <span class="tok-fn">getNumberOrFail</span>() !<span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReturnNumber;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_unwrap_error.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_unwrap_error.zig:2:44: </span><span class="sgr-31m">error: </span><span class="sgr-1m">caught unexpected error 'UnableToReturnNumber'
</span>    const number = getNumberOrFail() catch unreachable;
                                           <span class="sgr-32m">^~~~~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_unwrap_error.zig:7:18: </span><span class="sgr-36m">note: </span><span class="sgr-1m">error returned here
</span>    return error.UnableToReturnNumber;
                 <span class="sgr-32m">^~~~~~~~~~~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_unwrap_error.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> number = getNumberOrFail() <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{number});
}

<span class="tok-kw">fn</span> <span class="tok-fn">getNumberOrFail</span>() !<span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReturnNumber;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_unwrap_error.zig</kbd>
$ <kbd>./runtime_unwrap_error</kbd>
thread 2895126 panic: attempt to unwrap error: UnableToReturnNumber
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_unwrap_error.zig:9:5</span>: <span class="sgr-2m">0x113e86c in getNumberOrFail (runtime_unwrap_error.zig)</span>
    return error.UnableToReturnNumber;
    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_unwrap_error.zig:4:44</span>: <span class="sgr-2m">0x113e8d3 in main (runtime_unwrap_error.zig)</span>
    const number = getNumberOrFail() catch unreachable;
                                           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      <p>One way to avoid this crash is to test for an error instead of assuming a successful result, with
      the <code><span class="tok-kw">if</span></code> expression:</p>
      <figure><figcaption class="zig-cap"><cite class="file">testing_error_with_if.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = getNumberOrFail();

    <span class="tok-kw">if</span> (result) |number| {
        print(<span class="tok-str">"got number: {}\n"</span>, .{number});
    } <span class="tok-kw">else</span> |err| {
        print(<span class="tok-str">"got error: {s}\n"</span>, .{<span class="tok-builtin">@errorName</span>(err)});
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">getNumberOrFail</span>() !<span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReturnNumber;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe testing_error_with_if.zig</kbd>
$ <kbd>./testing_error_with_if</kbd>
got error: UnableToReturnNumber
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Errors">Errors</a></li>
</ul>

      
      <h3 id="Invalid-Error-Code"><a href="https://ziglang.org/documentation/0.15.2/#toc-Invalid-Error-Code">Invalid Error Code</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Invalid-Error-Code">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_invalid_error_code.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> err = <span class="tok-kw">error</span>.AnError;
    <span class="tok-kw">const</span> number = <span class="tok-builtin">@intFromError</span>(err) + <span class="tok-number">10</span>;
    <span class="tok-kw">const</span> invalid_err = <span class="tok-builtin">@errorFromInt</span>(number);
    _ = invalid_err;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_invalid_error_code.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_invalid_error_code.zig:4:39: </span><span class="sgr-31m">error: </span><span class="sgr-1m">integer value '11' represents no error
</span>    const invalid_err = @errorFromInt(number);
                                      <span class="sgr-32m">^~~~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_invalid_error_code.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> err = <span class="tok-kw">error</span>.AnError;
    <span class="tok-kw">var</span> number = <span class="tok-builtin">@intFromError</span>(err) + <span class="tok-number">500</span>;
    _ = &amp;number;
    <span class="tok-kw">const</span> invalid_err = <span class="tok-builtin">@errorFromInt</span>(number);
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{invalid_err});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_invalid_error_code.zig</kbd>
$ <kbd>./runtime_invalid_error_code</kbd>
thread 2900570 panic: invalid error code
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_invalid_error_code.zig:7:5</span>: <span class="sgr-2m">0x113e8a7 in main (runtime_invalid_error_code.zig)</span>
    const invalid_err = @errorFromInt(number);
    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      
      <h3 id="Invalid-Enum-Cast"><a href="https://ziglang.org/documentation/0.15.2/#toc-Invalid-Enum-Cast">Invalid Enum Cast</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Invalid-Enum-Cast">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_invalid_enum_cast.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Foo = <span class="tok-kw">enum</span> {
    a,
    b,
    c,
};
<span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">u2</span> = <span class="tok-number">3</span>;
    <span class="tok-kw">const</span> b: Foo = <span class="tok-builtin">@enumFromInt</span>(a);
    _ = b;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_invalid_enum_cast.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_invalid_enum_cast.zig:8:20: </span><span class="sgr-31m">error: </span><span class="sgr-1m">enum 'test_comptime_invalid_enum_cast.Foo' has no tag with value '3'
</span>    const b: Foo = @enumFromInt(a);
                   <span class="sgr-32m">^~~~~~~~~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_invalid_enum_cast.zig:1:13: </span><span class="sgr-36m">note: </span><span class="sgr-1m">enum declared here
</span>const Foo = enum {
            <span class="sgr-32m">^~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_invalid_enum_cast.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">const</span> Foo = <span class="tok-kw">enum</span> {
    a,
    b,
    c,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u2</span> = <span class="tok-number">3</span>;
    _ = &amp;a;
    <span class="tok-kw">const</span> b: Foo = <span class="tok-builtin">@enumFromInt</span>(a);
    std.debug.print(<span class="tok-str">"value: {s}\n"</span>, .{<span class="tok-builtin">@tagName</span>(b)});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_invalid_enum_cast.zig</kbd>
$ <kbd>./runtime_invalid_enum_cast</kbd>
thread 2902395 panic: invalid enum value
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_invalid_enum_cast.zig:12:20</span>: <span class="sgr-2m">0x113e8f0 in main (runtime_invalid_enum_cast.zig)</span>
    const b: Foo = @enumFromInt(a);
                   <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      

      <h3 id="Invalid-Error-Set-Cast"><a href="https://ziglang.org/documentation/0.15.2/#toc-Invalid-Error-Set-Cast">Invalid Error Set Cast</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Invalid-Error-Set-Cast">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_invalid_error_set_cast.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Set1 = <span class="tok-kw">error</span>{
    A,
    B,
};
<span class="tok-kw">const</span> Set2 = <span class="tok-kw">error</span>{
    A,
    C,
};
<span class="tok-kw">comptime</span> {
    _ = <span class="tok-builtin">@as</span>(Set2, <span class="tok-builtin">@errorCast</span>(Set1.B));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_invalid_error_set_cast.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_invalid_error_set_cast.zig:10:19: </span><span class="sgr-31m">error: </span><span class="sgr-1m">'error.B' not a member of error set 'error{A,C}'
</span>    _ = @as(Set2, @errorCast(Set1.B));
                  <span class="sgr-32m">^~~~~~~~~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_invalid_error_set_cast.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">const</span> Set1 = <span class="tok-kw">error</span>{
    A,
    B,
};
<span class="tok-kw">const</span> Set2 = <span class="tok-kw">error</span>{
    A,
    C,
};
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    foo(Set1.B);
}
<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(set1: Set1) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> x: Set2 = <span class="tok-builtin">@errorCast</span>(set1);
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{x});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_invalid_error_set_cast.zig</kbd>
$ <kbd>./runtime_invalid_error_set_cast</kbd>
thread 2900078 panic: invalid error code
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_invalid_error_set_cast.zig:15:21</span>: <span class="sgr-2m">0x113fb3c in foo (runtime_invalid_error_set_cast.zig)</span>
    const x: Set2 = @errorCast(set1);
                    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_invalid_error_set_cast.zig:12:8</span>: <span class="sgr-2m">0x113e877 in main (runtime_invalid_error_set_cast.zig)</span>
    foo(Set1.B);
       <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      

      <h3 id="Incorrect-Pointer-Alignment"><a href="https://ziglang.org/documentation/0.15.2/#toc-Incorrect-Pointer-Alignment">Incorrect Pointer Alignment</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Incorrect-Pointer-Alignment">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_incorrect_pointer_alignment.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> ptr: *<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-type">i32</span> = <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-number">0x1</span>);
    <span class="tok-kw">const</span> aligned: *<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">i32</span> = <span class="tok-builtin">@alignCast</span>(ptr);
    _ = aligned;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_incorrect_pointer_alignment.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_incorrect_pointer_alignment.zig:3:47: </span><span class="sgr-31m">error: </span><span class="sgr-1m">pointer address 0x1 is not aligned to 4 bytes
</span>    const aligned: *align(4) i32 = @alignCast(ptr);
                                              <span class="sgr-32m">^~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_incorrect_pointer_alignment.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).mem;
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> array <span class="tok-kw">align</span>(<span class="tok-number">4</span>) = [_]<span class="tok-type">u32</span>{ <span class="tok-number">0x11111111</span>, <span class="tok-number">0x11111111</span> };
    <span class="tok-kw">const</span> bytes = mem.sliceAsBytes(array[<span class="tok-number">0</span>..]);
    <span class="tok-kw">if</span> (foo(bytes) != <span class="tok-number">0x11111111</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Wrong;
}
<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(bytes: []<span class="tok-type">u8</span>) <span class="tok-type">u32</span> {
    <span class="tok-kw">const</span> slice4 = bytes[<span class="tok-number">1</span>..<span class="tok-number">5</span>];
    <span class="tok-kw">const</span> int_slice = mem.bytesAsSlice(<span class="tok-type">u32</span>, <span class="tok-builtin">@as</span>([]<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">u8</span>, <span class="tok-builtin">@alignCast</span>(slice4)));
    <span class="tok-kw">return</span> int_slice[<span class="tok-number">0</span>];
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_incorrect_pointer_alignment.zig</kbd>
$ <kbd>./runtime_incorrect_pointer_alignment</kbd>
thread 2897041 panic: incorrect alignment
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_incorrect_pointer_alignment.zig:9:64</span>: <span class="sgr-2m">0x113ec08 in foo (runtime_incorrect_pointer_alignment.zig)</span>
    const int_slice = mem.bytesAsSlice(u32, @as([]align(4) u8, @alignCast(slice4)));
                                                               <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_incorrect_pointer_alignment.zig:5:12</span>: <span class="sgr-2m">0x113d3f2 in main (runtime_incorrect_pointer_alignment.zig)</span>
    if (foo(bytes) != 0x11111111) return error.Wrong;
           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:627:37</span>: <span class="sgr-2m">0x113dbc9 in posixCallMainAndExit (std.zig)</span>
            const result = root.main() catch |err| {
                                    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      
      <h3 id="Wrong-Union-Field-Access"><a href="https://ziglang.org/documentation/0.15.2/#toc-Wrong-Union-Field-Access">Wrong Union Field Access</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Wrong-Union-Field-Access">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_wrong_union_field_access.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">var</span> f = Foo{ .int = <span class="tok-number">42</span> };
    f.float = <span class="tok-number">12.34</span>;
}

<span class="tok-kw">const</span> Foo = <span class="tok-kw">union</span> {
    float: <span class="tok-type">f32</span>,
    int: <span class="tok-type">u32</span>,
};</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_wrong_union_field_access.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_wrong_union_field_access.zig:3:6: </span><span class="sgr-31m">error: </span><span class="sgr-1m">access of union field 'float' while field 'int' is active
</span>    f.float = 12.34;
    <span class="sgr-32m">~^~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_wrong_union_field_access.zig:6:13: </span><span class="sgr-36m">note: </span><span class="sgr-1m">union declared here
</span>const Foo = union {
            <span class="sgr-32m">^~~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_wrong_union_field_access.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">const</span> Foo = <span class="tok-kw">union</span> {
    float: <span class="tok-type">f32</span>,
    int: <span class="tok-type">u32</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> f = Foo{ .int = <span class="tok-number">42</span> };
    bar(&amp;f);
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>(f: *Foo) <span class="tok-type">void</span> {
    f.float = <span class="tok-number">12.34</span>;
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{f.float});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_wrong_union_field_access.zig</kbd>
$ <kbd>./runtime_wrong_union_field_access</kbd>
thread 2901950 panic: access of union field 'float' while field 'int' is active
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_wrong_union_field_access.zig:14:6</span>: <span class="sgr-2m">0x113fb1e in bar (runtime_wrong_union_field_access.zig)</span>
    f.float = 12.34;
     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_wrong_union_field_access.zig:10:8</span>: <span class="sgr-2m">0x113e89f in main (runtime_wrong_union_field_access.zig)</span>
    bar(&amp;f);
       <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      <p>
      This safety is not available for <code><span class="tok-kw">extern</span></code> or <code><span class="tok-kw">packed</span></code> unions.
      </p>
      <p>
      To change the active field of a union, assign the entire union, like this:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">change_active_union_field.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">const</span> Foo = <span class="tok-kw">union</span> {
    float: <span class="tok-type">f32</span>,
    int: <span class="tok-type">u32</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> f = Foo{ .int = <span class="tok-number">42</span> };
    bar(&amp;f);
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>(f: *Foo) <span class="tok-type">void</span> {
    f.* = Foo{ .float = <span class="tok-number">12.34</span> };
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{f.float});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe change_active_union_field.zig</kbd>
$ <kbd>./change_active_union_field</kbd>
value: 12.34
</samp></pre></figure>

      <p>
      To change the active field of a union when a meaningful value for the field is not known,
      use <a href="https://ziglang.org/documentation/0.15.2/#undefined">undefined</a>, like this:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">undefined_active_union_field.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">const</span> Foo = <span class="tok-kw">union</span> {
    float: <span class="tok-type">f32</span>,
    int: <span class="tok-type">u32</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> f = Foo{ .int = <span class="tok-number">42</span> };
    f = Foo{ .float = <span class="tok-null">undefined</span> };
    bar(&amp;f);
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{f.float});
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>(f: *Foo) <span class="tok-type">void</span> {
    f.float = <span class="tok-number">12.34</span>;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe undefined_active_union_field.zig</kbd>
$ <kbd>./undefined_active_union_field</kbd>
value: 12.34
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#union">union</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#extern-union">extern union</a></li>
</ul>

      

      <h3 id="Out-of-Bounds-Float-to-Integer-Cast"><a href="https://ziglang.org/documentation/0.15.2/#toc-Out-of-Bounds-Float-to-Integer-Cast">Out of Bounds Float to Integer Cast</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Out-of-Bounds-Float-to-Integer-Cast">§</a></h3>

      <p>
      This happens when casting a float to an integer where the float has a value outside the
      integer type's range.
      </p>
      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_out_of_bounds_float_to_integer_cast.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> float: <span class="tok-type">f32</span> = <span class="tok-number">4294967296</span>;
    <span class="tok-kw">const</span> int: <span class="tok-type">i32</span> = <span class="tok-builtin">@intFromFloat</span>(float);
    _ = int;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_out_of_bounds_float_to_integer_cast.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_out_of_bounds_float_to_integer_cast.zig:3:36: </span><span class="sgr-31m">error: </span><span class="sgr-1m">float value '4294967296' cannot be stored in integer type 'i32'
</span>    const int: i32 = @intFromFloat(float);
                                   <span class="sgr-32m">^~~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_out_of_bounds_float_to_integer_cast.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> float: <span class="tok-type">f32</span> = <span class="tok-number">4294967296</span>; <span class="tok-comment">// runtime-known</span>
    _ = &amp;float;
    <span class="tok-kw">const</span> int: <span class="tok-type">i32</span> = <span class="tok-builtin">@intFromFloat</span>(float);
    _ = int;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_out_of_bounds_float_to_integer_cast.zig</kbd>
$ <kbd>./runtime_out_of_bounds_float_to_integer_cast</kbd>
thread 2898584 panic: integer part of floating point value out of bounds
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_out_of_bounds_float_to_integer_cast.zig:4:22</span>: <span class="sgr-2m">0x113e8d2 in main (runtime_out_of_bounds_float_to_integer_cast.zig)</span>
    const int: i32 = @intFromFloat(float);
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>
