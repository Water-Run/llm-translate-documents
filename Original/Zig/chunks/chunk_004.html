      <figure><figcaption class="zig-cap"><cite class="file">test_pointer_arithmetic.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"pointer arithmetic with many-item pointer"</span> {
    <span class="tok-kw">const</span> array = [_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };
    <span class="tok-kw">var</span> ptr: [*]<span class="tok-kw">const</span> <span class="tok-type">i32</span> = &amp;array;

    <span class="tok-kw">try</span> expect(ptr[<span class="tok-number">0</span>] == <span class="tok-number">1</span>);
    ptr += <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> expect(ptr[<span class="tok-number">0</span>] == <span class="tok-number">2</span>);

    <span class="tok-comment">// slicing a many-item pointer without an end is equivalent to</span>
    <span class="tok-comment">// pointer arithmetic: `ptr[start..] == ptr + start`</span>
    <span class="tok-kw">try</span> expect(ptr[<span class="tok-number">1</span>..] == ptr + <span class="tok-number">1</span>);

    <span class="tok-comment">// subtraction between any two pointers except slices based on element size is supported</span>
    <span class="tok-kw">try</span> expect(&amp;ptr[<span class="tok-number">1</span>] - &amp;ptr[<span class="tok-number">0</span>] == <span class="tok-number">1</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"pointer arithmetic with slices"</span> {
    <span class="tok-kw">var</span> array = [_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };
    <span class="tok-kw">var</span> length: <span class="tok-type">usize</span> = <span class="tok-number">0</span>; <span class="tok-comment">// var to make it runtime-known</span>
    _ = &amp;length; <span class="tok-comment">// suppress 'var is never mutated' error</span>
    <span class="tok-kw">var</span> slice = array[length..array.len];

    <span class="tok-kw">try</span> expect(slice[<span class="tok-number">0</span>] == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> expect(slice.len == <span class="tok-number">4</span>);

    slice.ptr += <span class="tok-number">1</span>;
    <span class="tok-comment">// now the slice is in an bad state since len has not been updated</span>

    <span class="tok-kw">try</span> expect(slice[<span class="tok-number">0</span>] == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> expect(slice.len == <span class="tok-number">4</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_pointer_arithmetic.zig</kbd>
1/2 test_pointer_arithmetic.test.pointer arithmetic with many-item pointer...OK
2/2 test_pointer_arithmetic.test.pointer arithmetic with slices...OK
All 2 tests passed.
</samp></pre></figure>

      <p>
        In Zig, we generally prefer <a href="https://ziglang.org/documentation/0.15.2/#Slices">Slices</a> rather than <a href="https://ziglang.org/documentation/0.15.2/#Sentinel-Terminated-Pointers">Sentinel-Terminated Pointers</a>.
        You can turn an array or pointer into a slice using slice syntax.
      </p>
      <p>
        Slices have bounds checking and are therefore protected
        against this kind of Illegal Behavior. This is one reason
        we prefer slices to pointers.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_slice_bounds.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"pointer slicing"</span> {
    <span class="tok-kw">var</span> array = [_]<span class="tok-type">u8</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span>, <span class="tok-number">9</span>, <span class="tok-number">10</span> };
    <span class="tok-kw">var</span> start: <span class="tok-type">usize</span> = <span class="tok-number">2</span>; <span class="tok-comment">// var to make it runtime-known</span>
    _ = &amp;start; <span class="tok-comment">// suppress 'var is never mutated' error</span>
    <span class="tok-kw">const</span> slice = array[start..<span class="tok-number">4</span>];
    <span class="tok-kw">try</span> expect(slice.len == <span class="tok-number">2</span>);

    <span class="tok-kw">try</span> expect(array[<span class="tok-number">3</span>] == <span class="tok-number">4</span>);
    slice[<span class="tok-number">1</span>] += <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> expect(array[<span class="tok-number">3</span>] == <span class="tok-number">5</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_slice_bounds.zig</kbd>
1/1 test_slice_bounds.test.pointer slicing...OK
All 1 tests passed.
</samp></pre></figure>

      <p>Pointers work at compile-time too, as long as the code does not depend on
      an undefined memory layout:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_pointers.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"comptime pointers"</span> {
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
        <span class="tok-kw">const</span> ptr = &amp;x;
        ptr.* += <span class="tok-number">1</span>;
        x += <span class="tok-number">1</span>;
        <span class="tok-kw">try</span> expect(ptr.* == <span class="tok-number">3</span>);
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_pointers.zig</kbd>
1/1 test_comptime_pointers.test.comptime pointers...OK
All 1 tests passed.
</samp></pre></figure>

      <p>To convert an integer address into a pointer, use <code><span class="tok-builtin">@ptrFromInt</span></code>.
      To convert a pointer to an integer, use <code><span class="tok-builtin">@intFromPtr</span></code>:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_integer_pointer_conversion.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"@intFromPtr and @ptrFromInt"</span> {
    <span class="tok-kw">const</span> ptr: *<span class="tok-type">i32</span> = <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-number">0xdeadbee0</span>);
    <span class="tok-kw">const</span> addr = <span class="tok-builtin">@intFromPtr</span>(ptr);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(addr) == <span class="tok-type">usize</span>);
    <span class="tok-kw">try</span> expect(addr == <span class="tok-number">0xdeadbee0</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_integer_pointer_conversion.zig</kbd>
1/1 test_integer_pointer_conversion.test.@intFromPtr and @ptrFromInt...OK
All 1 tests passed.
</samp></pre></figure>

      <p>Zig is able to preserve memory addresses in comptime code, as long as
      the pointer is never dereferenced:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_pointer_conversion.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"comptime @ptrFromInt"</span> {
    <span class="tok-kw">comptime</span> {
        <span class="tok-comment">// Zig is able to do this at compile-time, as long as</span>
        <span class="tok-comment">// ptr is never dereferenced.</span>
        <span class="tok-kw">const</span> ptr: *<span class="tok-type">i32</span> = <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-number">0xdeadbee0</span>);
        <span class="tok-kw">const</span> addr = <span class="tok-builtin">@intFromPtr</span>(ptr);
        <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(addr) == <span class="tok-type">usize</span>);
        <span class="tok-kw">try</span> expect(addr == <span class="tok-number">0xdeadbee0</span>);
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_pointer_conversion.zig</kbd>
1/1 test_comptime_pointer_conversion.test.comptime @ptrFromInt...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      <a href="https://ziglang.org/documentation/0.15.2/#ptrCast">@ptrCast</a> converts a pointer's element type to another. This
      creates a new pointer that can cause undetectable Illegal Behavior
      depending on the loads and stores that pass through it. Generally, other
      kinds of type conversions are preferable to
      <code><span class="tok-builtin">@ptrCast</span></code> if possible.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_pointer_casting.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"pointer casting"</span> {
    <span class="tok-kw">const</span> bytes <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<span class="tok-type">u32</span>)) = [_]<span class="tok-type">u8</span>{ <span class="tok-number">0x12</span>, <span class="tok-number">0x12</span>, <span class="tok-number">0x12</span>, <span class="tok-number">0x12</span> };
    <span class="tok-kw">const</span> u32_ptr: *<span class="tok-kw">const</span> <span class="tok-type">u32</span> = <span class="tok-builtin">@ptrCast</span>(&amp;bytes);
    <span class="tok-kw">try</span> expect(u32_ptr.* == <span class="tok-number">0x12121212</span>);

    <span class="tok-comment">// Even this example is contrived - there are better ways to do the above than</span>
    <span class="tok-comment">// pointer casting. For example, using a slice narrowing cast:</span>
    <span class="tok-kw">const</span> u32_value = std.mem.bytesAsSlice(<span class="tok-type">u32</span>, bytes[<span class="tok-number">0</span>..])[<span class="tok-number">0</span>];
    <span class="tok-kw">try</span> expect(u32_value == <span class="tok-number">0x12121212</span>);

    <span class="tok-comment">// And even another way, the most straightforward way to do it:</span>
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@bitCast</span>(bytes)) == <span class="tok-number">0x12121212</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"pointer child type"</span> {
    <span class="tok-comment">// pointer types have a `child` field which tells you the type they point to.</span>
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@typeInfo</span>(*<span class="tok-type">u32</span>).pointer.child == <span class="tok-type">u32</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_pointer_casting.zig</kbd>
1/2 test_pointer_casting.test.pointer casting...OK
2/2 test_pointer_casting.test.pointer child type...OK
All 2 tests passed.
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Optional-Pointers">Optional Pointers</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#ptrFromInt">@ptrFromInt</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#intFromPtr">@intFromPtr</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#C-Pointers">C Pointers</a></li>
</ul>

      <h3 id="volatile"><a href="https://ziglang.org/documentation/0.15.2/#toc-volatile">volatile</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#volatile">§</a></h3>

      <p>Loads and stores are assumed to not have side effects. If a given load or store
      should have side effects, such as Memory Mapped Input/Output (MMIO), use <code><span class="tok-kw">volatile</span></code>.
      In the following code, loads and stores with <code>mmio_ptr</code> are guaranteed to all happen
      and in the same order as in source code:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_volatile.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"volatile"</span> {
    <span class="tok-kw">const</span> mmio_ptr: *<span class="tok-kw">volatile</span> <span class="tok-type">u8</span> = <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-number">0x12345678</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(mmio_ptr) == *<span class="tok-kw">volatile</span> <span class="tok-type">u8</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_volatile.zig</kbd>
1/1 test_volatile.test.volatile...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      Note that <code><span class="tok-kw">volatile</span></code> is unrelated to concurrency and <a href="https://ziglang.org/documentation/0.15.2/#Atomics">Atomics</a>.
      If you see code that is using <code><span class="tok-kw">volatile</span></code> for something other than Memory Mapped
      Input/Output, it is probably a bug.
      </p>
      

      <h3 id="Alignment"><a href="https://ziglang.org/documentation/0.15.2/#toc-Alignment">Alignment</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Alignment">§</a></h3>

      <p>
      Each type has an <strong>alignment</strong> - a number of bytes such that,
      when a value of the type is loaded from or stored to memory,
      the memory address must be evenly divisible by this number. You can use
      <a href="https://ziglang.org/documentation/0.15.2/#alignOf">@alignOf</a> to find out this value for any type.
      </p>
      <p>
      Alignment depends on the CPU architecture, but is always a power of two, and
      less than <code><span class="tok-number">1</span> &lt;&lt; <span class="tok-number">29</span></code>.
      </p>
      <p>
      In Zig, a pointer type has an alignment value. If the value is equal to the
      alignment of the underlying type, it can be omitted from the type:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_variable_alignment.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">"builtin"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"variable alignment"</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    <span class="tok-kw">const</span> align_of_i32 = <span class="tok-builtin">@alignOf</span>(<span class="tok-builtin">@TypeOf</span>(x));
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(&amp;x) == *<span class="tok-type">i32</span>);
    <span class="tok-kw">try</span> expect(*<span class="tok-type">i32</span> == *<span class="tok-kw">align</span>(align_of_i32) <span class="tok-type">i32</span>);
    <span class="tok-kw">if</span> (builtin.target.cpu.arch == .x86_64) {
        <span class="tok-kw">try</span> expect(<span class="tok-builtin">@typeInfo</span>(*<span class="tok-type">i32</span>).pointer.alignment == <span class="tok-number">4</span>);
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_variable_alignment.zig</kbd>
1/1 test_variable_alignment.test.variable alignment...OK
All 1 tests passed.
</samp></pre></figure>

      <p>In the same way that a <code>*<span class="tok-type">i32</span></code> can be <a href="https://ziglang.org/documentation/0.15.2/#Type-Coercion">coerced</a> to a
          <code>*<span class="tok-kw">const</span> <span class="tok-type">i32</span></code>, a pointer with a larger alignment can be implicitly
      cast to a pointer with a smaller alignment, but not vice versa.
      </p>
      <p>
      You can specify alignment on variables and functions. If you do this, then
      pointers to them get the specified alignment:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_variable_func_alignment.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">var</span> foo: <span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-number">4</span>) = <span class="tok-number">100</span>;

<span class="tok-kw">test</span> <span class="tok-str">"global variable alignment"</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(&amp;foo)).pointer.alignment == <span class="tok-number">4</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(&amp;foo) == *<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">u8</span>);
    <span class="tok-kw">const</span> as_pointer_to_array: *<span class="tok-kw">align</span>(<span class="tok-number">4</span>) [<span class="tok-number">1</span>]<span class="tok-type">u8</span> = &amp;foo;
    <span class="tok-kw">const</span> as_slice: []<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">u8</span> = as_pointer_to_array;
    <span class="tok-kw">const</span> as_unaligned_slice: []<span class="tok-type">u8</span> = as_slice;
    <span class="tok-kw">try</span> expect(as_unaligned_slice[<span class="tok-number">0</span>] == <span class="tok-number">100</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">derp</span>() <span class="tok-kw">align</span>(<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) * <span class="tok-number">2</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> <span class="tok-number">1234</span>;
}
<span class="tok-kw">fn</span> <span class="tok-fn">noop1</span>() <span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-type">void</span> {}
<span class="tok-kw">fn</span> <span class="tok-fn">noop4</span>() <span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">void</span> {}

<span class="tok-kw">test</span> <span class="tok-str">"function alignment"</span> {
    <span class="tok-kw">try</span> expect(derp() == <span class="tok-number">1234</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(derp) == <span class="tok-kw">fn</span> () <span class="tok-type">i32</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(&amp;derp) == *<span class="tok-kw">align</span>(<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) * <span class="tok-number">2</span>) <span class="tok-kw">const</span> <span class="tok-kw">fn</span> () <span class="tok-type">i32</span>);

    noop1();
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(noop1) == <span class="tok-kw">fn</span> () <span class="tok-type">void</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(&amp;noop1) == *<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> <span class="tok-kw">fn</span> () <span class="tok-type">void</span>);

    noop4();
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(noop4) == <span class="tok-kw">fn</span> () <span class="tok-type">void</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(&amp;noop4) == *<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-kw">const</span> <span class="tok-kw">fn</span> () <span class="tok-type">void</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_variable_func_alignment.zig</kbd>
1/2 test_variable_func_alignment.test.global variable alignment...OK
2/2 test_variable_func_alignment.test.function alignment...OK
All 2 tests passed.
</samp></pre></figure>

      <p>
      If you have a pointer or a slice that has a small alignment, but you know that it actually
      has a bigger alignment, use <a href="https://ziglang.org/documentation/0.15.2/#alignCast">@alignCast</a> to change the
      pointer into a more aligned pointer. This is a no-op at runtime, but inserts a
      <a href="https://ziglang.org/documentation/0.15.2/#Incorrect-Pointer-Alignment">safety check</a>:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_incorrect_pointer_alignment.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">test</span> <span class="tok-str">"pointer alignment safety"</span> {
    <span class="tok-kw">var</span> array <span class="tok-kw">align</span>(<span class="tok-number">4</span>) = [_]<span class="tok-type">u32</span>{ <span class="tok-number">0x11111111</span>, <span class="tok-number">0x11111111</span> };
    <span class="tok-kw">const</span> bytes = std.mem.sliceAsBytes(array[<span class="tok-number">0</span>..]);
    <span class="tok-kw">try</span> std.testing.expect(foo(bytes) == <span class="tok-number">0x11111111</span>);
}
<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(bytes: []<span class="tok-type">u8</span>) <span class="tok-type">u32</span> {
    <span class="tok-kw">const</span> slice4 = bytes[<span class="tok-number">1</span>..<span class="tok-number">5</span>];
    <span class="tok-kw">const</span> int_slice = std.mem.bytesAsSlice(<span class="tok-type">u32</span>, <span class="tok-builtin">@as</span>([]<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">u8</span>, <span class="tok-builtin">@alignCast</span>(slice4)));
    <span class="tok-kw">return</span> int_slice[<span class="tok-number">0</span>];
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_incorrect_pointer_alignment.zig</kbd>
1/1 test_incorrect_pointer_alignment.test.pointer alignment safety...thread 2895819 panic: incorrect alignment
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_incorrect_pointer_alignment.zig:10:68</span>: <span class="sgr-2m">0x102c2a8 in foo (test_incorrect_pointer_alignment.zig)</span>
    const int_slice = std.mem.bytesAsSlice(u32, @as([]align(4) u8, @alignCast(slice4)));
                                                                   <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_incorrect_pointer_alignment.zig:6:31</span>: <span class="sgr-2m">0x102c0d2 in test.pointer alignment safety (test_incorrect_pointer_alignment.zig)</span>
    try std.testing.expect(foo(bytes) == 0x11111111);
                              <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:218:25</span>: <span class="sgr-2m">0x115cf30 in mainTerminal (test_runner.zig)</span>
        if (test_fn.func()) |_| {
                        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:66:28</span>: <span class="sgr-2m">0x1156151 in main (test_runner.zig)</span>
        return mainTerminal();
                           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x114feed in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x114f781 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
error: the following test command crashed:
/home/andy/dev/zig/.zig-cache/o/9cb7896b3cdf812f518129da5e21dc23/test --seed=0x441e5edd
</samp></pre></figure>

      

      <h3 id="allowzero"><a href="https://ziglang.org/documentation/0.15.2/#toc-allowzero">allowzero</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#allowzero">§</a></h3>

      <p>
      This pointer attribute allows a pointer to have address zero. This is only ever needed on the
      freestanding OS target, where the address zero is mappable. If you want to represent null pointers, use
      <a href="https://ziglang.org/documentation/0.15.2/#Optional-Pointers">Optional Pointers</a> instead. <a href="https://ziglang.org/documentation/0.15.2/#Optional-Pointers">Optional Pointers</a> with <code><span class="tok-kw">allowzero</span></code>
      are not the same size as pointers. In this code example, if the pointer
      did not have the <code><span class="tok-kw">allowzero</span></code> attribute, this would be a
      <a href="https://ziglang.org/documentation/0.15.2/#Pointer-Cast-Invalid-Null">Pointer Cast Invalid Null</a> panic:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_allowzero.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"allowzero"</span> {
    <span class="tok-kw">var</span> zero: <span class="tok-type">usize</span> = <span class="tok-number">0</span>; <span class="tok-comment">// var to make to runtime-known</span>
    _ = &amp;zero; <span class="tok-comment">// suppress 'var is never mutated' error</span>
    <span class="tok-kw">const</span> ptr: *<span class="tok-kw">allowzero</span> <span class="tok-type">i32</span> = <span class="tok-builtin">@ptrFromInt</span>(zero);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromPtr</span>(ptr) == <span class="tok-number">0</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_allowzero.zig</kbd>
1/1 test_allowzero.test.allowzero...OK
All 1 tests passed.
</samp></pre></figure>

      

      <h3 id="Sentinel-Terminated-Pointers"><a href="https://ziglang.org/documentation/0.15.2/#toc-Sentinel-Terminated-Pointers">Sentinel-Terminated Pointers</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Sentinel-Terminated-Pointers">§</a></h3>

      <p>
      The syntax <code>[*:x]T</code> describes a pointer that
      has a length determined by a sentinel value. This provides protection
      against buffer overflow and overreads.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">sentinel-terminated_pointer.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-comment">// This is also available as `std.c.printf`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">extern</span> <span class="tok-str">"c"</span> <span class="tok-kw">fn</span> <span class="tok-fn">printf</span>(format: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ...) <span class="tok-type">c_int</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {
    _ = printf(<span class="tok-str">"Hello, world!\n"</span>); <span class="tok-comment">// OK</span>

    <span class="tok-kw">const</span> msg = <span class="tok-str">"Hello, world!\n"</span>;
    <span class="tok-kw">const</span> non_null_terminated_msg: [msg.len]<span class="tok-type">u8</span> = msg.*;
    _ = printf(&amp;non_null_terminated_msg);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe sentinel-terminated_pointer.zig -lc</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/sentinel-terminated_pointer.zig:11:16: </span><span class="sgr-31m">error: </span><span class="sgr-1m">expected type '[*:0]const u8', found '*const [14]u8'
</span>    _ = printf(&amp;non_null_terminated_msg);
               <span class="sgr-32m">^~~~~~~~~~~~~~~~~~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/sentinel-terminated_pointer.zig:11:16: </span><span class="sgr-36m">note: </span><span class="sgr-1m">destination pointer requires '0' sentinel
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/sentinel-terminated_pointer.zig:4:34: </span><span class="sgr-36m">note: </span><span class="sgr-1m">parameter type declared here
</span>pub extern "c" fn printf(format: [*:0]const u8, ...) c_int;
                                 <span class="sgr-32m">^~~~~~~~~~~~~
</span><span class="sgr-2m">referenced by:
    callMain [inlined]: /home/andy/dev/zig/lib/std/start.zig:627:37
    callMainWithArgs [inlined]: /home/andy/dev/zig/lib/std/start.zig:587:20
    main: /home/andy/dev/zig/lib/std/start.zig:602:28
    1 reference(s) hidden; use '-freference-trace=4' to see all references
</span>
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Sentinel-Terminated-Slices">Sentinel-Terminated Slices</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Sentinel-Terminated-Arrays">Sentinel-Terminated Arrays</a></li>
</ul>

      
      

      <h2 id="Slices"><a href="https://ziglang.org/documentation/0.15.2/#toc-Slices">Slices</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Slices">§</a></h2>

      <p>
      A slice is a pointer and a length. The difference between an array and
      a slice is that the array's length is part of the type and known at
      compile-time, whereas the slice's length is known at runtime.
      Both can be accessed with the <code>len</code> field.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_basic_slices.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;
<span class="tok-kw">const</span> expectEqualSlices = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expectEqualSlices;

<span class="tok-kw">test</span> <span class="tok-str">"basic slices"</span> {
    <span class="tok-kw">var</span> array = [_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };
    <span class="tok-kw">var</span> known_at_runtime_zero: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    _ = &amp;known_at_runtime_zero;
    <span class="tok-kw">const</span> slice = array[known_at_runtime_zero..array.len];

    <span class="tok-comment">// alternative initialization using result location</span>
    <span class="tok-kw">const</span> alt_slice: []<span class="tok-kw">const</span> <span class="tok-type">i32</span> = &amp;.{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };

    <span class="tok-kw">try</span> expectEqualSlices(<span class="tok-type">i32</span>, slice, alt_slice);

    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(slice) == []<span class="tok-type">i32</span>);
    <span class="tok-kw">try</span> expect(&amp;slice[<span class="tok-number">0</span>] == &amp;array[<span class="tok-number">0</span>]);
    <span class="tok-kw">try</span> expect(slice.len == array.len);

    <span class="tok-comment">// If you slice with comptime-known start and end positions, the result is</span>
    <span class="tok-comment">// a pointer to an array, rather than a slice.</span>
    <span class="tok-kw">const</span> array_ptr = array[<span class="tok-number">0</span>..array.len];
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(array_ptr) == *[array.len]<span class="tok-type">i32</span>);

    <span class="tok-comment">// You can perform a slice-by-length by slicing twice. This allows the compiler</span>
    <span class="tok-comment">// to perform some optimisations like recognising a comptime-known length when</span>
    <span class="tok-comment">// the start position is only known at runtime.</span>
    <span class="tok-kw">var</span> runtime_start: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;
    _ = &amp;runtime_start;
    <span class="tok-kw">const</span> length = <span class="tok-number">2</span>;
    <span class="tok-kw">const</span> array_ptr_len = array[runtime_start..][<span class="tok-number">0</span>..length];
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(array_ptr_len) == *[length]<span class="tok-type">i32</span>);

    <span class="tok-comment">// Using the address-of operator on a slice gives a single-item pointer.</span>
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(&amp;slice[<span class="tok-number">0</span>]) == *<span class="tok-type">i32</span>);
    <span class="tok-comment">// Using the `ptr` field gives a many-item pointer.</span>
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(slice.ptr) == [*]<span class="tok-type">i32</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromPtr</span>(slice.ptr) == <span class="tok-builtin">@intFromPtr</span>(&amp;slice[<span class="tok-number">0</span>]));

    <span class="tok-comment">// Slices have array bounds checking. If you try to access something out</span>
    <span class="tok-comment">// of bounds, you'll get a safety check failure:</span>
    slice[<span class="tok-number">10</span>] += <span class="tok-number">1</span>;

    <span class="tok-comment">// Note that `slice.ptr` does not invoke safety checking, while `&amp;slice[0]`</span>
    <span class="tok-comment">// asserts that the slice has len &gt; 0.</span>

    <span class="tok-comment">// Empty slices can be created like this:</span>
    <span class="tok-kw">const</span> empty1 = &amp;[<span class="tok-number">0</span>]<span class="tok-type">u8</span>{};
    <span class="tok-comment">// If the type is known you can use this short hand:</span>
    <span class="tok-kw">const</span> empty2: []<span class="tok-type">u8</span> = &amp;.{};
    <span class="tok-kw">try</span> expect(empty1.len == <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> expect(empty2.len == <span class="tok-number">0</span>);

    <span class="tok-comment">// A zero-length initialization can always be used to create an empty slice, even if the slice is mutable.</span>
    <span class="tok-comment">// This is because the pointed-to data is zero bits long, so its immutability is irrelevant.</span>
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_basic_slices.zig</kbd>
1/1 test_basic_slices.test.basic slices...thread 2902466 panic: index out of bounds: index 10, len 4
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_basic_slices.zig:41:10</span>: <span class="sgr-2m">0x102e3c0 in test.basic slices (test_basic_slices.zig)</span>
    slice[10] += 1;
         <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:218:25</span>: <span class="sgr-2m">0x1160b60 in mainTerminal (test_runner.zig)</span>
        if (test_fn.func()) |_| {
                        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:66:28</span>: <span class="sgr-2m">0x1159d81 in main (test_runner.zig)</span>
        return mainTerminal();
                           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x1153b1d in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x11533b1 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
error: the following test command crashed:
/home/andy/dev/zig/.zig-cache/o/0e584e3dac6333a0b2d5158992704660/test --seed=0x665d12a2
</samp></pre></figure>

      <p>This is one reason we prefer slices to pointers.</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_slices.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;
<span class="tok-kw">const</span> mem = std.mem;
<span class="tok-kw">const</span> fmt = std.fmt;

<span class="tok-kw">test</span> <span class="tok-str">"using slices for strings"</span> {
    <span class="tok-comment">// Zig has no concept of strings. String literals are const pointers</span>
    <span class="tok-comment">// to null-terminated arrays of u8, and by convention parameters</span>
    <span class="tok-comment">// that are "strings" are expected to be UTF-8 encoded slices of u8.</span>
    <span class="tok-comment">// Here we coerce *const [5:0]u8 and *const [6:0]u8 to []const u8</span>
    <span class="tok-kw">const</span> hello: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">"hello"</span>;
    <span class="tok-kw">const</span> world: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">"世界"</span>;

    <span class="tok-kw">var</span> all_together: [<span class="tok-number">100</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-comment">// You can use slice syntax with at least one runtime-known index on an</span>
    <span class="tok-comment">// array to convert an array into a slice.</span>
    <span class="tok-kw">var</span> start: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    _ = &amp;start;
    <span class="tok-kw">const</span> all_together_slice = all_together[start..];
    <span class="tok-comment">// String concatenation example.</span>
    <span class="tok-kw">const</span> hello_world = <span class="tok-kw">try</span> fmt.bufPrint(all_together_slice, <span class="tok-str">"{s} {s}"</span>, .{ hello, world });

    <span class="tok-comment">// Generally, you can use UTF-8 and not worry about whether something is a</span>
    <span class="tok-comment">// string. If you don't need to deal with individual characters, no need</span>
    <span class="tok-comment">// to decode.</span>
    <span class="tok-kw">try</span> expect(mem.eql(<span class="tok-type">u8</span>, hello_world, <span class="tok-str">"hello 世界"</span>));
}

<span class="tok-kw">test</span> <span class="tok-str">"slice pointer"</span> {
    <span class="tok-kw">var</span> array: [<span class="tok-number">10</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> ptr = &amp;array;
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(ptr) == *[<span class="tok-number">10</span>]<span class="tok-type">u8</span>);

    <span class="tok-comment">// A pointer to an array can be sliced just like an array:</span>
    <span class="tok-kw">var</span> start: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> end: <span class="tok-type">usize</span> = <span class="tok-number">5</span>;
    _ = .{ &amp;start, &amp;end };
    <span class="tok-kw">const</span> slice = ptr[start..end];
    <span class="tok-comment">// The slice is mutable because we sliced a mutable pointer.</span>
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(slice) == []<span class="tok-type">u8</span>);
    slice[<span class="tok-number">2</span>] = <span class="tok-number">3</span>;
    <span class="tok-kw">try</span> expect(array[<span class="tok-number">2</span>] == <span class="tok-number">3</span>);

    <span class="tok-comment">// Again, slicing with comptime-known indexes will produce another pointer</span>
    <span class="tok-comment">// to an array:</span>
    <span class="tok-kw">const</span> ptr2 = slice[<span class="tok-number">2</span>..<span class="tok-number">3</span>];
    <span class="tok-kw">try</span> expect(ptr2.len == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> expect(ptr2[<span class="tok-number">0</span>] == <span class="tok-number">3</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(ptr2) == *[<span class="tok-number">1</span>]<span class="tok-type">u8</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_slices.zig</kbd>
1/2 test_slices.test.using slices for strings...OK
2/2 test_slices.test.slice pointer...OK
All 2 tests passed.
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Pointers">Pointers</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#for">for</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Arrays">Arrays</a></li>
</ul>


      <h3 id="Sentinel-Terminated-Slices"><a href="https://ziglang.org/documentation/0.15.2/#toc-Sentinel-Terminated-Slices">Sentinel-Terminated Slices</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Sentinel-Terminated-Slices">§</a></h3>

      <p>
      The syntax <code>[:x]T</code> is a slice which has a runtime-known length
      and also guarantees a sentinel value at the element indexed by the length. The type does not
      guarantee that there are no sentinel elements before that. Sentinel-terminated slices allow element
      access to the <code>len</code> index.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_null_terminated_slice.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"0-terminated slice"</span> {
    <span class="tok-kw">const</span> slice: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">"hello"</span>;

    <span class="tok-kw">try</span> expect(slice.len == <span class="tok-number">5</span>);
    <span class="tok-kw">try</span> expect(slice[<span class="tok-number">5</span>] == <span class="tok-number">0</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_null_terminated_slice.zig</kbd>
1/1 test_null_terminated_slice.test.0-terminated slice...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      Sentinel-terminated slices can also be created using a variation of the slice syntax
      <code>data[start..end :x]</code>, where <code>data</code> is a many-item pointer,
      array or slice and <code>x</code> is the sentinel value.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_null_terminated_slicing.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"0-terminated slicing"</span> {
    <span class="tok-kw">var</span> array = [_]<span class="tok-type">u8</span>{ <span class="tok-number">3</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span>, <span class="tok-number">3</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span> };
    <span class="tok-kw">var</span> runtime_length: <span class="tok-type">usize</span> = <span class="tok-number">3</span>;
    _ = &amp;runtime_length;
    <span class="tok-kw">const</span> slice = array[<span class="tok-number">0</span>..runtime_length :<span class="tok-number">0</span>];

    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(slice) == [:<span class="tok-number">0</span>]<span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> expect(slice.len == <span class="tok-number">3</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_null_terminated_slicing.zig</kbd>
1/1 test_null_terminated_slicing.test.0-terminated slicing...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      Sentinel-terminated slicing asserts that the element in the sentinel position of the backing data is
      actually the sentinel value. If this is not the case, safety-checked <a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">Illegal Behavior</a> results.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_sentinel_mismatch.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"sentinel mismatch"</span> {
    <span class="tok-kw">var</span> array = [_]<span class="tok-type">u8</span>{ <span class="tok-number">3</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span> };

    <span class="tok-comment">// Creating a sentinel-terminated slice from the array with a length of 2</span>
    <span class="tok-comment">// will result in the value `1` occupying the sentinel element position.</span>
    <span class="tok-comment">// This does not match the indicated sentinel value of `0` and will lead</span>
    <span class="tok-comment">// to a runtime panic.</span>
    <span class="tok-kw">var</span> runtime_length: <span class="tok-type">usize</span> = <span class="tok-number">2</span>;
    _ = &amp;runtime_length;
    <span class="tok-kw">const</span> slice = array[<span class="tok-number">0</span>..runtime_length :<span class="tok-number">0</span>];

    _ = slice;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_sentinel_mismatch.zig</kbd>
1/1 test_sentinel_mismatch.test.sentinel mismatch...thread 2902472 panic: sentinel mismatch: expected 0, found 1
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_sentinel_mismatch.zig:13:24</span>: <span class="sgr-2m">0x102c117 in test.sentinel mismatch (test_sentinel_mismatch.zig)</span>
    const slice = array[0..runtime_length :0];
                       <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:218:25</span>: <span class="sgr-2m">0x115cc90 in mainTerminal (test_runner.zig)</span>
        if (test_fn.func()) |_| {
                        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:66:28</span>: <span class="sgr-2m">0x1155eb1 in main (test_runner.zig)</span>
        return mainTerminal();
                           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x114fc4d in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x114f4e1 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
error: the following test command crashed:
/home/andy/dev/zig/.zig-cache/o/12c6cfa0971ea7c724c8448a09f20f6b/test --seed=0xb506c876
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Sentinel-Terminated-Pointers">Sentinel-Terminated Pointers</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Sentinel-Terminated-Arrays">Sentinel-Terminated Arrays</a></li>
</ul>

      
      

      <h2 id="struct"><a href="https://ziglang.org/documentation/0.15.2/#toc-struct">struct</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#struct">§</a></h2>

      <figure><figcaption class="zig-cap"><cite class="file">test_structs.zig</cite></figcaption><pre><code><span class="tok-comment">// Declare a struct.</span>
<span class="tok-comment">// Zig gives no guarantees about the order of fields and the size of</span>
<span class="tok-comment">// the struct but the fields are guaranteed to be ABI-aligned.</span>
<span class="tok-kw">const</span> Point = <span class="tok-kw">struct</span> {
    x: <span class="tok-type">f32</span>,
    y: <span class="tok-type">f32</span>,
};

<span class="tok-comment">// Declare an instance of a struct.</span>
<span class="tok-kw">const</span> p: Point = .{
    .x = <span class="tok-number">0.12</span>,
    .y = <span class="tok-number">0.34</span>,
};

<span class="tok-comment">// Functions in the struct's namespace can be called with dot syntax.</span>
<span class="tok-kw">const</span> Vec3 = <span class="tok-kw">struct</span> {
    x: <span class="tok-type">f32</span>,
    y: <span class="tok-type">f32</span>,
    z: <span class="tok-type">f32</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(x: <span class="tok-type">f32</span>, y: <span class="tok-type">f32</span>, z: <span class="tok-type">f32</span>) Vec3 {
        <span class="tok-kw">return</span> Vec3{
            .x = x,
            .y = y,
            .z = z,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dot</span>(self: Vec3, other: Vec3) <span class="tok-type">f32</span> {
        <span class="tok-kw">return</span> self.x * other.x + self.y * other.y + self.z * other.z;
    }
};

<span class="tok-kw">test</span> <span class="tok-str">"dot product"</span> {
    <span class="tok-kw">const</span> v1 = Vec3.init(<span class="tok-number">1.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">0.0</span>);
    <span class="tok-kw">const</span> v2 = Vec3.init(<span class="tok-number">0.0</span>, <span class="tok-number">1.0</span>, <span class="tok-number">0.0</span>);
    <span class="tok-kw">try</span> expect(v1.dot(v2) == <span class="tok-number">0.0</span>);

    <span class="tok-comment">// Other than being available to call with dot syntax, struct methods are</span>
    <span class="tok-comment">// not special. You can reference them as any other declaration inside</span>
    <span class="tok-comment">// the struct:</span>
    <span class="tok-kw">try</span> expect(Vec3.dot(v1, v2) == <span class="tok-number">0.0</span>);
}

<span class="tok-comment">// Structs can have declarations.</span>
<span class="tok-comment">// Structs can have 0 fields.</span>
<span class="tok-kw">const</span> Empty = <span class="tok-kw">struct</span> {
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> PI = <span class="tok-number">3.14</span>;
};
<span class="tok-kw">test</span> <span class="tok-str">"struct namespaced variable"</span> {
    <span class="tok-kw">try</span> expect(Empty.PI == <span class="tok-number">3.14</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@sizeOf</span>(Empty) == <span class="tok-number">0</span>);

    <span class="tok-comment">// Empty structs can be instantiated the same as usual.</span>
    <span class="tok-kw">const</span> does_nothing: Empty = .{};

    _ = does_nothing;
}

<span class="tok-comment">// Struct field order is determined by the compiler, however, a base pointer</span>
<span class="tok-comment">// can be computed from a field pointer:</span>
<span class="tok-kw">fn</span> <span class="tok-fn">setYBasedOnX</span>(x: *<span class="tok-type">f32</span>, y: <span class="tok-type">f32</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> point: *Point = <span class="tok-builtin">@fieldParentPtr</span>(<span class="tok-str">"x"</span>, x);
    point.y = y;
}
<span class="tok-kw">test</span> <span class="tok-str">"field parent pointer"</span> {
    <span class="tok-kw">var</span> point = Point{
        .x = <span class="tok-number">0.1234</span>,
        .y = <span class="tok-number">0.5678</span>,
    };
    setYBasedOnX(&amp;point.x, <span class="tok-number">0.9</span>);
    <span class="tok-kw">try</span> expect(point.y == <span class="tok-number">0.9</span>);
}

<span class="tok-comment">// Structs can be returned from functions.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">LinkedList</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Node = <span class="tok-kw">struct</span> {
            prev: ?*Node,
            next: ?*Node,
            data: T,
        };

        first: ?*Node,
        last: ?*Node,
        len: <span class="tok-type">usize</span>,
    };
}

<span class="tok-kw">test</span> <span class="tok-str">"linked list"</span> {
    <span class="tok-comment">// Functions called at compile-time are memoized.</span>
    <span class="tok-kw">try</span> expect(LinkedList(<span class="tok-type">i32</span>) == LinkedList(<span class="tok-type">i32</span>));

    <span class="tok-kw">const</span> list = LinkedList(<span class="tok-type">i32</span>){
        .first = <span class="tok-null">null</span>,
        .last = <span class="tok-null">null</span>,
        .len = <span class="tok-number">0</span>,
    };
    <span class="tok-kw">try</span> expect(list.len == <span class="tok-number">0</span>);

    <span class="tok-comment">// Since types are first class values you can instantiate the type</span>
    <span class="tok-comment">// by assigning it to a variable:</span>
    <span class="tok-kw">const</span> ListOfInts = LinkedList(<span class="tok-type">i32</span>);
    <span class="tok-kw">try</span> expect(ListOfInts == LinkedList(<span class="tok-type">i32</span>));

    <span class="tok-kw">var</span> node = ListOfInts.Node{
        .prev = <span class="tok-null">null</span>,
        .next = <span class="tok-null">null</span>,
        .data = <span class="tok-number">1234</span>,
    };
    <span class="tok-kw">const</span> list2 = LinkedList(<span class="tok-type">i32</span>){
        .first = &amp;node,
        .last = &amp;node,
        .len = <span class="tok-number">1</span>,
    };

    <span class="tok-comment">// When using a pointer to a struct, fields can be accessed directly,</span>
    <span class="tok-comment">// without explicitly dereferencing the pointer.</span>
    <span class="tok-comment">// So you can do</span>
    <span class="tok-kw">try</span> expect(list2.first.?.data == <span class="tok-number">1234</span>);
    <span class="tok-comment">// instead of try expect(list2.first.?.*.data == 1234);</span>
}

<span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_structs.zig</kbd>
1/4 test_structs.test.dot product...OK
2/4 test_structs.test.struct namespaced variable...OK
3/4 test_structs.test.field parent pointer...OK
4/4 test_structs.test.linked list...OK
All 4 tests passed.
</samp></pre></figure>


      <h3 id="Default-Field-Values"><a href="https://ziglang.org/documentation/0.15.2/#toc-Default-Field-Values">Default Field Values</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Default-Field-Values">§</a></h3>

      <p>
      Each struct field may have an expression indicating the default field
      value. Such expressions are executed at <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a>, and allow the
      field to be omitted in a struct literal expression:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">struct_default_field_values.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Foo = <span class="tok-kw">struct</span> {
    a: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>,
    b: <span class="tok-type">i32</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">"default struct initialization fields"</span> {
    <span class="tok-kw">const</span> x: Foo = .{
        .b = <span class="tok-number">5</span>,
    };
    <span class="tok-kw">if</span> (x.a + x.b != <span class="tok-number">1239</span>) {
        <span class="tok-kw">comptime</span> <span class="tok-kw">unreachable</span>;
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test struct_default_field_values.zig</kbd>
1/1 struct_default_field_values.test.default struct initialization fields...OK
All 1 tests passed.
</samp></pre></figure>

      <h4 id="Faulty-Default-Field-Values"><a href="https://ziglang.org/documentation/0.15.2/#toc-Faulty-Default-Field-Values">Faulty Default Field Values</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Faulty-Default-Field-Values">§</a></h4>

      <p>
      Default field values are only appropriate when the data invariants of a struct
      cannot be violated by omitting that field from an initialization.
      </p>
      <p>
      For example, here is an inappropriate use of default struct field initialization:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">bad_default_value.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Threshold = <span class="tok-kw">struct</span> {
    minimum: <span class="tok-type">f32</span> = <span class="tok-number">0.25</span>,
    maximum: <span class="tok-type">f32</span> = <span class="tok-number">0.75</span>,

    <span class="tok-kw">const</span> Category = <span class="tok-kw">enum</span> { low, medium, high };

    <span class="tok-kw">fn</span> <span class="tok-fn">categorize</span>(t: Threshold, value: <span class="tok-type">f32</span>) Category {
        assert(t.maximum &gt;= t.minimum);
        <span class="tok-kw">if</span> (value &lt; t.minimum) <span class="tok-kw">return</span> .low;
        <span class="tok-kw">if</span> (value &gt; t.maximum) <span class="tok-kw">return</span> .high;
        <span class="tok-kw">return</span> .medium;
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> threshold: Threshold = .{
        .maximum = <span class="tok-number">0.20</span>,
    };
    <span class="tok-kw">const</span> category = threshold.categorize(<span class="tok-number">0.90</span>);
    <span class="tok-kw">try</span> std.fs.File.stdout().writeAll(<span class="tok-builtin">@tagName</span>(category));
}

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> assert = std.debug.assert;</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe bad_default_value.zig</kbd>
$ <kbd>./bad_default_value</kbd>
thread 2895237 panic: reached unreachable code
<span class="sgr-1m">/home/andy/dev/zig/lib/std/debug.zig:559:14</span>: <span class="sgr-2m">0x1044179 in assert (std.zig)</span>
    if (!ok) unreachable; // assertion failure
             <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/bad_default_value.zig:8:15</span>: <span class="sgr-2m">0x113ec54 in categorize (bad_default_value.zig)</span>
        assert(t.maximum &gt;= t.minimum);
              <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/bad_default_value.zig:19:42</span>: <span class="sgr-2m">0x113d444 in main (bad_default_value.zig)</span>
    const category = threshold.categorize(0.90);
                                         <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:627:37</span>: <span class="sgr-2m">0x113dca9 in posixCallMainAndExit (std.zig)</span>
            const result = root.main() catch |err| {
                                    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      <p>
      Above you can see the danger of ignoring this principle. The default
      field values caused the data invariant to be violated, causing illegal
      behavior.
      </p>
      <p>
      To fix this, remove the default values from all the struct fields, and provide
      a named default value:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">struct_default_value.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Threshold = <span class="tok-kw">struct</span> {
    minimum: <span class="tok-type">f32</span>,
    maximum: <span class="tok-type">f32</span>,

    <span class="tok-kw">const</span> default: Threshold = .{
        .minimum = <span class="tok-number">0.25</span>,
        .maximum = <span class="tok-number">0.75</span>,
    };
};</code></pre></figure>

      <p>If a struct value requires a runtime-known value in order to be initialized
      without violating data invariants, then use an initialization method that accepts
      those runtime values, and populates the remaining fields.</p>
      
      

      <h3 id="extern-struct"><a href="https://ziglang.org/documentation/0.15.2/#toc-extern-struct">extern struct</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#extern-struct">§</a></h3>

      <p>An <code><span class="tok-kw">extern</span> <span class="tok-kw">struct</span></code> has in-memory layout matching
      the C ABI for the target.</p>
      <p>If well-defined in-memory layout is not required, <a href="https://ziglang.org/documentation/0.15.2/#struct">struct</a> is a better choice
      because it places fewer restrictions on the compiler.</p>
      <p>See <a href="https://ziglang.org/documentation/0.15.2/#packed-struct">packed struct</a> for a struct that has the ABI of its backing integer,
      which can be useful for modeling flags.</p>
      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#extern-union">extern union</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#extern-enum">extern enum</a></li>
</ul>

      

      <h3 id="packed-struct"><a href="https://ziglang.org/documentation/0.15.2/#toc-packed-struct">packed struct</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#packed-struct">§</a></h3>

      <p>
      <code><span class="tok-kw">packed</span></code> structs, like <code><span class="tok-kw">enum</span></code>, are based on the concept
      of interpreting integers differently. All packed structs have a <strong>backing integer</strong>,
      which is implicitly determined by the total bit count of fields, or explicitly specified.
      Packed structs have well-defined memory layout - exactly the same ABI as their backing integer.
      </p>
      <p>
      Each field of a packed struct is interpreted as a logical sequence of bits, arranged from
      least to most significant. Allowed field types:
      </p>
      <ul>
        <li>An <a href="https://ziglang.org/documentation/0.15.2/#Integers">integer</a> field uses exactly as many bits as its
        bit width. For example, a <code><span class="tok-type">u5</span></code> will use 5 bits of
        the backing integer.</li>
        <li>A <a href="https://ziglang.org/documentation/0.15.2/#Primitive-Types">bool</a> field uses exactly 1 bit.</li>
        <li>An <a href="https://ziglang.org/documentation/0.15.2/#enum">enum</a> field uses exactly the bit width of its integer tag type.</li>
        <li>A <a href="https://ziglang.org/documentation/0.15.2/#packed-union">packed union</a> field uses exactly the bit width of the union field with
        the largest bit width.</li>
        <li>A <code><span class="tok-kw">packed</span> <span class="tok-kw">struct</span></code> field uses the bits of its backing integer.</li>
      </ul>
      <p>
      This means that a <code><span class="tok-kw">packed</span> <span class="tok-kw">struct</span></code> can participate
      in a <a href="https://ziglang.org/documentation/0.15.2/#bitCast">@bitCast</a> or a <a href="https://ziglang.org/documentation/0.15.2/#ptrCast">@ptrCast</a> to reinterpret memory.
      This even works at <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a>:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_packed_structs.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> native_endian = <span class="tok-builtin">@import</span>(<span class="tok-str">"builtin"</span>).target.cpu.arch.endian();
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Full = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    number: <span class="tok-type">u16</span>,
};
<span class="tok-kw">const</span> Divided = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    half1: <span class="tok-type">u8</span>,
    quarter3: <span class="tok-type">u4</span>,
    quarter4: <span class="tok-type">u4</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">"@bitCast between packed structs"</span> {
    <span class="tok-kw">try</span> doTheTest();
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> doTheTest();
}

<span class="tok-kw">fn</span> <span class="tok-fn">doTheTest</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@sizeOf</span>(Full) == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@sizeOf</span>(Divided) == <span class="tok-number">2</span>);
    <span class="tok-kw">const</span> full = Full{ .number = <span class="tok-number">0x1234</span> };
    <span class="tok-kw">const</span> divided: Divided = <span class="tok-builtin">@bitCast</span>(full);
    <span class="tok-kw">try</span> expect(divided.half1 == <span class="tok-number">0x34</span>);
    <span class="tok-kw">try</span> expect(divided.quarter3 == <span class="tok-number">0x2</span>);
    <span class="tok-kw">try</span> expect(divided.quarter4 == <span class="tok-number">0x1</span>);

    <span class="tok-kw">const</span> ordered: [<span class="tok-number">2</span>]<span class="tok-type">u8</span> = <span class="tok-builtin">@bitCast</span>(full);
    <span class="tok-kw">switch</span> (native_endian) {
        .big =&gt; {
            <span class="tok-kw">try</span> expect(ordered[<span class="tok-number">0</span>] == <span class="tok-number">0x12</span>);
            <span class="tok-kw">try</span> expect(ordered[<span class="tok-number">1</span>] == <span class="tok-number">0x34</span>);
        },
        .little =&gt; {
            <span class="tok-kw">try</span> expect(ordered[<span class="tok-number">0</span>] == <span class="tok-number">0x34</span>);
            <span class="tok-kw">try</span> expect(ordered[<span class="tok-number">1</span>] == <span class="tok-number">0x12</span>);
        },
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_packed_structs.zig</kbd>
1/1 test_packed_structs.test.@bitCast between packed structs...OK
All 1 tests passed.
</samp></pre></figure>
      <p>
      The backing integer can be inferred or explicitly provided. When
      inferred, it will be unsigned. When explicitly provided, its bit width
      will be enforced at compile time to exactly match the total bit width of
      the fields:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_missized_packed_struct.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">"missized packed struct"</span> {
    <span class="tok-kw">const</span> S = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u32</span>) { a: <span class="tok-type">u16</span>, b: <span class="tok-type">u8</span> };
    _ = S{ .a = <span class="tok-number">4</span>, .b = <span class="tok-number">2</span> };
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_missized_packed_struct.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_missized_packed_struct.zig:2:29: </span><span class="sgr-31m">error: </span><span class="sgr-1m">backing integer type 'u32' has bit size 32 but the struct fields have a total bit size of 24
</span>    const S = packed struct(u32) { a: u16, b: u8 };
                            <span class="sgr-32m">^~~
</span><span class="sgr-2m">referenced by:
    test.missized packed struct: /home/andy/dev/zig/doc/langref/test_missized_packed_struct.zig:2:22
</span>
</samp></pre></figure>

      <p>
      Zig allows the address to be taken of a non-byte-aligned field:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_pointer_to_non-byte_aligned_field.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> BitField = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    a: <span class="tok-type">u3</span>,
    b: <span class="tok-type">u3</span>,
    c: <span class="tok-type">u2</span>,
};

<span class="tok-kw">var</span> foo = BitField{
    .a = <span class="tok-number">1</span>,
    .b = <span class="tok-number">2</span>,
    .c = <span class="tok-number">3</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">"pointer to non-byte-aligned field"</span> {
    <span class="tok-kw">const</span> ptr = &amp;foo.b;
    <span class="tok-kw">try</span> expect(ptr.* == <span class="tok-number">2</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_pointer_to_non-byte_aligned_field.zig</kbd>
1/1 test_pointer_to_non-byte_aligned_field.test.pointer to non-byte-aligned field...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      However, the pointer to a non-byte-aligned field has special properties and cannot
      be passed when a normal pointer is expected:
      </p>
