      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#setFloatMode">@setFloatMode</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Division-by-Zero">Division by Zero</a></li>
</ul>

      
      
      <h2 id="Operators"><a href="https://ziglang.org/documentation/0.15.2/#toc-Operators">Operators</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Operators">§</a></h2>

      <p>
      There is no operator overloading. When you see an operator in Zig, you know that
      it is doing something from this table, and nothing else.
      </p>
      <h3 id="Table-of-Operators"><a href="https://ziglang.org/documentation/0.15.2/#toc-Table-of-Operators">Table of Operators</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Table-of-Operators">§</a></h3>

      <div class="table-wrapper">
      <table>
        <thead>
        <tr>
          <th scope="col">Name</th>
          <th scope="col">Syntax</th>
          <th scope="col">Types</th>
          <th scope="col">Remarks</th>
          <th scope="col">Example</th>
        </tr>
        </thead>
        <tbody>
        <tr>
          <td>Addition</td>
          <td><pre><code>a + b
a += b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">Integers</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Can cause <a href="https://ziglang.org/documentation/0.15.2/#Default-Operations">overflow</a> for integers.</li>
              <li>Invokes <a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
              <li>See also <a href="https://ziglang.org/documentation/0.15.2/#addWithOverflow">@addWithOverflow</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-number">2</span> + <span class="tok-number">5</span> == <span class="tok-number">7</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Wrapping Addition</td>
          <td><pre><code>a +% b
a +%= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">Integers</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Twos-complement wrapping behavior.</li>
              <li>Invokes <a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
              <li>See also <a href="https://ziglang.org/documentation/0.15.2/#addWithOverflow">@addWithOverflow</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0xffffffff</span>) +% <span class="tok-number">1</span> == <span class="tok-number">0</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Saturating Addition</td>
          <td><pre><code>a +| b
a +|= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">Integers</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Invokes <a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">255</span>) +| <span class="tok-number">1</span> == <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">255</span>)</code></pre>
          </td>
        </tr>
        <tr>
          <td>Subtraction</td>
          <td><pre><code>a - b
a -= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">Integers</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Can cause <a href="https://ziglang.org/documentation/0.15.2/#Default-Operations">overflow</a> for integers.</li>
              <li>Invokes <a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
              <li>See also <a href="https://ziglang.org/documentation/0.15.2/#subWithOverflow">@subWithOverflow</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-number">2</span> - <span class="tok-number">5</span> == -<span class="tok-number">3</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Wrapping Subtraction</td>
          <td><pre><code>a -% b
a -%= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">Integers</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Twos-complement wrapping behavior.</li>
              <li>Invokes <a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
              <li>See also <a href="https://ziglang.org/documentation/0.15.2/#subWithOverflow">@subWithOverflow</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0</span>) -% <span class="tok-number">1</span> == <span class="tok-number">255</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Saturating Subtraction</td>
          <td><pre><code>a -| b
a -|= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">Integers</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Invokes <a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>) -| <span class="tok-number">1</span> == <span class="tok-number">0</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Negation</td>
          <td><pre><code>-a</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">Integers</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Can cause <a href="https://ziglang.org/documentation/0.15.2/#Default-Operations">overflow</a> for integers.</li>
            </ul>
          </td>
          <td>
            <pre><code>-<span class="tok-number">1</span> == <span class="tok-number">0</span> - <span class="tok-number">1</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Wrapping Negation</td>
          <td><pre><code>-%a</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">Integers</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Twos-complement wrapping behavior.</li>
            </ul>
          </td>
          <td>
            <pre><code>-%<span class="tok-builtin">@as</span>(<span class="tok-type">i8</span>, -<span class="tok-number">128</span>) == -<span class="tok-number">128</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Multiplication</td>
          <td><pre><code>a * b
a *= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">Integers</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Can cause <a href="https://ziglang.org/documentation/0.15.2/#Default-Operations">overflow</a> for integers.</li>
              <li>Invokes <a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
              <li>See also <a href="https://ziglang.org/documentation/0.15.2/#mulWithOverflow">@mulWithOverflow</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-number">2</span> * <span class="tok-number">5</span> == <span class="tok-number">10</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Wrapping Multiplication</td>
          <td><pre><code>a *% b
a *%= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">Integers</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Twos-complement wrapping behavior.</li>
              <li>Invokes <a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
              <li>See also <a href="https://ziglang.org/documentation/0.15.2/#mulWithOverflow">@mulWithOverflow</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">200</span>) *% <span class="tok-number">2</span> == <span class="tok-number">144</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Saturating Multiplication</td>
          <td><pre><code>a *| b
a *|= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">Integers</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Invokes <a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">200</span>) *| <span class="tok-number">2</span> == <span class="tok-number">255</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Division</td>
          <td><pre><code>a / b
a /= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">Integers</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Can cause <a href="https://ziglang.org/documentation/0.15.2/#Default-Operations">overflow</a> for integers.</li>
              <li>Can cause <a href="https://ziglang.org/documentation/0.15.2/#Division-by-Zero">Division by Zero</a> for integers.</li>
              <li>Can cause <a href="https://ziglang.org/documentation/0.15.2/#Division-by-Zero">Division by Zero</a> for floats in <a href="https://ziglang.org/documentation/0.15.2/#Floating-Point-Operations">FloatMode.Optimized Mode</a>.</li>
              <li>Signed integer operands must be comptime-known and positive. In other cases, use
                <a href="https://ziglang.org/documentation/0.15.2/#divTrunc">@divTrunc</a>,
                <a href="https://ziglang.org/documentation/0.15.2/#divFloor">@divFloor</a>, or
                <a href="https://ziglang.org/documentation/0.15.2/#divExact">@divExact</a> instead.
              </li>
              <li>Invokes <a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-number">10</span> / <span class="tok-number">5</span> == <span class="tok-number">2</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Remainder Division</td>
          <td><pre><code>a % b
a %= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">Integers</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Can cause <a href="https://ziglang.org/documentation/0.15.2/#Division-by-Zero">Division by Zero</a> for integers.</li>
              <li>Can cause <a href="https://ziglang.org/documentation/0.15.2/#Division-by-Zero">Division by Zero</a> for floats in <a href="https://ziglang.org/documentation/0.15.2/#Floating-Point-Operations">FloatMode.Optimized Mode</a>.</li>
              <li>Signed or floating-point operands must be comptime-known and positive. In other cases, use
                <a href="https://ziglang.org/documentation/0.15.2/#rem">@rem</a> or
                <a href="https://ziglang.org/documentation/0.15.2/#mod">@mod</a> instead.
              </li>
              <li>Invokes <a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-number">10</span> % <span class="tok-number">3</span> == <span class="tok-number">1</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Bit Shift Left</td>
          <td><pre><code>a &lt;&lt; b
a &lt;&lt;= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">Integers</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Moves all bits to the left, inserting new zeroes at the
              least-significant bit.</li>
              <li><code>b</code> must be
              <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime-known</a> or have a type with log2 number
              of bits as <code>a</code>.</li>
              <li>See also <a href="https://ziglang.org/documentation/0.15.2/#shlExact">@shlExact</a>.</li>
              <li>See also <a href="https://ziglang.org/documentation/0.15.2/#shlWithOverflow">@shlWithOverflow</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-number">0b1</span> &lt;&lt; <span class="tok-number">8</span> == <span class="tok-number">0b100000000</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Saturating Bit Shift Left</td>
          <td><pre><code>a &lt;&lt;| b
a &lt;&lt;|= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">Integers</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>See also <a href="https://ziglang.org/documentation/0.15.2/#shlExact">@shlExact</a>.</li>
              <li>See also <a href="https://ziglang.org/documentation/0.15.2/#shlWithOverflow">@shlWithOverflow</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">1</span>) &lt;&lt;| <span class="tok-number">8</span> == <span class="tok-number">255</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Bit Shift Right</td>
          <td><pre><code>a &gt;&gt; b
a &gt;&gt;= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">Integers</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Moves all bits to the right, inserting zeroes at the most-significant bit.</li>
              <li><code>b</code> must be
                <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime-known</a> or have a type with log2 number
                of bits as <code>a</code>.</li>
              <li>See also <a href="https://ziglang.org/documentation/0.15.2/#shrExact">@shrExact</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-number">0b1010</span> &gt;&gt; <span class="tok-number">1</span> == <span class="tok-number">0b101</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Bitwise And</td>
          <td><pre><code>a &amp; b
a &amp;= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">Integers</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Invokes <a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-number">0b011</span> &amp; <span class="tok-number">0b101</span> == <span class="tok-number">0b001</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Bitwise Or</td>
          <td><pre><code>a | b
a |= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">Integers</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Invokes <a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-number">0b010</span> | <span class="tok-number">0b100</span> == <span class="tok-number">0b110</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Bitwise Xor</td>
          <td><pre><code>a ^ b
a ^= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">Integers</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Invokes <a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-number">0b011</span> ^ <span class="tok-number">0b101</span> == <span class="tok-number">0b110</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Bitwise Not</td>
          <td><pre><code>~a</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">Integers</a></li>
            </ul>
          </td>
          <td></td>
          <td>
            <pre><code>~<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0b10101111</span>) == <span class="tok-number">0b01010000</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Defaulting Optional Unwrap</td>
          <td><pre><code>a <span class="tok-kw">orelse</span> b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Optionals">Optionals</a></li>
            </ul>
          </td>
          <td>If <code>a</code> is <code><span class="tok-null">null</span></code>,
          returns <code>b</code> ("default value"),
          otherwise returns the unwrapped value of <code>a</code>.
          Note that <code>b</code> may be a value of type <a href="https://ziglang.org/documentation/0.15.2/#noreturn">noreturn</a>.
          </td>
          <td>
            <pre><code><span class="tok-kw">const</span> value: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span>;
<span class="tok-kw">const</span> unwrapped = value <span class="tok-kw">orelse</span> <span class="tok-number">1234</span>;
unwrapped == <span class="tok-number">1234</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Optional Unwrap</td>
          <td><pre><code>a.?</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Optionals">Optionals</a></li>
            </ul>
          </td>
          <td>
            Equivalent to:
            <pre><code>a <span class="tok-kw">orelse</span> <span class="tok-kw">unreachable</span></code></pre>
          </td>
          <td>
            <pre><code><span class="tok-kw">const</span> value: ?<span class="tok-type">u32</span> = <span class="tok-number">5678</span>;
value.? == <span class="tok-number">5678</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Defaulting Error Unwrap</td>
          <td><pre><code>a <span class="tok-kw">catch</span> b
a <span class="tok-kw">catch</span> |err| b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Errors">Error Unions</a></li>
            </ul>
          </td>
          <td>If <code>a</code> is an <code><span class="tok-kw">error</span></code>,
          returns <code>b</code> ("default value"),
          otherwise returns the unwrapped value of <code>a</code>.
          Note that <code>b</code> may be a value of type <a href="https://ziglang.org/documentation/0.15.2/#noreturn">noreturn</a>.
<code>err</code> is the <code><span class="tok-kw">error</span></code> and is in scope of the expression <code>b</code>.
          </td>
          <td>
            <pre><code><span class="tok-kw">const</span> value: <span class="tok-type">anyerror</span>!<span class="tok-type">u32</span> = <span class="tok-kw">error</span>.Broken;
<span class="tok-kw">const</span> unwrapped = value <span class="tok-kw">catch</span> <span class="tok-number">1234</span>;
unwrapped == <span class="tok-number">1234</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Logical And</td>
          <td><pre><code>a <span class="tok-kw">and</span> b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Primitive-Types">bool</a></li>
            </ul>
          </td>
          <td>
          If <code>a</code> is <code><span class="tok-null">false</span></code>, returns <code><span class="tok-null">false</span></code>
          without evaluating <code>b</code>. Otherwise, returns <code>b</code>.
          </td>
          <td>
            <pre><code>(<span class="tok-null">false</span> <span class="tok-kw">and</span> <span class="tok-null">true</span>) == <span class="tok-null">false</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Logical Or</td>
          <td><pre><code>a <span class="tok-kw">or</span> b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Primitive-Types">bool</a></li>
            </ul>
          </td>
          <td>
              If <code>a</code> is <code><span class="tok-null">true</span></code>,
              returns <code><span class="tok-null">true</span></code> without evaluating
              <code>b</code>. Otherwise, returns
              <code>b</code>.
          </td>
          <td>
            <pre><code>(<span class="tok-null">false</span> <span class="tok-kw">or</span> <span class="tok-null">true</span>) == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Boolean Not</td>
          <td><pre><code>!a</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Primitive-Types">bool</a></li>
            </ul>
          </td>
          <td></td>
          <td>
            <pre><code>!<span class="tok-null">false</span> == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Equality</td>
          <td><pre><code>a == b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">Integers</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Floats">Floats</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Primitive-Types">bool</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Primitive-Types">type</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#packed-struct">packed struct</a></li>
            </ul>
          </td>
          <td>
              Returns <code><span class="tok-null">true</span></code> if a and b are equal, otherwise returns <code><span class="tok-null">false</span></code>.
            Invokes <a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.
          </td>
          <td>
            <pre><code>(<span class="tok-number">1</span> == <span class="tok-number">1</span>) == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Null Check</td>
          <td><pre><code>a == <span class="tok-null">null</span></code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Optionals">Optionals</a></li>
            </ul>
          </td>
          <td>
              Returns <code><span class="tok-null">true</span></code> if a is <code><span class="tok-null">null</span></code>, otherwise returns <code><span class="tok-null">false</span></code>.
          </td>
          <td>
            <pre><code><span class="tok-kw">const</span> value: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span>;
(value == <span class="tok-null">null</span>) == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Inequality</td>
          <td><pre><code>a != b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">Integers</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Floats">Floats</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Primitive-Types">bool</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Primitive-Types">type</a></li>
            </ul>
          </td>
          <td>
              Returns <code><span class="tok-null">false</span></code> if a and b are equal, otherwise returns <code><span class="tok-null">true</span></code>.
            Invokes <a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.
          </td>
          <td>
            <pre><code>(<span class="tok-number">1</span> != <span class="tok-number">1</span>) == <span class="tok-null">false</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Non-Null Check</td>
          <td><pre><code>a != <span class="tok-null">null</span></code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Optionals">Optionals</a></li>
            </ul>
          </td>
          <td>
              Returns <code><span class="tok-null">false</span></code> if a is <code><span class="tok-null">null</span></code>, otherwise returns <code><span class="tok-null">true</span></code>.
          </td>
          <td>
            <pre><code><span class="tok-kw">const</span> value: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span>;
(value != <span class="tok-null">null</span>) == <span class="tok-null">false</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Greater Than</td>
          <td><pre><code>a &gt; b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">Integers</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
              Returns <code><span class="tok-null">true</span></code> if a is greater than b, otherwise returns <code><span class="tok-null">false</span></code>.
            Invokes <a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.
          </td>
          <td>
            <pre><code>(<span class="tok-number">2</span> &gt; <span class="tok-number">1</span>) == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Greater or Equal</td>
          <td><pre><code>a &gt;= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">Integers</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
              Returns <code><span class="tok-null">true</span></code> if a is greater than or equal to b, otherwise returns <code><span class="tok-null">false</span></code>.
            Invokes <a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.
          </td>
          <td>
            <pre><code>(<span class="tok-number">2</span> &gt;= <span class="tok-number">1</span>) == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Less Than</td>
          <td><pre><code>a &lt; b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">Integers</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
              Returns <code><span class="tok-null">true</span></code> if a is less than b, otherwise returns <code><span class="tok-null">false</span></code>.
            Invokes <a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.
          </td>
          <td>
            <pre><code>(<span class="tok-number">1</span> &lt; <span class="tok-number">2</span>) == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Lesser or Equal</td>
          <td><pre><code>a &lt;= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">Integers</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
              Returns <code><span class="tok-null">true</span></code> if a is less than or equal to b, otherwise returns <code><span class="tok-null">false</span></code>.
            Invokes <a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.
          </td>
          <td>
            <pre><code>(<span class="tok-number">1</span> &lt;= <span class="tok-number">2</span>) == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Array Concatenation</td>
          <td><pre><code>a ++ b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Arrays">Arrays</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Only available when the lengths of both <code>a</code> and <code>b</code> are <a href="https://ziglang.org/documentation/0.15.2/#comptime">compile-time known</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).mem;
<span class="tok-kw">const</span> array1 = [_]<span class="tok-type">u32</span>{<span class="tok-number">1</span>,<span class="tok-number">2</span>};
<span class="tok-kw">const</span> array2 = [_]<span class="tok-type">u32</span>{<span class="tok-number">3</span>,<span class="tok-number">4</span>};
<span class="tok-kw">const</span> together = array1 ++ array2;
mem.eql(<span class="tok-type">u32</span>, &amp;together, &amp;[_]<span class="tok-type">u32</span>{<span class="tok-number">1</span>,<span class="tok-number">2</span>,<span class="tok-number">3</span>,<span class="tok-number">4</span>})</code></pre>
          </td>
        </tr>
        <tr>
          <td>Array Multiplication</td>
          <td><pre><code>a ** b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Arrays">Arrays</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Only available when the length of <code>a</code> and <code>b</code> are <a href="https://ziglang.org/documentation/0.15.2/#comptime">compile-time known</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).mem;
<span class="tok-kw">const</span> pattern = <span class="tok-str">"ab"</span> ** <span class="tok-number">3</span>;
mem.eql(<span class="tok-type">u8</span>, pattern, <span class="tok-str">"ababab"</span>)</code></pre>
          </td>
        </tr>
        <tr>
          <td>Pointer Dereference</td>
          <td><pre><code>a.*</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Pointers">Pointers</a></li>
            </ul>
          </td>
          <td>
            Pointer dereference.
          </td>
          <td>
            <pre><code><span class="tok-kw">const</span> x: <span class="tok-type">u32</span> = <span class="tok-number">1234</span>;
<span class="tok-kw">const</span> ptr = &amp;x;
ptr.* == <span class="tok-number">1234</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Address Of</td>
          <td><pre><code>&amp;a</code></pre></td>
          <td>
            All types
          </td>
          <td>
          </td>
          <td>
            <pre><code><span class="tok-kw">const</span> x: <span class="tok-type">u32</span> = <span class="tok-number">1234</span>;
<span class="tok-kw">const</span> ptr = &amp;x;
ptr.* == <span class="tok-number">1234</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Error Set Merge</td>
          <td><pre><code>a || b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Error-Set-Type">Error Set Type</a></li>
            </ul>
          </td>
          <td>
              <a href="https://ziglang.org/documentation/0.15.2/#Merging-Error-Sets">Merging Error Sets</a>
          </td>
          <td>
            <pre><code><span class="tok-kw">const</span> A = <span class="tok-kw">error</span>{One};
<span class="tok-kw">const</span> B = <span class="tok-kw">error</span>{Two};
(A || B) == <span class="tok-kw">error</span>{One, Two}</code></pre>
          </td>
        </tr>
        </tbody>
      </table>
      </div>
      
      <h3 id="Precedence"><a href="https://ziglang.org/documentation/0.15.2/#toc-Precedence">Precedence</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Precedence">§</a></h3>

      <pre><code>x() x[] x.y x.* x.?
a!b
x{}
!x -x -%x ~x &amp;x ?x
* / % ** *% *| ||
+ - ++ +% -% +| -|
&lt;&lt; &gt;&gt; &lt;&lt;|
&amp; ^ | <span class="tok-kw">orelse</span> <span class="tok-kw">catch</span>
== != &lt; &gt; &lt;= &gt;=
<span class="tok-kw">and</span>
<span class="tok-kw">or</span>
= *= *%= *|= /= %= += +%= +|= -= -%= -|= &lt;&lt;= &lt;&lt;|= &gt;&gt;= &amp;= ^= |=</code></pre>
      
      
      <h2 id="Arrays"><a href="https://ziglang.org/documentation/0.15.2/#toc-Arrays">Arrays</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Arrays">§</a></h2>

      <figure><figcaption class="zig-cap"><cite class="file">test_arrays.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;
<span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.assert;
<span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).mem;

<span class="tok-comment">// array literal</span>
<span class="tok-kw">const</span> message = [_]<span class="tok-type">u8</span>{ <span class="tok-str">'h'</span>, <span class="tok-str">'e'</span>, <span class="tok-str">'l'</span>, <span class="tok-str">'l'</span>, <span class="tok-str">'o'</span> };

<span class="tok-comment">// alternative initialization using result location</span>
<span class="tok-kw">const</span> alt_message: [<span class="tok-number">5</span>]<span class="tok-type">u8</span> = .{ <span class="tok-str">'h'</span>, <span class="tok-str">'e'</span>, <span class="tok-str">'l'</span>, <span class="tok-str">'l'</span>, <span class="tok-str">'o'</span> };

<span class="tok-kw">comptime</span> {
    assert(mem.eql(<span class="tok-type">u8</span>, &amp;message, &amp;alt_message));
}

<span class="tok-comment">// get the size of an array</span>
<span class="tok-kw">comptime</span> {
    assert(message.len == <span class="tok-number">5</span>);
}

<span class="tok-comment">// A string literal is a single-item pointer to an array.</span>
<span class="tok-kw">const</span> same_message = <span class="tok-str">"hello"</span>;

<span class="tok-kw">comptime</span> {
    assert(mem.eql(<span class="tok-type">u8</span>, &amp;message, same_message));
}

<span class="tok-kw">test</span> <span class="tok-str">"iterate over an array"</span> {
    <span class="tok-kw">var</span> sum: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (message) |byte| {
        sum += byte;
    }
    <span class="tok-kw">try</span> expect(sum == <span class="tok-str">'h'</span> + <span class="tok-str">'e'</span> + <span class="tok-str">'l'</span> * <span class="tok-number">2</span> + <span class="tok-str">'o'</span>);
}

<span class="tok-comment">// modifiable array</span>
<span class="tok-kw">var</span> some_integers: [<span class="tok-number">100</span>]<span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;

<span class="tok-kw">test</span> <span class="tok-str">"modify an array"</span> {
    <span class="tok-kw">for</span> (&amp;some_integers, <span class="tok-number">0</span>..) |*item, i| {
        item.* = <span class="tok-builtin">@intCast</span>(i);
    }
    <span class="tok-kw">try</span> expect(some_integers[<span class="tok-number">10</span>] == <span class="tok-number">10</span>);
    <span class="tok-kw">try</span> expect(some_integers[<span class="tok-number">99</span>] == <span class="tok-number">99</span>);
}

<span class="tok-comment">// array concatenation works if the values are known</span>
<span class="tok-comment">// at compile time</span>
<span class="tok-kw">const</span> part_one = [_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };
<span class="tok-kw">const</span> part_two = [_]<span class="tok-type">i32</span>{ <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span> };
<span class="tok-kw">const</span> all_of_it = part_one ++ part_two;
<span class="tok-kw">comptime</span> {
    assert(mem.eql(<span class="tok-type">i32</span>, &amp;all_of_it, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span> }));
}

<span class="tok-comment">// remember that string literals are arrays</span>
<span class="tok-kw">const</span> hello = <span class="tok-str">"hello"</span>;
<span class="tok-kw">const</span> world = <span class="tok-str">"world"</span>;
<span class="tok-kw">const</span> hello_world = hello ++ <span class="tok-str">" "</span> ++ world;
<span class="tok-kw">comptime</span> {
    assert(mem.eql(<span class="tok-type">u8</span>, hello_world, <span class="tok-str">"hello world"</span>));
}

<span class="tok-comment">// ** does repeating patterns</span>
<span class="tok-kw">const</span> pattern = <span class="tok-str">"ab"</span> ** <span class="tok-number">3</span>;
<span class="tok-kw">comptime</span> {
    assert(mem.eql(<span class="tok-type">u8</span>, pattern, <span class="tok-str">"ababab"</span>));
}

<span class="tok-comment">// initialize an array to zero</span>
<span class="tok-kw">const</span> all_zero = [_]<span class="tok-type">u16</span>{<span class="tok-number">0</span>} ** <span class="tok-number">10</span>;

<span class="tok-kw">comptime</span> {
    assert(all_zero.len == <span class="tok-number">10</span>);
    assert(all_zero[<span class="tok-number">5</span>] == <span class="tok-number">0</span>);
}

<span class="tok-comment">// use compile-time code to initialize an array</span>
<span class="tok-kw">var</span> fancy_array = init: {
    <span class="tok-kw">var</span> initial_value: [<span class="tok-number">10</span>]Point = <span class="tok-null">undefined</span>;
    <span class="tok-kw">for</span> (&amp;initial_value, <span class="tok-number">0</span>..) |*pt, i| {
        pt.* = Point{
            .x = <span class="tok-builtin">@intCast</span>(i),
            .y = <span class="tok-builtin">@intCast</span>(i * <span class="tok-number">2</span>),
        };
    }
    <span class="tok-kw">break</span> :init initial_value;
};
<span class="tok-kw">const</span> Point = <span class="tok-kw">struct</span> {
    x: <span class="tok-type">i32</span>,
    y: <span class="tok-type">i32</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">"compile-time array initialization"</span> {
    <span class="tok-kw">try</span> expect(fancy_array[<span class="tok-number">4</span>].x == <span class="tok-number">4</span>);
    <span class="tok-kw">try</span> expect(fancy_array[<span class="tok-number">4</span>].y == <span class="tok-number">8</span>);
}

<span class="tok-comment">// call a function to initialize an array</span>
<span class="tok-kw">var</span> more_points = [_]Point{makePoint(<span class="tok-number">3</span>)} ** <span class="tok-number">10</span>;
<span class="tok-kw">fn</span> <span class="tok-fn">makePoint</span>(x: <span class="tok-type">i32</span>) Point {
    <span class="tok-kw">return</span> Point{
        .x = x,
        .y = x * <span class="tok-number">2</span>,
    };
}
<span class="tok-kw">test</span> <span class="tok-str">"array initialization with function calls"</span> {
    <span class="tok-kw">try</span> expect(more_points[<span class="tok-number">4</span>].x == <span class="tok-number">3</span>);
    <span class="tok-kw">try</span> expect(more_points[<span class="tok-number">4</span>].y == <span class="tok-number">6</span>);
    <span class="tok-kw">try</span> expect(more_points.len == <span class="tok-number">10</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_arrays.zig</kbd>
1/4 test_arrays.test.iterate over an array...OK
2/4 test_arrays.test.modify an array...OK
3/4 test_arrays.test.compile-time array initialization...OK
4/4 test_arrays.test.array initialization with function calls...OK
All 4 tests passed.
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#for">for</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Slices">Slices</a></li>
</ul>


      <h3 id="Multidimensional-Arrays"><a href="https://ziglang.org/documentation/0.15.2/#toc-Multidimensional-Arrays">Multidimensional Arrays</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Multidimensional-Arrays">§</a></h3>

      <p>
      Multidimensional arrays can be created by nesting arrays:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_multidimensional_arrays.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;
<span class="tok-kw">const</span> expectEqual = std.testing.expectEqual;

<span class="tok-kw">const</span> mat4x5 = [<span class="tok-number">4</span>][<span class="tok-number">5</span>]<span class="tok-type">f32</span>{
    [_]<span class="tok-type">f32</span>{ <span class="tok-number">1.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">0.0</span> },
    [_]<span class="tok-type">f32</span>{ <span class="tok-number">0.0</span>, <span class="tok-number">1.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">1.0</span>, <span class="tok-number">0.0</span> },
    [_]<span class="tok-type">f32</span>{ <span class="tok-number">0.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">1.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">0.0</span> },
    [_]<span class="tok-type">f32</span>{ <span class="tok-number">0.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">1.0</span>, <span class="tok-number">9.9</span> },
};
<span class="tok-kw">test</span> <span class="tok-str">"multidimensional arrays"</span> {
    <span class="tok-comment">// mat4x5 itself is a one-dimensional array of arrays.</span>
    <span class="tok-kw">try</span> expectEqual(mat4x5[<span class="tok-number">1</span>], [_]<span class="tok-type">f32</span>{ <span class="tok-number">0.0</span>, <span class="tok-number">1.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">1.0</span>, <span class="tok-number">0.0</span> });

    <span class="tok-comment">// Access the 2D array by indexing the outer array, and then the inner array.</span>
    <span class="tok-kw">try</span> expect(mat4x5[<span class="tok-number">3</span>][<span class="tok-number">4</span>] == <span class="tok-number">9.9</span>);

    <span class="tok-comment">// Here we iterate with for loops.</span>
    <span class="tok-kw">for</span> (mat4x5, <span class="tok-number">0</span>..) |row, row_index| {
        <span class="tok-kw">for</span> (row, <span class="tok-number">0</span>..) |cell, column_index| {
            <span class="tok-kw">if</span> (row_index == column_index) {
                <span class="tok-kw">try</span> expect(cell == <span class="tok-number">1.0</span>);
            }
        }
    }

    <span class="tok-comment">// Initialize a multidimensional array to zeros.</span>
    <span class="tok-kw">const</span> all_zero: [<span class="tok-number">4</span>][<span class="tok-number">5</span>]<span class="tok-type">f32</span> = .{.{<span class="tok-number">0</span>} ** <span class="tok-number">5</span>} ** <span class="tok-number">4</span>;
    <span class="tok-kw">try</span> expect(all_zero[<span class="tok-number">0</span>][<span class="tok-number">0</span>] == <span class="tok-number">0</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_multidimensional_arrays.zig</kbd>
1/1 test_multidimensional_arrays.test.multidimensional arrays...OK
All 1 tests passed.
</samp></pre></figure>

      

      <h3 id="Sentinel-Terminated-Arrays"><a href="https://ziglang.org/documentation/0.15.2/#toc-Sentinel-Terminated-Arrays">Sentinel-Terminated Arrays</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Sentinel-Terminated-Arrays">§</a></h3>

      <p>
      The syntax <code>[N:x]T</code> describes an array which has a sentinel element of value <code>x</code> at the
      index corresponding to the length <code>N</code>.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_null_terminated_array.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"0-terminated sentinel array"</span> {
    <span class="tok-kw">const</span> array = [_:<span class="tok-number">0</span>]<span class="tok-type">u8</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };

    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(array) == [<span class="tok-number">4</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> expect(array.len == <span class="tok-number">4</span>);
    <span class="tok-kw">try</span> expect(array[<span class="tok-number">4</span>] == <span class="tok-number">0</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"extra 0s in 0-terminated sentinel array"</span> {
    <span class="tok-comment">// The sentinel value may appear earlier, but does not influence the compile-time 'len'.</span>
    <span class="tok-kw">const</span> array = [_:<span class="tok-number">0</span>]<span class="tok-type">u8</span>{ <span class="tok-number">1</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">4</span> };

    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(array) == [<span class="tok-number">4</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> expect(array.len == <span class="tok-number">4</span>);
    <span class="tok-kw">try</span> expect(array[<span class="tok-number">4</span>] == <span class="tok-number">0</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_null_terminated_array.zig</kbd>
1/2 test_null_terminated_array.test.0-terminated sentinel array...OK
2/2 test_null_terminated_array.test.extra 0s in 0-terminated sentinel array...OK
All 2 tests passed.
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Sentinel-Terminated-Pointers">Sentinel-Terminated Pointers</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Sentinel-Terminated-Slices">Sentinel-Terminated Slices</a></li>
</ul>

      

      <h3 id="Destructuring-Arrays"><a href="https://ziglang.org/documentation/0.15.2/#toc-Destructuring-Arrays">Destructuring Arrays</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Destructuring-Arrays">§</a></h3>

      <p>
        Arrays can be destructured:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">destructuring_arrays.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;

<span class="tok-kw">fn</span> <span class="tok-fn">swizzleRgbaToBgra</span>(rgba: [<span class="tok-number">4</span>]<span class="tok-type">u8</span>) [<span class="tok-number">4</span>]<span class="tok-type">u8</span> {
    <span class="tok-comment">// readable swizzling by destructuring</span>
    <span class="tok-kw">const</span> r, <span class="tok-kw">const</span> g, <span class="tok-kw">const</span> b, <span class="tok-kw">const</span> a = rgba;
    <span class="tok-kw">return</span> .{ b, g, r, a };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> pos = [_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span> };
    <span class="tok-kw">const</span> x, <span class="tok-kw">const</span> y = pos;
    print(<span class="tok-str">"x = {}, y = {}\n"</span>, .{x, y});

    <span class="tok-kw">const</span> orange: [<span class="tok-number">4</span>]<span class="tok-type">u8</span> = .{ <span class="tok-number">255</span>, <span class="tok-number">165</span>, <span class="tok-number">0</span>, <span class="tok-number">255</span> };
    print(<span class="tok-str">"{any}\n"</span>, .{swizzleRgbaToBgra(orange)});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe destructuring_arrays.zig</kbd>
$ <kbd>./destructuring_arrays</kbd>
x = 1, y = 2
{ 0, 165, 255, 255 }
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Destructuring">Destructuring</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Destructuring-Tuples">Destructuring Tuples</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Destructuring-Vectors">Destructuring Vectors</a></li>
</ul>

      
      

      <h2 id="Vectors"><a href="https://ziglang.org/documentation/0.15.2/#toc-Vectors">Vectors</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Vectors">§</a></h2>

      <p>
      A vector is a group of booleans, <a href="https://ziglang.org/documentation/0.15.2/#Integers">Integers</a>, <a href="https://ziglang.org/documentation/0.15.2/#Floats">Floats</a>, or
      <a href="https://ziglang.org/documentation/0.15.2/#Pointers">Pointers</a> which are operated on in parallel, using SIMD instructions if possible.
      Vector types are created with the builtin function <a href="https://ziglang.org/documentation/0.15.2/#Vector">@Vector</a>.
      </p>
      <p>
      Vectors generally support the same builtin operators as their underlying base types.
      The only exception to this is the keywords `and` and `or` on vectors of bools, since
      these operators affect control flow, which is not allowed for vectors.
      All other operations are performed element-wise, and return a vector of the same length
      as the input vectors. This includes:
      </p>
      <ul>
          <li>Arithmetic (<code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>,
                         <code><span class="tok-builtin">@divFloor</span></code>, <code><span class="tok-builtin">@sqrt</span></code>, <code><span class="tok-builtin">@ceil</span></code>,
                         <code><span class="tok-builtin">@log</span></code>, etc.)</li>
          <li>Bitwise operators (<code>&gt;&gt;</code>, <code>&lt;&lt;</code>, <code>&amp;</code>,
                                 <code>|</code>, <code>~</code>, etc.)</li>
          <li>Comparison operators (<code>&lt;</code>, <code>&gt;</code>, <code>==</code>, etc.)</li>
          <li>Boolean not (<code>!</code>)</li>
      </ul>
      <p>
      It is prohibited to use a math operator on a mixture of scalars (individual numbers)
      and vectors. Zig provides the <a href="https://ziglang.org/documentation/0.15.2/#splat">@splat</a> builtin to easily convert from scalars
      to vectors, and it supports <a href="https://ziglang.org/documentation/0.15.2/#reduce">@reduce</a> and array indexing syntax to convert
      from vectors to scalars. Vectors also support assignment to and from fixed-length
      arrays with comptime-known length.
      </p>
      <p>
      For rearranging elements within and between vectors, Zig provides the <a href="https://ziglang.org/documentation/0.15.2/#shuffle">@shuffle</a> and <a href="https://ziglang.org/documentation/0.15.2/#select">@select</a> functions.
      </p>
      <p>
      Operations on vectors shorter than the target machine's native SIMD size will typically compile to single SIMD
      instructions, while vectors longer than the target machine's native SIMD size will compile to multiple SIMD
      instructions. If a given operation doesn't have SIMD support on the target architecture, the compiler will default
      to operating on each vector element one at a time. Zig supports any comptime-known vector length up to 2^32-1,
      although small powers of two (2-64) are most typical. Note that excessively long vector lengths (e.g. 2^20) may
      result in compiler crashes on current versions of Zig.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_vector.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expectEqual = std.testing.expectEqual;

<span class="tok-kw">test</span> <span class="tok-str">"Basic vector usage"</span> {
    <span class="tok-comment">// Vectors have a compile-time known length and base type.</span>
    <span class="tok-kw">const</span> a = <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">i32</span>){ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };
    <span class="tok-kw">const</span> b = <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">i32</span>){ <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span> };

    <span class="tok-comment">// Math operations take place element-wise.</span>
    <span class="tok-kw">const</span> c = a + b;

    <span class="tok-comment">// Individual vector elements can be accessed using array indexing syntax.</span>
    <span class="tok-kw">try</span> expectEqual(<span class="tok-number">6</span>, c[<span class="tok-number">0</span>]);
    <span class="tok-kw">try</span> expectEqual(<span class="tok-number">8</span>, c[<span class="tok-number">1</span>]);
    <span class="tok-kw">try</span> expectEqual(<span class="tok-number">10</span>, c[<span class="tok-number">2</span>]);
    <span class="tok-kw">try</span> expectEqual(<span class="tok-number">12</span>, c[<span class="tok-number">3</span>]);
}

<span class="tok-kw">test</span> <span class="tok-str">"Conversion between vectors, arrays, and slices"</span> {
    <span class="tok-comment">// Vectors and fixed-length arrays can be automatically assigned back and forth</span>
    <span class="tok-kw">const</span> arr1: [<span class="tok-number">4</span>]<span class="tok-type">f32</span> = [_]<span class="tok-type">f32</span>{ <span class="tok-number">1.1</span>, <span class="tok-number">3.2</span>, <span class="tok-number">4.5</span>, <span class="tok-number">5.6</span> };
    <span class="tok-kw">const</span> vec: <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">f32</span>) = arr1;
    <span class="tok-kw">const</span> arr2: [<span class="tok-number">4</span>]<span class="tok-type">f32</span> = vec;
    <span class="tok-kw">try</span> expectEqual(arr1, arr2);

    <span class="tok-comment">// You can also assign from a slice with comptime-known length to a vector using .*</span>
    <span class="tok-kw">const</span> vec2: <span class="tok-builtin">@Vector</span>(<span class="tok-number">2</span>, <span class="tok-type">f32</span>) = arr1[<span class="tok-number">1</span>..<span class="tok-number">3</span>].*;

    <span class="tok-kw">const</span> slice: []<span class="tok-kw">const</span> <span class="tok-type">f32</span> = &amp;arr1;
    <span class="tok-kw">var</span> offset: <span class="tok-type">u32</span> = <span class="tok-number">1</span>; <span class="tok-comment">// var to make it runtime-known</span>
    _ = &amp;offset; <span class="tok-comment">// suppress 'var is never mutated' error</span>
    <span class="tok-comment">// To extract a comptime-known length from a runtime-known offset,</span>
    <span class="tok-comment">// first extract a new slice from the starting offset, then an array of</span>
    <span class="tok-comment">// comptime-known length</span>
    <span class="tok-kw">const</span> vec3: <span class="tok-builtin">@Vector</span>(<span class="tok-number">2</span>, <span class="tok-type">f32</span>) = slice[offset..][<span class="tok-number">0</span>..<span class="tok-number">2</span>].*;
    <span class="tok-kw">try</span> expectEqual(slice[offset], vec2[<span class="tok-number">0</span>]);
    <span class="tok-kw">try</span> expectEqual(slice[offset + <span class="tok-number">1</span>], vec2[<span class="tok-number">1</span>]);
    <span class="tok-kw">try</span> expectEqual(vec2, vec3);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_vector.zig</kbd>
1/2 test_vector.test.Basic vector usage...OK
2/2 test_vector.test.Conversion between vectors, arrays, and slices...OK
All 2 tests passed.
</samp></pre></figure>

      <p>
      TODO talk about C ABI interop<br>
      TODO consider suggesting std.MultiArrayList
      </p>
      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#splat">@splat</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#shuffle">@shuffle</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#select">@select</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#reduce">@reduce</a></li>
</ul>


      <h3 id="Destructuring-Vectors"><a href="https://ziglang.org/documentation/0.15.2/#toc-Destructuring-Vectors">Destructuring Vectors</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Destructuring-Vectors">§</a></h3>

      <p>
        Vectors can be destructured:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">destructuring_vectors.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;

<span class="tok-comment">// emulate punpckldq</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unpack</span>(x: <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">f32</span>), y: <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">f32</span>)) <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">f32</span>) {
    <span class="tok-kw">const</span> a, <span class="tok-kw">const</span> c, _, _ = x;
    <span class="tok-kw">const</span> b, <span class="tok-kw">const</span> d, _, _ = y;
    <span class="tok-kw">return</span> .{ a, b, c, d };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> x: <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">f32</span>) = .{ <span class="tok-number">1.0</span>, <span class="tok-number">2.0</span>, <span class="tok-number">3.0</span>, <span class="tok-number">4.0</span> };
    <span class="tok-kw">const</span> y: <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">f32</span>) = .{ <span class="tok-number">5.0</span>, <span class="tok-number">6.0</span>, <span class="tok-number">7.0</span>, <span class="tok-number">8.0</span> };
    print(<span class="tok-str">"{}"</span>, .{unpack(x, y)});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe destructuring_vectors.zig</kbd>
$ <kbd>./destructuring_vectors</kbd>
{ 1, 5, 2, 6 }
</samp></pre></figure>
      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Destructuring">Destructuring</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Destructuring-Tuples">Destructuring Tuples</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Destructuring-Arrays">Destructuring Arrays</a></li>
</ul>

      

      

      <h2 id="Pointers"><a href="https://ziglang.org/documentation/0.15.2/#toc-Pointers">Pointers</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Pointers">§</a></h2>

      <p>
      Zig has two kinds of pointers: single-item and many-item.
      </p>
      <ul>
          <li><code>*T</code> - single-item pointer to exactly one item.
            <ul>
              <li>Supports deref syntax: <code>ptr.*</code></li>
              <li>Supports slice syntax: <code>ptr[<span class="tok-number">0</span>..<span class="tok-number">1</span>]</code></li>
              <li>Supports pointer subtraction: <code>ptr - ptr</code></li>
            </ul>
          </li>
          <li><code>[*]T</code> - many-item pointer to unknown number of items.
            <ul>
              <li>Supports index syntax: <code>ptr[i]</code></li>
              <li>Supports slice syntax: <code>ptr[start..end]</code> and <code>ptr[start..]</code></li>
              <li>Supports pointer-integer arithmetic: <code>ptr + int</code>, <code>ptr - int</code></li>
              <li>Supports pointer subtraction: <code>ptr - ptr</code></li>
            </ul>
            <code>T</code> must have a known size, which means that it cannot be
            <code><span class="tok-type">anyopaque</span></code> or any other <a href="https://ziglang.org/documentation/0.15.2/#opaque">opaque type</a>.
          </li>
      </ul>
      <p>These types are closely related to <a href="https://ziglang.org/documentation/0.15.2/#Arrays">Arrays</a> and <a href="https://ziglang.org/documentation/0.15.2/#Slices">Slices</a>:</p>
        <ul>
            <li><code>*[N]T</code> - pointer to N items, same as single-item pointer to an array.
            <ul>
                <li>Supports index syntax: <code>array_ptr[i]</code></li>
                <li>Supports slice syntax: <code>array_ptr[start..end]</code></li>
                <li>Supports len property: <code>array_ptr.len</code></li>
                <li>Supports pointer subtraction: <code>array_ptr - array_ptr</code></li>
            </ul>
            </li>
        </ul>
        <ul>
            <li><code>[]T</code> - is a slice (a fat pointer, which contains a pointer of type <code>[*]T</code> and a length).
            <ul>
                <li>Supports index syntax: <code>slice[i]</code></li>
                <li>Supports slice syntax: <code>slice[start..end]</code></li>
                <li>Supports len property: <code>slice.len</code></li>
            </ul>
            </li>
        </ul>
        <p>Use <code>&amp;x</code> to obtain a single-item pointer:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_single_item_pointer.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"address of syntax"</span> {
    <span class="tok-comment">// Get the address of a variable:</span>
    <span class="tok-kw">const</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    <span class="tok-kw">const</span> x_ptr = &amp;x;

    <span class="tok-comment">// Dereference a pointer:</span>
    <span class="tok-kw">try</span> expect(x_ptr.* == <span class="tok-number">1234</span>);

    <span class="tok-comment">// When you get the address of a const variable, you get a const single-item pointer.</span>
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(x_ptr) == *<span class="tok-kw">const</span> <span class="tok-type">i32</span>);

    <span class="tok-comment">// If you want to mutate the value, you'd need an address of a mutable variable:</span>
    <span class="tok-kw">var</span> y: <span class="tok-type">i32</span> = <span class="tok-number">5678</span>;
    <span class="tok-kw">const</span> y_ptr = &amp;y;
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(y_ptr) == *<span class="tok-type">i32</span>);
    y_ptr.* += <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> expect(y_ptr.* == <span class="tok-number">5679</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"pointer array access"</span> {
    <span class="tok-comment">// Taking an address of an individual element gives a</span>
    <span class="tok-comment">// single-item pointer. This kind of pointer</span>
    <span class="tok-comment">// does not support pointer arithmetic.</span>
    <span class="tok-kw">var</span> array = [_]<span class="tok-type">u8</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span>, <span class="tok-number">9</span>, <span class="tok-number">10</span> };
    <span class="tok-kw">const</span> ptr = &amp;array[<span class="tok-number">2</span>];
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(ptr) == *<span class="tok-type">u8</span>);

    <span class="tok-kw">try</span> expect(array[<span class="tok-number">2</span>] == <span class="tok-number">3</span>);
    ptr.* += <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> expect(array[<span class="tok-number">2</span>] == <span class="tok-number">4</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"slice syntax"</span> {
    <span class="tok-comment">// Get a pointer to a variable:</span>
    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    <span class="tok-kw">const</span> x_ptr = &amp;x;

    <span class="tok-comment">// Convert to array pointer using slice syntax:</span>
    <span class="tok-kw">const</span> x_array_ptr = x_ptr[<span class="tok-number">0</span>..<span class="tok-number">1</span>];
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(x_array_ptr) == *[<span class="tok-number">1</span>]<span class="tok-type">i32</span>);

    <span class="tok-comment">// Coerce to many-item pointer:</span>
    <span class="tok-kw">const</span> x_many_ptr: [*]<span class="tok-type">i32</span> = x_array_ptr;
    <span class="tok-kw">try</span> expect(x_many_ptr[<span class="tok-number">0</span>] == <span class="tok-number">1234</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_single_item_pointer.zig</kbd>
1/3 test_single_item_pointer.test.address of syntax...OK
2/3 test_single_item_pointer.test.pointer array access...OK
3/3 test_single_item_pointer.test.slice syntax...OK
All 3 tests passed.
</samp></pre></figure>

      <p>
       Zig supports pointer arithmetic. It's better to assign the pointer to <code>[*]T</code> and increment that variable. For example, directly incrementing the pointer from a slice will corrupt it.
      </p>
