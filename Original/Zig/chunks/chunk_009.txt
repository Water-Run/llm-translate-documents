      <pre><code><span class="tok-builtin">@exp</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Base-e exponential function on a floating point number. Uses a dedicated hardware instruction
      when available.
      </p>
      <p>
      Supports <a href="https://ziglang.org/documentation/0.15.2/#Floats">Floats</a> and <a href="https://ziglang.org/documentation/0.15.2/#Vectors">Vectors</a> of floats.
      </p>
      
      <h3 id="exp2"><a href="https://ziglang.org/documentation/0.15.2/#toc-exp2">@exp2</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#exp2">§</a></h3>

      <pre><code><span class="tok-builtin">@exp2</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Base-2 exponential function on a floating point number. Uses a dedicated hardware instruction
      when available.
      </p>
      <p>
      Supports <a href="https://ziglang.org/documentation/0.15.2/#Floats">Floats</a> and <a href="https://ziglang.org/documentation/0.15.2/#Vectors">Vectors</a> of floats.
      </p>
      
      <h3 id="log"><a href="https://ziglang.org/documentation/0.15.2/#toc-log">@log</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#log">§</a></h3>

      <pre><code><span class="tok-builtin">@log</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Returns the natural logarithm of a floating point number. Uses a dedicated hardware instruction
      when available.
      </p>
      <p>
      Supports <a href="https://ziglang.org/documentation/0.15.2/#Floats">Floats</a> and <a href="https://ziglang.org/documentation/0.15.2/#Vectors">Vectors</a> of floats.
      </p>
      
      <h3 id="log2"><a href="https://ziglang.org/documentation/0.15.2/#toc-log2">@log2</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#log2">§</a></h3>

      <pre><code><span class="tok-builtin">@log2</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Returns the logarithm to the base 2 of a floating point number. Uses a dedicated hardware instruction
      when available.
      </p>
      <p>
      Supports <a href="https://ziglang.org/documentation/0.15.2/#Floats">Floats</a> and <a href="https://ziglang.org/documentation/0.15.2/#Vectors">Vectors</a> of floats.
      </p>
      
      <h3 id="log10"><a href="https://ziglang.org/documentation/0.15.2/#toc-log10">@log10</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#log10">§</a></h3>

      <pre><code><span class="tok-builtin">@log10</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Returns the logarithm to the base 10 of a floating point number. Uses a dedicated hardware instruction
      when available.
      </p>
      <p>
      Supports <a href="https://ziglang.org/documentation/0.15.2/#Floats">Floats</a> and <a href="https://ziglang.org/documentation/0.15.2/#Vectors">Vectors</a> of floats.
      </p>
      
      <h3 id="abs"><a href="https://ziglang.org/documentation/0.15.2/#toc-abs">@abs</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#abs">§</a></h3>

      <pre><code><span class="tok-builtin">@abs</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      Returns the absolute value of an integer or a floating point number. Uses a dedicated hardware instruction
      when available.

      The return type is always an unsigned integer of the same bit width as the operand if the operand is an integer.
      Unsigned integer operands are supported. The builtin cannot overflow for signed integer operands.
      </p>
      <p>
      Supports <a href="https://ziglang.org/documentation/0.15.2/#Floats">Floats</a>, <a href="https://ziglang.org/documentation/0.15.2/#Integers">Integers</a> and <a href="https://ziglang.org/documentation/0.15.2/#Vectors">Vectors</a> of floats or integers.
      </p>
      
      <h3 id="floor"><a href="https://ziglang.org/documentation/0.15.2/#toc-floor">@floor</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#floor">§</a></h3>

      <pre><code><span class="tok-builtin">@floor</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Returns the largest integral value not greater than the given floating point number.
      Uses a dedicated hardware instruction when available.
      </p>
      <p>
      Supports <a href="https://ziglang.org/documentation/0.15.2/#Floats">Floats</a> and <a href="https://ziglang.org/documentation/0.15.2/#Vectors">Vectors</a> of floats.
      </p>
      
      <h3 id="ceil"><a href="https://ziglang.org/documentation/0.15.2/#toc-ceil">@ceil</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#ceil">§</a></h3>

      <pre><code><span class="tok-builtin">@ceil</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Returns the smallest integral value not less than the given floating point number.
      Uses a dedicated hardware instruction when available.
      </p>
      <p>
      Supports <a href="https://ziglang.org/documentation/0.15.2/#Floats">Floats</a> and <a href="https://ziglang.org/documentation/0.15.2/#Vectors">Vectors</a> of floats.
      </p>
      
      <h3 id="trunc"><a href="https://ziglang.org/documentation/0.15.2/#toc-trunc">@trunc</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#trunc">§</a></h3>

      <pre><code><span class="tok-builtin">@trunc</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Rounds the given floating point number to an integer, towards zero.
      Uses a dedicated hardware instruction when available.
      </p>
      <p>
      Supports <a href="https://ziglang.org/documentation/0.15.2/#Floats">Floats</a> and <a href="https://ziglang.org/documentation/0.15.2/#Vectors">Vectors</a> of floats.
      </p>
      
      <h3 id="round"><a href="https://ziglang.org/documentation/0.15.2/#toc-round">@round</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#round">§</a></h3>

      <pre><code><span class="tok-builtin">@round</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Rounds the given floating point number to the nearest integer. If two integers are equally close, rounds away from zero.
      Uses a dedicated hardware instruction when available.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_round_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"@round"</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@round</span>(<span class="tok-number">1.4</span>) == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@round</span>(<span class="tok-number">1.5</span>) == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@round</span>(-<span class="tok-number">1.4</span>) == -<span class="tok-number">1</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@round</span>(-<span class="tok-number">2.5</span>) == -<span class="tok-number">3</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_round_builtin.zig</kbd>
1/1 test_round_builtin.test.@round...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      Supports <a href="https://ziglang.org/documentation/0.15.2/#Floats">Floats</a> and <a href="https://ziglang.org/documentation/0.15.2/#Vectors">Vectors</a> of floats.
      </p>
      

      <h3 id="subWithOverflow"><a href="https://ziglang.org/documentation/0.15.2/#toc-subWithOverflow">@subWithOverflow</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#subWithOverflow">§</a></h3>

      <pre><code><span class="tok-builtin">@subWithOverflow</span>(a: <span class="tok-kw">anytype</span>, b: <span class="tok-kw">anytype</span>) <span class="tok-kw">struct</span> { <span class="tok-builtin">@TypeOf</span>(a, b), <span class="tok-type">u1</span> }</code></pre>
      <p>
      Performs <code>a - b</code> and returns a tuple with the result and a possible overflow bit.
      </p>
      

      <h3 id="tagName"><a href="https://ziglang.org/documentation/0.15.2/#toc-tagName">@tagName</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#tagName">§</a></h3>

      <pre><code><span class="tok-builtin">@tagName</span>(value: <span class="tok-kw">anytype</span>) [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre>
      <p>
      Converts an enum value or union value to a string literal representing the name.</p><p>If the enum is non-exhaustive and the tag value does not map to a name, it invokes safety-checked <a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">Illegal Behavior</a>.
      </p>
      

      <h3 id="This"><a href="https://ziglang.org/documentation/0.15.2/#toc-This">@This</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#This">§</a></h3>

      <pre><code><span class="tok-builtin">@This</span>() <span class="tok-type">type</span></code></pre>
      <p>
      Returns the innermost struct, enum, or union that this function call is inside.
      This can be useful for an anonymous struct that needs to refer to itself:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_this_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"@This()"</span> {
    <span class="tok-kw">var</span> items = [_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };
    <span class="tok-kw">const</span> list = List(<span class="tok-type">i32</span>){ .items = items[<span class="tok-number">0</span>..] };
    <span class="tok-kw">try</span> expect(list.length() == <span class="tok-number">4</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">List</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        items: []T,

        <span class="tok-kw">fn</span> <span class="tok-fn">length</span>(self: Self) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.items.len;
        }
    };
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_this_builtin.zig</kbd>
1/1 test_this_builtin.test.@This()...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      When <code><span class="tok-builtin">@This</span>()</code> is used at file scope, it returns a reference to the
      struct that corresponds to the current file.
      </p>
      

      <h3 id="trap"><a href="https://ziglang.org/documentation/0.15.2/#toc-trap">@trap</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#trap">§</a></h3>

      <pre><code><span class="tok-builtin">@trap</span>() <span class="tok-type">noreturn</span></code></pre>
      <p>
      This function inserts a platform-specific trap/jam instruction which can be used to exit the program abnormally.
      This may be implemented by explicitly emitting an invalid instruction which may cause an illegal instruction exception of some sort.
      Unlike for <code><span class="tok-builtin">@breakpoint</span>()</code>, execution does not continue after this point.
      </p>
      <p>
      Outside function scope, this builtin causes a compile error.
      </p>
      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#breakpoint">@breakpoint</a></li>
</ul>

      

      <h3 id="truncate"><a href="https://ziglang.org/documentation/0.15.2/#toc-truncate">@truncate</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#truncate">§</a></h3>

      <pre><code><span class="tok-builtin">@truncate</span>(integer: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      This function truncates bits from an integer type, resulting in a smaller
      or same-sized integer type. The return type is the inferred result type.
      </p>
      <p>
      This function always truncates the significant bits of the integer, regardless
      of endianness on the target platform.
      </p>
      <p>
      Calling <code><span class="tok-builtin">@truncate</span></code> on a number out of range of the destination type is well defined and working code:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_truncate_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"integer truncation"</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">u16</span> = <span class="tok-number">0xabcd</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">u8</span> = <span class="tok-builtin">@truncate</span>(a);
    <span class="tok-kw">try</span> expect(b == <span class="tok-number">0xcd</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_truncate_builtin.zig</kbd>
1/1 test_truncate_builtin.test.integer truncation...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      Use <a href="https://ziglang.org/documentation/0.15.2/#intCast">@intCast</a> to convert numbers guaranteed to fit the destination type.
      </p>
      

      <h3 id="Type"><a href="https://ziglang.org/documentation/0.15.2/#toc-Type">@Type</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Type">§</a></h3>

      <pre><code><span class="tok-builtin">@Type</span>(<span class="tok-kw">comptime</span> info: std.builtin.Type) <span class="tok-type">type</span></code></pre>
      <p>
      This function is the inverse of <a href="https://ziglang.org/documentation/0.15.2/#typeInfo">@typeInfo</a>. It reifies type information
      into a <code><span class="tok-type">type</span></code>.
      </p>
      <p>
      It is available for the following types:
      </p>
      <ul>
          <li><code><span class="tok-type">type</span></code></li>
          <li><code><span class="tok-type">noreturn</span></code></li>
          <li><code><span class="tok-type">void</span></code></li>
          <li><code><span class="tok-type">bool</span></code></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">Integers</a> - The maximum bit count for an integer type is <code><span class="tok-number">65535</span></code>.</li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#Floats">Floats</a></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#Pointers">Pointers</a></li>
          <li><code><span class="tok-type">comptime_int</span></code></li>
          <li><code><span class="tok-type">comptime_float</span></code></li>
          <li><code><span class="tok-builtin">@TypeOf</span>(<span class="tok-null">undefined</span>)</code></li>
          <li><code><span class="tok-builtin">@TypeOf</span>(<span class="tok-null">null</span>)</code></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#Arrays">Arrays</a></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#Optionals">Optionals</a></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#Error-Set-Type">Error Set Type</a></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#Error-Union-Type">Error Union Type</a></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#Vectors">Vectors</a></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#opaque">opaque</a></li>
          <li><code><span class="tok-kw">anyframe</span></code></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#struct">struct</a></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#enum">enum</a></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#Enum-Literals">Enum Literals</a></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#union">union</a></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#Functions">Functions</a></li>
      </ul>
      
      <h3 id="typeInfo"><a href="https://ziglang.org/documentation/0.15.2/#toc-typeInfo">@typeInfo</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#typeInfo">§</a></h3>

      <pre><code><span class="tok-builtin">@typeInfo</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) std.builtin.Type</code></pre>
      <p>
      Provides type reflection.
      </p>
      <p>
      Type information of <a href="https://ziglang.org/documentation/0.15.2/#struct">structs</a>, <a href="https://ziglang.org/documentation/0.15.2/#union">unions</a>, <a href="https://ziglang.org/documentation/0.15.2/#enum">enums</a>, and
      <a href="https://ziglang.org/documentation/0.15.2/#Error-Set-Type">error sets</a> has fields which are guaranteed to be in the same
      order as appearance in the source file.
      </p>
      <p>
      Type information of <a href="https://ziglang.org/documentation/0.15.2/#struct">structs</a>, <a href="https://ziglang.org/documentation/0.15.2/#union">unions</a>, <a href="https://ziglang.org/documentation/0.15.2/#enum">enums</a>, and
      <a href="https://ziglang.org/documentation/0.15.2/#opaque">opaques</a> has declarations, which are also guaranteed to be in the same
      order as appearance in the source file.
      </p>
      

      <h3 id="typeName"><a href="https://ziglang.org/documentation/0.15.2/#toc-typeName">@typeName</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#typeName">§</a></h3>

      <pre><code><span class="tok-builtin">@typeName</span>(T: <span class="tok-type">type</span>) *<span class="tok-kw">const</span> [N:<span class="tok-number">0</span>]<span class="tok-type">u8</span></code></pre>
      <p>
      This function returns the string representation of a type, as
      an array. It is equivalent to a string literal of the type name.
      The returned type name is fully qualified with the parent namespace included
      as part of the type name with a series of dots.
      </p>
      

      <h3 id="TypeOf"><a href="https://ziglang.org/documentation/0.15.2/#toc-TypeOf">@TypeOf</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#TypeOf">§</a></h3>

      <pre><code><span class="tok-builtin">@TypeOf</span>(...) <span class="tok-type">type</span></code></pre>
      <p>
      <code><span class="tok-builtin">@TypeOf</span></code> is a special builtin function that takes any (non-zero) number of expressions
      as parameters and returns the type of the result, using <a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">Peer Type Resolution</a>.
      </p>
      <p>
      The expressions are evaluated, however they are guaranteed to have no <em>runtime</em> side-effects:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_TypeOf_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"no runtime side effects"</span> {
    <span class="tok-kw">var</span> data: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> T = <span class="tok-builtin">@TypeOf</span>(foo(<span class="tok-type">i32</span>, &amp;data));
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> expect(T == <span class="tok-type">i32</span>);
    <span class="tok-kw">try</span> expect(data == <span class="tok-number">0</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *T) T {
    ptr.* += <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> ptr.*;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_TypeOf_builtin.zig</kbd>
1/1 test_TypeOf_builtin.test.no runtime side effects...OK
All 1 tests passed.
</samp></pre></figure>

      

      <h3 id="unionInit"><a href="https://ziglang.org/documentation/0.15.2/#toc-unionInit">@unionInit</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#unionInit">§</a></h3>

      <pre><code><span class="tok-builtin">@unionInit</span>(<span class="tok-kw">comptime</span> Union: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> active_field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, init_expr) Union</code></pre>
      <p>
      This is the same thing as <a href="https://ziglang.org/documentation/0.15.2/#union">union</a> initialization syntax, except that the field name is a
      <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a>-known value rather than an identifier token.
      </p>
      <p>
      <code><span class="tok-builtin">@unionInit</span></code> forwards its <a href="https://ziglang.org/documentation/0.15.2/#Result-Location-Semantics">result location</a> to <code>init_expr</code>.
      </p>
      


      <h3 id="Vector"><a href="https://ziglang.org/documentation/0.15.2/#toc-Vector">@Vector</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Vector">§</a></h3>

      <pre><code><span class="tok-builtin">@Vector</span>(len: <span class="tok-type">comptime_int</span>, Element: <span class="tok-type">type</span>) <span class="tok-type">type</span></code></pre>
      <p>Creates <a href="https://ziglang.org/documentation/0.15.2/#Vectors">Vectors</a>.</p>
      

      <h3 id="volatileCast"><a href="https://ziglang.org/documentation/0.15.2/#toc-volatileCast">@volatileCast</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#volatileCast">§</a></h3>

      <pre><code><span class="tok-builtin">@volatileCast</span>(value: <span class="tok-kw">anytype</span>) DestType</code></pre>
      <p>
      Remove <code><span class="tok-kw">volatile</span></code> qualifier from a pointer.
      </p>
      

      <h3 id="workGroupId"><a href="https://ziglang.org/documentation/0.15.2/#toc-workGroupId">@workGroupId</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#workGroupId">§</a></h3>

      <pre><code><span class="tok-builtin">@workGroupId</span>(<span class="tok-kw">comptime</span> dimension: <span class="tok-type">u32</span>) <span class="tok-type">u32</span></code></pre>
      <p>
      Returns the index of the work group in the current kernel invocation in dimension <code>dimension</code>.
      </p>
      

      <h3 id="workGroupSize"><a href="https://ziglang.org/documentation/0.15.2/#toc-workGroupSize">@workGroupSize</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#workGroupSize">§</a></h3>

      <pre><code><span class="tok-builtin">@workGroupSize</span>(<span class="tok-kw">comptime</span> dimension: <span class="tok-type">u32</span>) <span class="tok-type">u32</span></code></pre>
      <p>
      Returns the number of work items that a work group has in dimension <code>dimension</code>.
      </p>
      

      <h3 id="workItemId"><a href="https://ziglang.org/documentation/0.15.2/#toc-workItemId">@workItemId</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#workItemId">§</a></h3>

      <pre><code><span class="tok-builtin">@workItemId</span>(<span class="tok-kw">comptime</span> dimension: <span class="tok-type">u32</span>) <span class="tok-type">u32</span></code></pre>
      <p>
      Returns the index of the work item in the work group in dimension <code>dimension</code>. This function returns values between <code><span class="tok-number">0</span></code> (inclusive) and <code><span class="tok-builtin">@workGroupSize</span>(dimension)</code> (exclusive).
      </p>
      

      

      <h2 id="Build-Mode"><a href="https://ziglang.org/documentation/0.15.2/#toc-Build-Mode">Build Mode</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Build-Mode">§</a></h2>

      <p>
      Zig has four build modes:
      </p>
      <ul>
        <li><a href="https://ziglang.org/documentation/0.15.2/#Debug">Debug</a> (default)</li>
        <li><a href="https://ziglang.org/documentation/0.15.2/#ReleaseFast">ReleaseFast</a></li>
        <li><a href="https://ziglang.org/documentation/0.15.2/#ReleaseSafe">ReleaseSafe</a></li>
        <li><a href="https://ziglang.org/documentation/0.15.2/#ReleaseSmall">ReleaseSmall</a></li>
      </ul>
      <p>
      To add standard build options to a <code class="file">build.zig</code> file:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">build.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">build</span>(b: *std.Build) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> optimize = b.standardOptimizeOption(.{});
    <span class="tok-kw">const</span> exe = b.addExecutable(.{
        .name = <span class="tok-str">"example"</span>,
        .root_module = b.createModule(.{
            .root_source_file = b.path(<span class="tok-str">"example.zig"</span>),
            .optimize = optimize,
        }),
    });
    b.default_step.dependOn(&amp;exe.step);
}</code></pre></figure>

      <p>
      This causes these options to be available:
      </p>
      <dl>
        <dt><kbd>-Doptimize=Debug</kbd></dt><dd>Optimizations off and safety on (default)</dd>
        <dt><kbd>-Doptimize=ReleaseSafe</kbd></dt><dd>Optimizations on and safety on</dd>
        <dt><kbd>-Doptimize=ReleaseFast</kbd></dt><dd>Optimizations on and safety off</dd>
        <dt><kbd>-Doptimize=ReleaseSmall</kbd></dt><dd>Size optimizations on and safety off</dd>
      </dl>
      <h3 id="Debug"><a href="https://ziglang.org/documentation/0.15.2/#toc-Debug">Debug</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Debug">§</a></h3>

      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe example.zig</kbd>
</samp></pre></figure>
      <ul>
        <li>Fast compilation speed</li>
        <li>Safety checks enabled</li>
        <li>Slow runtime performance</li>
        <li>Large binary size</li>
        <li>No reproducible build requirement</li>
      </ul>
      
      <h3 id="ReleaseFast"><a href="https://ziglang.org/documentation/0.15.2/#toc-ReleaseFast">ReleaseFast</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#ReleaseFast">§</a></h3>

      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe example.zig -O ReleaseFast</kbd>
</samp></pre></figure>
      <ul>
        <li>Fast runtime performance</li>
        <li>Safety checks disabled</li>
        <li>Slow compilation speed</li>
        <li>Large binary size</li>
        <li>Reproducible build</li>
      </ul>
      
      <h3 id="ReleaseSafe"><a href="https://ziglang.org/documentation/0.15.2/#toc-ReleaseSafe">ReleaseSafe</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#ReleaseSafe">§</a></h3>

      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe example.zig -O ReleaseSafe</kbd>
</samp></pre></figure>
      <ul>
        <li>Medium runtime performance</li>
        <li>Safety checks enabled</li>
        <li>Slow compilation speed</li>
        <li>Large binary size</li>
        <li>Reproducible build</li>
      </ul>
      
      <h3 id="ReleaseSmall"><a href="https://ziglang.org/documentation/0.15.2/#toc-ReleaseSmall">ReleaseSmall</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#ReleaseSmall">§</a></h3>

      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe example.zig -O ReleaseSmall</kbd>
</samp></pre></figure>
      <ul>
        <li>Medium runtime performance</li>
        <li>Safety checks disabled</li>
        <li>Slow compilation speed</li>
        <li>Small binary size</li>
        <li>Reproducible build</li>
      </ul>
      
      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Compile-Variables">Compile Variables</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Zig-Build-System">Zig Build System</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">Illegal Behavior</a></li>
</ul>

      

      <h2 id="Single-Threaded-Builds"><a href="https://ziglang.org/documentation/0.15.2/#toc-Single-Threaded-Builds">Single Threaded Builds</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Single-Threaded-Builds">§</a></h2>

      <p>Zig has a compile option <kbd>-fsingle-threaded</kbd> which has the following effects:</p>
      <ul>
        <li>All <a href="https://ziglang.org/documentation/0.15.2/#Thread-Local-Variables">Thread Local Variables</a> are treated as regular <a href="https://ziglang.org/documentation/0.15.2/#Container-Level-Variables">Container Level Variables</a>.</li>
        <li>The overhead of <a href="https://ziglang.org/documentation/0.15.2/#Async-Functions">Async Functions</a> becomes equivalent to function call overhead.</li>
        <li>The <code><span class="tok-builtin">@import</span>(<span class="tok-str">"builtin"</span>).single_threaded</code> becomes <code><span class="tok-null">true</span></code>
          and therefore various userland APIs which read this variable become more efficient.
          For example <code>std.Mutex</code> becomes
          an empty data structure and all of its functions become no-ops.</li>
      </ul>
      

      <h2 id="Illegal-Behavior"><a href="https://ziglang.org/documentation/0.15.2/#toc-Illegal-Behavior">Illegal Behavior</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">§</a></h2>

      <p>
      Many operations in Zig trigger what is known as "Illegal Behavior" (IB). If Illegal Behavior is detected at
      compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught
      at compile-time, it falls into one of two categories.
      </p>
      <p>
      Some Illegal Behavior is <em>safety-checked</em>: this means that the compiler will insert "safety checks"
      anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it
      is, the safety check "fails", which triggers a panic.
      </p>
      <p>
      All other Illegal Behavior is <em>unchecked</em>, meaning the compiler is unable to insert safety checks for
      it. If Unchecked Illegal Behavior is invoked at runtime, anything can happen: usually that will be some kind of
      crash, but the optimizer is free to make Unchecked Illegal Behavior do anything, such as calling arbitrary functions
      or clobbering arbitrary data. This is similar to the concept of "undefined behavior" in some other languages. Note that
      Unchecked Illegal Behavior still always results in a compile error if evaluated at <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a>, because the Zig
      compiler is able to perform more sophisticated checks at compile-time than at runtime.
      </p>
      <p>
      Most Illegal Behavior is safety-checked. However, to facilitate optimizations, safety checks are disabled by default
      in the <a href="https://ziglang.org/documentation/0.15.2/#ReleaseFast">ReleaseFast</a> and <a href="https://ziglang.org/documentation/0.15.2/#ReleaseSmall">ReleaseSmall</a> optimization modes. Safety checks can also be enabled or disabled
      on a per-block basis, overriding the default for the current optimization mode, using <a href="https://ziglang.org/documentation/0.15.2/#setRuntimeSafety">@setRuntimeSafety</a>. When
      safety checks are disabled, Safety-Checked Illegal Behavior behaves like Unchecked Illegal Behavior; that is, any behavior
      may result from invoking it.
      </p>
      <p>
      When a safety check fails, Zig's default panic handler crashes with a stack trace, like this:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_illegal_behavior.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">"safety check"</span> {
    <span class="tok-kw">unreachable</span>;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_illegal_behavior.zig</kbd>
1/1 test_illegal_behavior.test.safety check...thread 2892891 panic: reached unreachable code
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_illegal_behavior.zig:2:5</span>: <span class="sgr-2m">0x102c00c in test.safety check (test_illegal_behavior.zig)</span>
    unreachable;
    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:218:25</span>: <span class="sgr-2m">0x115cb20 in mainTerminal (test_runner.zig)</span>
        if (test_fn.func()) |_| {
                        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:66:28</span>: <span class="sgr-2m">0x1155d41 in main (test_runner.zig)</span>
        return mainTerminal();
                           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x114fadd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x114f371 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
error: the following test command crashed:
/home/andy/dev/zig/.zig-cache/o/e72b27fd3a681a218f2215fb6e7fd433/test --seed=0xeebe2201
</samp></pre></figure>

      <h3 id="Reaching-Unreachable-Code"><a href="https://ziglang.org/documentation/0.15.2/#toc-Reaching-Unreachable-Code">Reaching Unreachable Code</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Reaching-Unreachable-Code">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_reaching_unreachable.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    assert(<span class="tok-null">false</span>);
}
<span class="tok-kw">fn</span> <span class="tok-fn">assert</span>(ok: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!ok) <span class="tok-kw">unreachable</span>; <span class="tok-comment">// assertion failure</span>
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_reaching_unreachable.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_reaching_unreachable.zig:5:14: </span><span class="sgr-31m">error: </span><span class="sgr-1m">reached unreachable code
</span>    if (!ok) unreachable; // assertion failure
             <span class="sgr-32m">^~~~~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_reaching_unreachable.zig:2:11: </span><span class="sgr-36m">note: </span><span class="sgr-1m">called at comptime here
</span>    assert(false);
    <span class="sgr-32m">~~~~~~^~~~~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_reaching_unreachable.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    std.debug.assert(<span class="tok-null">false</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_reaching_unreachable.zig</kbd>
$ <kbd>./runtime_reaching_unreachable</kbd>
thread 2897013 panic: reached unreachable code
<span class="sgr-1m">/home/andy/dev/zig/lib/std/debug.zig:559:14</span>: <span class="sgr-2m">0x1044179 in assert (std.zig)</span>
    if (!ok) unreachable; // assertion failure
             <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_reaching_unreachable.zig:4:21</span>: <span class="sgr-2m">0x113e86e in main (runtime_reaching_unreachable.zig)</span>
    std.debug.assert(false);
                    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      
      <h3 id="Index-out-of-Bounds"><a href="https://ziglang.org/documentation/0.15.2/#toc-Index-out-of-Bounds">Index out of Bounds</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Index-out-of-Bounds">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_index_out_of_bounds.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> array: [<span class="tok-number">5</span>]<span class="tok-type">u8</span> = <span class="tok-str">"hello"</span>.*;
    <span class="tok-kw">const</span> garbage = array[<span class="tok-number">5</span>];
    _ = garbage;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_index_out_of_bounds.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_index_out_of_bounds.zig:3:27: </span><span class="sgr-31m">error: </span><span class="sgr-1m">index 5 outside array of length 5
</span>    const garbage = array[5];
                          <span class="sgr-32m">^
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_index_out_of_bounds.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> x = foo(<span class="tok-str">"hello"</span>);
    _ = x;
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(x: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> x[<span class="tok-number">5</span>];
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_index_out_of_bounds.zig</kbd>
$ <kbd>./runtime_index_out_of_bounds</kbd>
thread 2893998 panic: index out of bounds: index 5, len 5
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_index_out_of_bounds.zig:7:13</span>: <span class="sgr-2m">0x113fae6 in foo (runtime_index_out_of_bounds.zig)</span>
    return x[5];
            <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_index_out_of_bounds.zig:2:18</span>: <span class="sgr-2m">0x113e87a in main (runtime_index_out_of_bounds.zig)</span>
    const x = foo("hello");
                 <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      
      <h3 id="Cast-Negative-Number-to-Unsigned-Integer"><a href="https://ziglang.org/documentation/0.15.2/#toc-Cast-Negative-Number-to-Unsigned-Integer">Cast Negative Number to Unsigned Integer</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Cast-Negative-Number-to-Unsigned-Integer">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_invalid_cast.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> value: <span class="tok-type">i32</span> = -<span class="tok-number">1</span>;
    <span class="tok-kw">const</span> unsigned: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(value);
    _ = unsigned;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_invalid_cast.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_invalid_cast.zig:3:36: </span><span class="sgr-31m">error: </span><span class="sgr-1m">type 'u32' cannot represent integer value '-1'
</span>    const unsigned: u32 = @intCast(value);
                                   <span class="sgr-32m">^~~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_invalid_cast.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> value: <span class="tok-type">i32</span> = -<span class="tok-number">1</span>; <span class="tok-comment">// runtime-known</span>
    _ = &amp;value;
    <span class="tok-kw">const</span> unsigned: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(value);
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{unsigned});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_invalid_cast.zig</kbd>
$ <kbd>./runtime_invalid_cast</kbd>
thread 2899906 panic: integer does not fit in destination type
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_invalid_cast.zig:6:27</span>: <span class="sgr-2m">0x113e87f in main (runtime_invalid_cast.zig)</span>
    const unsigned: u32 = @intCast(value);
                          <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      <p>
      To obtain the maximum value of an unsigned integer, use <code>std.math.maxInt</code>.
      </p>
      
      <h3 id="Cast-Truncates-Data"><a href="https://ziglang.org/documentation/0.15.2/#toc-Cast-Truncates-Data">Cast Truncates Data</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Cast-Truncates-Data">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_invalid_cast_truncate.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> spartan_count: <span class="tok-type">u16</span> = <span class="tok-number">300</span>;
    <span class="tok-kw">const</span> byte: <span class="tok-type">u8</span> = <span class="tok-builtin">@intCast</span>(spartan_count);
    _ = byte;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_invalid_cast_truncate.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_invalid_cast_truncate.zig:3:31: </span><span class="sgr-31m">error: </span><span class="sgr-1m">type 'u8' cannot represent integer value '300'
</span>    const byte: u8 = @intCast(spartan_count);
                              <span class="sgr-32m">^~~~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_invalid_cast_truncate.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> spartan_count: <span class="tok-type">u16</span> = <span class="tok-number">300</span>; <span class="tok-comment">// runtime-known</span>
    _ = &amp;spartan_count;
    <span class="tok-kw">const</span> byte: <span class="tok-type">u8</span> = <span class="tok-builtin">@intCast</span>(spartan_count);
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{byte});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_invalid_cast_truncate.zig</kbd>
$ <kbd>./runtime_invalid_cast_truncate</kbd>
thread 2899317 panic: integer does not fit in destination type
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_invalid_cast_truncate.zig:6:22</span>: <span class="sgr-2m">0x113e880 in main (runtime_invalid_cast_truncate.zig)</span>
    const byte: u8 = @intCast(spartan_count);
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      <p>
      To truncate bits, use <a href="https://ziglang.org/documentation/0.15.2/#truncate">@truncate</a>.
      </p>
      
      <h3 id="Integer-Overflow"><a href="https://ziglang.org/documentation/0.15.2/#toc-Integer-Overflow">Integer Overflow</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Integer-Overflow">§</a></h3>

      <h4 id="Default-Operations"><a href="https://ziglang.org/documentation/0.15.2/#toc-Default-Operations">Default Operations</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Default-Operations">§</a></h4>

      <p>The following operators can cause integer overflow:</p>
      <ul>
          <li><code>+</code> (addition)</li>
          <li><code>-</code> (subtraction)</li>
          <li><code>-</code> (negation)</li>
          <li><code>*</code> (multiplication)</li>
          <li><code>/</code> (division)</li>
        <li><a href="https://ziglang.org/documentation/0.15.2/#divTrunc">@divTrunc</a> (division)</li>
        <li><a href="https://ziglang.org/documentation/0.15.2/#divFloor">@divFloor</a> (division)</li>
        <li><a href="https://ziglang.org/documentation/0.15.2/#divExact">@divExact</a> (division)</li>
      </ul>
      <p>Example with addition at compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_overflow.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">var</span> byte: <span class="tok-type">u8</span> = <span class="tok-number">255</span>;
    byte += <span class="tok-number">1</span>;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_overflow.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_overflow.zig:3:10: </span><span class="sgr-31m">error: </span><span class="sgr-1m">overflow of integer type 'u8' with value '256'
</span>    byte += 1;
    <span class="sgr-32m">~~~~~^~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_overflow.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> byte: <span class="tok-type">u8</span> = <span class="tok-number">255</span>;
    byte += <span class="tok-number">1</span>;
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{byte});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_overflow.zig</kbd>
$ <kbd>./runtime_overflow</kbd>
thread 2892886 panic: integer overflow
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_overflow.zig:5:10</span>: <span class="sgr-2m">0x113e895 in main (runtime_overflow.zig)</span>
    byte += 1;
         <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      
      <h4 id="Standard-Library-Math-Functions"><a href="https://ziglang.org/documentation/0.15.2/#toc-Standard-Library-Math-Functions">Standard Library Math Functions</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Standard-Library-Math-Functions">§</a></h4>

      <p>These functions provided by the standard library return possible errors.</p>
      <ul>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).math.add</code></li>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).math.sub</code></li>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).math.mul</code></li>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).math.divTrunc</code></li>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).math.divFloor</code></li>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).math.divExact</code></li>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).math.shl</code></li>
      </ul>
      <p>Example of catching an overflow for addition:</p>
      <figure><figcaption class="zig-cap"><cite class="file">math_add.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> math = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).math;
<span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> byte: <span class="tok-type">u8</span> = <span class="tok-number">255</span>;

    byte = <span class="tok-kw">if</span> (math.add(<span class="tok-type">u8</span>, byte, <span class="tok-number">1</span>)) |result| result <span class="tok-kw">else</span> |err| {
        print(<span class="tok-str">"unable to add one: {s}\n"</span>, .{<span class="tok-builtin">@errorName</span>(err)});
        <span class="tok-kw">return</span> err;
    };

    print(<span class="tok-str">"result: {}\n"</span>, .{byte});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe math_add.zig</kbd>
$ <kbd>./math_add</kbd>
unable to add one: Overflow
error: Overflow
<span class="sgr-1m">/home/andy/dev/zig/lib/std/math.zig:570:21</span>: <span class="sgr-2m">0x113ebae in add__anon_22552 (std.zig)</span>
    if (ov[1] != 0) return error.Overflow;
                    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/math_add.zig:8:9</span>: <span class="sgr-2m">0x113d422 in main (math_add.zig)</span>
        return err;
        <span class="sgr-32m">^</span>
</samp></pre></figure>

      
      <h4 id="Builtin-Overflow-Functions"><a href="https://ziglang.org/documentation/0.15.2/#toc-Builtin-Overflow-Functions">Builtin Overflow Functions</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Builtin-Overflow-Functions">§</a></h4>

      <p>
      These builtins return a tuple containing whether there was an overflow
      (as a <code><span class="tok-type">u1</span></code>) and the possibly overflowed bits of the operation:
      </p>
      <ul>
          <li><a href="https://ziglang.org/documentation/0.15.2/#addWithOverflow">@addWithOverflow</a></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#subWithOverflow">@subWithOverflow</a></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#mulWithOverflow">@mulWithOverflow</a></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#shlWithOverflow">@shlWithOverflow</a></li>
      </ul>
      <p>
      Example of <a href="https://ziglang.org/documentation/0.15.2/#addWithOverflow">@addWithOverflow</a>:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">addWithOverflow_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> byte: <span class="tok-type">u8</span> = <span class="tok-number">255</span>;

    <span class="tok-kw">const</span> ov = <span class="tok-builtin">@addWithOverflow</span>(byte, <span class="tok-number">10</span>);
    <span class="tok-kw">if</span> (ov[<span class="tok-number">1</span>] != <span class="tok-number">0</span>) {
        print(<span class="tok-str">"overflowed result: {}\n"</span>, .{ov[<span class="tok-number">0</span>]});
    } <span class="tok-kw">else</span> {
        print(<span class="tok-str">"result: {}\n"</span>, .{ov[<span class="tok-number">0</span>]});
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe addWithOverflow_builtin.zig</kbd>
$ <kbd>./addWithOverflow_builtin</kbd>
overflowed result: 9
</samp></pre></figure>

      
      <h4 id="Wrapping-Operations"><a href="https://ziglang.org/documentation/0.15.2/#toc-Wrapping-Operations">Wrapping Operations</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Wrapping-Operations">§</a></h4>

      <p>
      These operations have guaranteed wraparound semantics.
      </p>
      <ul>
          <li><code>+%</code> (wraparound addition)</li>
          <li><code>-%</code> (wraparound subtraction)</li>
          <li><code>-%</code> (wraparound negation)</li>
          <li><code>*%</code> (wraparound multiplication)</li>
      </ul>
      <figure><figcaption class="zig-cap"><cite class="file">test_wraparound_semantics.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;
<span class="tok-kw">const</span> minInt = std.math.minInt;
<span class="tok-kw">const</span> maxInt = std.math.maxInt;

<span class="tok-kw">test</span> <span class="tok-str">"wraparound addition and subtraction"</span> {
    <span class="tok-kw">const</span> x: <span class="tok-type">i32</span> = maxInt(<span class="tok-type">i32</span>);
    <span class="tok-kw">const</span> min_val = x +% <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> expect(min_val == minInt(<span class="tok-type">i32</span>));
    <span class="tok-kw">const</span> max_val = min_val -% <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> expect(max_val == maxInt(<span class="tok-type">i32</span>));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_wraparound_semantics.zig</kbd>
1/1 test_wraparound_semantics.test.wraparound addition and subtraction...OK
All 1 tests passed.
</samp></pre></figure>

      
      
      <h3 id="Exact-Left-Shift-Overflow"><a href="https://ziglang.org/documentation/0.15.2/#toc-Exact-Left-Shift-Overflow">Exact Left Shift Overflow</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Exact-Left-Shift-Overflow">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_shlExact_overflow.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> x = <span class="tok-builtin">@shlExact</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0b01010101</span>), <span class="tok-number">2</span>);
    _ = x;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_shlExact_overflow.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_shlExact_overflow.zig:2:15: </span><span class="sgr-31m">error: </span><span class="sgr-1m">overflow of integer type 'u8' with value '340'
</span>    const x = @shlExact(@as(u8, 0b01010101), 2);
              <span class="sgr-32m">^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_shlExact_overflow.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">u8</span> = <span class="tok-number">0b01010101</span>; <span class="tok-comment">// runtime-known</span>
    _ = &amp;x;
    <span class="tok-kw">const</span> y = <span class="tok-builtin">@shlExact</span>(x, <span class="tok-number">2</span>);
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{y});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_shlExact_overflow.zig</kbd>
$ <kbd>./runtime_shlExact_overflow</kbd>
thread 2896313 panic: left shift overflowed bits
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_shlExact_overflow.zig:6:5</span>: <span class="sgr-2m">0x113e8a1 in main (runtime_shlExact_overflow.zig)</span>
    const y = @shlExact(x, 2);
    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      
      <h3 id="Exact-Right-Shift-Overflow"><a href="https://ziglang.org/documentation/0.15.2/#toc-Exact-Right-Shift-Overflow">Exact Right Shift Overflow</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Exact-Right-Shift-Overflow">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_shrExact_overflow.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> x = <span class="tok-builtin">@shrExact</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0b10101010</span>), <span class="tok-number">2</span>);
    _ = x;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_shrExact_overflow.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_shrExact_overflow.zig:2:15: </span><span class="sgr-31m">error: </span><span class="sgr-1m">exact shift shifted out 1 bits
</span>    const x = @shrExact(@as(u8, 0b10101010), 2);
              <span class="sgr-32m">^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_shrExact_overflow.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">"builtin"</span>);
<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">u8</span> = <span class="tok-number">0b10101010</span>; <span class="tok-comment">// runtime-known</span>
    _ = &amp;x;
    <span class="tok-kw">const</span> y = <span class="tok-builtin">@shrExact</span>(x, <span class="tok-number">2</span>);
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{y});

    <span class="tok-kw">if</span> (builtin.cpu.arch.isRISCV() <span class="tok-kw">and</span> builtin.zig_backend == .stage2_llvm) <span class="tok-builtin">@panic</span>(<span class="tok-str">"https://github.com/ziglang/zig/issues/24304"</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_shrExact_overflow.zig</kbd>
$ <kbd>./runtime_shrExact_overflow</kbd>
thread 2897712 panic: right shift overflowed bits
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_shrExact_overflow.zig:7:5</span>: <span class="sgr-2m">0x113e88a in main (runtime_shrExact_overflow.zig)</span>
    const y = @shrExact(x, 2);
    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      
      <h3 id="Division-by-Zero"><a href="https://ziglang.org/documentation/0.15.2/#toc-Division-by-Zero">Division by Zero</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Division-by-Zero">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_division_by_zero.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> c = a / b;
    _ = c;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_division_by_zero.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_division_by_zero.zig:4:19: </span><span class="sgr-31m">error: </span><span class="sgr-1m">division by zero here causes illegal behavior
</span>    const c = a / b;
                  <span class="sgr-32m">^
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_division_by_zero.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u32</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">var</span> b: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    _ = .{ &amp;a, &amp;b };
    <span class="tok-kw">const</span> c = a / b;
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{c});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_division_by_zero.zig</kbd>
$ <kbd>./runtime_division_by_zero</kbd>
thread 2902461 panic: division by zero
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_division_by_zero.zig:7:17</span>: <span class="sgr-2m">0x113e890 in main (runtime_division_by_zero.zig)</span>
    const c = a / b;
                <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      
      <h3 id="Remainder-Division-by-Zero"><a href="https://ziglang.org/documentation/0.15.2/#toc-Remainder-Division-by-Zero">Remainder Division by Zero</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Remainder-Division-by-Zero">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_remainder_division_by_zero.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">i32</span> = <span class="tok-number">10</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> c = a % b;
    _ = c;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_remainder_division_by_zero.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_remainder_division_by_zero.zig:4:19: </span><span class="sgr-31m">error: </span><span class="sgr-1m">division by zero here causes illegal behavior
</span>    const c = a % b;
                  <span class="sgr-32m">^
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_remainder_division_by_zero.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u32</span> = <span class="tok-number">10</span>;
    <span class="tok-kw">var</span> b: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    _ = .{ &amp;a, &amp;b };
    <span class="tok-kw">const</span> c = a % b;
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{c});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_remainder_division_by_zero.zig</kbd>
$ <kbd>./runtime_remainder_division_by_zero</kbd>
thread 2899727 panic: division by zero
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_remainder_division_by_zero.zig:7:17</span>: <span class="sgr-2m">0x113e890 in main (runtime_remainder_division_by_zero.zig)</span>
    const c = a % b;
                <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      
      <h3 id="Exact-Division-Remainder"><a href="https://ziglang.org/documentation/0.15.2/#toc-Exact-Division-Remainder">Exact Division Remainder</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Exact-Division-Remainder">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_divExact_remainder.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">u32</span> = <span class="tok-number">10</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">u32</span> = <span class="tok-number">3</span>;
    <span class="tok-kw">const</span> c = <span class="tok-builtin">@divExact</span>(a, b);
    _ = c;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_divExact_remainder.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_divExact_remainder.zig:4:15: </span><span class="sgr-31m">error: </span><span class="sgr-1m">exact division produced remainder
</span>    const c = @divExact(a, b);
              <span class="sgr-32m">^~~~~~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_divExact_remainder.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u32</span> = <span class="tok-number">10</span>;
    <span class="tok-kw">var</span> b: <span class="tok-type">u32</span> = <span class="tok-number">3</span>;
    _ = .{ &amp;a, &amp;b };
    <span class="tok-kw">const</span> c = <span class="tok-builtin">@divExact</span>(a, b);
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{c});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_divExact_remainder.zig</kbd>
$ <kbd>./runtime_divExact_remainder</kbd>
thread 2901529 panic: exact division produced remainder
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_divExact_remainder.zig:7:15</span>: <span class="sgr-2m">0x113e8c7 in main (runtime_divExact_remainder.zig)</span>
    const c = @divExact(a, b);
              <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      
      <h3 id="Attempt-to-Unwrap-Null"><a href="https://ziglang.org/documentation/0.15.2/#toc-Attempt-to-Unwrap-Null">Attempt to Unwrap Null</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Attempt-to-Unwrap-Null">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_unwrap_null.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> optional_number: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> number = optional_number.?;
    _ = number;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_unwrap_null.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_unwrap_null.zig:3:35: </span><span class="sgr-31m">error: </span><span class="sgr-1m">unable to unwrap null
</span>    const number = optional_number.?;
                   <span class="sgr-32m">~~~~~~~~~~~~~~~^~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_unwrap_null.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> optional_number: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>;
    _ = &amp;optional_number;
    <span class="tok-kw">const</span> number = optional_number.?;
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{number});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_unwrap_null.zig</kbd>
$ <kbd>./runtime_unwrap_null</kbd>
thread 2892887 panic: attempt to use null value
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_unwrap_null.zig:6:35</span>: <span class="sgr-2m">0x113e8b4 in main (runtime_unwrap_null.zig)</span>
    const number = optional_number.?;
                                  <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      <p>One way to avoid this crash is to test for null instead of assuming non-null, with
      the <code><span class="tok-kw">if</span></code> expression:</p>
      <figure><figcaption class="zig-cap"><cite class="file">testing_null_with_if.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> optional_number: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>;

    <span class="tok-kw">if</span> (optional_number) |number| {
        print(<span class="tok-str">"got number: {}\n"</span>, .{number});
    } <span class="tok-kw">else</span> {
        print(<span class="tok-str">"it's null\n"</span>, .{});
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe testing_null_with_if.zig</kbd>
$ <kbd>./testing_null_with_if</kbd>
it's null
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Optionals">Optionals</a></li>
</ul>

      
      <h3 id="Attempt-to-Unwrap-Error"><a href="https://ziglang.org/documentation/0.15.2/#toc-Attempt-to-Unwrap-Error">Attempt to Unwrap Error</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Attempt-to-Unwrap-Error">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_unwrap_error.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> number = getNumberOrFail() <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    _ = number;
}

<span class="tok-kw">fn</span> <span class="tok-fn">getNumberOrFail</span>() !<span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReturnNumber;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_unwrap_error.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_unwrap_error.zig:2:44: </span><span class="sgr-31m">error: </span><span class="sgr-1m">caught unexpected error 'UnableToReturnNumber'
</span>    const number = getNumberOrFail() catch unreachable;
                                           <span class="sgr-32m">^~~~~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_unwrap_error.zig:7:18: </span><span class="sgr-36m">note: </span><span class="sgr-1m">error returned here
</span>    return error.UnableToReturnNumber;
                 <span class="sgr-32m">^~~~~~~~~~~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_unwrap_error.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> number = getNumberOrFail() <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{number});
}

<span class="tok-kw">fn</span> <span class="tok-fn">getNumberOrFail</span>() !<span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReturnNumber;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_unwrap_error.zig</kbd>
$ <kbd>./runtime_unwrap_error</kbd>
thread 2895126 panic: attempt to unwrap error: UnableToReturnNumber
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_unwrap_error.zig:9:5</span>: <span class="sgr-2m">0x113e86c in getNumberOrFail (runtime_unwrap_error.zig)</span>
    return error.UnableToReturnNumber;
    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_unwrap_error.zig:4:44</span>: <span class="sgr-2m">0x113e8d3 in main (runtime_unwrap_error.zig)</span>
    const number = getNumberOrFail() catch unreachable;
                                           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      <p>One way to avoid this crash is to test for an error instead of assuming a successful result, with
      the <code><span class="tok-kw">if</span></code> expression:</p>
      <figure><figcaption class="zig-cap"><cite class="file">testing_error_with_if.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = getNumberOrFail();

    <span class="tok-kw">if</span> (result) |number| {
        print(<span class="tok-str">"got number: {}\n"</span>, .{number});
    } <span class="tok-kw">else</span> |err| {
        print(<span class="tok-str">"got error: {s}\n"</span>, .{<span class="tok-builtin">@errorName</span>(err)});
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">getNumberOrFail</span>() !<span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReturnNumber;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe testing_error_with_if.zig</kbd>
$ <kbd>./testing_error_with_if</kbd>
got error: UnableToReturnNumber
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Errors">Errors</a></li>
</ul>

      
      <h3 id="Invalid-Error-Code"><a href="https://ziglang.org/documentation/0.15.2/#toc-Invalid-Error-Code">Invalid Error Code</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Invalid-Error-Code">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_invalid_error_code.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> err = <span class="tok-kw">error</span>.AnError;
    <span class="tok-kw">const</span> number = <span class="tok-builtin">@intFromError</span>(err) + <span class="tok-number">10</span>;
    <span class="tok-kw">const</span> invalid_err = <span class="tok-builtin">@errorFromInt</span>(number);
    _ = invalid_err;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_invalid_error_code.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_invalid_error_code.zig:4:39: </span><span class="sgr-31m">error: </span><span class="sgr-1m">integer value '11' represents no error
</span>    const invalid_err = @errorFromInt(number);
                                      <span class="sgr-32m">^~~~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_invalid_error_code.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> err = <span class="tok-kw">error</span>.AnError;
    <span class="tok-kw">var</span> number = <span class="tok-builtin">@intFromError</span>(err) + <span class="tok-number">500</span>;
    _ = &amp;number;
    <span class="tok-kw">const</span> invalid_err = <span class="tok-builtin">@errorFromInt</span>(number);
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{invalid_err});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_invalid_error_code.zig</kbd>
$ <kbd>./runtime_invalid_error_code</kbd>
thread 2900570 panic: invalid error code
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_invalid_error_code.zig:7:5</span>: <span class="sgr-2m">0x113e8a7 in main (runtime_invalid_error_code.zig)</span>
    const invalid_err = @errorFromInt(number);
    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      
      <h3 id="Invalid-Enum-Cast"><a href="https://ziglang.org/documentation/0.15.2/#toc-Invalid-Enum-Cast">Invalid Enum Cast</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Invalid-Enum-Cast">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_invalid_enum_cast.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Foo = <span class="tok-kw">enum</span> {
    a,
    b,
    c,
};
<span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">u2</span> = <span class="tok-number">3</span>;
    <span class="tok-kw">const</span> b: Foo = <span class="tok-builtin">@enumFromInt</span>(a);
    _ = b;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_invalid_enum_cast.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_invalid_enum_cast.zig:8:20: </span><span class="sgr-31m">error: </span><span class="sgr-1m">enum 'test_comptime_invalid_enum_cast.Foo' has no tag with value '3'
</span>    const b: Foo = @enumFromInt(a);
                   <span class="sgr-32m">^~~~~~~~~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_invalid_enum_cast.zig:1:13: </span><span class="sgr-36m">note: </span><span class="sgr-1m">enum declared here
</span>const Foo = enum {
            <span class="sgr-32m">^~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_invalid_enum_cast.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">const</span> Foo = <span class="tok-kw">enum</span> {
    a,
    b,
    c,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u2</span> = <span class="tok-number">3</span>;
    _ = &amp;a;
    <span class="tok-kw">const</span> b: Foo = <span class="tok-builtin">@enumFromInt</span>(a);
    std.debug.print(<span class="tok-str">"value: {s}\n"</span>, .{<span class="tok-builtin">@tagName</span>(b)});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_invalid_enum_cast.zig</kbd>
$ <kbd>./runtime_invalid_enum_cast</kbd>
thread 2902395 panic: invalid enum value
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_invalid_enum_cast.zig:12:20</span>: <span class="sgr-2m">0x113e8f0 in main (runtime_invalid_enum_cast.zig)</span>
    const b: Foo = @enumFromInt(a);
                   <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      

      <h3 id="Invalid-Error-Set-Cast"><a href="https://ziglang.org/documentation/0.15.2/#toc-Invalid-Error-Set-Cast">Invalid Error Set Cast</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Invalid-Error-Set-Cast">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_invalid_error_set_cast.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Set1 = <span class="tok-kw">error</span>{
    A,
    B,
};
<span class="tok-kw">const</span> Set2 = <span class="tok-kw">error</span>{
    A,
    C,
};
<span class="tok-kw">comptime</span> {
    _ = <span class="tok-builtin">@as</span>(Set2, <span class="tok-builtin">@errorCast</span>(Set1.B));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_invalid_error_set_cast.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_invalid_error_set_cast.zig:10:19: </span><span class="sgr-31m">error: </span><span class="sgr-1m">'error.B' not a member of error set 'error{A,C}'
</span>    _ = @as(Set2, @errorCast(Set1.B));
                  <span class="sgr-32m">^~~~~~~~~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_invalid_error_set_cast.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">const</span> Set1 = <span class="tok-kw">error</span>{
    A,
    B,
};
<span class="tok-kw">const</span> Set2 = <span class="tok-kw">error</span>{
    A,
    C,
};
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    foo(Set1.B);
}
<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(set1: Set1) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> x: Set2 = <span class="tok-builtin">@errorCast</span>(set1);
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{x});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_invalid_error_set_cast.zig</kbd>
$ <kbd>./runtime_invalid_error_set_cast</kbd>
thread 2900078 panic: invalid error code
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_invalid_error_set_cast.zig:15:21</span>: <span class="sgr-2m">0x113fb3c in foo (runtime_invalid_error_set_cast.zig)</span>
    const x: Set2 = @errorCast(set1);
                    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_invalid_error_set_cast.zig:12:8</span>: <span class="sgr-2m">0x113e877 in main (runtime_invalid_error_set_cast.zig)</span>
    foo(Set1.B);
       <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      

      <h3 id="Incorrect-Pointer-Alignment"><a href="https://ziglang.org/documentation/0.15.2/#toc-Incorrect-Pointer-Alignment">Incorrect Pointer Alignment</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Incorrect-Pointer-Alignment">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_incorrect_pointer_alignment.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> ptr: *<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-type">i32</span> = <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-number">0x1</span>);
    <span class="tok-kw">const</span> aligned: *<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">i32</span> = <span class="tok-builtin">@alignCast</span>(ptr);
    _ = aligned;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_incorrect_pointer_alignment.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_incorrect_pointer_alignment.zig:3:47: </span><span class="sgr-31m">error: </span><span class="sgr-1m">pointer address 0x1 is not aligned to 4 bytes
</span>    const aligned: *align(4) i32 = @alignCast(ptr);
                                              <span class="sgr-32m">^~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_incorrect_pointer_alignment.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).mem;
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> array <span class="tok-kw">align</span>(<span class="tok-number">4</span>) = [_]<span class="tok-type">u32</span>{ <span class="tok-number">0x11111111</span>, <span class="tok-number">0x11111111</span> };
    <span class="tok-kw">const</span> bytes = mem.sliceAsBytes(array[<span class="tok-number">0</span>..]);
    <span class="tok-kw">if</span> (foo(bytes) != <span class="tok-number">0x11111111</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Wrong;
}
<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(bytes: []<span class="tok-type">u8</span>) <span class="tok-type">u32</span> {
    <span class="tok-kw">const</span> slice4 = bytes[<span class="tok-number">1</span>..<span class="tok-number">5</span>];
    <span class="tok-kw">const</span> int_slice = mem.bytesAsSlice(<span class="tok-type">u32</span>, <span class="tok-builtin">@as</span>([]<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">u8</span>, <span class="tok-builtin">@alignCast</span>(slice4)));
    <span class="tok-kw">return</span> int_slice[<span class="tok-number">0</span>];
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_incorrect_pointer_alignment.zig</kbd>
$ <kbd>./runtime_incorrect_pointer_alignment</kbd>
thread 2897041 panic: incorrect alignment
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_incorrect_pointer_alignment.zig:9:64</span>: <span class="sgr-2m">0x113ec08 in foo (runtime_incorrect_pointer_alignment.zig)</span>
    const int_slice = mem.bytesAsSlice(u32, @as([]align(4) u8, @alignCast(slice4)));
                                                               <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_incorrect_pointer_alignment.zig:5:12</span>: <span class="sgr-2m">0x113d3f2 in main (runtime_incorrect_pointer_alignment.zig)</span>
    if (foo(bytes) != 0x11111111) return error.Wrong;
           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:627:37</span>: <span class="sgr-2m">0x113dbc9 in posixCallMainAndExit (std.zig)</span>
            const result = root.main() catch |err| {
                                    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      
      <h3 id="Wrong-Union-Field-Access"><a href="https://ziglang.org/documentation/0.15.2/#toc-Wrong-Union-Field-Access">Wrong Union Field Access</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Wrong-Union-Field-Access">§</a></h3>

