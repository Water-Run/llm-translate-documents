      <table>
        <caption>Primitive Types</caption>
        <thead>
            <tr>
            <th scope="col">Type</th>
            <th scope="col">C Equivalent</th>
            <th scope="col">Description</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th scope="row"><code><span class="tok-type">i8</span></code></th>
          <td><code class="c">int8_t</code></td>
          <td>signed 8-bit integer</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">u8</span></code></th>
          <td><code class="c">uint8_t</code></td>
          <td>unsigned 8-bit integer</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">i16</span></code></th>
          <td><code class="c">int16_t</code></td>
          <td>signed 16-bit integer</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">u16</span></code></th>
          <td><code class="c">uint16_t</code></td>
          <td>unsigned 16-bit integer</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">i32</span></code></th>
          <td><code class="c">int32_t</code></td>
          <td>signed 32-bit integer</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">u32</span></code></th>
          <td><code class="c">uint32_t</code></td>
          <td>unsigned 32-bit integer</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">i64</span></code></th>
          <td><code class="c">int64_t</code></td>
          <td>signed 64-bit integer</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">u64</span></code></th>
          <td><code class="c">uint64_t</code></td>
          <td>unsigned 64-bit integer</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">i128</span></code></th>
          <td><code class="c">__int128</code></td>
          <td>signed 128-bit integer</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">u128</span></code></th>
          <td><code class="c">unsigned __int128</code></td>
          <td>unsigned 128-bit integer</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">isize</span></code></th>
          <td><code class="c">intptr_t</code></td>
          <td>signed pointer sized integer</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">usize</span></code></th>
          <td><code class="c">uintptr_t</code>, <code class="c">size_t</code></td>
          <td>unsigned pointer sized integer. Also see <a href="https://github.com/ziglang/zig/issues/5185">#5185</a></td>
        </tr>

        <tr>
            <th scope="row"><code><span class="tok-type">c_char</span></code></th>
          <td><code class="c">char</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">c_short</span></code></th>
          <td><code class="c">short</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">c_ushort</span></code></th>
          <td><code class="c">unsigned short</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">c_int</span></code></th>
          <td><code class="c">int</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">c_uint</span></code></th>
          <td><code class="c">unsigned int</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">c_long</span></code></th>
          <td><code class="c">long</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">c_ulong</span></code></th>
          <td><code class="c">unsigned long</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">c_longlong</span></code></th>
          <td><code class="c">long long</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">c_ulonglong</span></code></th>
          <td><code class="c">unsigned long long</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">c_longdouble</span></code></th>
          <td><code class="c">long double</code></td>
          <td>for ABI compatibility with C</td>
        </tr>

        <tr>
            <th scope="row"><code><span class="tok-type">f16</span></code></th>
          <td><code class="c">_Float16</code></td>
          <td>16-bit floating point (10-bit mantissa) IEEE-754-2008 binary16</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">f32</span></code></th>
          <td><code class="c">float</code></td>
          <td>32-bit floating point (23-bit mantissa) IEEE-754-2008 binary32</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">f64</span></code></th>
          <td><code class="c">double</code></td>
          <td>64-bit floating point (52-bit mantissa) IEEE-754-2008 binary64</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">f80</span></code></th>
          <td><code class="c">long double</code></td>
          <td>80-bit floating point (64-bit mantissa) IEEE-754-2008 80-bit extended precision</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">f128</span></code></th>
            <td><code class="c">_Float128</code></td>
          <td>128-bit floating point (112-bit mantissa) IEEE-754-2008 binary128</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">bool</span></code></th>
          <td><code class="c">bool</code></td>
          <td><code><span class="tok-null">true</span></code> or <code><span class="tok-null">false</span></code></td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">anyopaque</span></code></th>
          <td><code class="c">void</code></td>
          <td>Used for type-erased pointers.</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">void</span></code></th>
          <td>(none)</td>
          <td>Always the value <code><span class="tok-type">void</span>{}</code></td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">noreturn</span></code></th>
          <td>(none)</td>
          <td>the type of <code><span class="tok-kw">break</span></code>, <code><span class="tok-kw">continue</span></code>, <code><span class="tok-kw">return</span></code>, <code><span class="tok-kw">unreachable</span></code>, and <code><span class="tok-kw">while</span> (<span class="tok-null">true</span>) {}</code></td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">type</span></code></th>
          <td>(none)</td>
          <td>the type of types</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">anyerror</span></code></th>
          <td>(none)</td>
          <td>an error code</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">comptime_int</span></code></th>
          <td>(none)</td>
          <td>Only allowed for <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a>-known values. The type of integer literals.</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">comptime_float</span></code></th>
          <td>(none)</td>
          <td>Only allowed for <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a>-known values. The type of float literals.</td>
        </tr>
        </tbody>
      </table>
      </div>
      <p>
      In addition to the integer types above, arbitrary bit-width integers can be referenced by using
      an identifier of <code>i</code> or <code>u</code> followed by digits. For example, the identifier
      <code><span class="tok-type">i7</span></code> refers to a signed 7-bit integer. The maximum allowed bit-width of an
      integer type is <code><span class="tok-number">65535</span></code>.
      </p>
      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Integers">Integers</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Floats">Floats</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#void">void</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Errors">Errors</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Type">@Type</a></li>
</ul>

      
      <h3 id="Primitive-Values"><a href="https://ziglang.org/documentation/0.15.2/#toc-Primitive-Values">Primitive Values</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Primitive-Values">ยง</a></h3>

      <div class="table-wrapper">
      <table>
        <caption>Primitive Values</caption>
        <thead>
        <tr>
          <th scope="col">Name</th>
          <th scope="col">Description</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th scope="row"><code><span class="tok-null">true</span></code> and <code><span class="tok-null">false</span></code></th>
            <td><code><span class="tok-type">bool</span></code> values</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-null">null</span></code></th>
            <td>used to set an optional type to <code><span class="tok-null">null</span></code></td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-null">undefined</span></code></th>
          <td>used to leave a value unspecified</td>
        </tr>
        </tbody>
      </table>
      </div>
      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Optionals">Optionals</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#undefined">undefined</a></li>
</ul>

      
      <h3 id="String-Literals-and-Unicode-Code-Point-Literals"><a href="https://ziglang.org/documentation/0.15.2/#toc-String-Literals-and-Unicode-Code-Point-Literals">String Literals and Unicode Code Point Literals</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#String-Literals-and-Unicode-Code-Point-Literals">ยง</a></h3>

      <p>
      String literals are constant single-item <a href="https://ziglang.org/documentation/0.15.2/#Pointers">Pointers</a> to null-terminated byte arrays.
      The type of string literals encodes both the length, and the fact that they are null-terminated,
      and thus they can be <a href="https://ziglang.org/documentation/0.15.2/#Type-Coercion">coerced</a> to both <a href="https://ziglang.org/documentation/0.15.2/#Slices">Slices</a> and
      <a href="https://ziglang.org/documentation/0.15.2/#Sentinel-Terminated-Pointers">Null-Terminated Pointers</a>.
      Dereferencing string literals converts them to <a href="https://ziglang.org/documentation/0.15.2/#Arrays">Arrays</a>.
      </p>
      <p>
      Because Zig source code is <a href="https://ziglang.org/documentation/0.15.2/#Source-Encoding">UTF-8 encoded</a>, any
      non-ASCII bytes appearing within a string literal in source code carry
      their UTF-8 meaning into the content of the string in the Zig program;
      the bytes are not modified by the compiler. It is possible to embed
      non-UTF-8 bytes into a string literal using <code>\xNN</code> notation.
      </p>
      <p>Indexing into a string containing non-ASCII bytes returns individual
      bytes, whether valid UTF-8 or not.</p>
      <p>
      Unicode code point literals have type <code><span class="tok-type">comptime_int</span></code>, the same as
      <a href="https://ziglang.org/documentation/0.15.2/#Integer-Literals">Integer Literals</a>. All <a href="https://ziglang.org/documentation/0.15.2/#Escape-Sequences">Escape Sequences</a> are valid in both string literals
      and Unicode code point literals.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">string_literals.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;
<span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).mem; <span class="tok-comment">// will be used to compare bytes</span>

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> bytes = <span class="tok-str">"hello"</span>;
    print(<span class="tok-str">"{}\n"</span>, .{<span class="tok-builtin">@TypeOf</span>(bytes)}); <span class="tok-comment">// *const [5:0]u8</span>
    print(<span class="tok-str">"{d}\n"</span>, .{bytes.len}); <span class="tok-comment">// 5</span>
    print(<span class="tok-str">"{c}\n"</span>, .{bytes[<span class="tok-number">1</span>]}); <span class="tok-comment">// 'e'</span>
    print(<span class="tok-str">"{d}\n"</span>, .{bytes[<span class="tok-number">5</span>]}); <span class="tok-comment">// 0</span>
    print(<span class="tok-str">"{}\n"</span>, .{<span class="tok-str">'e'</span> == <span class="tok-str">'\x65'</span>}); <span class="tok-comment">// true</span>
    print(<span class="tok-str">"{d}\n"</span>, .{<span class="tok-str">'\u{1f4a9}'</span>}); <span class="tok-comment">// 128169</span>
    print(<span class="tok-str">"{d}\n"</span>, .{<span class="tok-str">'๐ฏ'</span>}); <span class="tok-comment">// 128175</span>
    print(<span class="tok-str">"{u}\n"</span>, .{<span class="tok-str">'โก'</span>});
    print(<span class="tok-str">"{}\n"</span>, .{mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">"hello"</span>, <span class="tok-str">"h\x65llo"</span>)}); <span class="tok-comment">// true</span>
    print(<span class="tok-str">"{}\n"</span>, .{mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">"๐ฏ"</span>, <span class="tok-str">"\xf0\x9f\x92\xaf"</span>)}); <span class="tok-comment">// also true</span>
    <span class="tok-kw">const</span> invalid_utf8 = <span class="tok-str">"\xff\xfe"</span>; <span class="tok-comment">// non-UTF-8 strings are possible with \xNN notation.</span>
    print(<span class="tok-str">"0x{x}\n"</span>, .{invalid_utf8[<span class="tok-number">1</span>]}); <span class="tok-comment">// indexing them returns individual bytes...</span>
    print(<span class="tok-str">"0x{x}\n"</span>, .{<span class="tok-str">"๐ฏ"</span>[<span class="tok-number">1</span>]}); <span class="tok-comment">// ...as does indexing part-way through non-ASCII characters</span>
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe string_literals.zig</kbd>
$ <kbd>./string_literals</kbd>
*const [5:0]u8
5
e
0
true
128169
128175
โก
true
true
0xfe
0x9f
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Arrays">Arrays</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Source-Encoding">Source Encoding</a></li>
</ul>

      <h4 id="Escape-Sequences"><a href="https://ziglang.org/documentation/0.15.2/#toc-Escape-Sequences">Escape Sequences</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Escape-Sequences">ยง</a></h4>

      <div class="table-wrapper">
      <table>
        <caption>Escape Sequences</caption>
        <thead>
        <tr>
          <th scope="col">Escape Sequence</th>
          <th scope="col">Name</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th scope="row"><code>\n</code></th>
          <td>Newline</td>
        </tr>
        <tr>
            <th scope="row"><code>\r</code></th>
          <td>Carriage Return</td>
        </tr>
        <tr>
            <th scope="row"><code>\t</code></th>
          <td>Tab</td>
        </tr>
        <tr>
            <th scope="row"><code>\\</code></th>
          <td>Backslash</td>
        </tr>
        <tr>
            <th scope="row"><code>\'</code></th>
          <td>Single Quote</td>
        </tr>
        <tr>
            <th scope="row"><code>\"</code></th>
          <td>Double Quote</td>
        </tr>
        <tr>
            <th scope="row"><code>\xNN</code></th>
          <td>hexadecimal 8-bit byte value (2 digits)</td>
        </tr>
        <tr>
            <th scope="row"><code>\u{NNNNNN}</code></th>
          <td>hexadecimal Unicode scalar value UTF-8 encoded (1 or more digits)</td>
        </tr>
        </tbody>
      </table>
      </div>
      <p>Note that the maximum valid Unicode scalar value is <code><span class="tok-number">0x10ffff</span></code>.</p>
      
      <h4 id="Multiline-String-Literals"><a href="https://ziglang.org/documentation/0.15.2/#toc-Multiline-String-Literals">Multiline String Literals</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Multiline-String-Literals">ยง</a></h4>

      <p>
      Multiline string literals have no escapes and can span across multiple lines.
      To start a multiline string literal, use the <code><span class="tok-str">\\</span></code> token. Just like a comment,
      the string literal goes until the end of the line. The end of the line is
      not included in the string literal.
      However, if the next line begins with <code><span class="tok-str">\\</span></code> then a newline is appended and
      the string literal continues.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">multiline_string_literals.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> hello_world_in_c =
    <span class="tok-str">\\#include &lt;stdio.h&gt;</span>
    <span class="tok-str">\\</span>
    <span class="tok-str">\\int main(int argc, char **argv) {</span>
    <span class="tok-str">\\    printf("hello world\n");</span>
    <span class="tok-str">\\    return 0;</span>
    <span class="tok-str">\\}</span>
;</code></pre></figure>

      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#embedFile">@embedFile</a></li>
</ul>

      
      
      <h3 id="Assignment"><a href="https://ziglang.org/documentation/0.15.2/#toc-Assignment">Assignment</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Assignment">ยง</a></h3>

      <p>Use the <code><span class="tok-kw">const</span></code> keyword to assign a value to an identifier:</p>
      <figure><figcaption class="zig-cap"><cite class="file">constant_identifier_cannot_change.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> x = <span class="tok-number">1234</span>;

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">void</span> {
    <span class="tok-comment">// It works at file scope as well as inside functions.</span>
    <span class="tok-kw">const</span> y = <span class="tok-number">5678</span>;

    <span class="tok-comment">// Once assigned, an identifier cannot be changed.</span>
    y += <span class="tok-number">1</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    foo();
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe constant_identifier_cannot_change.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/constant_identifier_cannot_change.zig:8:5: </span><span class="sgr-31m">error: </span><span class="sgr-1m">cannot assign to constant
</span>    y += 1;
    <span class="sgr-32m">^
</span><span class="sgr-2m">referenced by:
    main: /home/andy/dev/zig/doc/langref/constant_identifier_cannot_change.zig:12:8
    callMain [inlined]: /home/andy/dev/zig/lib/std/start.zig:618:22
    callMainWithArgs [inlined]: /home/andy/dev/zig/lib/std/start.zig:587:20
    posixCallMainAndExit: /home/andy/dev/zig/lib/std/start.zig:542:36
    2 reference(s) hidden; use '-freference-trace=6' to see all references
</span>
</samp></pre></figure>

      <p><code><span class="tok-kw">const</span></code> applies to all of the bytes that the identifier immediately addresses. <a href="https://ziglang.org/documentation/0.15.2/#Pointers">Pointers</a> have their own const-ness.</p>
      <p>If you need a variable that you can modify, use the <code><span class="tok-kw">var</span></code> keyword:</p>
      <figure><figcaption class="zig-cap"><cite class="file">mutable_var.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> y: <span class="tok-type">i32</span> = <span class="tok-number">5678</span>;

    y += <span class="tok-number">1</span>;

    print(<span class="tok-str">"{d}"</span>, .{y});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe mutable_var.zig</kbd>
$ <kbd>./mutable_var</kbd>
5679
</samp></pre></figure>

      <p>Variables must be initialized:</p>
      <figure><figcaption class="zig-cap"><cite class="file">var_must_be_initialized.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span>;

    x = <span class="tok-number">1</span>;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe var_must_be_initialized.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/var_must_be_initialized.zig:2:15: </span><span class="sgr-31m">error: </span><span class="sgr-1m">expected '=', found ';'
</span>    var x: i32;
              <span class="sgr-32m">^
</span>
</samp></pre></figure>

      <h4 id="undefined"><a href="https://ziglang.org/documentation/0.15.2/#toc-undefined">undefined</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#undefined">ยง</a></h4>

      <p>Use <code><span class="tok-null">undefined</span></code> to leave variables uninitialized:</p>
      <figure><figcaption class="zig-cap"><cite class="file">assign_undefined.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;
    x = <span class="tok-number">1</span>;
    print(<span class="tok-str">"{d}"</span>, .{x});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe assign_undefined.zig</kbd>
$ <kbd>./assign_undefined</kbd>
1
</samp></pre></figure>

      <p>
      <code><span class="tok-null">undefined</span></code> can be <a href="https://ziglang.org/documentation/0.15.2/#Type-Coercion">coerced</a> to any type.
          Once this happens, it is no longer possible to detect that the value is <code><span class="tok-null">undefined</span></code>.
              <code><span class="tok-null">undefined</span></code> means the value could be anything, even something that is nonsense
                  according to the type. Translated into English, <code><span class="tok-null">undefined</span></code> means "Not a meaningful
      value. Using this value would be a bug. The value will be unused, or overwritten before being used."
      </p>
      <p>
      In <a href="https://ziglang.org/documentation/0.15.2/#Debug">Debug</a> and <a href="https://ziglang.org/documentation/0.15.2/#ReleaseSafe">ReleaseSafe</a> mode, Zig writes <code><span class="tok-number">0xaa</span></code> bytes to undefined memory. This is to catch
      bugs early, and to help detect use of undefined memory in a debugger. However, this behavior is only an
      implementation feature, not a language semantic, so it is not guaranteed to be observable to code.
      </p>
      

      <h4 id="Destructuring"><a href="https://ziglang.org/documentation/0.15.2/#toc-Destructuring">Destructuring</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Destructuring">ยง</a></h4>

      <p>
        A destructuring assignment can separate elements of indexable aggregate types
        (<a href="https://ziglang.org/documentation/0.15.2/#Tuples">Tuples</a>, <a href="https://ziglang.org/documentation/0.15.2/#Arrays">Arrays</a>, <a href="https://ziglang.org/documentation/0.15.2/#Vectors">Vectors</a>):
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">destructuring_to_existing.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> y: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> z: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;

    <span class="tok-kw">const</span> tuple = .{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span> };

    x, y, z = tuple;

    print(<span class="tok-str">"tuple: x = {}, y = {}, z = {}\n"</span>, .{x, y, z});

    <span class="tok-kw">const</span> array = [_]<span class="tok-type">u32</span>{ <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span> };

    x, y, z = array;

    print(<span class="tok-str">"array: x = {}, y = {}, z = {}\n"</span>, .{x, y, z});

    <span class="tok-kw">const</span> vector: <span class="tok-builtin">@Vector</span>(<span class="tok-number">3</span>, <span class="tok-type">u32</span>) = .{ <span class="tok-number">7</span>, <span class="tok-number">8</span>, <span class="tok-number">9</span> };

    x, y, z = vector;

    print(<span class="tok-str">"vector: x = {}, y = {}, z = {}\n"</span>, .{x, y, z});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe destructuring_to_existing.zig</kbd>
$ <kbd>./destructuring_to_existing</kbd>
tuple: x = 1, y = 2, z = 3
array: x = 4, y = 5, z = 6
vector: x = 7, y = 8, z = 9
</samp></pre></figure>

      <p>
        A destructuring expression may only appear within a block (i.e. not at container scope).
        The left hand side of the assignment must consist of a comma separated list,
        each element of which may be either an lvalue (for instance, an existing `var`) or a variable declaration:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">destructuring_mixed.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;

    <span class="tok-kw">const</span> tuple = .{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span> };

    x, <span class="tok-kw">var</span> y : <span class="tok-type">u32</span>, <span class="tok-kw">const</span> z = tuple;

    print(<span class="tok-str">"x = {}, y = {}, z = {}\n"</span>, .{x, y, z});

    <span class="tok-comment">// y is mutable</span>
    y = <span class="tok-number">100</span>;

    <span class="tok-comment">// You can use _ to throw away unwanted values.</span>
    _, x, _ = tuple;

    print(<span class="tok-str">"x = {}"</span>, .{x});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe destructuring_mixed.zig</kbd>
$ <kbd>./destructuring_mixed</kbd>
x = 1, y = 2, z = 3
x = 2
</samp></pre></figure>

      <p>
        A destructure may be prefixed with the <code><span class="tok-kw">comptime</span></code> keyword, in which case the entire
        destructure expression is evaluated at <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a>. All <code><span class="tok-kw">var</span></code>s declared would
        be <code><span class="tok-kw">comptime</span> <span class="tok-kw">var</span></code>s and all expressions (both result locations and the assignee
        expression) are evaluated at <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a>.
      </p>

      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Destructuring-Tuples">Destructuring Tuples</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Destructuring-Arrays">Destructuring Arrays</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Destructuring-Vectors">Destructuring Vectors</a></li>
</ul>

      
      
      
      <h2 id="Zig-Test"><a href="https://ziglang.org/documentation/0.15.2/#toc-Zig-Test">Zig Test</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Zig-Test">ยง</a></h2>

      <p>
        Code written within one or more <code><span class="tok-kw">test</span></code> declarations can be used to ensure behavior meets expectations:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">testing_introduction.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">test</span> <span class="tok-str">"expect addOne adds one to 41"</span> {

    <span class="tok-comment">// The Standard Library contains useful functions to help create tests.</span>
    <span class="tok-comment">// `expect` is a function that verifies its argument is true.</span>
    <span class="tok-comment">// It will return an error if its argument is false to indicate a failure.</span>
    <span class="tok-comment">// `try` is used to return an error to the test runner to notify it that the test failed.</span>
    <span class="tok-kw">try</span> std.testing.expect(addOne(<span class="tok-number">41</span>) == <span class="tok-number">42</span>);
}

<span class="tok-kw">test</span> addOne {
    <span class="tok-comment">// A test name can also be written using an identifier.</span>
    <span class="tok-comment">// This is a doctest, and serves as documentation for `addOne`.</span>
    <span class="tok-kw">try</span> std.testing.expect(addOne(<span class="tok-number">41</span>) == <span class="tok-number">42</span>);
}

<span class="tok-comment">/// The function `addOne` adds one to the number given as its argument.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">addOne</span>(number: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> number + <span class="tok-number">1</span>;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test testing_introduction.zig</kbd>
1/2 testing_introduction.test.expect addOne adds one to 41...OK
2/2 testing_introduction.decltest.addOne...OK
All 2 tests passed.
</samp></pre></figure>

      <p>
        The <code class="file">testing_introduction.zig</code> code sample tests the <a href="https://ziglang.org/documentation/0.15.2/#Functions">function</a>
        <code>addOne</code> to ensure that it returns <code><span class="tok-number">42</span></code> given the input
        <code><span class="tok-number">41</span></code>. From this test's perspective, the <code>addOne</code> function is
        said to be <em>code under test</em>.
      </p>
      <p>
        <kbd>zig test</kbd> is a tool that creates and runs a test build. By default, it builds and runs an
        executable program using the <em>default test runner</em> provided by the <a href="https://ziglang.org/documentation/0.15.2/#Zig-Standard-Library">Zig Standard Library</a>
        as its main entry point. During the build, <code><span class="tok-kw">test</span></code> declarations found while
        <a href="https://ziglang.org/documentation/0.15.2/#File-and-Declaration-Discovery">resolving</a> the given Zig source file are included for the default test runner
        to run and report on.
      </p>
      <aside>
        This documentation discusses the features of the default test runner as provided by the Zig Standard Library.
        Its source code is located in <code class="file">lib/compiler/test_runner.zig</code>.
      </aside>
      <p>
        The shell output shown above displays two lines after the <kbd>zig test</kbd> command. These lines are
        printed to standard error by the default test runner:
      </p>
      <dl>
        <dt><samp>1/2 testing_introduction.test.expect addOne adds one to 41...</samp></dt>
        <dd>Lines like this indicate which test, out of the total number of tests, is being run.
          In this case, <samp>1/2</samp> indicates that the first test, out of a total of two tests,
          is being run. Note that, when the test runner program's standard error is output
          to the terminal, these lines are cleared when a test succeeds.
        </dd>
        <dt><samp>2/2 testing_introduction.decltest.addOne...</samp></dt>
        <dd>When the test name is an identifier, the default test runner uses the text
          decltest instead of test.
        </dd>
        <dt><samp>All 2 tests passed.</samp></dt>
        <dd>This line indicates the total number of tests that have passed.</dd>
      </dl>
      <h3 id="Test-Declarations"><a href="https://ziglang.org/documentation/0.15.2/#toc-Test-Declarations">Test Declarations</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Test-Declarations">ยง</a></h3>

      <p>
        Test declarations contain the <a href="https://ziglang.org/documentation/0.15.2/#Keyword-Reference">keyword</a> <code><span class="tok-kw">test</span></code>, followed by an
        optional name written as a <a href="https://ziglang.org/documentation/0.15.2/#String-Literals-and-Unicode-Code-Point-Literals">string literal</a> or an
        <a href="https://ziglang.org/documentation/0.15.2/#Identifiers">identifier</a>, followed by a <a href="https://ziglang.org/documentation/0.15.2/#Blocks">block</a> containing any valid Zig code that
        is allowed in a <a href="https://ziglang.org/documentation/0.15.2/#Functions">function</a>.
      </p>
      <p>Non-named test blocks always run during test builds and are exempt from
        <a href="https://ziglang.org/documentation/0.15.2/#Skip-Tests">Skip Tests</a>.</p>
      <p>
        Test declarations are similar to <a href="https://ziglang.org/documentation/0.15.2/#Functions">Functions</a>: they have a return type and a block of code. The implicit
        return type of <code><span class="tok-kw">test</span></code> is the <a href="https://ziglang.org/documentation/0.15.2/#Error-Union-Type">Error Union Type</a> <code><span class="tok-type">anyerror</span>!<span class="tok-type">void</span></code>,
        and it cannot be changed. When a Zig source file is not built using the <kbd>zig test</kbd> tool, the test
        declarations are omitted from the build.
      </p>
      <p>
        Test declarations can be written in the same file, where code under test is written, or in a separate Zig source file.
        Since test declarations are top-level declarations, they are order-independent and can
        be written before or after the code under test.
      </p>
      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#The-Global-Error-Set">The Global Error Set</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Grammar">Grammar</a></li>
</ul>

      <h4 id="Doctests"><a href="https://ziglang.org/documentation/0.15.2/#toc-Doctests">Doctests</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Doctests">ยง</a></h4>

      <p>
        Test declarations named using an identifier are <em>doctests</em>. The identifier must refer to another declaration in
        scope. A doctest, like a <a href="https://ziglang.org/documentation/0.15.2/#Doc-Comments">doc comment</a>, serves as documentation for the associated declaration, and
        will appear in the generated documentation for the declaration.
      </p>
      <p>
        An effective doctest should be self-contained and focused on the declaration being tested, answering questions a new
        user might have about its interface or intended usage, while avoiding unnecessary or confusing details. A doctest is not
        a substitute for a doc comment, but rather a supplement and companion providing a testable, code-driven example, verified
        by <kbd>zig test</kbd>.
      </p>
      
      
      <h3 id="Test-Failure"><a href="https://ziglang.org/documentation/0.15.2/#toc-Test-Failure">Test Failure</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Test-Failure">ยง</a></h3>

      <p>
        The default test runner checks for an <a href="https://ziglang.org/documentation/0.15.2/#Errors">error</a> returned from a test.
        When a test returns an error, the test is considered a failure and its <a href="https://ziglang.org/documentation/0.15.2/#Error-Return-Traces">error return trace</a>
        is output to standard error. The total number of failures will be reported after all tests have run.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">testing_failure.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">test</span> <span class="tok-str">"expect this to fail"</span> {
    <span class="tok-kw">try</span> std.testing.expect(<span class="tok-null">false</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"expect this to succeed"</span> {
    <span class="tok-kw">try</span> std.testing.expect(<span class="tok-null">true</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test testing_failure.zig</kbd>
1/2 testing_failure.test.expect this to fail...FAIL (TestUnexpectedResult)
<span class="sgr-1m">/home/andy/dev/zig/lib/std/testing.zig:607:14</span>: <span class="sgr-2m">0x102f019 in expect (std.zig)</span>
    if (!ok) return error.TestUnexpectedResult;
             <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/testing_failure.zig:4:5</span>: <span class="sgr-2m">0x102f078 in test.expect this to fail (testing_failure.zig)</span>
    try std.testing.expect(false);
    <span class="sgr-32m">^</span>
2/2 testing_failure.test.expect this to succeed...OK
1 passed; 0 skipped; 1 failed.
error: the following test command failed with exit code 1:
/home/andy/dev/zig/.zig-cache/o/bac0cff07a7d3f5b652a5a9cf02e6de1/test --seed=0x7a2fdb1
</samp></pre></figure>

      
      <h3 id="Skip-Tests"><a href="https://ziglang.org/documentation/0.15.2/#toc-Skip-Tests">Skip Tests</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Skip-Tests">ยง</a></h3>

      <p>
        One way to skip tests is to filter them out by using the <kbd>zig test</kbd> command line parameter
        <kbd>--test-filter [text]</kbd>. This makes the test build only include tests whose name contains the
        supplied filter text. Note that non-named tests are run even when using the <kbd>--test-filter [text]</kbd>
        command line parameter.
      </p>
      <p>
        To programmatically skip a test, make a <code><span class="tok-kw">test</span></code> return the error
        <code><span class="tok-kw">error</span>.SkipZigTest</code> and the default test runner will consider the test as being skipped.
        The total number of skipped tests will be reported after all tests have run.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">testing_skip.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">"this will be skipped"</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test testing_skip.zig</kbd>
1/1 testing_skip.test.this will be skipped...SKIP
0 passed; 1 skipped; 0 failed.
</samp></pre></figure>

      

      <h3 id="Report-Memory-Leaks"><a href="https://ziglang.org/documentation/0.15.2/#toc-Report-Memory-Leaks">Report Memory Leaks</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Report-Memory-Leaks">ยง</a></h3>

      <p>
        When code allocates <a href="https://ziglang.org/documentation/0.15.2/#Memory">Memory</a> using the <a href="https://ziglang.org/documentation/0.15.2/#Zig-Standard-Library">Zig Standard Library</a>'s testing allocator,
        <code>std.testing.allocator</code>, the default test runner will report any leaks that are
        found from using the testing allocator:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">testing_detect_leak.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">test</span> <span class="tok-str">"detect leak"</span> {
    <span class="tok-kw">var</span> list = std.array_list.Managed(<span class="tok-type">u21</span>).init(std.testing.allocator);
    <span class="tok-comment">// missing `defer list.deinit();`</span>
    <span class="tok-kw">try</span> list.append(<span class="tok-str">'โ'</span>);

    <span class="tok-kw">try</span> std.testing.expect(list.items.len == <span class="tok-number">1</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test testing_detect_leak.zig</kbd>
1/1 testing_detect_leak.test.detect leak...OK
[gpa] (err): memory address 0x7f74a8aa0000 leaked:
<span class="sgr-1m">/home/andy/dev/zig/lib/std/array_list.zig:468:67</span>: <span class="sgr-2m">0x10aa8fe in ensureTotalCapacityPrecise (std.zig)</span>
                const new_memory = try self.allocator.alignedAlloc(T, alignment, new_capacity);
                                                                  <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/array_list.zig:444:51</span>: <span class="sgr-2m">0x107c9e4 in ensureTotalCapacity (std.zig)</span>
            return self.ensureTotalCapacityPrecise(better_capacity);
                                                  <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/array_list.zig:494:41</span>: <span class="sgr-2m">0x105590d in addOne (std.zig)</span>
            try self.ensureTotalCapacity(newlen);
                                        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/array_list.zig:252:49</span>: <span class="sgr-2m">0x1038771 in append (std.zig)</span>
            const new_item_ptr = try self.addOne();
                                                <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/testing_detect_leak.zig:6:20</span>: <span class="sgr-2m">0x10350a9 in test.detect leak (testing_detect_leak.zig)</span>
    try list.append('โ');
                   <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:218:25</span>: <span class="sgr-2m">0x1174760 in mainTerminal (test_runner.zig)</span>
        if (test_fn.func()) |_| {
                        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:66:28</span>: <span class="sgr-2m">0x1170d81 in main (test_runner.zig)</span>
        return mainTerminal();
                           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x116ab1d in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x116a3b1 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>

All 1 tests passed.
1 errors were logged.
1 tests leaked memory.
error: the following test command failed with exit code 1:
/home/andy/dev/zig/.zig-cache/o/4df377b3969e36bf7e0b2704790b75be/test --seed=0xabc34e97
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#defer">defer</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Memory">Memory</a></li>
</ul>

      
      <h3 id="Detecting-Test-Build"><a href="https://ziglang.org/documentation/0.15.2/#toc-Detecting-Test-Build">Detecting Test Build</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Detecting-Test-Build">ยง</a></h3>

      <p>
        Use the <a href="https://ziglang.org/documentation/0.15.2/#Compile-Variables">compile variable</a> <code><span class="tok-builtin">@import</span>(<span class="tok-str">"builtin"</span>).is_test</code>
        to detect a test build:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">testing_detect_test.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">"builtin"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"builtin.is_test"</span> {
    <span class="tok-kw">try</span> expect(isATest());
}

<span class="tok-kw">fn</span> <span class="tok-fn">isATest</span>() <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> builtin.is_test;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test testing_detect_test.zig</kbd>
1/1 testing_detect_test.test.builtin.is_test...OK
All 1 tests passed.
</samp></pre></figure>

      
      <h3 id="Test-Output-and-Logging"><a href="https://ziglang.org/documentation/0.15.2/#toc-Test-Output-and-Logging">Test Output and Logging</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Test-Output-and-Logging">ยง</a></h3>

      <p>
        The default test runner and the Zig Standard Library's testing namespace output messages to standard error.
      </p>
      
      <h3 id="The-Testing-Namespace"><a href="https://ziglang.org/documentation/0.15.2/#toc-The-Testing-Namespace">The Testing Namespace</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#The-Testing-Namespace">ยง</a></h3>

      <p>
        The Zig Standard Library's <code>testing</code> namespace contains useful functions to help
        you create tests. In addition to the <code>expect</code> function, this document uses a couple of more functions
        as exemplified here:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">testing_namespace.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">test</span> <span class="tok-str">"expectEqual demo"</span> {
    <span class="tok-kw">const</span> expected: <span class="tok-type">i32</span> = <span class="tok-number">42</span>;
    <span class="tok-kw">const</span> actual = <span class="tok-number">42</span>;

    <span class="tok-comment">// The first argument to `expectEqual` is the known, expected, result.</span>
    <span class="tok-comment">// The second argument is the result of some expression.</span>
    <span class="tok-comment">// The actual's type is casted to the type of expected.</span>
    <span class="tok-kw">try</span> std.testing.expectEqual(expected, actual);
}

<span class="tok-kw">test</span> <span class="tok-str">"expectError demo"</span> {
    <span class="tok-kw">const</span> expected_error = <span class="tok-kw">error</span>.DemoError;
    <span class="tok-kw">const</span> actual_error_union: <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> = <span class="tok-kw">error</span>.DemoError;

    <span class="tok-comment">// `expectError` will fail when the actual error is different than</span>
    <span class="tok-comment">// the expected error.</span>
    <span class="tok-kw">try</span> std.testing.expectError(expected_error, actual_error_union);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test testing_namespace.zig</kbd>
1/2 testing_namespace.test.expectEqual demo...OK
2/2 testing_namespace.test.expectError demo...OK
All 2 tests passed.
</samp></pre></figure>

      <p>The Zig Standard Library also contains functions to compare <a href="https://ziglang.org/documentation/0.15.2/#Slices">Slices</a>, strings, and more. See the rest of the
        <code>std.testing</code> namespace in the <a href="https://ziglang.org/documentation/0.15.2/#Zig-Standard-Library">Zig Standard Library</a> for more available functions.</p>
      
      <h3 id="Test-Tool-Documentation"><a href="https://ziglang.org/documentation/0.15.2/#toc-Test-Tool-Documentation">Test Tool Documentation</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Test-Tool-Documentation">ยง</a></h3>

      <p>
        <kbd>zig test</kbd> has a few command line parameters which affect the compilation.
        See <kbd>zig test --help</kbd> for a full list.
      </p>
      
      

      <h2 id="Variables"><a href="https://ziglang.org/documentation/0.15.2/#toc-Variables">Variables</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Variables">ยง</a></h2>

      <p>
      A variable is a unit of <a href="https://ziglang.org/documentation/0.15.2/#Memory">Memory</a> storage.
      </p>
      <p>
      It is generally preferable to use <code><span class="tok-kw">const</span></code> rather than
      <code><span class="tok-kw">var</span></code> when declaring a variable. This causes less work for both
      humans and computers to do when reading code, and creates more optimization opportunities.
      </p>
      <p>
      The <code><span class="tok-kw">extern</span></code> keyword or <a href="https://ziglang.org/documentation/0.15.2/#extern">@extern</a> builtin function can be used to link against a variable that is exported
      from another object. The <code><span class="tok-kw">export</span></code> keyword or <a href="https://ziglang.org/documentation/0.15.2/#export">@export</a> builtin function
      can be used to make a variable available to other objects at link time. In both cases,
      the type of the variable must be C ABI compatible.
      </p>
      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Exporting-a-C-Library">Exporting a C Library</a></li>
</ul>


      <h3 id="Identifiers"><a href="https://ziglang.org/documentation/0.15.2/#toc-Identifiers">Identifiers</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Identifiers">ยง</a></h3>

      <p>
      Variable identifiers are never allowed to shadow identifiers from an outer scope.
      </p>
      <p>
      Identifiers must start with an alphabetic character or underscore and may be followed
      by any number of alphanumeric characters or underscores.
      They must not overlap with any keywords. See <a href="https://ziglang.org/documentation/0.15.2/#Keyword-Reference">Keyword Reference</a>.
      </p>
      <p>
      If a name that does not fit these requirements is needed, such as for linking with external libraries, the <code>@""</code> syntax may be used.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">identifiers.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> @"identifier with spaces in it" = <span class="tok-number">0xff</span>;
<span class="tok-kw">const</span> @"1SmallStep4Man" = <span class="tok-number">112358</span>;

<span class="tok-kw">const</span> c = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).c;
<span class="tok-kw">pub</span> <span class="tok-kw">extern</span> <span class="tok-str">"c"</span> <span class="tok-kw">fn</span> <span class="tok-fn">@"error"</span>() <span class="tok-type">void</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">extern</span> <span class="tok-str">"c"</span> <span class="tok-kw">fn</span> <span class="tok-fn">@"fstat$INODE64"</span>(fd: c.fd_t, buf: *c.Stat) <span class="tok-type">c_int</span>;

<span class="tok-kw">const</span> Color = <span class="tok-kw">enum</span> {
    red,
    @"really red",
};
<span class="tok-kw">const</span> color: Color = .@"really red";</code></pre></figure>

      

      <h3 id="Container-Level-Variables"><a href="https://ziglang.org/documentation/0.15.2/#toc-Container-Level-Variables">Container Level Variables</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Container-Level-Variables">ยง</a></h3>

      <p>
      <a href="https://ziglang.org/documentation/0.15.2/#Containers">Container</a> level variables have static lifetime and are order-independent and lazily analyzed.
      The initialization value of container level variables is implicitly
      <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a>. If a container level variable is <code><span class="tok-kw">const</span></code> then its value is
      <code><span class="tok-kw">comptime</span></code>-known, otherwise it is runtime-known.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_container_level_variables.zig</cite></figcaption><pre><code><span class="tok-kw">var</span> y: <span class="tok-type">i32</span> = add(<span class="tok-number">10</span>, x);
<span class="tok-kw">const</span> x: <span class="tok-type">i32</span> = add(<span class="tok-number">12</span>, <span class="tok-number">34</span>);

<span class="tok-kw">test</span> <span class="tok-str">"container level variables"</span> {
    <span class="tok-kw">try</span> expect(x == <span class="tok-number">46</span>);
    <span class="tok-kw">try</span> expect(y == <span class="tok-number">56</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">add</span>(a: <span class="tok-type">i32</span>, b: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> a + b;
}

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_container_level_variables.zig</kbd>
1/1 test_container_level_variables.test.container level variables...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      Container level variables may be declared inside a <a href="https://ziglang.org/documentation/0.15.2/#struct">struct</a>, <a href="https://ziglang.org/documentation/0.15.2/#union">union</a>, <a href="https://ziglang.org/documentation/0.15.2/#enum">enum</a>, or <a href="https://ziglang.org/documentation/0.15.2/#opaque">opaque</a>:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_namespaced_container_level_variable.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"namespaced container level variable"</span> {
    <span class="tok-kw">try</span> expect(foo() == <span class="tok-number">1235</span>);
    <span class="tok-kw">try</span> expect(foo() == <span class="tok-number">1236</span>);
}

<span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
};

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">i32</span> {
    S.x += <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> S.x;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_namespaced_container_level_variable.zig</kbd>
1/1 test_namespaced_container_level_variable.test.namespaced container level variable...OK
All 1 tests passed.
</samp></pre></figure>

      

      <h3 id="Static-Local-Variables"><a href="https://ziglang.org/documentation/0.15.2/#toc-Static-Local-Variables">Static Local Variables</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Static-Local-Variables">ยง</a></h3>

      <p>
        It is also possible to have local variables with static lifetime by using containers inside functions.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_static_local_variable.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"static local variable"</span> {
    <span class="tok-kw">try</span> expect(foo() == <span class="tok-number">1235</span>);
    <span class="tok-kw">try</span> expect(foo() == <span class="tok-number">1236</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">i32</span> {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    };
    S.x += <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> S.x;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_static_local_variable.zig</kbd>
1/1 test_static_local_variable.test.static local variable...OK
All 1 tests passed.
</samp></pre></figure>

      

      <h3 id="Thread-Local-Variables"><a href="https://ziglang.org/documentation/0.15.2/#toc-Thread-Local-Variables">Thread Local Variables</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Thread-Local-Variables">ยง</a></h3>

      <p>A variable may be specified to be a thread-local variable using the
      <code><span class="tok-kw">threadlocal</span></code> keyword,
      which makes each thread work with a separate instance of the variable:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_thread_local_variables.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> assert = std.debug.assert;

<span class="tok-kw">threadlocal</span> <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;

<span class="tok-kw">test</span> <span class="tok-str">"thread local storage"</span> {
    <span class="tok-kw">const</span> thread1 = <span class="tok-kw">try</span> std.Thread.spawn(.{}, testTls, .{});
    <span class="tok-kw">const</span> thread2 = <span class="tok-kw">try</span> std.Thread.spawn(.{}, testTls, .{});
    testTls();
    thread1.join();
    thread2.join();
}

<span class="tok-kw">fn</span> <span class="tok-fn">testTls</span>() <span class="tok-type">void</span> {
    assert(x == <span class="tok-number">1234</span>);
    x += <span class="tok-number">1</span>;
    assert(x == <span class="tok-number">1235</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_thread_local_variables.zig</kbd>
1/1 test_thread_local_variables.test.thread local storage...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      For <a href="https://ziglang.org/documentation/0.15.2/#Single-Threaded-Builds">Single Threaded Builds</a>, all thread local variables are treated as regular <a href="https://ziglang.org/documentation/0.15.2/#Container-Level-Variables">Container Level Variables</a>.
      </p>
      <p>
      Thread local variables may not be <code><span class="tok-kw">const</span></code>.
      </p>
      

      <h3 id="Local-Variables"><a href="https://ziglang.org/documentation/0.15.2/#toc-Local-Variables">Local Variables</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Local-Variables">ยง</a></h3>

      <p>
      Local variables occur inside <a href="https://ziglang.org/documentation/0.15.2/#Functions">Functions</a>, <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a> blocks, and <a href="https://ziglang.org/documentation/0.15.2/#cImport">@cImport</a> blocks.
      </p>
      <p>
      When a local variable is <code><span class="tok-kw">const</span></code>, it means that after initialization, the variable's
      value will not change. If the initialization value of a <code><span class="tok-kw">const</span></code> variable is
      <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a>-known, then the variable is also <code><span class="tok-kw">comptime</span></code>-known.
      </p>
      <p>
      A local variable may be qualified with the <code><span class="tok-kw">comptime</span></code> keyword. This causes
      the variable's value to be <code><span class="tok-kw">comptime</span></code>-known, and all loads and stores of the
      variable to happen during semantic analysis of the program, rather than at runtime.
      All variables declared in a <code><span class="tok-kw">comptime</span></code> expression are implicitly
      <code><span class="tok-kw">comptime</span></code> variables.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_variables.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"comptime vars"</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> y: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;

    x += <span class="tok-number">1</span>;
    y += <span class="tok-number">1</span>;

    <span class="tok-kw">try</span> expect(x == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> expect(y == <span class="tok-number">2</span>);

    <span class="tok-kw">if</span> (y != <span class="tok-number">2</span>) {
        <span class="tok-comment">// This compile error never triggers because y is a comptime variable,</span>
        <span class="tok-comment">// and so `y != 2` is a comptime value, and this if is statically evaluated.</span>
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">"wrong y value"</span>);
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_variables.zig</kbd>
1/1 test_comptime_variables.test.comptime vars...OK
All 1 tests passed.
</samp></pre></figure>

      
      

      <h2 id="Integers"><a href="https://ziglang.org/documentation/0.15.2/#toc-Integers">Integers</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Integers">ยง</a></h2>

      <h3 id="Integer-Literals"><a href="https://ziglang.org/documentation/0.15.2/#toc-Integer-Literals">Integer Literals</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Integer-Literals">ยง</a></h3>

      <figure><figcaption class="zig-cap"><cite class="file">integer_literals.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> decimal_int = <span class="tok-number">98222</span>;
<span class="tok-kw">const</span> hex_int = <span class="tok-number">0xff</span>;
<span class="tok-kw">const</span> another_hex_int = <span class="tok-number">0xFF</span>;
<span class="tok-kw">const</span> octal_int = <span class="tok-number">0o755</span>;
<span class="tok-kw">const</span> binary_int = <span class="tok-number">0b11110000</span>;

<span class="tok-comment">// underscores may be placed between two digits as a visual separator</span>
<span class="tok-kw">const</span> one_billion = <span class="tok-number">1_000_000_000</span>;
<span class="tok-kw">const</span> binary_mask = <span class="tok-number">0b1_1111_1111</span>;
<span class="tok-kw">const</span> permissions = <span class="tok-number">0o7_5_5</span>;
<span class="tok-kw">const</span> big_address = <span class="tok-number">0xFF80_0000_0000_0000</span>;</code></pre></figure>

      
      <h3 id="Runtime-Integer-Values"><a href="https://ziglang.org/documentation/0.15.2/#toc-Runtime-Integer-Values">Runtime Integer Values</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Runtime-Integer-Values">ยง</a></h3>

      <p>
      Integer literals have no size limitation, and if any Illegal Behavior occurs,
      the compiler catches it.
      </p>
      <p>
      However, once an integer value is no longer known at compile-time, it must have a
      known size, and is vulnerable to safety-checked <a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">Illegal Behavior</a>.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_vs_comptime.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">divide</span>(a: <span class="tok-type">i32</span>, b: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> a / b;
}</code></pre></figure>

      <p>
      In this function, values <code>a</code> and <code>b</code> are known only at runtime,
      and thus this division operation is vulnerable to both <a href="https://ziglang.org/documentation/0.15.2/#Integer-Overflow">Integer Overflow</a> and
      <a href="https://ziglang.org/documentation/0.15.2/#Division-by-Zero">Division by Zero</a>.
      </p>
      <p>
      Operators such as <code>+</code> and <code>-</code> cause <a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">Illegal Behavior</a> on
      integer overflow. Alternative operators are provided for wrapping and saturating arithmetic on all targets.
      <code>+%</code> and <code>-%</code> perform wrapping arithmetic
      while <code>+|</code> and <code>-|</code> perform saturating arithmetic.
      </p>
      <p>
      Zig supports arbitrary bit-width integers, referenced by using
      an identifier of <code>i</code> or <code>u</code> followed by digits. For example, the identifier
      <code><span class="tok-type">i7</span></code> refers to a signed 7-bit integer. The maximum allowed bit-width of an
      integer type is <code><span class="tok-number">65535</span></code>. For signed integer types, Zig uses a
      <a href="https://en.wikipedia.org/wiki/Two&#39;s_complement">two's complement</a> representation.
      </p>
      <p>See also:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Wrapping-Operations">Wrapping Operations</a></li>
</ul>

      
      
      <h2 id="Floats"><a href="https://ziglang.org/documentation/0.15.2/#toc-Floats">Floats</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Floats">ยง</a></h2>

      <p>Zig has the following floating point types:</p>
      <ul>
          <li><code><span class="tok-type">f16</span></code> - IEEE-754-2008 binary16</li>
          <li><code><span class="tok-type">f32</span></code> - IEEE-754-2008 binary32</li>
          <li><code><span class="tok-type">f64</span></code> - IEEE-754-2008 binary64</li>
          <li><code><span class="tok-type">f80</span></code> - IEEE-754-2008 80-bit extended precision</li>
          <li><code><span class="tok-type">f128</span></code> - IEEE-754-2008 binary128</li>
          <li><code><span class="tok-type">c_longdouble</span></code> - matches <code class="c">long double</code> for the target C ABI</li>
      </ul>
      <h3 id="Float-Literals"><a href="https://ziglang.org/documentation/0.15.2/#toc-Float-Literals">Float Literals</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Float-Literals">ยง</a></h3>

      <p>
      Float literals have type <code><span class="tok-type">comptime_float</span></code> which is guaranteed to have
      the same precision and operations of the largest other floating point type, which is
      <code><span class="tok-type">f128</span></code>.
      </p>
      <p>
      Float literals <a href="https://ziglang.org/documentation/0.15.2/#Type-Coercion">coerce</a> to any floating point type,
      and to any <a href="https://ziglang.org/documentation/0.15.2/#Integers">integer</a> type when there is no fractional component.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">float_literals.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> floating_point = <span class="tok-number">123.0E+77</span>;
<span class="tok-kw">const</span> another_float = <span class="tok-number">123.0</span>;
<span class="tok-kw">const</span> yet_another = <span class="tok-number">123.0e+77</span>;

<span class="tok-kw">const</span> hex_floating_point = <span class="tok-number">0x103.70p-5</span>;
<span class="tok-kw">const</span> another_hex_float = <span class="tok-number">0x103.70</span>;
<span class="tok-kw">const</span> yet_another_hex_float = <span class="tok-number">0x103.70P-5</span>;

<span class="tok-comment">// underscores may be placed between two digits as a visual separator</span>
<span class="tok-kw">const</span> lightspeed = <span class="tok-number">299_792_458.000_000</span>;
<span class="tok-kw">const</span> nanosecond = <span class="tok-number">0.000_000_001</span>;
<span class="tok-kw">const</span> more_hex = <span class="tok-number">0x1234_5678.9ABC_CDEFp-10</span>;</code></pre></figure>

      <p>
      There is no syntax for NaN, infinity, or negative infinity. For these special values,
      one must use the standard library:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">float_special_values.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">const</span> inf = std.math.inf(<span class="tok-type">f32</span>);
<span class="tok-kw">const</span> negative_inf = -std.math.inf(<span class="tok-type">f64</span>);
<span class="tok-kw">const</span> nan = std.math.nan(<span class="tok-type">f128</span>);</code></pre></figure>

      
      <h3 id="Floating-Point-Operations"><a href="https://ziglang.org/documentation/0.15.2/#toc-Floating-Point-Operations">Floating Point Operations</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Floating-Point-Operations">ยง</a></h3>

      <p>By default floating point operations use <code>Strict</code> mode,
          but you can switch to <code>Optimized</code> mode on a per-block basis:</p>
      <figure><figcaption class="zig-cap"><cite class="file">float_mode_obj.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> big = <span class="tok-builtin">@as</span>(<span class="tok-type">f64</span>, <span class="tok-number">1</span> &lt;&lt; <span class="tok-number">40</span>);

<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo_strict</span>(x: <span class="tok-type">f64</span>) <span class="tok-type">f64</span> {
    <span class="tok-kw">return</span> x + big - big;
}

<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo_optimized</span>(x: <span class="tok-type">f64</span>) <span class="tok-type">f64</span> {
    <span class="tok-builtin">@setFloatMode</span>(.optimized);
    <span class="tok-kw">return</span> x + big - big;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-obj float_mode_obj.zig -O ReleaseFast</kbd>
</samp></pre></figure>

      <p>For this test we have to separate code into two object files -
      otherwise the optimizer figures out all the values at compile-time,
      which operates in strict mode.</p>
      <figure><figcaption class="zig-cap"><cite class="file">float_mode_exe.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;

<span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo_strict</span>(x: <span class="tok-type">f64</span>) <span class="tok-type">f64</span>;
<span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo_optimized</span>(x: <span class="tok-type">f64</span>) <span class="tok-type">f64</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> x = <span class="tok-number">0.001</span>;
    print(<span class="tok-str">"optimized = {}\n"</span>, .{foo_optimized(x)});
    print(<span class="tok-str">"strict = {}\n"</span>, .{foo_strict(x)});
}</code></pre></figure>

