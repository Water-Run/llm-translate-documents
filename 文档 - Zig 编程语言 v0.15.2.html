<!-- ====== BEGIN CHUNK 1: new_01.html ====== -->
<!DOCTYPE html>
<!-- saved from url=(0041)https://ziglang.org/documentation/0.15.2/ -->
<html lang="zh-CN"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>文档 - Zig 编程语言</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg==">
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style>
      :root{
         --nav-width: 26em;
         --nav-margin-l: 1em;
      }
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }
      header {
        padding: 0 1em;
      }
      #contents {
        max-width: 60em;
        margin: auto;
        padding: 0 1em;
      }
      #navigation {
        padding: 0 1em;
      }
      table ul {
        list-style-type: none;
        padding: 0em;
      }
      table li {
        padding-bottom: 1em;
        line-height:1.2em;
      }
      table, th, td {
        border-collapse: collapse;
        border: 1px solid grey;
      }
      th, td {
        padding: 0.5em;
      }
      th[scope=row] {
          text-align: left;
          font-weight: normal;
      }

      @media screen and (min-width: 1025px) {
        header {
          margin-left: calc(var(--nav-width) + var(--nav-margin-l));
        }
        header h1 {
          margin: auto;
          max-width: 30em;
        }
        #navigation {
          overflow: auto;
          width: var(--nav-width);
          height: 100vh;
          position: fixed;
          top:0;
          left:0;
          bottom:0;
          padding: unset;
          margin-left: var(--nav-margin-l);
        }
        #navigation nav ul {
          padding-left: 1em;
        }
        #contents-wrapper {
          margin-left: calc(var(--nav-width) + var(--nav-margin-l));
        }
      }

      a:hover,a:focus {
        background: #fff2a8;
      }
      dt {
        font-weight: bold;
      }
      .sgr-1m {
        font-weight: bold;
      }
      .sgr-2m {
        color: #575757;
      }
      .sgr-31_1m {
        color: #b40000;
      }
      .sgr-32_1m {
        color: green;
      }
      .sgr-36_1m {
        color: #005C7A;
      }
      .file {
        font-weight: bold;
        border: unset;
      }
      code {
        background: #f8f8f8;
        border: 1px dotted silver;
        padding-left: 0.3em;
        padding-right: 0.3em;
      }
      pre > code {
        display: block;
        overflow: auto;
        padding: 0.5em;
        border: 1px solid #eee;
        line-height: normal;
      }
      samp {
        background: #fafafa;
      }
      pre > samp {
        display: block;
        overflow: auto;
        padding: 0.5em;
        border: 1px solid #eee;
        line-height: normal;
      }
      kbd {
        font-weight: normal;
      }
      .table-wrapper {
        width: 100%;
        overflow-x: auto;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      figure {
        margin: auto 0;
      }
      figure pre {
        margin-top: 0;
      }

      figcaption {
        padding-left: 0.5em;
        font-size: small;
        border-top-left-radius: 5px;
        border-top-right-radius: 5px;
      }
      figcaption.zig-cap {
        background: #fcdba5;
      }
      figcaption.c-cap {
        background: #a8b9cc;
        color: #000;
      }
      figcaption.peg-cap {
        background: #fcdba5;
      }
      figcaption.javascript-cap {
        background: #365d95;
        color: #fff;
      }
      figcaption.shell-cap {
        background: #ccc;
        color: #000;
      }

      aside {
        border-left: 0.25em solid #f7a41d;
        padding: 0 1em 0 1em;
      }

      h1 a, h2 a, h3 a, h4 a, h5 a {
        text-decoration: none;
        color: #333;
      }

      a.hdr {
        visibility: hidden;
      }
      h1:hover > a.hdr, h2:hover > a.hdr, h3:hover > a.hdr, h4:hover > a.hdr, h5:hover > a.hdr {
        visibility: visible;
      }

      th pre code {
          background: none;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#121212;
            color: #ccc;
        }
        a {
            color: #88f;
        }
        a:hover,a:focus {
            color: #000;
        }
        table, th, td {
            border-color: grey;
        }
        .sgr-2m {
            color: grey;
        }
        .sgr-31_1m {
            color: red;
        }
        .sgr-32_1m {
            color: #00B800;
        }
        .sgr-36_1m {
            color: #0086b3;
        }
        code {
          background: #222;
          border-color: #444;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        samp {
          background: #000;
          color: #ccc;
        }
        pre > samp {
          border: unset;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
        h1 a, h2 a, h3 a, h4 a, h5 a {
            color: #aaa;
        }
        figcaption.zig-cap {
            background-color: #b27306;
            color: #000;
        }
        figcaption.peg-cap {
            background-color: #b27306;
            color: #000;
        }
        figcaption.shell-cap {
          background: #2a2a2a;
          color: #fff;
        }
      }
    </style>
</head>
<body>
  <header><h1>Zig 语言参考</h1></header>
  <div id="main-wrapper">
      <div id="navigation">
        <nav aria-labelledby="zig-version">
          <h2 id="zig-version">Zig 版本</h2>
          <a href="https://ziglang.org/documentation/0.1.1/">0.1.1</a> |
<a href="https://ziglang.org/documentation/0.2.0/">0.2.0</a> |
<a href="https://ziglang.org/documentation/0.3.0/">0.3.0</a> |
<a href="https://ziglang.org/documentation/0.4.0/">0.4.0</a> |
<a href="https://ziglang.org/documentation/0.5.0/">0.5.0</a> |
<a href="https://ziglang.org/documentation/0.6.0/">0.6.0</a> |
<a href="https://ziglang.org/documentation/0.7.1/">0.7.1</a> |
<a href="https://ziglang.org/documentation/0.8.1/">0.8.1</a> |
<a href="https://ziglang.org/documentation/0.9.1/">0.9.1</a> |
<a href="https://ziglang.org/documentation/0.10.1/">0.10.1</a> |
<a href="https://ziglang.org/documentation/0.11.0/">0.11.0</a> |
<a href="https://ziglang.org/documentation/0.12.1/">0.12.1</a> |
<a href="https://ziglang.org/documentation/0.13.0/">0.13.0</a> |
<a href="https://ziglang.org/documentation/0.14.1/">0.14.1</a> |
0.15.2 |
<a href="https://ziglang.org/documentation/master/">master</a>
        </nav>
        <nav aria-labelledby="table-of-contents">
          <h2 id="table-of-contents">目录</h2>
          

    <ul>
        <li><a id="toc-Introduction" href="https://ziglang.org/documentation/0.15.2/#Introduction">简介</a></li>
        <li><a id="toc-Zig-Standard-Library" href="https://ziglang.org/documentation/0.15.2/#Zig-Standard-Library">Zig 标准库</a></li>
        <li><a id="toc-Hello-World" href="https://ziglang.org/documentation/0.15.2/#Hello-World">Hello World</a></li>
        <li><a id="toc-Comments" href="https://ziglang.org/documentation/0.15.2/#Comments">注释</a>
        <ul>
            <li><a id="toc-Doc-Comments" href="https://ziglang.org/documentation/0.15.2/#Doc-Comments">文档注释</a></li>
            <li><a id="toc-Top-Level-Doc-Comments" href="https://ziglang.org/documentation/0.15.2/#Top-Level-Doc-Comments">顶级文档注释</a></li>
        </ul></li>
        <li><a id="toc-Values" href="https://ziglang.org/documentation/0.15.2/#Values">值</a>
        <ul>
            <li><a id="toc-Primitive-Types" href="https://ziglang.org/documentation/0.15.2/#Primitive-Types">基本类型</a></li>
            <li><a id="toc-Primitive-Values" href="https://ziglang.org/documentation/0.15.2/#Primitive-Values">基本值</a></li>
            <li><a id="toc-String-Literals-and-Unicode-Code-Point-Literals" href="https://ziglang.org/documentation/0.15.2/#String-Literals-and-Unicode-Code-Point-Literals">字符串字面量和 Unicode 码点字面量</a>
            <ul>
                <li><a id="toc-Escape-Sequences" href="https://ziglang.org/documentation/0.15.2/#Escape-Sequences">转义序列</a></li>
                <li><a id="toc-Multiline-String-Literals" href="https://ziglang.org/documentation/0.15.2/#Multiline-String-Literals">多行字符串字面量</a></li>
            </ul></li>
            <li><a id="toc-Assignment" href="https://ziglang.org/documentation/0.15.2/#Assignment">赋值</a>
            <ul>
                <li><a id="toc-undefined" href="https://ziglang.org/documentation/0.15.2/#undefined">undefined</a></li>
                <li><a id="toc-Destructuring" href="https://ziglang.org/documentation/0.15.2/#Destructuring">解构</a></li>
            </ul></li>
        </ul></li>
        <li><a id="toc-Zig-Test" href="https://ziglang.org/documentation/0.15.2/#Zig-Test">Zig 测试</a>
        <ul>
            <li><a id="toc-Test-Declarations" href="https://ziglang.org/documentation/0.15.2/#Test-Declarations">测试声明</a>
            <ul>
                <li><a id="toc-Doctests" href="https://ziglang.org/documentation/0.15.2/#Doctests">文档测试</a></li>
            </ul></li>
            <li><a id="toc-Test-Failure" href="https://ziglang.org/documentation/0.15.2/#Test-Failure">测试失败</a></li>
            <li><a id="toc-Skip-Tests" href="https://ziglang.org/documentation/0.15.2/#Skip-Tests">跳过测试</a></li>
            <li><a id="toc-Report-Memory-Leaks" href="https://ziglang.org/documentation/0.15.2/#Report-Memory-Leaks">报告内存泄漏</a></li>
            <li><a id="toc-Detecting-Test-Build" href="https://ziglang.org/documentation/0.15.2/#Detecting-Test-Build">检测测试构建</a></li>
            <li><a id="toc-Test-Output-and-Logging" href="https://ziglang.org/documentation/0.15.2/#Test-Output-and-Logging">测试输出和日志</a></li>
            <li><a id="toc-The-Testing-Namespace" href="https://ziglang.org/documentation/0.15.2/#The-Testing-Namespace">测试命名空间</a></li>
            <li><a id="toc-Test-Tool-Documentation" href="https://ziglang.org/documentation/0.15.2/#Test-Tool-Documentation">测试工具文档</a></li>
        </ul></li>
        <li><a id="toc-Variables" href="https://ziglang.org/documentation/0.15.2/#Variables">变量</a>
        <ul>
            <li><a id="toc-Identifiers" href="https://ziglang.org/documentation/0.15.2/#Identifiers">标识符</a></li>
            <li><a id="toc-Container-Level-Variables" href="https://ziglang.org/documentation/0.15.2/#Container-Level-Variables">容器级变量</a></li>
            <li><a id="toc-Static-Local-Variables" href="https://ziglang.org/documentation/0.15.2/#Static-Local-Variables">静态局部变量</a></li>
            <li><a id="toc-Thread-Local-Variables" href="https://ziglang.org/documentation/0.15.2/#Thread-Local-Variables">线程局部变量</a></li>
            <li><a id="toc-Local-Variables" href="https://ziglang.org/documentation/0.15.2/#Local-Variables">局部变量</a></li>
        </ul></li>
        <li><a id="toc-Integers" href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a>
        <ul>
            <li><a id="toc-Integer-Literals" href="https://ziglang.org/documentation/0.15.2/#Integer-Literals">整数字面量</a></li>
            <li><a id="toc-Runtime-Integer-Values" href="https://ziglang.org/documentation/0.15.2/#Runtime-Integer-Values">运行时整数值</a></li>
        </ul></li>
        <li><a id="toc-Floats" href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a>
        <ul>
            <li><a id="toc-Float-Literals" href="https://ziglang.org/documentation/0.15.2/#Float-Literals">浮点数字面量</a></li>
            <li><a id="toc-Floating-Point-Operations" href="https://ziglang.org/documentation/0.15.2/#Floating-Point-Operations">浮点数操作</a></li>
        </ul></li>
        <li><a id="toc-Operators" href="https://ziglang.org/documentation/0.15.2/#Operators">运算符</a>
        <ul>
            <li><a id="toc-Table-of-Operators" href="https://ziglang.org/documentation/0.15.2/#Table-of-Operators">运算符表</a></li>
            <li><a id="toc-Precedence" href="https://ziglang.org/documentation/0.15.2/#Precedence">优先级</a></li>
        </ul></li>
        <li><a id="toc-Arrays" href="https://ziglang.org/documentation/0.15.2/#Arrays">数组</a>
        <ul>
            <li><a id="toc-Multidimensional-Arrays" href="https://ziglang.org/documentation/0.15.2/#Multidimensional-Arrays">多维数组</a></li>
            <li><a id="toc-Sentinel-Terminated-Arrays" href="https://ziglang.org/documentation/0.15.2/#Sentinel-Terminated-Arrays">哨兵终止数组</a></li>
            <li><a id="toc-Destructuring-Arrays" href="https://ziglang.org/documentation/0.15.2/#Destructuring-Arrays">解构数组</a></li>
        </ul></li>
        <li><a id="toc-Vectors" href="https://ziglang.org/documentation/0.15.2/#Vectors">向量</a>
        <ul>
            <li><a id="toc-Destructuring-Vectors" href="https://ziglang.org/documentation/0.15.2/#Destructuring-Vectors">解构向量</a></li>
        </ul></li>
        <li><a id="toc-Pointers" href="https://ziglang.org/documentation/0.15.2/#Pointers">指针</a>
        <ul>
            <li><a id="toc-volatile" href="https://ziglang.org/documentation/0.15.2/#volatile">volatile</a></li>
            <li><a id="toc-Alignment" href="https://ziglang.org/documentation/0.15.2/#Alignment">对齐</a></li>
            <li><a id="toc-allowzero" href="https://ziglang.org/documentation/0.15.2/#allowzero">allowzero</a></li>
            <li><a id="toc-Sentinel-Terminated-Pointers" href="https://ziglang.org/documentation/0.15.2/#Sentinel-Terminated-Pointers">哨兵终止指针</a></li>
        </ul></li>
        <li><a id="toc-Slices" href="https://ziglang.org/documentation/0.15.2/#Slices">切片</a>
        <ul>
            <li><a id="toc-Sentinel-Terminated-Slices" href="https://ziglang.org/documentation/0.15.2/#Sentinel-Terminated-Slices">哨兵终止切片</a></li>
        </ul></li>
        <li><a id="toc-struct" href="https://ziglang.org/documentation/0.15.2/#struct">struct</a>
        <ul>
            <li><a id="toc-Default-Field-Values" href="https://ziglang.org/documentation/0.15.2/#Default-Field-Values">默认字段值</a>
            <ul>
                <li><a id="toc-Faulty-Default-Field-Values" href="https://ziglang.org/documentation/0.15.2/#Faulty-Default-Field-Values">错误的默认字段值</a></li>
            </ul></li>
            <li><a id="toc-extern-struct" href="https://ziglang.org/documentation/0.15.2/#extern-struct">extern struct</a></li>
            <li><a id="toc-packed-struct" href="https://ziglang.org/documentation/0.15.2/#packed-struct">packed struct</a></li>
            <li><a id="toc-Struct-Naming" href="https://ziglang.org/documentation/0.15.2/#Struct-Naming">结构体命名</a></li>
            <li><a id="toc-Anonymous-Struct-Literals" href="https://ziglang.org/documentation/0.15.2/#Anonymous-Struct-Literals">匿名结构体字面量</a></li>
            <li><a id="toc-Tuples" href="https://ziglang.org/documentation/0.15.2/#Tuples">元组</a>
            <ul>
                <li><a id="toc-Destructuring-Tuples" href="https://ziglang.org/documentation/0.15.2/#Destructuring-Tuples">解构元组</a></li>
            </ul></li>
        </ul></li>
        <li><a id="toc-enum" href="https://ziglang.org/documentation/0.15.2/#enum">enum</a>
        <ul>
            <li><a id="toc-extern-enum" href="https://ziglang.org/documentation/0.15.2/#extern-enum">extern enum</a></li>
            <li><a id="toc-Enum-Literals" href="https://ziglang.org/documentation/0.15.2/#Enum-Literals">枚举字面量</a></li>
            <li><a id="toc-Non-exhaustive-enum" href="https://ziglang.org/documentation/0.15.2/#Non-exhaustive-enum">非穷尽枚举</a></li>
        </ul></li>
        <li><a id="toc-union" href="https://ziglang.org/documentation/0.15.2/#union">union</a>
        <ul>
            <li><a id="toc-Tagged-union" href="https://ziglang.org/documentation/0.15.2/#Tagged-union">标记联合</a></li>
            <li><a id="toc-extern-union" href="https://ziglang.org/documentation/0.15.2/#extern-union">extern union</a></li>
            <li><a id="toc-packed-union" href="https://ziglang.org/documentation/0.15.2/#packed-union">packed union</a></li>
            <li><a id="toc-Anonymous-Union-Literals" href="https://ziglang.org/documentation/0.15.2/#Anonymous-Union-Literals">匿名联合字面量</a></li>
        </ul></li>
        <li><a id="toc-opaque" href="https://ziglang.org/documentation/0.15.2/#opaque">opaque</a></li>
        <li><a id="toc-Blocks" href="https://ziglang.org/documentation/0.15.2/#Blocks">块</a>
        <ul>
            <li><a id="toc-Shadowing" href="https://ziglang.org/documentation/0.15.2/#Shadowing">遮蔽</a></li>
            <li><a id="toc-Empty-Blocks" href="https://ziglang.org/documentation/0.15.2/#Empty-Blocks">空块</a></li>
        </ul></li>
        <li><a id="toc-switch" href="https://ziglang.org/documentation/0.15.2/#switch">switch</a>
        <ul>
            <li><a id="toc-Exhaustive-Switching" href="https://ziglang.org/documentation/0.15.2/#Exhaustive-Switching">穷尽切换</a></li>
            <li><a id="toc-Switching-with-Enum-Literals" href="https://ziglang.org/documentation/0.15.2/#Switching-with-Enum-Literals">使用枚举字面量切换</a></li>
            <li><a id="toc-Labeled-switch" href="https://ziglang.org/documentation/0.15.2/#Labeled-switch">带标签的 switch</a></li>
            <li><a id="toc-Inline-Switch-Prongs" href="https://ziglang.org/documentation/0.15.2/#Inline-Switch-Prongs">内联 Switch 分支</a></li>
        </ul></li>
        <li><a id="toc-while" href="https://ziglang.org/documentation/0.15.2/#while">while</a>
        <ul>
            <li><a id="toc-Labeled-while" href="https://ziglang.org/documentation/0.15.2/#Labeled-while">带标签的 while</a></li>
            <li><a id="toc-while-with-Optionals" href="https://ziglang.org/documentation/0.15.2/#while-with-Optionals">while 与可选值</a></li>
            <li><a id="toc-while-with-Error-Unions" href="https://ziglang.org/documentation/0.15.2/#while-with-Error-Unions">while 与错误联合</a></li>
            <li><a id="toc-inline-while" href="https://ziglang.org/documentation/0.15.2/#inline-while">inline while</a></li>
        </ul></li>
        <li><a id="toc-for" href="https://ziglang.org/documentation/0.15.2/#for">for</a>
        <ul>
            <li><a id="toc-Labeled-for" href="https://ziglang.org/documentation/0.15.2/#Labeled-for">带标签的 for</a></li>
            <li><a id="toc-inline-for" href="https://ziglang.org/documentation/0.15.2/#inline-for">inline for</a></li>
        </ul></li>
        <li><a id="toc-if" href="https://ziglang.org/documentation/0.15.2/#if">if</a>
        <ul>
            <li><a id="toc-if-with-Optionals" href="https://ziglang.org/documentation/0.15.2/#if-with-Optionals">if 与可选值</a></li>
        </ul></li>
        <li><a id="toc-defer" href="https://ziglang.org/documentation/0.15.2/#defer">defer</a></li>
        <li><a id="toc-unreachable" href="https://ziglang.org/documentation/0.15.2/#unreachable">unreachable</a>
        <ul>
            <li><a id="toc-Basics" href="https://ziglang.org/documentation/0.15.2/#Basics">基础</a></li>
            <li><a id="toc-At-Compile-Time" href="https://ziglang.org/documentation/0.15.2/#At-Compile-Time">编译时</a></li>
        </ul></li>
        <li><a id="toc-noreturn" href="https://ziglang.org/documentation/0.15.2/#noreturn">noreturn</a></li>
        <li><a id="toc-Functions" href="https://ziglang.org/documentation/0.15.2/#Functions">函数</a>
        <ul>
            <li><a id="toc-Pass-by-value-Parameters" href="https://ziglang.org/documentation/0.15.2/#Pass-by-value-Parameters">按值传递参数</a></li>
            <li><a id="toc-Function-Parameter-Type-Inference" href="https://ziglang.org/documentation/0.15.2/#Function-Parameter-Type-Inference">函数参数类型推断</a></li>
            <li><a id="toc-inline-fn" href="https://ziglang.org/documentation/0.15.2/#inline-fn">inline fn</a></li>
            <li><a id="toc-Function-Reflection" href="https://ziglang.org/documentation/0.15.2/#Function-Reflection">函数反射</a></li>
        </ul></li>
        <li><a id="toc-Errors" href="https://ziglang.org/documentation/0.15.2/#Errors">错误</a>
        <ul>
            <li><a id="toc-Error-Set-Type" href="https://ziglang.org/documentation/0.15.2/#Error-Set-Type">错误集类型</a>
            <ul>
                <li><a id="toc-The-Global-Error-Set" href="https://ziglang.org/documentation/0.15.2/#The-Global-Error-Set">全局错误集</a></li>
            </ul></li>
            <li><a id="toc-Error-Union-Type" href="https://ziglang.org/documentation/0.15.2/#Error-Union-Type">错误联合类型</a>
            <ul>
                <li><a id="toc-catch" href="https://ziglang.org/documentation/0.15.2/#catch">catch</a></li>
                <li><a id="toc-try" href="https://ziglang.org/documentation/0.15.2/#try">try</a></li>
                <li><a id="toc-errdefer" href="https://ziglang.org/documentation/0.15.2/#errdefer">errdefer</a></li>
                <li><a id="toc-Merging-Error-Sets" href="https://ziglang.org/documentation/0.15.2/#Merging-Error-Sets">合并错误集</a></li>
                <li><a id="toc-Inferred-Error-Sets" href="https://ziglang.org/documentation/0.15.2/#Inferred-Error-Sets">推断错误集</a></li>
            </ul></li>
            <li><a id="toc-Error-Return-Traces" href="https://ziglang.org/documentation/0.15.2/#Error-Return-Traces">错误返回跟踪</a>
            <ul>
                <li><a id="toc-Implementation-Details" href="https://ziglang.org/documentation/0.15.2/#Implementation-Details">实现细节</a></li>
            </ul></li>
        </ul></li>
        <li><a id="toc-Optionals" href="https://ziglang.org/documentation/0.15.2/#Optionals">可选值</a>
        <ul>
            <li><a id="toc-Optional-Type" href="https://ziglang.org/documentation/0.15.2/#Optional-Type">可选值类型</a></li>
            <li><a id="toc-null" href="https://ziglang.org/documentation/0.15.2/#null">null</a></li>
            <li><a id="toc-Optional-Pointers" href="https://ziglang.org/documentation/0.15.2/#Optional-Pointers">可选指针</a></li>
        </ul></li>
        <li><a id="toc-Casting" href="https://ziglang.org/documentation/0.15.2/#Casting">类型转换</a>
        <ul>
            <li><a id="toc-Type-Coercion" href="https://ziglang.org/documentation/0.15.2/#Type-Coercion">类型强制转换</a>
            <ul>
                <li><a id="toc-Type-Coercion-Stricter-Qualification" href="https://ziglang.org/documentation/0.15.2/#Type-Coercion-Stricter-Qualification">类型强制转换:更严格的限定</a></li>
                <li><a id="toc-Type-Coercion-Integer-and-Float-Widening" href="https://ziglang.org/documentation/0.15.2/#Type-Coercion-Integer-and-Float-Widening">类型强制转换:整数和浮点数扩展</a></li>
                <li><a id="toc-Type-Coercion-Float-to-Int" href="https://ziglang.org/documentation/0.15.2/#Type-Coercion-Float-to-Int">类型强制转换:浮点数到整数</a></li>
                <li><a id="toc-Type-Coercion-Slices-Arrays-and-Pointers" href="https://ziglang.org/documentation/0.15.2/#Type-Coercion-Slices-Arrays-and-Pointers">类型强制转换:切片、数组和指针</a></li>
                <li><a id="toc-Type-Coercion-Optionals" href="https://ziglang.org/documentation/0.15.2/#Type-Coercion-Optionals">类型强制转换:可选值</a></li>
                <li><a id="toc-Type-Coercion-Error-Unions" href="https://ziglang.org/documentation/0.15.2/#Type-Coercion-Error-Unions">类型强制转换:错误联合</a></li>
                <li><a id="toc-Type-Coercion-Compile-Time-Known-Numbers" href="https://ziglang.org/documentation/0.15.2/#Type-Coercion-Compile-Time-Known-Numbers">类型强制转换:编译时已知数字</a></li>
                <li><a id="toc-Type-Coercion-Unions-and-Enums" href="https://ziglang.org/documentation/0.15.2/#Type-Coercion-Unions-and-Enums">类型强制转换:联合和枚举</a></li>
                <li><a id="toc-Type-Coercion-undefined" href="https://ziglang.org/documentation/0.15.2/#Type-Coercion-undefined">类型强制转换:undefined</a></li>
                <li><a id="toc-Type-Coercion-Tuples-to-Arrays" href="https://ziglang.org/documentation/0.15.2/#Type-Coercion-Tuples-to-Arrays">类型强制转换:元组到数组</a></li>
            </ul></li>
            <li><a id="toc-Explicit-Casts" href="https://ziglang.org/documentation/0.15.2/#Explicit-Casts">显式转换</a></li>
            <li><a id="toc-Peer-Type-Resolution" href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">对等类型解析</a></li>
        </ul></li>
        <li><a id="toc-Zero-Bit-Types" href="https://ziglang.org/documentation/0.15.2/#Zero-Bit-Types">零位类型</a>
        <ul>
            <li><a id="toc-void" href="https://ziglang.org/documentation/0.15.2/#void">void</a></li>
        </ul></li>
        <li><a id="toc-Result-Location-Semantics" href="https://ziglang.org/documentation/0.15.2/#Result-Location-Semantics">结果位置语义</a>
        <ul>
            <li><a id="toc-Result-Types" href="https://ziglang.org/documentation/0.15.2/#Result-Types">结果类型</a></li>
            <li><a id="toc-Result-Locations" href="https://ziglang.org/documentation/0.15.2/#Result-Locations">结果位置</a></li>
        </ul></li>
        <li><a id="toc-comptime" href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a>
        <ul>
            <li><a id="toc-Introducing-the-Compile-Time-Concept" href="https://ziglang.org/documentation/0.15.2/#Introducing-the-Compile-Time-Concept">引入编译时概念</a>
            <ul>
                <li><a id="toc-Compile-Time-Parameters" href="https://ziglang.org/documentation/0.15.2/#Compile-Time-Parameters">编译时参数</a></li>
                <li><a id="toc-Compile-Time-Variables" href="https://ziglang.org/documentation/0.15.2/#Compile-Time-Variables">编译时变量</a></li>
                <li><a id="toc-Compile-Time-Expressions" href="https://ziglang.org/documentation/0.15.2/#Compile-Time-Expressions">编译时表达式</a></li>
            </ul></li>
            <li><a id="toc-Generic-Data-Structures" href="https://ziglang.org/documentation/0.15.2/#Generic-Data-Structures">泛型数据结构</a></li>
            <li><a id="toc-Case-Study-print-in-Zig" href="https://ziglang.org/documentation/0.15.2/#Case-Study-print-in-Zig">案例研究:Zig 中的 print</a></li>
        </ul></li>
        <li><a id="toc-Assembly" href="https://ziglang.org/documentation/0.15.2/#Assembly">汇编</a>
        <ul>
            <li><a id="toc-Output-Constraints" href="https://ziglang.org/documentation/0.15.2/#Output-Constraints">输出约束</a></li>
            <li><a id="toc-Input-Constraints" href="https://ziglang.org/documentation/0.15.2/#Input-Constraints">输入约束</a></li>
            <li><a id="toc-Clobbers" href="https://ziglang.org/documentation/0.15.2/#Clobbers">破坏列表</a></li>
            <li><a id="toc-Global-Assembly" href="https://ziglang.org/documentation/0.15.2/#Global-Assembly">全局汇编</a></li>
        </ul></li>
        <li><a id="toc-Atomics" href="https://ziglang.org/documentation/0.15.2/#Atomics">原子操作</a></li>
        <li><a id="toc-Async-Functions" href="https://ziglang.org/documentation/0.15.2/#Async-Functions">异步函数</a></li>
        <li><a id="toc-Builtin-Functions" href="https://ziglang.org/documentation/0.15.2/#Builtin-Functions">内置函数</a>
        <ul style="columns: 2">
            <li><a id="toc-addrSpaceCast" href="https://ziglang.org/documentation/0.15.2/#addrSpaceCast">@addrSpaceCast</a></li>
            <li><a id="toc-addWithOverflow" href="https://ziglang.org/documentation/0.15.2/#addWithOverflow">@addWithOverflow</a></li>
            <li><a id="toc-alignCast" href="https://ziglang.org/documentation/0.15.2/#alignCast">@alignCast</a></li>
            <li><a id="toc-alignOf" href="https://ziglang.org/documentation/0.15.2/#alignOf">@alignOf</a></li>
            <li><a id="toc-as" href="https://ziglang.org/documentation/0.15.2/#as">@as</a></li>
            <li><a id="toc-atomicLoad" href="https://ziglang.org/documentation/0.15.2/#atomicLoad">@atomicLoad</a></li>
            <li><a id="toc-atomicRmw" href="https://ziglang.org/documentation/0.15.2/#atomicRmw">@atomicRmw</a></li>
            <li><a id="toc-atomicStore" href="https://ziglang.org/documentation/0.15.2/#atomicStore">@atomicStore</a></li>
            <li><a id="toc-bitCast" href="https://ziglang.org/documentation/0.15.2/#bitCast">@bitCast</a></li>
            <li><a id="toc-bitOffsetOf" href="https://ziglang.org/documentation/0.15.2/#bitOffsetOf">@bitOffsetOf</a></li>
            <li><a id="toc-bitSizeOf" href="https://ziglang.org/documentation/0.15.2/#bitSizeOf">@bitSizeOf</a></li>
            <li><a id="toc-branchHint" href="https://ziglang.org/documentation/0.15.2/#branchHint">@branchHint</a></li>
            <li><a id="toc-breakpoint" href="https://ziglang.org/documentation/0.15.2/#breakpoint">@breakpoint</a></li>
            <li><a id="toc-mulAdd" href="https://ziglang.org/documentation/0.15.2/#mulAdd">@mulAdd</a></li>
            <li><a id="toc-byteSwap" href="https://ziglang.org/documentation/0.15.2/#byteSwap">@byteSwap</a></li>
            <li><a id="toc-bitReverse" href="https://ziglang.org/documentation/0.15.2/#bitReverse">@bitReverse</a></li>
            <li><a id="toc-offsetOf" href="https://ziglang.org/documentation/0.15.2/#offsetOf">@offsetOf</a></li>
            <li><a id="toc-call" href="https://ziglang.org/documentation/0.15.2/#call">@call</a></li>
            <li><a id="toc-cDefine" href="https://ziglang.org/documentation/0.15.2/#cDefine">@cDefine</a></li>
            <li><a id="toc-cImport" href="https://ziglang.org/documentation/0.15.2/#cImport">@cImport</a></li>
            <li><a id="toc-cInclude" href="https://ziglang.org/documentation/0.15.2/#cInclude">@cInclude</a></li>
            <li><a id="toc-clz" href="https://ziglang.org/documentation/0.15.2/#clz">@clz</a></li>
            <li><a id="toc-cmpxchgStrong" href="https://ziglang.org/documentation/0.15.2/#cmpxchgStrong">@cmpxchgStrong</a></li>
            <li><a id="toc-cmpxchgWeak" href="https://ziglang.org/documentation/0.15.2/#cmpxchgWeak">@cmpxchgWeak</a></li>
            <li><a id="toc-compileError" href="https://ziglang.org/documentation/0.15.2/#compileError">@compileError</a></li>
            <li><a id="toc-compileLog" href="https://ziglang.org/documentation/0.15.2/#compileLog">@compileLog</a></li>
            <li><a id="toc-constCast" href="https://ziglang.org/documentation/0.15.2/#constCast">@constCast</a></li>
            <li><a id="toc-ctz" href="https://ziglang.org/documentation/0.15.2/#ctz">@ctz</a></li>
            <li><a id="toc-cUndef" href="https://ziglang.org/documentation/0.15.2/#cUndef">@cUndef</a></li>
            <li><a id="toc-cVaArg" href="https://ziglang.org/documentation/0.15.2/#cVaArg">@cVaArg</a></li>
            <li><a id="toc-cVaCopy" href="https://ziglang.org/documentation/0.15.2/#cVaCopy">@cVaCopy</a></li>
            <li><a id="toc-cVaEnd" href="https://ziglang.org/documentation/0.15.2/#cVaEnd">@cVaEnd</a></li>
            <li><a id="toc-cVaStart" href="https://ziglang.org/documentation/0.15.2/#cVaStart">@cVaStart</a></li>
            <li><a id="toc-divExact" href="https://ziglang.org/documentation/0.15.2/#divExact">@divExact</a></li>
            <li><a id="toc-divFloor" href="https://ziglang.org/documentation/0.15.2/#divFloor">@divFloor</a></li>
            <li><a id="toc-divTrunc" href="https://ziglang.org/documentation/0.15.2/#divTrunc">@divTrunc</a></li>
            <li><a id="toc-embedFile" href="https://ziglang.org/documentation/0.15.2/#embedFile">@embedFile</a></li>
            <li><a id="toc-enumFromInt" href="https://ziglang.org/documentation/0.15.2/#enumFromInt">@enumFromInt</a></li>
            <li><a id="toc-errorFromInt" href="https://ziglang.org/documentation/0.15.2/#errorFromInt">@errorFromInt</a></li>
            <li><a id="toc-errorName" href="https://ziglang.org/documentation/0.15.2/#errorName">@errorName</a></li>
            <li><a id="toc-errorReturnTrace" href="https://ziglang.org/documentation/0.15.2/#errorReturnTrace">@errorReturnTrace</a></li>
            <li><a id="toc-errorCast" href="https://ziglang.org/documentation/0.15.2/#errorCast">@errorCast</a></li>
            <li><a id="toc-export" href="https://ziglang.org/documentation/0.15.2/#export">@export</a></li>
            <li><a id="toc-extern" href="https://ziglang.org/documentation/0.15.2/#extern">@extern</a></li>
            <li><a id="toc-field" href="https://ziglang.org/documentation/0.15.2/#field">@field</a></li>
            <li><a id="toc-fieldParentPtr" href="https://ziglang.org/documentation/0.15.2/#fieldParentPtr">@fieldParentPtr</a></li>
            <li><a id="toc-FieldType" href="https://ziglang.org/documentation/0.15.2/#FieldType">@FieldType</a></li>
            <li><a id="toc-floatCast" href="https://ziglang.org/documentation/0.15.2/#floatCast">@floatCast</a></li>
            <li><a id="toc-floatFromInt" href="https://ziglang.org/documentation/0.15.2/#floatFromInt">@floatFromInt</a></li>
            <li><a id="toc-frameAddress" href="https://ziglang.org/documentation/0.15.2/#frameAddress">@frameAddress</a></li>
            <li><a id="toc-hasDecl" href="https://ziglang.org/documentation/0.15.2/#hasDecl">@hasDecl</a></li>
            <li><a id="toc-hasField" href="https://ziglang.org/documentation/0.15.2/#hasField">@hasField</a></li>
            <li><a id="toc-import" href="https://ziglang.org/documentation/0.15.2/#import">@import</a></li>
            <li><a id="toc-inComptime" href="https://ziglang.org/documentation/0.15.2/#inComptime">@inComptime</a></li>
            <li><a id="toc-intCast" href="https://ziglang.org/documentation/0.15.2/#intCast">@intCast</a></li>
            <li><a id="toc-intFromBool" href="https://ziglang.org/documentation/0.15.2/#intFromBool">@intFromBool</a></li>
            <li><a id="toc-intFromEnum" href="https://ziglang.org/documentation/0.15.2/#intFromEnum">@intFromEnum</a></li>
            <li><a id="toc-intFromError" href="https://ziglang.org/documentation/0.15.2/#intFromError">@intFromError</a></li>
            <li><a id="toc-intFromFloat" href="https://ziglang.org/documentation/0.15.2/#intFromFloat">@intFromFloat</a></li>
            <li><a id="toc-intFromPtr" href="https://ziglang.org/documentation/0.15.2/#intFromPtr">@intFromPtr</a></li>
            <li><a id="toc-max" href="https://ziglang.org/documentation/0.15.2/#max">@max</a></li>
            <li><a id="toc-memcpy" href="https://ziglang.org/documentation/0.15.2/#memcpy">@memcpy</a></li>
            <li><a id="toc-memset" href="https://ziglang.org/documentation/0.15.2/#memset">@memset</a></li>
            <li><a id="toc-memmove" href="https://ziglang.org/documentation/0.15.2/#memmove">@memmove</a></li>
            <li><a id="toc-min" href="https://ziglang.org/documentation/0.15.2/#min">@min</a></li>
            <li><a id="toc-wasmMemorySize" href="https://ziglang.org/documentation/0.15.2/#wasmMemorySize">@wasmMemorySize</a></li>
            <li><a id="toc-wasmMemoryGrow" href="https://ziglang.org/documentation/0.15.2/#wasmMemoryGrow">@wasmMemoryGrow</a></li>
            <li><a id="toc-mod" href="https://ziglang.org/documentation/0.15.2/#mod">@mod</a></li>
            <li><a id="toc-mulWithOverflow" href="https://ziglang.org/documentation/0.15.2/#mulWithOverflow">@mulWithOverflow</a></li>
            <li><a id="toc-panic" href="https://ziglang.org/documentation/0.15.2/#panic">@panic</a></li>
            <li><a id="toc-popCount" href="https://ziglang.org/documentation/0.15.2/#popCount">@popCount</a></li>
            <li><a id="toc-prefetch" href="https://ziglang.org/documentation/0.15.2/#prefetch">@prefetch</a></li>
            <li><a id="toc-ptrCast" href="https://ziglang.org/documentation/0.15.2/#ptrCast">@ptrCast</a></li>
            <li><a id="toc-ptrFromInt" href="https://ziglang.org/documentation/0.15.2/#ptrFromInt">@ptrFromInt</a></li>
            <li><a id="toc-rem" href="https://ziglang.org/documentation/0.15.2/#rem">@rem</a></li>
            <li><a id="toc-returnAddress" href="https://ziglang.org/documentation/0.15.2/#returnAddress">@returnAddress</a></li>
            <li><a id="toc-select" href="https://ziglang.org/documentation/0.15.2/#select">@select</a></li>
            <li><a id="toc-setEvalBranchQuota" href="https://ziglang.org/documentation/0.15.2/#setEvalBranchQuota">@setEvalBranchQuota</a></li>
            <li><a id="toc-setFloatMode" href="https://ziglang.org/documentation/0.15.2/#setFloatMode">@setFloatMode</a></li>
            <li><a id="toc-setRuntimeSafety" href="https://ziglang.org/documentation/0.15.2/#setRuntimeSafety">@setRuntimeSafety</a></li>
            <li><a id="toc-shlExact" href="https://ziglang.org/documentation/0.15.2/#shlExact">@shlExact</a></li>
            <li><a id="toc-shlWithOverflow" href="https://ziglang.org/documentation/0.15.2/#shlWithOverflow">@shlWithOverflow</a></li>
            <li><a id="toc-shrExact" href="https://ziglang.org/documentation/0.15.2/#shrExact">@shrExact</a></li>
            <li><a id="toc-shuffle" href="https://ziglang.org/documentation/0.15.2/#shuffle">@shuffle</a></li>
            <li><a id="toc-sizeOf" href="https://ziglang.org/documentation/0.15.2/#sizeOf">@sizeOf</a></li>
            <li><a id="toc-splat" href="https://ziglang.org/documentation/0.15.2/#splat">@splat</a></li>
            <li><a id="toc-reduce" href="https://ziglang.org/documentation/0.15.2/#reduce">@reduce</a></li>
            <li><a id="toc-src" href="https://ziglang.org/documentation/0.15.2/#src">@src</a></li>
            <li><a id="toc-sqrt" href="https://ziglang.org/documentation/0.15.2/#sqrt">@sqrt</a></li>
            <li><a id="toc-sin" href="https://ziglang.org/documentation/0.15.2/#sin">@sin</a></li>
            <li><a id="toc-cos" href="https://ziglang.org/documentation/0.15.2/#cos">@cos</a></li>
            <li><a id="toc-tan" href="https://ziglang.org/documentation/0.15.2/#tan">@tan</a></li>
            <li><a id="toc-exp" href="https://ziglang.org/documentation/0.15.2/#exp">@exp</a></li>
            <li><a id="toc-exp2" href="https://ziglang.org/documentation/0.15.2/#exp2">@exp2</a></li>
            <li><a id="toc-log" href="https://ziglang.org/documentation/0.15.2/#log">@log</a></li>
            <li><a id="toc-log2" href="https://ziglang.org/documentation/0.15.2/#log2">@log2</a></li>
            <li><a id="toc-log10" href="https://ziglang.org/documentation/0.15.2/#log10">@log10</a></li>
            <li><a id="toc-abs" href="https://ziglang.org/documentation/0.15.2/#abs">@abs</a></li>
            <li><a id="toc-floor" href="https://ziglang.org/documentation/0.15.2/#floor">@floor</a></li>
            <li><a id="toc-ceil" href="https://ziglang.org/documentation/0.15.2/#ceil">@ceil</a></li>
            <li><a id="toc-trunc" href="https://ziglang.org/documentation/0.15.2/#trunc">@trunc</a></li>
            <li><a id="toc-round" href="https://ziglang.org/documentation/0.15.2/#round">@round</a></li>
            <li><a id="toc-subWithOverflow" href="https://ziglang.org/documentation/0.15.2/#subWithOverflow">@subWithOverflow</a></li>
            <li><a id="toc-tagName" href="https://ziglang.org/documentation/0.15.2/#tagName">@tagName</a></li>
            <li><a id="toc-This" href="https://ziglang.org/documentation/0.15.2/#This">@This</a></li>
            <li><a id="toc-trap" href="https://ziglang.org/documentation/0.15.2/#trap">@trap</a></li>
            <li><a id="toc-truncate" href="https://ziglang.org/documentation/0.15.2/#truncate">@truncate</a></li>
            <li><a id="toc-Type" href="https://ziglang.org/documentation/0.15.2/#Type">@Type</a></li>
            <li><a id="toc-typeInfo" href="https://ziglang.org/documentation/0.15.2/#typeInfo">@typeInfo</a></li>
            <li><a id="toc-typeName" href="https://ziglang.org/documentation/0.15.2/#typeName">@typeName</a></li>
            <li><a id="toc-TypeOf" href="https://ziglang.org/documentation/0.15.2/#TypeOf">@TypeOf</a></li>
            <li><a id="toc-unionInit" href="https://ziglang.org/documentation/0.15.2/#unionInit">@unionInit</a></li>
            <li><a id="toc-Vector" href="https://ziglang.org/documentation/0.15.2/#Vector">@Vector</a></li>
            <li><a id="toc-volatileCast" href="https://ziglang.org/documentation/0.15.2/#volatileCast">@volatileCast</a></li>
            <li><a id="toc-workGroupId" href="https://ziglang.org/documentation/0.15.2/#workGroupId">@workGroupId</a></li>
            <li><a id="toc-workGroupSize" href="https://ziglang.org/documentation/0.15.2/#workGroupSize">@workGroupSize</a></li>
            <li><a id="toc-workItemId" href="https://ziglang.org/documentation/0.15.2/#workItemId">@workItemId</a></li>
        </ul></li>
        <li><a id="toc-Build-Mode" href="https://ziglang.org/documentation/0.15.2/#Build-Mode">构建模式</a>
        <ul>
            <li><a id="toc-Debug" href="https://ziglang.org/documentation/0.15.2/#Debug">Debug</a></li>
            <li><a id="toc-ReleaseFast" href="https://ziglang.org/documentation/0.15.2/#ReleaseFast">ReleaseFast</a></li>
            <li><a id="toc-ReleaseSafe" href="https://ziglang.org/documentation/0.15.2/#ReleaseSafe">ReleaseSafe</a></li>
            <li><a id="toc-ReleaseSmall" href="https://ziglang.org/documentation/0.15.2/#ReleaseSmall">ReleaseSmall</a></li>
        </ul></li>
        <li><a id="toc-Single-Threaded-Builds" href="https://ziglang.org/documentation/0.15.2/#Single-Threaded-Builds">单线程构建</a></li>
        <li><a id="toc-Illegal-Behavior" href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>
        <ul>
            <li><a id="toc-Reaching-Unreachable-Code" href="https://ziglang.org/documentation/0.15.2/#Reaching-Unreachable-Code">到达不可达代码</a></li>
            <li><a id="toc-Index-out-of-Bounds" href="https://ziglang.org/documentation/0.15.2/#Index-out-of-Bounds">索引越界</a></li>
            <li><a id="toc-Cast-Negative-Number-to-Unsigned-Integer" href="https://ziglang.org/documentation/0.15.2/#Cast-Negative-Number-to-Unsigned-Integer">将负数转换为无符号整数</a></li>
            <li><a id="toc-Cast-Truncates-Data" href="https://ziglang.org/documentation/0.15.2/#Cast-Truncates-Data">转换截断数据</a></li>
            <li><a id="toc-Integer-Overflow" href="https://ziglang.org/documentation/0.15.2/#Integer-Overflow">整数溢出</a>
            <ul>
                <li><a id="toc-Default-Operations" href="https://ziglang.org/documentation/0.15.2/#Default-Operations">默认操作</a></li>
                <li><a id="toc-Standard-Library-Math-Functions" href="https://ziglang.org/documentation/0.15.2/#Standard-Library-Math-Functions">标准库数学函数</a></li>
                <li><a id="toc-Builtin-Overflow-Functions" href="https://ziglang.org/documentation/0.15.2/#Builtin-Overflow-Functions">内置溢出函数</a></li>
                <li><a id="toc-Wrapping-Operations" href="https://ziglang.org/documentation/0.15.2/#Wrapping-Operations">环绕操作</a></li>
            </ul></li>
            <li><a id="toc-Exact-Left-Shift-Overflow" href="https://ziglang.org/documentation/0.15.2/#Exact-Left-Shift-Overflow">精确左移溢出</a></li>
            <li><a id="toc-Exact-Right-Shift-Overflow" href="https://ziglang.org/documentation/0.15.2/#Exact-Right-Shift-Overflow">精确右移溢出</a></li>
            <li><a id="toc-Division-by-Zero" href="https://ziglang.org/documentation/0.15.2/#Division-by-Zero">除以零</a></li>
            <li><a id="toc-Remainder-Division-by-Zero" href="https://ziglang.org/documentation/0.15.2/#Remainder-Division-by-Zero">余数除以零</a></li>
            <li><a id="toc-Exact-Division-Remainder" href="https://ziglang.org/documentation/0.15.2/#Exact-Division-Remainder">精确除法余数</a></li>
            <li><a id="toc-Attempt-to-Unwrap-Null" href="https://ziglang.org/documentation/0.15.2/#Attempt-to-Unwrap-Null">尝试解包 Null</a></li>
            <li><a id="toc-Attempt-to-Unwrap-Error" href="https://ziglang.org/documentation/0.15.2/#Attempt-to-Unwrap-Error">尝试解包错误</a></li>
            <li><a id="toc-Invalid-Error-Code" href="https://ziglang.org/documentation/0.15.2/#Invalid-Error-Code">无效错误代码</a></li>
            <li><a id="toc-Invalid-Enum-Cast" href="https://ziglang.org/documentation/0.15.2/#Invalid-Enum-Cast">无效枚举转换</a></li>
            <li><a id="toc-Invalid-Error-Set-Cast" href="https://ziglang.org/documentation/0.15.2/#Invalid-Error-Set-Cast">无效错误集转换</a></li>
            <li><a id="toc-Incorrect-Pointer-Alignment" href="https://ziglang.org/documentation/0.15.2/#Incorrect-Pointer-Alignment">指针对齐不正确</a></li>
            <li><a id="toc-Wrong-Union-Field-Access" href="https://ziglang.org/documentation/0.15.2/#Wrong-Union-Field-Access">错误的联合字段访问</a></li>
            <li><a id="toc-Out-of-Bounds-Float-to-Integer-Cast" href="https://ziglang.org/documentation/0.15.2/#Out-of-Bounds-Float-to-Integer-Cast">浮点数到整数转换越界</a></li>
            <li><a id="toc-Pointer-Cast-Invalid-Null" href="https://ziglang.org/documentation/0.15.2/#Pointer-Cast-Invalid-Null">指针转换无效 Null</a></li>
        </ul></li>
        <li><a id="toc-Memory" href="https://ziglang.org/documentation/0.15.2/#Memory">内存</a>
        <ul>
            <li><a id="toc-Choosing-an-Allocator" href="https://ziglang.org/documentation/0.15.2/#Choosing-an-Allocator">选择分配器</a></li>
            <li><a id="toc-Where-are-the-bytes" href="https://ziglang.org/documentation/0.15.2/#Where-are-the-bytes">字节在哪里?</a></li>
            <li><a id="toc-Heap-Allocation-Failure" href="https://ziglang.org/documentation/0.15.2/#Heap-Allocation-Failure">堆分配失败</a></li>
            <li><a id="toc-Recursion" href="https://ziglang.org/documentation/0.15.2/#Recursion">递归</a></li>
            <li><a id="toc-Lifetime-and-Ownership" href="https://ziglang.org/documentation/0.15.2/#Lifetime-and-Ownership">生命周期和所有权</a></li>
        </ul></li>
        <li><a id="toc-Compile-Variables" href="https://ziglang.org/documentation/0.15.2/#Compile-Variables">编译变量</a></li>
        <li><a id="toc-Compilation-Model" href="https://ziglang.org/documentation/0.15.2/#Compilation-Model">编译模型</a>
        <ul>
            <li><a id="toc-Source-File-Structs" href="https://ziglang.org/documentation/0.15.2/#Source-File-Structs">源文件结构</a></li>
            <li><a id="toc-File-and-Declaration-Discovery" href="https://ziglang.org/documentation/0.15.2/#File-and-Declaration-Discovery">文件和声明发现</a></li>
            <li><a id="toc-Special-Root-Declarations" href="https://ziglang.org/documentation/0.15.2/#Special-Root-Declarations">特殊根声明</a>
            <ul>
                <li><a id="toc-Entry-Point" href="https://ziglang.org/documentation/0.15.2/#Entry-Point">入口点</a></li>
                <li><a id="toc-Standard-Library-Options" href="https://ziglang.org/documentation/0.15.2/#Standard-Library-Options">标准库选项</a></li>
                <li><a id="toc-Panic-Handler" href="https://ziglang.org/documentation/0.15.2/#Panic-Handler">Panic 处理器</a></li>
            </ul></li>
        </ul></li>
        <li><a id="toc-Zig-Build-System" href="https://ziglang.org/documentation/0.15.2/#Zig-Build-System">Zig 构建系统</a></li>
        <li><a id="toc-C" href="https://ziglang.org/documentation/0.15.2/#C">C</a>
        <ul>
            <li><a id="toc-C-Type-Primitives" href="https://ziglang.org/documentation/0.15.2/#C-Type-Primitives">C 类型基本类型</a></li>
            <li><a id="toc-Import-from-C-Header-File" href="https://ziglang.org/documentation/0.15.2/#Import-from-C-Header-File">从 C 头文件导入</a></li>
            <li><a id="toc-C-Translation-CLI" href="https://ziglang.org/documentation/0.15.2/#C-Translation-CLI">C 翻译 CLI</a>
            <ul>
                <li><a id="toc-Command-line-flags" href="https://ziglang.org/documentation/0.15.2/#Command-line-flags">命令行标志</a></li>
                <li><a id="toc-Using--target-and--cflags" href="https://ziglang.org/documentation/0.15.2/#Using--target-and--cflags">使用 -target 和 -cflags</a></li>
                <li><a id="toc-cImport-vs-translate-c" href="https://ziglang.org/documentation/0.15.2/#cImport-vs-translate-c">@cImport 对比 translate-c</a></li>
            </ul></li>
            <li><a id="toc-C-Translation-Caching" href="https://ziglang.org/documentation/0.15.2/#C-Translation-Caching">C 翻译缓存</a></li>
            <li><a id="toc-Translation-failures" href="https://ziglang.org/documentation/0.15.2/#Translation-failures">翻译失败</a></li>
            <li><a id="toc-C-Macros" href="https://ziglang.org/documentation/0.15.2/#C-Macros">C 宏</a></li>
            <li><a id="toc-C-Pointers" href="https://ziglang.org/documentation/0.15.2/#C-Pointers">C 指针</a></li>
            <li><a id="toc-C-Variadic-Functions" href="https://ziglang.org/documentation/0.15.2/#C-Variadic-Functions">C 可变参数函数</a></li>
            <li><a id="toc-Exporting-a-C-Library" href="https://ziglang.org/documentation/0.15.2/#Exporting-a-C-Library">导出 C 库</a></li>
            <li><a id="toc-Mixing-Object-Files" href="https://ziglang.org/documentation/0.15.2/#Mixing-Object-Files">混合目标文件</a></li>
        </ul></li>
        <li><a id="toc-WebAssembly" href="https://ziglang.org/documentation/0.15.2/#WebAssembly">WebAssembly</a>
        <ul>
            <li><a id="toc-Freestanding" href="https://ziglang.org/documentation/0.15.2/#Freestanding">独立模式</a></li>
            <li><a id="toc-WASI" href="https://ziglang.org/documentation/0.15.2/#WASI">WASI</a></li>
        </ul></li>
        <li><a id="toc-Targets" href="https://ziglang.org/documentation/0.15.2/#Targets">目标</a></li>
        <li><a id="toc-Style-Guide" href="https://ziglang.org/documentation/0.15.2/#Style-Guide">风格指南</a>
        <ul>
            <li><a id="toc-Avoid-Redundancy-in-Names" href="https://ziglang.org/documentation/0.15.2/#Avoid-Redundancy-in-Names">避免名称冗余</a></li>
            <li><a id="toc-Avoid-Redundant-Names-in-Fully-Qualified-Namespaces" href="https://ziglang.org/documentation/0.15.2/#Avoid-Redundant-Names-in-Fully-Qualified-Namespaces">避免完全限定命名空间中的冗余名称</a></li>
            <li><a id="toc-Whitespace" href="https://ziglang.org/documentation/0.15.2/#Whitespace">空白</a></li>
            <li><a id="toc-Names" href="https://ziglang.org/documentation/0.15.2/#Names">命名</a></li>
            <li><a id="toc-Examples" href="https://ziglang.org/documentation/0.15.2/#Examples">示例</a></li>
            <li><a id="toc-Doc-Comment-Guidance" href="https://ziglang.org/documentation/0.15.2/#Doc-Comment-Guidance">文档注释指南</a></li>
        </ul></li>
        <li><a id="toc-Source-Encoding" href="https://ziglang.org/documentation/0.15.2/#Source-Encoding">源代码编码</a></li>
        <li><a id="toc-Keyword-Reference" href="https://ziglang.org/documentation/0.15.2/#Keyword-Reference">关键字参考</a></li>
        <li><a id="toc-Appendix" href="https://ziglang.org/documentation/0.15.2/#Appendix">附录</a>
        <ul>
            <li><a id="toc-Containers" href="https://ziglang.org/documentation/0.15.2/#Containers">容器</a></li>
            <li><a id="toc-Grammar" href="https://ziglang.org/documentation/0.15.2/#Grammar">语法</a></li>
            <li><a id="toc-Zen" href="https://ziglang.org/documentation/0.15.2/#Zen">Zen</a></li>
        </ul></li>
    </ul>

        </nav>
      </div>
      <div id="contents-wrapper"><main id="contents">
      <h2 id="Introduction"><a href="https://ziglang.org/documentation/0.15.2/#toc-Introduction">简介</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Introduction">§</a></h2>

      <p>
      <a href="https://ziglang.org/">Zig</a> 是一种通用编程语言和工具链,用于维护<strong>健壮</strong>、<strong>优化</strong>和<strong>可重用</strong>的软件。
      </p>
      <dl>
        <dt>健壮</dt><dd>即使在边缘情况(如内存不足)下,行为也是正确的。</dd>
        <dt>优化</dt><dd>以最佳方式编写程序,使其行为和性能达到最优。</dd>
        <dt>可重用</dt><dd>相同的代码可以在具有不同约束的多种环境中工作。</dd>
        <dt>可维护</dt><dd>向编译器和其他程序员精确传达意图。该语言在阅读代码时施加的开销很低,并且对不断变化的需求和环境具有弹性。</dd>
      </dl>
      <p>
      通常,学习新事物最有效的方法是查看示例,因此本文档展示了如何使用 Zig 的每个特性。它全部在一个页面上,因此您可以使用浏览器的搜索工具进行搜索。
      </p>
      <p>
      本文档中的代码示例作为 Zig 主测试套件的一部分进行编译和测试。
      </p>
      <p>
      此 HTML 文档不依赖于任何外部文件,因此您可以离线使用它。
      </p>
      

      <h2 id="Zig-Standard-Library"><a href="https://ziglang.org/documentation/0.15.2/#toc-Zig-Standard-Library">Zig 标准库</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Zig-Standard-Library">§</a></h2>

      <p>
        <a href="https://ziglang.org/documentation/0.15.2/std/">Zig 标准库</a>有自己的文档。
      </p>
      <p>
        Zig 标准库包含常用的算法、数据结构和定义,可帮助您构建程序或库。您将在本文档中看到许多使用 Zig 标准库的示例。要了解有关 Zig 标准库的更多信息,请访问上面的链接。
      </p>
      <p>
        或者,每个 Zig 发行版都提供 Zig 标准库文档。可以通过本地 Web 服务器渲染它:
      </p>
      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>zig std
</samp></pre></figure>
      

      <h2 id="Hello-World"><a href="https://ziglang.org/documentation/0.15.2/#toc-Hello-World">Hello World</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Hello-World">§</a></h2>


      <figure><figcaption class="zig-cap"><cite class="file">hello.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> std.fs.File.stdout().writeAll(<span class="tok-str">"Hello, World!\n"</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe hello.zig</kbd>
$ <kbd>./hello</kbd>
Hello, World!
</samp></pre></figure>

      <p>
      大多数时候,写入 stderr 而不是 stdout 更合适,并且消息是否成功写入流并不相关。此外,格式化打印通常也很方便。对于这种常见情况,有一个更简单的 API:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">hello_again.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    std.debug.print(<span class="tok-str">"Hello, {s}!\n"</span>, .{<span class="tok-str">"World"</span>});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe hello_again.zig</kbd>
$ <kbd>./hello_again</kbd>
Hello, World!
</samp></pre></figure>

      <p>
      在这种情况下,可以从 <code>main</code> 的返回类型中省略 <code>!</code>,因为该函数不会返回错误。
      </p>
      <p>另见:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Values">值</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Tuples">元组</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#import">@import</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Errors">错误</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Entry-Point">入口点</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Source-Encoding">源代码编码</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#try">try</a></li>
</ul>

      
      <h2 id="Comments"><a href="https://ziglang.org/documentation/0.15.2/#toc-Comments">注释</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Comments">§</a></h2>

      <p>
      Zig 支持 3 种注释类型。普通注释会被忽略,但文档注释和顶级文档注释被编译器用于生成包文档。
      </p>
      <p>
      生成的文档仍处于实验阶段,可以使用以下命令生成:
      </p>
      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>zig test -femit-docs main.zig
</samp></pre></figure>
      <figure><figcaption class="zig-cap"><cite class="file">comments.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-comment">// Zig 中的注释以 "//" 开头,在下一个 LF 字节(行尾)结束。</span>
    <span class="tok-comment">// 下面的行是注释,不会被执行。</span>

    <span class="tok-comment">//print("Hello?", .{});</span>

    print(<span class="tok-str">"Hello, world!\n"</span>, .{}); <span class="tok-comment">// 另一个注释</span>
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe comments.zig</kbd>
$ <kbd>./comments</kbd>
Hello, world!
</samp></pre></figure>

      <p>
      Zig 中没有多行注释(例如 C 中的 <code class="c">/* */</code> 注释)。这使得 Zig 具有这样的特性:每行代码都可以在没有上下文的情况下进行标记化。
      </p>
      <h3 id="Doc-Comments"><a href="https://ziglang.org/documentation/0.15.2/#toc-Doc-Comments">文档注释</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Doc-Comments">§</a></h3>

      <p>
      文档注释是以恰好三个斜杠开头的注释(即 <code><span class="tok-comment">///</span></code> 但不是 <code><span class="tok-comment">////</span></code>);连续的多个文档注释会合并在一起形成多行文档注释。文档注释记录紧随其后的内容。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">doc_comments.zig</cite></figcaption><pre><code><span class="tok-comment">/// 用于存储时间戳的结构,具有纳秒精度(这是一个</span>
<span class="tok-comment">/// 多行文档注释)。</span>
<span class="tok-kw">const</span> Timestamp = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// 自纪元以来的秒数(这也是一个文档注释)。</span>
    seconds: <span class="tok-type">i64</span>, <span class="tok-comment">// 有符号,所以我们可以表示 1970 年之前(不是文档注释)</span>
    <span class="tok-comment">/// 超过秒数的纳秒数(又是文档注释)。</span>
    nanos: <span class="tok-type">u32</span>,

    <span class="tok-comment">/// 返回表示 Unix 纪元的 `Timestamp` 结构;即</span>
    <span class="tok-comment">/// 1970 年 1 月 1 日 00:00:00 UTC 的时刻(这也是文档注释)。</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unixEpoch</span>() Timestamp {
        <span class="tok-kw">return</span> Timestamp{
            .seconds = <span class="tok-number">0</span>,
            .nanos = <span class="tok-number">0</span>,
        };
    }
};</code></pre></figure>

      <p>
      文档注释只允许在某些位置;在意外位置出现文档注释是编译错误,例如在表达式的中间,或在非文档注释之前。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">invalid_doc-comment.zig</cite></figcaption><pre><code><span class="tok-comment">/// 文档注释</span>
<span class="tok-comment">//! 顶级文档注释</span>
<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-obj invalid_doc-comment.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/invalid_doc-comment.zig:1:16: </span><span class="sgr-31m">error: </span><span class="sgr-1m">期望类型表达式,发现 '文档注释'
</span>/// 文档注释
               <span class="sgr-32m">^
</span>
</samp></pre></figure>

      <figure><figcaption class="zig-cap"><cite class="file">unattached_doc-comment.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {}

<span class="tok-comment">/// 文件结束</span></code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-obj unattached_doc-comment.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/unattached_doc-comment.zig:3:1: </span><span class="sgr-31m">error: </span><span class="sgr-1m">未附加的文档注释
</span>/// 文件结束
<span class="sgr-32m">^~~~~~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>
      文档注释可以与普通注释交错。目前,在生成包文档时,普通注释会与文档注释合并。
      </p>
      
      <h3 id="Top-Level-Doc-Comments"><a href="https://ziglang.org/documentation/0.15.2/#toc-Top-Level-Doc-Comments">顶级文档注释</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Top-Level-Doc-Comments">§</a></h3>

      <p>
      顶级文档注释是以两个斜杠和一个感叹号开头的注释:<code><span class="tok-comment">//!</span></code>;它记录当前模块。
      </p>
      <p>
      如果顶级文档注释未放置在<a href="https://ziglang.org/documentation/0.15.2/#Containers">容器</a>的开头、任何表达式之前,则是编译错误。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">tldoc_comments.zig</cite></figcaption><pre><code><span class="tok-comment">//! 此模块提供用于检索当前日期和</span>
<span class="tok-comment">//! 时间的函数,具有不同程度的精度和准确性。它不</span>
<span class="tok-comment">//! 依赖于 libc,但如果可用,将使用其中的函数。</span>

<span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
    <span class="tok-comment">//! 顶级注释允许出现在模块以外的容器中,</span>
    <span class="tok-comment">//! 但这并不是很有用。目前,在生成包</span>
    <span class="tok-comment">//! 文档时,这些注释会被忽略。</span>
};</code></pre></figure>

      
      
      <h2 id="Values"><a href="https://ziglang.org/documentation/0.15.2/#toc-Values">值</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Values">§</a></h2>

      <figure><figcaption class="zig-cap"><cite class="file">values.zig</cite></figcaption><pre><code><span class="tok-comment">// 顶级声明与顺序无关:</span>
<span class="tok-kw">const</span> print = std.debug.print;
<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> os = std.os;
<span class="tok-kw">const</span> assert = std.debug.assert;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-comment">// 整数</span>
    <span class="tok-kw">const</span> one_plus_one: <span class="tok-type">i32</span> = <span class="tok-number">1</span> + <span class="tok-number">1</span>;
    print(<span class="tok-str">"1 + 1 = {}\n"</span>, .{one_plus_one});

    <span class="tok-comment">// 浮点数</span>
    <span class="tok-kw">const</span> seven_div_three: <span class="tok-type">f32</span> = <span class="tok-number">7.0</span> / <span class="tok-number">3.0</span>;
    print(<span class="tok-str">"7.0 / 3.0 = {}\n"</span>, .{seven_div_three});

    <span class="tok-comment">// 布尔值</span>
    print(<span class="tok-str">"{}\n{}\n{}\n"</span>, .{
        <span class="tok-null">true</span> <span class="tok-kw">and</span> <span class="tok-null">false</span>,
        <span class="tok-null">true</span> <span class="tok-kw">or</span> <span class="tok-null">false</span>,
        !<span class="tok-null">true</span>,
    });

    <span class="tok-comment">// 可选值</span>
    <span class="tok-kw">var</span> optional_value: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>;
    assert(optional_value == <span class="tok-null">null</span>);

    print(<span class="tok-str">"\n可选值 1\n类型: {}\n值: {?s}\n"</span>, .{
        <span class="tok-builtin">@TypeOf</span>(optional_value), optional_value,
    });

    optional_value = <span class="tok-str">"hi"</span>;
    assert(optional_value != <span class="tok-null">null</span>);

    print(<span class="tok-str">"\n可选值 2\n类型: {}\n值: {?s}\n"</span>, .{
        <span class="tok-builtin">@TypeOf</span>(optional_value), optional_value,
    });

    <span class="tok-comment">// 错误联合</span>
    <span class="tok-kw">var</span> number_or_error: <span class="tok-type">anyerror</span>!<span class="tok-type">i32</span> = <span class="tok-kw">error</span>.ArgNotFound;

    print(<span class="tok-str">"\n错误联合 1\n类型: {}\n值: {!}\n"</span>, .{
        <span class="tok-builtin">@TypeOf</span>(number_or_error),
        number_or_error,
    });

    number_or_error = <span class="tok-number">1234</span>;

    print(<span class="tok-str">"\n错误联合 2\n类型: {}\n值: {!}\n"</span>, .{
        <span class="tok-builtin">@TypeOf</span>(number_or_error), number_or_error,
    });
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe values.zig</kbd>
$ <kbd>./values</kbd>
1 + 1 = 2
7.0 / 3.0 = 2.3333333
false
true
false

可选值 1
类型: ?[]const u8
值: null

可选值 2
类型: ?[]const u8
值: hi

错误联合 1
类型: anyerror!i32
值: error.ArgNotFound

错误联合 2
类型: anyerror!i32
值: 1234
</samp></pre></figure>

      <h3 id="Primitive-Types"><a href="https://ziglang.org/documentation/0.15.2/#toc-Primitive-Types">基本类型</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Primitive-Types">§</a></h3>

      <div class="table-wrapper">
<!-- ====== END CHUNK 1: new_01.html ====== -->

<!-- ====== BEGIN CHUNK 2: new_02.html ====== -->
<table>
        <caption>原始类型</caption>
        <thead>
            <tr>
            <th scope="col">类型</th>
            <th scope="col">C 等价类型</th>
            <th scope="col">描述</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th scope="row"><code><span class="tok-type">i8</span></code></th>
          <td><code class="c">int8_t</code></td>
          <td>有符号 8 位整数</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">u8</span></code></th>
          <td><code class="c">uint8_t</code></td>
          <td>无符号 8 位整数</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">i16</span></code></th>
          <td><code class="c">int16_t</code></td>
          <td>有符号 16 位整数</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">u16</span></code></th>
          <td><code class="c">uint16_t</code></td>
          <td>无符号 16 位整数</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">i32</span></code></th>
          <td><code class="c">int32_t</code></td>
          <td>有符号 32 位整数</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">u32</span></code></th>
          <td><code class="c">uint32_t</code></td>
          <td>无符号 32 位整数</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">i64</span></code></th>
          <td><code class="c">int64_t</code></td>
          <td>有符号 64 位整数</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">u64</span></code></th>
          <td><code class="c">uint64_t</code></td>
          <td>无符号 64 位整数</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">i128</span></code></th>
          <td><code class="c">__int128</code></td>
          <td>有符号 128 位整数</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">u128</span></code></th>
          <td><code class="c">unsigned __int128</code></td>
          <td>无符号 128 位整数</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">isize</span></code></th>
          <td><code class="c">intptr_t</code></td>
          <td>有符号指针大小的整数</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">usize</span></code></th>
          <td><code class="c">uintptr_t</code>, <code class="c">size_t</code></td>
          <td>无符号指针大小的整数。另请参见 <a href="https://github.com/ziglang/zig/issues/5185">#5185</a></td>
        </tr>

        <tr>
            <th scope="row"><code><span class="tok-type">c_char</span></code></th>
          <td><code class="c">char</code></td>
          <td>用于与 C 的 ABI 兼容</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">c_short</span></code></th>
          <td><code class="c">short</code></td>
          <td>用于与 C 的 ABI 兼容</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">c_ushort</span></code></th>
          <td><code class="c">unsigned short</code></td>
          <td>用于与 C 的 ABI 兼容</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">c_int</span></code></th>
          <td><code class="c">int</code></td>
          <td>用于与 C 的 ABI 兼容</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">c_uint</span></code></th>
          <td><code class="c">unsigned int</code></td>
          <td>用于与 C 的 ABI 兼容</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">c_long</span></code></th>
          <td><code class="c">long</code></td>
          <td>用于与 C 的 ABI 兼容</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">c_ulong</span></code></th>
          <td><code class="c">unsigned long</code></td>
          <td>用于与 C 的 ABI 兼容</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">c_longlong</span></code></th>
          <td><code class="c">long long</code></td>
          <td>用于与 C 的 ABI 兼容</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">c_ulonglong</span></code></th>
          <td><code class="c">unsigned long long</code></td>
          <td>用于与 C 的 ABI 兼容</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">c_longdouble</span></code></th>
          <td><code class="c">long double</code></td>
          <td>用于与 C 的 ABI 兼容</td>
        </tr>

        <tr>
            <th scope="row"><code><span class="tok-type">f16</span></code></th>
          <td><code class="c">_Float16</code></td>
          <td>16 位浮点数（10 位尾数）IEEE-754-2008 binary16</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">f32</span></code></th>
          <td><code class="c">float</code></td>
          <td>32 位浮点数（23 位尾数）IEEE-754-2008 binary32</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">f64</span></code></th>
          <td><code class="c">double</code></td>
          <td>64 位浮点数（52 位尾数）IEEE-754-2008 binary64</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">f80</span></code></th>
          <td><code class="c">long double</code></td>
          <td>80 位浮点数（64 位尾数）IEEE-754-2008 80 位扩展精度</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">f128</span></code></th>
            <td><code class="c">_Float128</code></td>
          <td>128 位浮点数（112 位尾数）IEEE-754-2008 binary128</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">bool</span></code></th>
          <td><code class="c">bool</code></td>
          <td><code><span class="tok-null">true</span></code> 或 <code><span class="tok-null">false</span></code></td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">anyopaque</span></code></th>
          <td><code class="c">void</code></td>
          <td>用于类型擦除指针。</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">void</span></code></th>
          <td>(无)</td>
          <td>始终为值 <code><span class="tok-type">void</span>{}</code></td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">noreturn</span></code></th>
          <td>(无)</td>
          <td><code><span class="tok-kw">break</span></code>、<code><span class="tok-kw">continue</span></code>、<code><span class="tok-kw">return</span></code>、<code><span class="tok-kw">unreachable</span></code> 和 <code><span class="tok-kw">while</span> (<span class="tok-null">true</span>) {}</code> 的类型</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">type</span></code></th>
          <td>(无)</td>
          <td>类型的类型</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">anyerror</span></code></th>
          <td>(无)</td>
          <td>错误代码</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">comptime_int</span></code></th>
          <td>(无)</td>
          <td>仅允许用于 <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a> 已知值。整数字面量的类型。</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">comptime_float</span></code></th>
          <td>(无)</td>
          <td>仅允许用于 <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a> 已知值。浮点字面量的类型。</td>
        </tr>
        </tbody>
      </table>
      </div>
      <p>
      除了上述整数类型之外，还可以通过使用以 <code>i</code> 或 <code>u</code> 开头后跟数字的标识符来引用任意位宽的整数。例如，标识符 <code><span class="tok-type">i7</span></code> 表示有符号 7 位整数。整数类型允许的最大位宽为 <code><span class="tok-number">65535</span></code>。
      </p>
      <p>另请参见：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#void">void</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Errors">错误</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Type">@Type</a></li>
</ul>

      
      <h3 id="Primitive-Values"><a href="https://ziglang.org/documentation/0.15.2/#toc-Primitive-Values">原始值</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Primitive-Values">§</a></h3>

      <div class="table-wrapper">
      <table>
        <caption>原始值</caption>
        <thead>
        <tr>
          <th scope="col">名称</th>
          <th scope="col">描述</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th scope="row"><code><span class="tok-null">true</span></code> 和 <code><span class="tok-null">false</span></code></th>
            <td><code><span class="tok-type">bool</span></code> 值</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-null">null</span></code></th>
            <td>用于将可选类型设置为 <code><span class="tok-null">null</span></code></td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-null">undefined</span></code></th>
          <td>用于保留值未指定</td>
        </tr>
        </tbody>
      </table>
      </div>
      <p>另请参见：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Optionals">可选类型</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#undefined">undefined</a></li>
</ul>

      
      <h3 id="String-Literals-and-Unicode-Code-Point-Literals"><a href="https://ziglang.org/documentation/0.15.2/#toc-String-Literals-and-Unicode-Code-Point-Literals">字符串字面量和 Unicode 码点字面量</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#String-Literals-and-Unicode-Code-Point-Literals">§</a></h3>

      <p>
      字符串字面量是指向以 null 结尾的字节数组的常量单项<a href="https://ziglang.org/documentation/0.15.2/#Pointers">指针</a>。字符串字面量的类型编码了长度和以 null 结尾的事实，因此它们可以被<a href="https://ziglang.org/documentation/0.15.2/#Type-Coercion">强制转换</a>为<a href="https://ziglang.org/documentation/0.15.2/#Slices">切片</a>和<a href="https://ziglang.org/documentation/0.15.2/#Sentinel-Terminated-Pointers">以 null 结尾的指针</a>。解引用字符串字面量将它们转换为<a href="https://ziglang.org/documentation/0.15.2/#Arrays">数组</a>。
      </p>
      <p>
      由于 Zig 源代码是 <a href="https://ziglang.org/documentation/0.15.2/#Source-Encoding">UTF-8 编码</a>的，源代码中字符串字面量内出现的任何非 ASCII 字节都会将其 UTF-8 含义带入 Zig 程序中字符串的内容；编译器不会修改这些字节。可以使用 <code>\xNN</code> 表示法将非 UTF-8 字节嵌入字符串字面量中。
      </p>
      <p>索引包含非 ASCII 字节的字符串会返回单个字节，无论是否为有效的 UTF-8。</p>
      <p>
      Unicode 码点字面量的类型为 <code><span class="tok-type">comptime_int</span></code>，与<a href="https://ziglang.org/documentation/0.15.2/#Integer-Literals">整数字面量</a>相同。所有<a href="https://ziglang.org/documentation/0.15.2/#Escape-Sequences">转义序列</a>在字符串字面量和 Unicode 码点字面量中都是有效的。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">string_literals.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;
<span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).mem; <span class="tok-comment">// 将用于比较字节</span>

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> bytes = <span class="tok-str">"hello"</span>;
    print(<span class="tok-str">"{}\n"</span>, .{<span class="tok-builtin">@TypeOf</span>(bytes)}); <span class="tok-comment">// *const [5:0]u8</span>
    print(<span class="tok-str">"{d}\n"</span>, .{bytes.len}); <span class="tok-comment">// 5</span>
    print(<span class="tok-str">"{c}\n"</span>, .{bytes[<span class="tok-number">1</span>]}); <span class="tok-comment">// 'e'</span>
    print(<span class="tok-str">"{d}\n"</span>, .{bytes[<span class="tok-number">5</span>]}); <span class="tok-comment">// 0</span>
    print(<span class="tok-str">"{}\n"</span>, .{<span class="tok-str">'e'</span> == <span class="tok-str">'\x65'</span>}); <span class="tok-comment">// true</span>
    print(<span class="tok-str">"{d}\n"</span>, .{<span class="tok-str">'\u{1f4a9}'</span>}); <span class="tok-comment">// 128169</span>
    print(<span class="tok-str">"{d}\n"</span>, .{<span class="tok-str">'💯'</span>}); <span class="tok-comment">// 128175</span>
    print(<span class="tok-str">"{u}\n"</span>, .{<span class="tok-str">'⚡'</span>});
    print(<span class="tok-str">"{}\n"</span>, .{mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">"hello"</span>, <span class="tok-str">"h\x65llo"</span>)}); <span class="tok-comment">// true</span>
    print(<span class="tok-str">"{}\n"</span>, .{mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">"💯"</span>, <span class="tok-str">"\xf0\x9f\x92\xaf"</span>)}); <span class="tok-comment">// 也为 true</span>
    <span class="tok-kw">const</span> invalid_utf8 = <span class="tok-str">"\xff\xfe"</span>; <span class="tok-comment">// 使用 \xNN 表示法可以创建非 UTF-8 字符串。</span>
    print(<span class="tok-str">"0x{x}\n"</span>, .{invalid_utf8[<span class="tok-number">1</span>]}); <span class="tok-comment">// 索引它们会返回单个字节...</span>
    print(<span class="tok-str">"0x{x}\n"</span>, .{<span class="tok-str">"💯"</span>[<span class="tok-number">1</span>]}); <span class="tok-comment">// ...索引非 ASCII 字符的中间部分也是如此</span>
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe string_literals.zig</kbd>
$ <kbd>./string_literals</kbd>
*const [5:0]u8
5
e
0
true
128169
128175
⚡
true
true
0xfe
0x9f
</samp></pre></figure>

      <p>另请参见：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Arrays">数组</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Source-Encoding">源代码编码</a></li>
</ul>

      <h4 id="Escape-Sequences"><a href="https://ziglang.org/documentation/0.15.2/#toc-Escape-Sequences">转义序列</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Escape-Sequences">§</a></h4>

      <div class="table-wrapper">
      <table>
        <caption>转义序列</caption>
        <thead>
        <tr>
          <th scope="col">转义序列</th>
          <th scope="col">名称</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th scope="row"><code>\n</code></th>
          <td>换行</td>
        </tr>
        <tr>
            <th scope="row"><code>\r</code></th>
          <td>回车</td>
        </tr>
        <tr>
            <th scope="row"><code>\t</code></th>
          <td>制表符</td>
        </tr>
        <tr>
            <th scope="row"><code>\\</code></th>
          <td>反斜杠</td>
        </tr>
        <tr>
            <th scope="row"><code>\'</code></th>
          <td>单引号</td>
        </tr>
        <tr>
            <th scope="row"><code>\"</code></th>
          <td>双引号</td>
        </tr>
        <tr>
            <th scope="row"><code>\xNN</code></th>
          <td>十六进制 8 位字节值（2 位数字）</td>
        </tr>
        <tr>
            <th scope="row"><code>\u{NNNNNN}</code></th>
          <td>十六进制 Unicode 标量值的 UTF-8 编码（1 位或更多位数字）</td>
        </tr>
        </tbody>
      </table>
      </div>
      <p>注意，最大有效的 Unicode 标量值是 <code><span class="tok-number">0x10ffff</span></code>。</p>
      
      <h4 id="Multiline-String-Literals"><a href="https://ziglang.org/documentation/0.15.2/#toc-Multiline-String-Literals">多行字符串字面量</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Multiline-String-Literals">§</a></h4>

      <p>
      多行字符串字面量没有转义，可以跨越多行。要开始多行字符串字面量，使用 <code><span class="tok-str">\\</span></code> 标记。就像注释一样，字符串字面量会持续到行尾。行尾不包含在字符串字面量中。但是，如果下一行以 <code><span class="tok-str">\\</span></code> 开头，则会追加换行符并且字符串字面量继续。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">multiline_string_literals.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> hello_world_in_c =
    <span class="tok-str">\\#include &lt;stdio.h&gt;</span>
    <span class="tok-str">\\</span>
    <span class="tok-str">\\int main(int argc, char **argv) {</span>
    <span class="tok-str">\\    printf("hello world\n");</span>
    <span class="tok-str">\\    return 0;</span>
    <span class="tok-str">\\}</span>
;</code></pre></figure>

      <p>另请参见：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#embedFile">@embedFile</a></li>
</ul>

      
      
      <h3 id="Assignment"><a href="https://ziglang.org/documentation/0.15.2/#toc-Assignment">赋值</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Assignment">§</a></h3>

      <p>使用 <code><span class="tok-kw">const</span></code> 关键字为标识符赋值：</p>
      <figure><figcaption class="zig-cap"><cite class="file">constant_identifier_cannot_change.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> x = <span class="tok-number">1234</span>;

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">void</span> {
    <span class="tok-comment">// 它在文件作用域和函数内部都有效。</span>
    <span class="tok-kw">const</span> y = <span class="tok-number">5678</span>;

    <span class="tok-comment">// 一旦赋值，标识符就不能更改。</span>
    y += <span class="tok-number">1</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    foo();
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe constant_identifier_cannot_change.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/constant_identifier_cannot_change.zig:8:5: </span><span class="sgr-31m">error: </span><span class="sgr-1m">无法赋值给常量
</span>    y += 1;
    <span class="sgr-32m">^
</span><span class="sgr-2m">referenced by:
    main: /home/andy/dev/zig/doc/langref/constant_identifier_cannot_change.zig:12:8
    callMain [inlined]: /home/andy/dev/zig/lib/std/start.zig:618:22
    callMainWithArgs [inlined]: /home/andy/dev/zig/lib/std/start.zig:587:20
    posixCallMainAndExit: /home/andy/dev/zig/lib/std/start.zig:542:36
    2 reference(s) hidden; use '-freference-trace=6' to see all references
</span>
</samp></pre></figure>

      <p><code><span class="tok-kw">const</span></code> 适用于标识符直接寻址的所有字节。<a href="https://ziglang.org/documentation/0.15.2/#Pointers">指针</a>有自己的常量性。</p>
      <p>如果需要可以修改的变量，使用 <code><span class="tok-kw">var</span></code> 关键字：</p>
      <figure><figcaption class="zig-cap"><cite class="file">mutable_var.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> y: <span class="tok-type">i32</span> = <span class="tok-number">5678</span>;

    y += <span class="tok-number">1</span>;

    print(<span class="tok-str">"{d}"</span>, .{y});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe mutable_var.zig</kbd>
$ <kbd>./mutable_var</kbd>
5679
</samp></pre></figure>

      <p>变量必须初始化：</p>
      <figure><figcaption class="zig-cap"><cite class="file">var_must_be_initialized.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span>;

    x = <span class="tok-number">1</span>;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe var_must_be_initialized.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/var_must_be_initialized.zig:2:15: </span><span class="sgr-31m">error: </span><span class="sgr-1m">期望 '='，找到 ';'
</span>    var x: i32;
              <span class="sgr-32m">^
</span>
</samp></pre></figure>

      <h4 id="undefined"><a href="https://ziglang.org/documentation/0.15.2/#toc-undefined">undefined</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#undefined">§</a></h4>

      <p>使用 <code><span class="tok-null">undefined</span></code> 让变量保持未初始化：</p>
      <figure><figcaption class="zig-cap"><cite class="file">assign_undefined.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;
    x = <span class="tok-number">1</span>;
    print(<span class="tok-str">"{d}"</span>, .{x});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe assign_undefined.zig</kbd>
$ <kbd>./assign_undefined</kbd>
1
</samp></pre></figure>

      <p>
      <code><span class="tok-null">undefined</span></code> 可以被<a href="https://ziglang.org/documentation/0.15.2/#Type-Coercion">强制转换</a>为任何类型。一旦发生这种情况，就不再可能检测到该值是 <code><span class="tok-null">undefined</span></code>。<code><span class="tok-null">undefined</span></code> 意味着该值可以是任何值，甚至是根据类型来说毫无意义的值。用英语翻译，<code><span class="tok-null">undefined</span></code> 的意思是"不是一个有意义的值。使用这个值将是一个错误。该值将不被使用，或在使用之前被覆盖。"
      </p>
      <p>
      在<a href="https://ziglang.org/documentation/0.15.2/#Debug">调试</a>和 <a href="https://ziglang.org/documentation/0.15.2/#ReleaseSafe">ReleaseSafe</a> 模式下，Zig 会向未定义的内存写入 <code><span class="tok-number">0xaa</span></code> 字节。这是为了尽早捕获错误，并帮助在调试器中检测未定义内存的使用。然而，这种行为只是一个实现特性，而不是语言语义，因此不能保证代码可以观察到它。
      </p>
      

      <h4 id="Destructuring"><a href="https://ziglang.org/documentation/0.15.2/#toc-Destructuring">解构</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Destructuring">§</a></h4>

      <p>
        解构赋值可以分离可索引聚合类型的元素（<a href="https://ziglang.org/documentation/0.15.2/#Tuples">元组</a>、<a href="https://ziglang.org/documentation/0.15.2/#Arrays">数组</a>、<a href="https://ziglang.org/documentation/0.15.2/#Vectors">向量</a>）：
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">destructuring_to_existing.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> y: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> z: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;

    <span class="tok-kw">const</span> tuple = .{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span> };

    x, y, z = tuple;

    print(<span class="tok-str">"tuple: x = {}, y = {}, z = {}\n"</span>, .{x, y, z});

    <span class="tok-kw">const</span> array = [_]<span class="tok-type">u32</span>{ <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span> };

    x, y, z = array;

    print(<span class="tok-str">"array: x = {}, y = {}, z = {}\n"</span>, .{x, y, z});

    <span class="tok-kw">const</span> vector: <span class="tok-builtin">@Vector</span>(<span class="tok-number">3</span>, <span class="tok-type">u32</span>) = .{ <span class="tok-number">7</span>, <span class="tok-number">8</span>, <span class="tok-number">9</span> };

    x, y, z = vector;

    print(<span class="tok-str">"vector: x = {}, y = {}, z = {}\n"</span>, .{x, y, z});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe destructuring_to_existing.zig</kbd>
$ <kbd>./destructuring_to_existing</kbd>
tuple: x = 1, y = 2, z = 3
array: x = 4, y = 5, z = 6
vector: x = 7, y = 8, z = 9
</samp></pre></figure>

      <p>
        解构表达式只能出现在块内（即不能在容器作用域）。赋值的左侧必须由逗号分隔的列表组成，其中每个元素可以是左值（例如，现有的 `var`）或变量声明：
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">destructuring_mixed.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;

    <span class="tok-kw">const</span> tuple = .{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span> };

    x, <span class="tok-kw">var</span> y : <span class="tok-type">u32</span>, <span class="tok-kw">const</span> z = tuple;

    print(<span class="tok-str">"x = {}, y = {}, z = {}\n"</span>, .{x, y, z});

    <span class="tok-comment">// y 是可变的</span>
    y = <span class="tok-number">100</span>;

    <span class="tok-comment">// 您可以使用 _ 丢弃不需要的值。</span>
    _, x, _ = tuple;

    print(<span class="tok-str">"x = {}"</span>, .{x});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe destructuring_mixed.zig</kbd>
$ <kbd>./destructuring_mixed</kbd>
x = 1, y = 2, z = 3
x = 2
</samp></pre></figure>

      <p>
        解构可以使用 <code><span class="tok-kw">comptime</span></code> 关键字作为前缀，在这种情况下，整个解构表达式将在 <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a> 时求值。所有声明的 <code><span class="tok-kw">var</span></code> 都将是 <code><span class="tok-kw">comptime</span> <span class="tok-kw">var</span></code>，并且所有表达式（结果位置和被赋值的表达式）都将在 <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a> 时求值。
      </p>

      <p>另请参见：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Destructuring-Tuples">解构元组</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Destructuring-Arrays">解构数组</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Destructuring-Vectors">解构向量</a></li>
</ul>

      
      
      
      <h2 id="Zig-Test"><a href="https://ziglang.org/documentation/0.15.2/#toc-Zig-Test">Zig 测试</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Zig-Test">§</a></h2>

      <p>
        在一个或多个 <code><span class="tok-kw">test</span></code> 声明中编写的代码可用于确保行为符合预期：
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">testing_introduction.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">test</span> <span class="tok-str">"expect addOne adds one to 41"</span> {

    <span class="tok-comment">// 标准库包含有用的函数来帮助创建测试。</span>
    <span class="tok-comment">// `expect` 是一个验证其参数为 true 的函数。</span>
    <span class="tok-comment">// 如果其参数为 false，它将返回错误以指示失败。</span>
    <span class="tok-comment">// `try` 用于将错误返回给测试运行器以通知它测试失败。</span>
    <span class="tok-kw">try</span> std.testing.expect(addOne(<span class="tok-number">41</span>) == <span class="tok-number">42</span>);
}

<span class="tok-kw">test</span> addOne {
    <span class="tok-comment">// 测试名称也可以使用标识符编写。</span>
    <span class="tok-comment">// 这是一个文档测试，用作 `addOne` 的文档。</span>
    <span class="tok-kw">try</span> std.testing.expect(addOne(<span class="tok-number">41</span>) == <span class="tok-number">42</span>);
}

<span class="tok-comment">/// 函数 `addOne` 将给定作为其参数的数字加一。</span>
<span class="tok-kw">fn</span> <span class="tok-fn">addOne</span>(number: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> number + <span class="tok-number">1</span>;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test testing_introduction.zig</kbd>
1/2 testing_introduction.test.expect addOne adds one to 41...OK
2/2 testing_introduction.decltest.addOne...OK
All 2 tests passed.
</samp></pre></figure>

      <p>
        <code class="file">testing_introduction.zig</code> 代码示例测试<a href="https://ziglang.org/documentation/0.15.2/#Functions">函数</a> <code>addOne</code>，以确保在给定输入 <code><span class="tok-number">41</span></code> 时返回 <code><span class="tok-number">42</span></code>。从这个测试的角度来看，<code>addOne</code> 函数被称为<em>被测试代码</em>。
      </p>
      <p>
        <kbd>zig test</kbd> 是一个工具，它使用 <a href="https://ziglang.org/documentation/0.15.2/#Zig-Standard-Library">Zig 标准库</a>提供的<em>默认测试运行器</em>作为其主入口点来创建和运行测试构建。在构建期间，在<a href="https://ziglang.org/documentation/0.15.2/#File-and-Declaration-Discovery">解析</a>给定 Zig 源文件时找到的 <code><span class="tok-kw">test</span></code> 声明将包含在默认测试运行器中以运行和报告。
      </p>
      <aside>
        本文档讨论的是 Zig 标准库提供的默认测试运行器的功能。其源代码位于 <code class="file">lib/compiler/test_runner.zig</code>。
      </aside>
      <p>
        上面显示的 shell 输出在 <kbd>zig test</kbd> 命令之后显示了两行。这些行由默认测试运行器打印到标准错误：
      </p>
      <dl>
        <dt><samp>1/2 testing_introduction.test.expect addOne adds one to 41...</samp></dt>
        <dd>这样的行表示正在运行总测试数中的哪个测试。在这种情况下，<samp>1/2</samp> 表示正在运行总共两个测试中的第一个。请注意，当测试运行器程序的标准错误输出到终端时，如果测试成功，这些行将被清除。
        </dd>
        <dt><samp>2/2 testing_introduction.decltest.addOne...</samp></dt>
        <dd>当测试名称是标识符时，默认测试运行器使用文本 decltest 而不是 test。
        </dd>
        <dt><samp>All 2 tests passed.</samp></dt>
        <dd>此行表示已通过的测试总数。</dd>
      </dl>
      <h3 id="Test-Declarations"><a href="https://ziglang.org/documentation/0.15.2/#toc-Test-Declarations">测试声明</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Test-Declarations">§</a></h3>

      <p>
        测试声明包含<a href="https://ziglang.org/documentation/0.15.2/#Keyword-Reference">关键字</a> <code><span class="tok-kw">test</span></code>，后跟一个可选名称（写成<a href="https://ziglang.org/documentation/0.15.2/#String-Literals-and-Unicode-Code-Point-Literals">字符串字面量</a>或<a href="https://ziglang.org/documentation/0.15.2/#Identifiers">标识符</a>），然后是一个包含任何在<a href="https://ziglang.org/documentation/0.15.2/#Functions">函数</a>中允许的有效 Zig 代码的<a href="https://ziglang.org/documentation/0.15.2/#Blocks">块</a>。
      </p>
      <p>非命名测试块始终在测试构建期间运行，并且不受<a href="https://ziglang.org/documentation/0.15.2/#Skip-Tests">跳过测试</a>的限制。</p>
      <p>
        测试声明类似于<a href="https://ziglang.org/documentation/0.15.2/#Functions">函数</a>：它们有返回类型和代码块。测试的隐式返回类型是<a href="https://ziglang.org/documentation/0.15.2/#Error-Union-Type">错误联合类型</a> <code><span class="tok-type">anyerror</span>!<span class="tok-type">void</span></code>，并且不能更改。当不使用 <kbd>zig test</kbd> 工具构建 Zig 源文件时，测试声明将从构建中省略。
      </p>
      <p>
        测试声明可以写在被测试代码所在的同一文件中，或写在单独的 Zig 源文件中。由于测试声明是顶级声明，因此它们与顺序无关，可以在被测试代码之前或之后编写。
      </p>
      <p>另请参见：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#The-Global-Error-Set">全局错误集</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Grammar">语法</a></li>
</ul>

      <h4 id="Doctests"><a href="https://ziglang.org/documentation/0.15.2/#toc-Doctests">文档测试</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Doctests">§</a></h4>

      <p>
        使用标识符命名的测试声明是<em>文档测试</em>。标识符必须引用作用域中的另一个声明。文档测试像<a href="https://ziglang.org/documentation/0.15.2/#Doc-Comments">文档注释</a>一样，作为关联声明的文档，并将出现在为该声明生成的文档中。
      </p>
      <p>
        有效的文档测试应该是独立的，并专注于正在测试的声明，回答新用户可能对其接口或预期用法提出的问题，同时避免不必要或令人困惑的细节。文档测试不是文档注释的替代品，而是补充和伴随，提供由 <kbd>zig test</kbd> 验证的可测试的代码驱动示例。
      </p>
      
      
      <h3 id="Test-Failure"><a href="https://ziglang.org/documentation/0.15.2/#toc-Test-Failure">测试失败</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Test-Failure">§</a></h3>

      <p>
        默认测试运行器会检查测试返回的<a href="https://ziglang.org/documentation/0.15.2/#Errors">错误</a>。当测试返回错误时，该测试被视为失败，其<a href="https://ziglang.org/documentation/0.15.2/#Error-Return-Traces">错误返回跟踪</a>会输出到标准错误。所有测试运行后将报告失败总数。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">testing_failure.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">test</span> <span class="tok-str">"expect this to fail"</span> {
    <span class="tok-kw">try</span> std.testing.expect(<span class="tok-null">false</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"expect this to succeed"</span> {
    <span class="tok-kw">try</span> std.testing.expect(<span class="tok-null">true</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test testing_failure.zig</kbd>
1/2 testing_failure.test.expect this to fail...FAIL (TestUnexpectedResult)
<span class="sgr-1m">/home/andy/dev/zig/lib/std/testing.zig:607:14</span>: <span class="sgr-2m">0x102f019 in expect (std.zig)</span>
    if (!ok) return error.TestUnexpectedResult;
             <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/testing_failure.zig:4:5</span>: <span class="sgr-2m">0x102f078 in test.expect this to fail (testing_failure.zig)</span>
    try std.testing.expect(false);
    <span class="sgr-32m">^</span>
2/2 testing_failure.test.expect this to succeed...OK
1 passed; 0 skipped; 1 failed.
error: the following test command failed with exit code 1:
/home/andy/dev/zig/.zig-cache/o/bac0cff07a7d3f5b652a5a9cf02e6de1/test --seed=0x7a2fdb1
</samp></pre></figure>

      
      <h3 id="Skip-Tests"><a href="https://ziglang.org/documentation/0.15.2/#toc-Skip-Tests">跳过测试</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Skip-Tests">§</a></h3>

      <p>
        跳过测试的一种方法是使用 <kbd>zig test</kbd> 命令行参数 <kbd>--test-filter [text]</kbd> 将它们过滤掉。这使得测试构建仅包含名称包含提供的过滤器文本的测试。请注意，即使使用 <kbd>--test-filter [text]</kbd> 命令行参数，非命名测试也会运行。
      </p>
      <p>
        要以编程方式跳过测试，使 <code><span class="tok-kw">test</span></code> 返回错误 <code><span class="tok-kw">error</span>.SkipZigTest</code>，默认测试运行器将把该测试视为被跳过。所有测试运行后将报告跳过测试的总数。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">testing_skip.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">"this will be skipped"</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test testing_skip.zig</kbd>
1/1 testing_skip.test.this will be skipped...SKIP
0 passed; 1 skipped; 0 failed.
</samp></pre></figure>

      

      <h3 id="Report-Memory-Leaks"><a href="https://ziglang.org/documentation/0.15.2/#toc-Report-Memory-Leaks">报告内存泄漏</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Report-Memory-Leaks">§</a></h3>

      <p>
        当代码使用 <a href="https://ziglang.org/documentation/0.15.2/#Zig-Standard-Library">Zig 标准库</a>的测试分配器 <code>std.testing.allocator</code> 分配<a href="https://ziglang.org/documentation/0.15.2/#Memory">内存</a>时，默认测试运行器将报告使用测试分配器发现的任何泄漏：
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">testing_detect_leak.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">test</span> <span class="tok-str">"detect leak"</span> {
    <span class="tok-kw">var</span> list = std.array_list.Managed(<span class="tok-type">u21</span>).init(std.testing.allocator);
    <span class="tok-comment">// 缺少 `defer list.deinit();`</span>
    <span class="tok-kw">try</span> list.append(<span class="tok-str">'☔'</span>);

    <span class="tok-kw">try</span> std.testing.expect(list.items.len == <span class="tok-number">1</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test testing_detect_leak.zig</kbd>
1/1 testing_detect_leak.test.detect leak...OK
[gpa] (err): memory address 0x7f74a8aa0000 leaked:
<span class="sgr-1m">/home/andy/dev/zig/lib/std/array_list.zig:468:67</span>: <span class="sgr-2m">0x10aa8fe in ensureTotalCapacityPrecise (std.zig)</span>
                const new_memory = try self.allocator.alignedAlloc(T, alignment, new_capacity);
                                                                  <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/array_list.zig:444:51</span>: <span class="sgr-2m">0x107c9e4 in ensureTotalCapacity (std.zig)</span>
            return self.ensureTotalCapacityPrecise(better_capacity);
                                                  <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/array_list.zig:494:41</span>: <span class="sgr-2m">0x105590d in addOne (std.zig)</span>
            try self.ensureTotalCapacity(newlen);
                                        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/array_list.zig:252:49</span>: <span class="sgr-2m">0x1038771 in append (std.zig)</span>
            const new_item_ptr = try self.addOne();
                                                <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/testing_detect_leak.zig:6:20</span>: <span class="sgr-2m">0x10350a9 in test.detect leak (testing_detect_leak.zig)</span>
    try list.append('☔');
                   <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:218:25</span>: <span class="sgr-2m">0x1174760 in mainTerminal (test_runner.zig)</span>
        if (test_fn.func()) |_| {
                        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:66:28</span>: <span class="sgr-2m">0x1170d81 in main (test_runner.zig)</span>
        return mainTerminal();
                           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x116ab1d in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x116a3b1 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>

All 1 tests passed.
1 errors were logged.
1 tests leaked memory.
error: the following test command failed with exit code 1:
/home/andy/dev/zig/.zig-cache/o/4df377b3969e36bf7e0b2704790b75be/test --seed=0xabc34e97
</samp></pre></figure>

      <p>另请参见：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#defer">defer</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Memory">内存</a></li>
</ul>

      
      <h3 id="Detecting-Test-Build"><a href="https://ziglang.org/documentation/0.15.2/#toc-Detecting-Test-Build">检测测试构建</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Detecting-Test-Build">§</a></h3>

      <p>
        使用<a href="https://ziglang.org/documentation/0.15.2/#Compile-Variables">编译变量</a> <code><span class="tok-builtin">@import</span>(<span class="tok-str">"builtin"</span>).is_test</code> 来检测测试构建：
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">testing_detect_test.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">"builtin"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"builtin.is_test"</span> {
    <span class="tok-kw">try</span> expect(isATest());
}

<span class="tok-kw">fn</span> <span class="tok-fn">isATest</span>() <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> builtin.is_test;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test testing_detect_test.zig</kbd>
1/1 testing_detect_test.test.builtin.is_test...OK
All 1 tests passed.
</samp></pre></figure>

      
      <h3 id="Test-Output-and-Logging"><a href="https://ziglang.org/documentation/0.15.2/#toc-Test-Output-and-Logging">测试输出和日志记录</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Test-Output-and-Logging">§</a></h3>

      <p>
        默认测试运行器和 Zig 标准库的测试命名空间将消息输出到标准错误。
      </p>
      
      <h3 id="The-Testing-Namespace"><a href="https://ziglang.org/documentation/0.15.2/#toc-The-Testing-Namespace">测试命名空间</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#The-Testing-Namespace">§</a></h3>

      <p>
        Zig 标准库的 <code>testing</code> 命名空间包含有用的函数来帮助您创建测试。除了 <code>expect</code> 函数之外，本文档还使用了一些其他函数，如下例所示：
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">testing_namespace.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">test</span> <span class="tok-str">"expectEqual demo"</span> {
    <span class="tok-kw">const</span> expected: <span class="tok-type">i32</span> = <span class="tok-number">42</span>;
    <span class="tok-kw">const</span> actual = <span class="tok-number">42</span>;

    <span class="tok-comment">// `expectEqual` 的第一个参数是已知的、预期的结果。</span>
    <span class="tok-comment">// 第二个参数是某个表达式的结果。</span>
    <span class="tok-comment">// actual 的类型会被转换为 expected 的类型。</span>
    <span class="tok-kw">try</span> std.testing.expectEqual(expected, actual);
}

<span class="tok-kw">test</span> <span class="tok-str">"expectError demo"</span> {
    <span class="tok-kw">const</span> expected_error = <span class="tok-kw">error</span>.DemoError;
    <span class="tok-kw">const</span> actual_error_union: <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> = <span class="tok-kw">error</span>.DemoError;

    <span class="tok-comment">// 当实际错误与预期错误不同时，`expectError` 将失败。</span>
    <span class="tok-kw">try</span> std.testing.expectError(expected_error, actual_error_union);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test testing_namespace.zig</kbd>
1/2 testing_namespace.test.expectEqual demo...OK
2/2 testing_namespace.test.expectError demo...OK
All 2 tests passed.
</samp></pre></figure>

      <p>Zig 标准库还包含比较<a href="https://ziglang.org/documentation/0.15.2/#Slices">切片</a>、字符串等的函数。有关更多可用函数，请参阅 <a href="https://ziglang.org/documentation/0.15.2/#Zig-Standard-Library">Zig 标准库</a>中 <code>std.testing</code> 命名空间的其余部分。</p>
      
      <h3 id="Test-Tool-Documentation"><a href="https://ziglang.org/documentation/0.15.2/#toc-Test-Tool-Documentation">测试工具文档</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Test-Tool-Documentation">§</a></h3>

      <p>
        <kbd>zig test</kbd> 有一些影响编译的命令行参数。有关完整列表，请参阅 <kbd>zig test --help</kbd>。
      </p>
      
      

      <h2 id="Variables"><a href="https://ziglang.org/documentation/0.15.2/#toc-Variables">变量</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Variables">§</a></h2>

      <p>
      变量是<a href="https://ziglang.org/documentation/0.15.2/#Memory">内存</a>存储单元。
      </p>
      <p>
      在声明变量时，通常最好使用 <code><span class="tok-kw">const</span></code> 而不是 <code><span class="tok-kw">var</span></code>。这会减少人类和计算机在阅读代码时需要做的工作，并创造更多优化机会。
      </p>
      <p>
      <code><span class="tok-kw">extern</span></code> 关键字或 <a href="https://ziglang.org/documentation/0.15.2/#extern">@extern</a> 内置函数可用于链接从另一个对象导出的变量。<code><span class="tok-kw">export</span></code> 关键字或 <a href="https://ziglang.org/documentation/0.15.2/#export">@export</a> 内置函数可用于使变量在链接时对其他对象可用。在这两种情况下，变量的类型必须与 C ABI 兼容。
      </p>
      <p>另请参见：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Exporting-a-C-Library">导出 C 库</a></li>
</ul>


      <h3 id="Identifiers"><a href="https://ziglang.org/documentation/0.15.2/#toc-Identifiers">标识符</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Identifiers">§</a></h3>

      <p>
      变量标识符永远不允许遮蔽外部作用域的标识符。
      </p>
      <p>
      标识符必须以字母字符或下划线开头，后面可以跟任意数量的字母数字字符或下划线。它们不得与任何关键字重叠。请参阅<a href="https://ziglang.org/documentation/0.15.2/#Keyword-Reference">关键字参考</a>。
      </p>
      <p>
      如果需要不符合这些要求的名称，例如用于与外部库链接，可以使用 <code>@""</code> 语法。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">identifiers.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> @"identifier with spaces in it" = <span class="tok-number">0xff</span>;
<span class="tok-kw">const</span> @"1SmallStep4Man" = <span class="tok-number">112358</span>;

<span class="tok-kw">const</span> c = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).c;
<span class="tok-kw">pub</span> <span class="tok-kw">extern</span> <span class="tok-str">"c"</span> <span class="tok-kw">fn</span> <span class="tok-fn">@"error"</span>() <span class="tok-type">void</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">extern</span> <span class="tok-str">"c"</span> <span class="tok-kw">fn</span> <span class="tok-fn">@"fstat$INODE64"</span>(fd: c.fd_t, buf: *c.Stat) <span class="tok-type">c_int</span>;

<span class="tok-kw">const</span> Color = <span class="tok-kw">enum</span> {
    red,
    @"really red",
};
<span class="tok-kw">const</span> color: Color = .@"really red";</code></pre></figure>

      

      <h3 id="Container-Level-Variables"><a href="https://ziglang.org/documentation/0.15.2/#toc-Container-Level-Variables">容器级变量</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Container-Level-Variables">§</a></h3>

      <p>
      <a href="https://ziglang.org/documentation/0.15.2/#Containers">容器</a>级变量具有静态生命周期，且与顺序无关并延迟分析。容器级变量的初始化值隐式为 <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a>。如果容器级变量是 <code><span class="tok-kw">const</span></code>，则其值为 <code><span class="tok-kw">comptime</span></code> 已知，否则为运行时已知。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_container_level_variables.zig</cite></figcaption><pre><code><span class="tok-kw">var</span> y: <span class="tok-type">i32</span> = add(<span class="tok-number">10</span>, x);
<span class="tok-kw">const</span> x: <span class="tok-type">i32</span> = add(<span class="tok-number">12</span>, <span class="tok-number">34</span>);

<span class="tok-kw">test</span> <span class="tok-str">"container level variables"</span> {
    <span class="tok-kw">try</span> expect(x == <span class="tok-number">46</span>);
    <span class="tok-kw">try</span> expect(y == <span class="tok-number">56</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">add</span>(a: <span class="tok-type">i32</span>, b: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> a + b;
}

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_container_level_variables.zig</kbd>
1/1 test_container_level_variables.test.container level variables...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      容器级变量可以在 <a href="https://ziglang.org/documentation/0.15.2/#struct">struct</a>、<a href="https://ziglang.org/documentation/0.15.2/#union">union</a>、<a href="https://ziglang.org/documentation/0.15.2/#enum">enum</a> 或 <a href="https://ziglang.org/documentation/0.15.2/#opaque">opaque</a> 内部声明：
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_namespaced_container_level_variable.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"namespaced container level variable"</span> {
    <span class="tok-kw">try</span> expect(foo() == <span class="tok-number">1235</span>);
    <span class="tok-kw">try</span> expect(foo() == <span class="tok-number">1236</span>);
}

<span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
};

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">i32</span> {
    S.x += <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> S.x;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_namespaced_container_level_variable.zig</kbd>
1/1 test_namespaced_container_level_variable.test.namespaced container level variable...OK
All 1 tests passed.
</samp></pre></figure>

      

      <h3 id="Static-Local-Variables"><a href="https://ziglang.org/documentation/0.15.2/#toc-Static-Local-Variables">静态局部变量</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Static-Local-Variables">§</a></h3>

      <p>
        还可以通过在函数内部使用容器来拥有具有静态生命周期的局部变量。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_static_local_variable.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"static local variable"</span> {
    <span class="tok-kw">try</span> expect(foo() == <span class="tok-number">1235</span>);
    <span class="tok-kw">try</span> expect(foo() == <span class="tok-number">1236</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">i32</span> {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    };
    S.x += <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> S.x;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_static_local_variable.zig</kbd>
1/1 test_static_local_variable.test.static local variable...OK
All 1 tests passed.
</samp></pre></figure>

      

      <h3 id="Thread-Local-Variables"><a href="https://ziglang.org/documentation/0.15.2/#toc-Thread-Local-Variables">线程局部变量</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Thread-Local-Variables">§</a></h3>

      <p>可以使用 <code><span class="tok-kw">threadlocal</span></code> 关键字将变量指定为线程局部变量，这使得每个线程使用变量的单独实例：</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_thread_local_variables.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> assert = std.debug.assert;

<span class="tok-kw">threadlocal</span> <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;

<span class="tok-kw">test</span> <span class="tok-str">"thread local storage"</span> {
    <span class="tok-kw">const</span> thread1 = <span class="tok-kw">try</span> std.Thread.spawn(.{}, testTls, .{});
    <span class="tok-kw">const</span> thread2 = <span class="tok-kw">try</span> std.Thread.spawn(.{}, testTls, .{});
    testTls();
    thread1.join();
    thread2.join();
}

<span class="tok-kw">fn</span> <span class="tok-fn">testTls</span>() <span class="tok-type">void</span> {
    assert(x == <span class="tok-number">1234</span>);
    x += <span class="tok-number">1</span>;
    assert(x == <span class="tok-number">1235</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_thread_local_variables.zig</kbd>
1/1 test_thread_local_variables.test.thread local storage...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      对于<a href="https://ziglang.org/documentation/0.15.2/#Single-Threaded-Builds">单线程构建</a>，所有线程局部变量都被视为常规的<a href="https://ziglang.org/documentation/0.15.2/#Container-Level-Variables">容器级变量</a>。
      </p>
      <p>
      线程局部变量不能是 <code><span class="tok-kw">const</span></code>。
      </p>
      

      <h3 id="Local-Variables"><a href="https://ziglang.org/documentation/0.15.2/#toc-Local-Variables">局部变量</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Local-Variables">§</a></h3>

      <p>
      局部变量出现在<a href="https://ziglang.org/documentation/0.15.2/#Functions">函数</a>、<a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a> 块和 <a href="https://ziglang.org/documentation/0.15.2/#cImport">@cImport</a> 块中。
      </p>
      <p>
      当局部变量是 <code><span class="tok-kw">const</span></code> 时，意味着初始化后，变量的值不会改变。如果 <code><span class="tok-kw">const</span></code> 变量的初始化值为 <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a> 已知，则该变量也是 <code><span class="tok-kw">comptime</span></code> 已知。
      </p>
      <p>
      局部变量可以用 <code><span class="tok-kw">comptime</span></code> 关键字限定。这会使变量的值为 <code><span class="tok-kw">comptime</span></code> 已知，并且所有对变量的加载和存储都在程序的语义分析期间进行，而不是在运行时。所有在 <code><span class="tok-kw">comptime</span></code> 表达式中声明的变量都隐式为 <code><span class="tok-kw">comptime</span></code> 变量。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_variables.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"comptime vars"</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> y: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;

    x += <span class="tok-number">1</span>;
    y += <span class="tok-number">1</span>;

    <span class="tok-kw">try</span> expect(x == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> expect(y == <span class="tok-number">2</span>);

    <span class="tok-kw">if</span> (y != <span class="tok-number">2</span>) {
        <span class="tok-comment">// 这个编译错误永远不会触发，因为 y 是一个 comptime 变量，</span>
        <span class="tok-comment">// 因此 `y != 2` 是一个 comptime 值，并且这个 if 是静态求值的。</span>
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">"wrong y value"</span>);
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_variables.zig</kbd>
1/1 test_comptime_variables.test.comptime vars...OK
All 1 tests passed.
</samp></pre></figure>

      
      

      <h2 id="Integers"><a href="https://ziglang.org/documentation/0.15.2/#toc-Integers">整数</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Integers">§</a></h2>

      <h3 id="Integer-Literals"><a href="https://ziglang.org/documentation/0.15.2/#toc-Integer-Literals">整数字面量</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Integer-Literals">§</a></h3>

      <figure><figcaption class="zig-cap"><cite class="file">integer_literals.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> decimal_int = <span class="tok-number">98222</span>;
<span class="tok-kw">const</span> hex_int = <span class="tok-number">0xff</span>;
<span class="tok-kw">const</span> another_hex_int = <span class="tok-number">0xFF</span>;
<span class="tok-kw">const</span> octal_int = <span class="tok-number">0o755</span>;
<span class="tok-kw">const</span> binary_int = <span class="tok-number">0b11110000</span>;

<span class="tok-comment">// 下划线可以放置在两个数字之间作为视觉分隔符</span>
<span class="tok-kw">const</span> one_billion = <span class="tok-number">1_000_000_000</span>;
<span class="tok-kw">const</span> binary_mask = <span class="tok-number">0b1_1111_1111</span>;
<span class="tok-kw">const</span> permissions = <span class="tok-number">0o7_5_5</span>;
<span class="tok-kw">const</span> big_address = <span class="tok-number">0xFF80_0000_0000_0000</span>;</code></pre></figure>

      
      <h3 id="Runtime-Integer-Values"><a href="https://ziglang.org/documentation/0.15.2/#toc-Runtime-Integer-Values">运行时整数值</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Runtime-Integer-Values">§</a></h3>

      <p>
      整数字面量没有大小限制，如果发生任何非法行为，编译器会捕获它。
      </p>
      <p>
      但是，一旦整数值不再在编译时已知，它必须有一个已知的大小，并且容易受到安全检查的<a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>的影响。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_vs_comptime.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">divide</span>(a: <span class="tok-type">i32</span>, b: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> a / b;
}</code></pre></figure>

      <p>
      在此函数中，值 <code>a</code> 和 <code>b</code> 仅在运行时已知，因此此除法运算容易受到<a href="https://ziglang.org/documentation/0.15.2/#Integer-Overflow">整数溢出</a>和<a href="https://ziglang.org/documentation/0.15.2/#Division-by-Zero">除以零</a>的影响。
      </p>
      <p>
      诸如 <code>+</code> 和 <code>-</code> 之类的运算符会在整数溢出时导致<a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>。在所有目标上都提供了用于环绕和饱和算术的替代运算符。<code>+%</code> 和 <code>-%</code> 执行环绕算术，而 <code>+|</code> 和 <code>-|</code> 执行饱和算术。
      </p>
      <p>
      Zig 支持任意位宽整数，通过使用后跟数字的 <code>i</code> 或 <code>u</code> 标识符来引用。例如，标识符 <code><span class="tok-type">i7</span></code> 表示有符号 7 位整数。整数类型允许的最大位宽为 <code><span class="tok-number">65535</span></code>。对于有符号整数类型，Zig 使用<a href="https://en.wikipedia.org/wiki/Two&#39;s_complement">二进制补码</a>表示法。
      </p>
      <p>另请参见：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Wrapping-Operations">环绕操作</a></li>
</ul>

      
      
      <h2 id="Floats"><a href="https://ziglang.org/documentation/0.15.2/#toc-Floats">浮点数</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Floats">§</a></h2>

      <p>Zig 具有以下浮点类型：</p>
      <ul>
          <li><code><span class="tok-type">f16</span></code> - IEEE-754-2008 binary16</li>
          <li><code><span class="tok-type">f32</span></code> - IEEE-754-2008 binary32</li>
          <li><code><span class="tok-type">f64</span></code> - IEEE-754-2008 binary64</li>
          <li><code><span class="tok-type">f80</span></code> - IEEE-754-2008 80 位扩展精度</li>
          <li><code><span class="tok-type">f128</span></code> - IEEE-754-2008 binary128</li>
          <li><code><span class="tok-type">c_longdouble</span></code> - 匹配目标 C ABI 的 <code class="c">long double</code></li>
      </ul>
      <h3 id="Float-Literals"><a href="https://ziglang.org/documentation/0.15.2/#toc-Float-Literals">浮点字面量</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Float-Literals">§</a></h3>

      <p>
      浮点字面量的类型为 <code><span class="tok-type">comptime_float</span></code>，它保证具有与最大的其他浮点类型相同的精度和操作，即 <code><span class="tok-type">f128</span></code>。
      </p>
      <p>
      浮点字面量可以<a href="https://ziglang.org/documentation/0.15.2/#Type-Coercion">强制转换</a>为任何浮点类型，并且在没有小数部分时可以转换为任何<a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a>类型。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">float_literals.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> floating_point = <span class="tok-number">123.0E+77</span>;
<span class="tok-kw">const</span> another_float = <span class="tok-number">123.0</span>;
<span class="tok-kw">const</span> yet_another = <span class="tok-number">123.0e+77</span>;

<span class="tok-kw">const</span> hex_floating_point = <span class="tok-number">0x103.70p-5</span>;
<span class="tok-kw">const</span> another_hex_float = <span class="tok-number">0x103.70</span>;
<span class="tok-kw">const</span> yet_another_hex_float = <span class="tok-number">0x103.70P-5</span>;

<span class="tok-comment">// 下划线可以放置在两个数字之间作为视觉分隔符</span>
<span class="tok-kw">const</span> lightspeed = <span class="tok-number">299_792_458.000_000</span>;
<span class="tok-kw">const</span> nanosecond = <span class="tok-number">0.000_000_001</span>;
<span class="tok-kw">const</span> more_hex = <span class="tok-number">0x1234_5678.9ABC_CDEFp-10</span>;</code></pre></figure>

      <p>
      没有用于 NaN、无穷大或负无穷大的语法。对于这些特殊值，必须使用标准库：
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">float_special_values.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">const</span> inf = std.math.inf(<span class="tok-type">f32</span>);
<span class="tok-kw">const</span> negative_inf = -std.math.inf(<span class="tok-type">f64</span>);
<span class="tok-kw">const</span> nan = std.math.nan(<span class="tok-type">f128</span>);</code></pre></figure>

      
      <h3 id="Floating-Point-Operations"><a href="https://ziglang.org/documentation/0.15.2/#toc-Floating-Point-Operations">浮点运算</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Floating-Point-Operations">§</a></h3>

      <p>默认情况下，浮点运算使用 <code>Strict</code> 模式，但您可以在每个块的基础上切换到 <code>Optimized</code> 模式：</p>
      <figure><figcaption class="zig-cap"><cite class="file">float_mode_obj.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> big = <span class="tok-builtin">@as</span>(<span class="tok-type">f64</span>, <span class="tok-number">1</span> &lt;&lt; <span class="tok-number">40</span>);

<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo_strict</span>(x: <span class="tok-type">f64</span>) <span class="tok-type">f64</span> {
    <span class="tok-kw">return</span> x + big - big;
}

<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo_optimized</span>(x: <span class="tok-type">f64</span>) <span class="tok-type">f64</span> {
    <span class="tok-builtin">@setFloatMode</span>(.optimized);
    <span class="tok-kw">return</span> x + big - big;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-obj float_mode_obj.zig -O ReleaseFast</kbd>
</samp></pre></figure>

      <p>对于此测试，我们必须将代码分离到两个对象文件中——否则优化器会在编译时计算出所有值，而编译时在严格模式下运行。</p>
      <figure><figcaption class="zig-cap"><cite class="file">float_mode_exe.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;

<span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo_strict</span>(x: <span class="tok-type">f64</span>) <span class="tok-type">f64</span>;
<span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo_optimized</span>(x: <span class="tok-type">f64</span>) <span class="tok-type">f64</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> x = <span class="tok-number">0.001</span>;
    print(<span class="tok-str">"optimized = {}\n"</span>, .{foo_optimized(x)});
    print(<span class="tok-str">"strict = {}\n"</span>, .{foo_strict(x)});
}</code></pre></figure>
<!-- ====== END CHUNK 2: new_02.html ====== -->

<!-- ====== BEGIN CHUNK 3: new_03.html ====== -->
<p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#setFloatMode">@setFloatMode</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Division-by-Zero">除以零</a></li>
</ul>

      
      
      <h2 id="Operators"><a href="https://ziglang.org/documentation/0.15.2/#toc-Operators">运算符</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Operators">§</a></h2>

      <p>
      Zig 中没有运算符重载。当你在 Zig 中看到一个运算符时,你知道它正在执行此表中的某些操作,而不会是其他操作。
      </p>
      <h3 id="Table-of-Operators"><a href="https://ziglang.org/documentation/0.15.2/#toc-Table-of-Operators">运算符表</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Table-of-Operators">§</a></h3>

      <div class="table-wrapper">
      <table>
        <thead>
        <tr>
          <th scope="col">名称</th>
          <th scope="col">语法</th>
          <th scope="col">类型</th>
          <th scope="col">备注</th>
          <th scope="col">示例</th>
        </tr>
        </thead>
        <tbody>
        <tr>
          <td>加法</td>
          <td><pre><code>a + b
a += b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>对于整数可能导致<a href="https://ziglang.org/documentation/0.15.2/#Default-Operations">溢出</a>。</li>
              <li>对操作数调用<a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">对等类型解析</a>。</li>
              <li>另请参阅 <a href="https://ziglang.org/documentation/0.15.2/#addWithOverflow">@addWithOverflow</a>。</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-number">2</span> + <span class="tok-number">5</span> == <span class="tok-number">7</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>回绕加法</td>
          <td><pre><code>a +% b
a +%= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>二进制补码回绕行为。</li>
              <li>对操作数调用<a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">对等类型解析</a>。</li>
              <li>另请参阅 <a href="https://ziglang.org/documentation/0.15.2/#addWithOverflow">@addWithOverflow</a>。</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0xffffffff</span>) +% <span class="tok-number">1</span> == <span class="tok-number">0</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>饱和加法</td>
          <td><pre><code>a +| b
a +|= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>对操作数调用<a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">对等类型解析</a>。</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">255</span>) +| <span class="tok-number">1</span> == <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">255</span>)</code></pre>
          </td>
        </tr>
        <tr>
          <td>减法</td>
          <td><pre><code>a - b
a -= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>对于整数可能导致<a href="https://ziglang.org/documentation/0.15.2/#Default-Operations">溢出</a>。</li>
              <li>对操作数调用<a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">对等类型解析</a>。</li>
              <li>另请参阅 <a href="https://ziglang.org/documentation/0.15.2/#subWithOverflow">@subWithOverflow</a>。</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-number">2</span> - <span class="tok-number">5</span> == -<span class="tok-number">3</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>回绕减法</td>
          <td><pre><code>a -% b
a -%= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>二进制补码回绕行为。</li>
              <li>对操作数调用<a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">对等类型解析</a>。</li>
              <li>另请参阅 <a href="https://ziglang.org/documentation/0.15.2/#subWithOverflow">@subWithOverflow</a>。</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0</span>) -% <span class="tok-number">1</span> == <span class="tok-number">255</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>饱和减法</td>
          <td><pre><code>a -| b
a -|= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>对操作数调用<a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">对等类型解析</a>。</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>) -| <span class="tok-number">1</span> == <span class="tok-number">0</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>取负</td>
          <td><pre><code>-a</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>对于整数可能导致<a href="https://ziglang.org/documentation/0.15.2/#Default-Operations">溢出</a>。</li>
            </ul>
          </td>
          <td>
            <pre><code>-<span class="tok-number">1</span> == <span class="tok-number">0</span> - <span class="tok-number">1</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>回绕取负</td>
          <td><pre><code>-%a</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>二进制补码回绕行为。</li>
            </ul>
          </td>
          <td>
            <pre><code>-%<span class="tok-builtin">@as</span>(<span class="tok-type">i8</span>, -<span class="tok-number">128</span>) == -<span class="tok-number">128</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>乘法</td>
          <td><pre><code>a * b
a *= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>对于整数可能导致<a href="https://ziglang.org/documentation/0.15.2/#Default-Operations">溢出</a>。</li>
              <li>对操作数调用<a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">对等类型解析</a>。</li>
              <li>另请参阅 <a href="https://ziglang.org/documentation/0.15.2/#mulWithOverflow">@mulWithOverflow</a>。</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-number">2</span> * <span class="tok-number">5</span> == <span class="tok-number">10</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>回绕乘法</td>
          <td><pre><code>a *% b
a *%= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>二进制补码回绕行为。</li>
              <li>对操作数调用<a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">对等类型解析</a>。</li>
              <li>另请参阅 <a href="https://ziglang.org/documentation/0.15.2/#mulWithOverflow">@mulWithOverflow</a>。</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">200</span>) *% <span class="tok-number">2</span> == <span class="tok-number">144</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>饱和乘法</td>
          <td><pre><code>a *| b
a *|= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>对操作数调用<a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">对等类型解析</a>。</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">200</span>) *| <span class="tok-number">2</span> == <span class="tok-number">255</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>除法</td>
          <td><pre><code>a / b
a /= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>对于整数可能导致<a href="https://ziglang.org/documentation/0.15.2/#Default-Operations">溢出</a>。</li>
              <li>对于整数可能导致<a href="https://ziglang.org/documentation/0.15.2/#Division-by-Zero">除以零</a>。</li>
              <li>在<a href="https://ziglang.org/documentation/0.15.2/#Floating-Point-Operations">FloatMode.Optimized 模式</a>下,对于浮点数可能导致<a href="https://ziglang.org/documentation/0.15.2/#Division-by-Zero">除以零</a>。</li>
              <li>有符号整数操作数必须在编译时已知且为正。在其他情况下,请改用
                <a href="https://ziglang.org/documentation/0.15.2/#divTrunc">@divTrunc</a>、
                <a href="https://ziglang.org/documentation/0.15.2/#divFloor">@divFloor</a> 或
                <a href="https://ziglang.org/documentation/0.15.2/#divExact">@divExact</a>。
              </li>
              <li>对操作数调用<a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">对等类型解析</a>。</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-number">10</span> / <span class="tok-number">5</span> == <span class="tok-number">2</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>取余除法</td>
          <td><pre><code>a % b
a %= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>对于整数可能导致<a href="https://ziglang.org/documentation/0.15.2/#Division-by-Zero">除以零</a>。</li>
              <li>在<a href="https://ziglang.org/documentation/0.15.2/#Floating-Point-Operations">FloatMode.Optimized 模式</a>下,对于浮点数可能导致<a href="https://ziglang.org/documentation/0.15.2/#Division-by-Zero">除以零</a>。</li>
              <li>有符号或浮点操作数必须在编译时已知且为正。在其他情况下,请改用
                <a href="https://ziglang.org/documentation/0.15.2/#rem">@rem</a> 或
                <a href="https://ziglang.org/documentation/0.15.2/#mod">@mod</a>。
              </li>
              <li>对操作数调用<a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">对等类型解析</a>。</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-number">10</span> % <span class="tok-number">3</span> == <span class="tok-number">1</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>位左移</td>
          <td><pre><code>a &lt;&lt; b
a &lt;&lt;= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>将所有位向左移动,在最低有效位插入新的零。</li>
              <li><code>b</code> 必须是<a href="https://ziglang.org/documentation/0.15.2/#comptime">编译时已知</a>的,或者具有与 <code>a</code> 的位数的 log2 相同的类型。</li>
              <li>另请参阅 <a href="https://ziglang.org/documentation/0.15.2/#shlExact">@shlExact</a>。</li>
              <li>另请参阅 <a href="https://ziglang.org/documentation/0.15.2/#shlWithOverflow">@shlWithOverflow</a>。</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-number">0b1</span> &lt;&lt; <span class="tok-number">8</span> == <span class="tok-number">0b100000000</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>饱和位左移</td>
          <td><pre><code>a &lt;&lt;| b
a &lt;&lt;|= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>另请参阅 <a href="https://ziglang.org/documentation/0.15.2/#shlExact">@shlExact</a>。</li>
              <li>另请参阅 <a href="https://ziglang.org/documentation/0.15.2/#shlWithOverflow">@shlWithOverflow</a>。</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">1</span>) &lt;&lt;| <span class="tok-number">8</span> == <span class="tok-number">255</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>位右移</td>
          <td><pre><code>a &gt;&gt; b
a &gt;&gt;= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>将所有位向右移动,在最高有效位插入零。</li>
              <li><code>b</code> 必须是<a href="https://ziglang.org/documentation/0.15.2/#comptime">编译时已知</a>的,或者具有与 <code>a</code> 的位数的 log2 相同的类型。</li>
              <li>另请参阅 <a href="https://ziglang.org/documentation/0.15.2/#shrExact">@shrExact</a>。</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-number">0b1010</span> &gt;&gt; <span class="tok-number">1</span> == <span class="tok-number">0b101</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>按位与</td>
          <td><pre><code>a &amp; b
a &amp;= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>对操作数调用<a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">对等类型解析</a>。</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-number">0b011</span> &amp; <span class="tok-number">0b101</span> == <span class="tok-number">0b001</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>按位或</td>
          <td><pre><code>a | b
a |= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>对操作数调用<a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">对等类型解析</a>。</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-number">0b010</span> | <span class="tok-number">0b100</span> == <span class="tok-number">0b110</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>按位异或</td>
          <td><pre><code>a ^ b
a ^= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>对操作数调用<a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">对等类型解析</a>。</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-number">0b011</span> ^ <span class="tok-number">0b101</span> == <span class="tok-number">0b110</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>按位取反</td>
          <td><pre><code>~a</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a></li>
            </ul>
          </td>
          <td></td>
          <td>
            <pre><code>~<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0b10101111</span>) == <span class="tok-number">0b01010000</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>可选值默认解包</td>
          <td><pre><code>a <span class="tok-kw">orelse</span> b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Optionals">可选值</a></li>
            </ul>
          </td>
          <td>如果 <code>a</code> 是 <code><span class="tok-null">null</span></code>,
          返回 <code>b</code>("默认值"),
          否则返回 <code>a</code> 的解包值。
          注意 <code>b</code> 可以是 <a href="https://ziglang.org/documentation/0.15.2/#noreturn">noreturn</a> 类型的值。
          </td>
          <td>
            <pre><code><span class="tok-kw">const</span> value: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span>;
<span class="tok-kw">const</span> unwrapped = value <span class="tok-kw">orelse</span> <span class="tok-number">1234</span>;
unwrapped == <span class="tok-number">1234</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>可选值解包</td>
          <td><pre><code>a.?</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Optionals">可选值</a></li>
            </ul>
          </td>
          <td>
            等价于:
            <pre><code>a <span class="tok-kw">orelse</span> <span class="tok-kw">unreachable</span></code></pre>
          </td>
          <td>
            <pre><code><span class="tok-kw">const</span> value: ?<span class="tok-type">u32</span> = <span class="tok-number">5678</span>;
value.? == <span class="tok-number">5678</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>错误默认解包</td>
          <td><pre><code>a <span class="tok-kw">catch</span> b
a <span class="tok-kw">catch</span> |err| b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Errors">错误联合</a></li>
            </ul>
          </td>
          <td>如果 <code>a</code> 是 <code><span class="tok-kw">error</span></code>,
          返回 <code>b</code>("默认值"),
          否则返回 <code>a</code> 的解包值。
          注意 <code>b</code> 可以是 <a href="https://ziglang.org/documentation/0.15.2/#noreturn">noreturn</a> 类型的值。
<code>err</code> 是 <code><span class="tok-kw">error</span></code>,并且在表达式 <code>b</code> 的作用域内。
          </td>
          <td>
            <pre><code><span class="tok-kw">const</span> value: <span class="tok-type">anyerror</span>!<span class="tok-type">u32</span> = <span class="tok-kw">error</span>.Broken;
<span class="tok-kw">const</span> unwrapped = value <span class="tok-kw">catch</span> <span class="tok-number">1234</span>;
unwrapped == <span class="tok-number">1234</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>逻辑与</td>
          <td><pre><code>a <span class="tok-kw">and</span> b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Primitive-Types">bool</a></li>
            </ul>
          </td>
          <td>
          如果 <code>a</code> 是 <code><span class="tok-null">false</span></code>,不计算 <code>b</code> 即返回 <code><span class="tok-null">false</span></code>。否则,返回 <code>b</code>。
          </td>
          <td>
            <pre><code>(<span class="tok-null">false</span> <span class="tok-kw">and</span> <span class="tok-null">true</span>) == <span class="tok-null">false</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>逻辑或</td>
          <td><pre><code>a <span class="tok-kw">or</span> b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Primitive-Types">bool</a></li>
            </ul>
          </td>
          <td>
              如果 <code>a</code> 是 <code><span class="tok-null">true</span></code>,
              不计算 <code>b</code> 即返回 <code><span class="tok-null">true</span></code>。否则,返回
              <code>b</code>。
          </td>
          <td>
            <pre><code>(<span class="tok-null">false</span> <span class="tok-kw">or</span> <span class="tok-null">true</span>) == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>布尔取反</td>
          <td><pre><code>!a</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Primitive-Types">bool</a></li>
            </ul>
          </td>
          <td></td>
          <td>
            <pre><code>!<span class="tok-null">false</span> == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>相等</td>
          <td><pre><code>a == b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Primitive-Types">bool</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Primitive-Types">type</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#packed-struct">紧凑结构体</a></li>
            </ul>
          </td>
          <td>
              如果 a 和 b 相等,返回 <code><span class="tok-null">true</span></code>,否则返回 <code><span class="tok-null">false</span></code>。
            对操作数调用<a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">对等类型解析</a>。
          </td>
          <td>
            <pre><code>(<span class="tok-number">1</span> == <span class="tok-number">1</span>) == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>空值检查</td>
          <td><pre><code>a == <span class="tok-null">null</span></code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Optionals">可选值</a></li>
            </ul>
          </td>
          <td>
              如果 a 是 <code><span class="tok-null">null</span></code>,返回 <code><span class="tok-null">true</span></code>,否则返回 <code><span class="tok-null">false</span></code>。
          </td>
          <td>
            <pre><code><span class="tok-kw">const</span> value: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span>;
(value == <span class="tok-null">null</span>) == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>不相等</td>
          <td><pre><code>a != b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Primitive-Types">bool</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Primitive-Types">type</a></li>
            </ul>
          </td>
          <td>
              如果 a 和 b 相等,返回 <code><span class="tok-null">false</span></code>,否则返回 <code><span class="tok-null">true</span></code>。
            对操作数调用<a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">对等类型解析</a>。
          </td>
          <td>
            <pre><code>(<span class="tok-number">1</span> != <span class="tok-number">1</span>) == <span class="tok-null">false</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>非空检查</td>
          <td><pre><code>a != <span class="tok-null">null</span></code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Optionals">可选值</a></li>
            </ul>
          </td>
          <td>
              如果 a 是 <code><span class="tok-null">null</span></code>,返回 <code><span class="tok-null">false</span></code>,否则返回 <code><span class="tok-null">true</span></code>。
          </td>
          <td>
            <pre><code><span class="tok-kw">const</span> value: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span>;
(value != <span class="tok-null">null</span>) == <span class="tok-null">false</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>大于</td>
          <td><pre><code>a &gt; b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a></li>
            </ul>
          </td>
          <td>
              如果 a 大于 b,返回 <code><span class="tok-null">true</span></code>,否则返回 <code><span class="tok-null">false</span></code>。
            对操作数调用<a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">对等类型解析</a>。
          </td>
          <td>
            <pre><code>(<span class="tok-number">2</span> &gt; <span class="tok-number">1</span>) == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>大于或等于</td>
          <td><pre><code>a &gt;= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a></li>
            </ul>
          </td>
          <td>
              如果 a 大于或等于 b,返回 <code><span class="tok-null">true</span></code>,否则返回 <code><span class="tok-null">false</span></code>。
            对操作数调用<a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">对等类型解析</a>。
          </td>
          <td>
            <pre><code>(<span class="tok-number">2</span> &gt;= <span class="tok-number">1</span>) == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>小于</td>
          <td><pre><code>a &lt; b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a></li>
            </ul>
          </td>
          <td>
              如果 a 小于 b,返回 <code><span class="tok-null">true</span></code>,否则返回 <code><span class="tok-null">false</span></code>。
            对操作数调用<a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">对等类型解析</a>。
          </td>
          <td>
            <pre><code>(<span class="tok-number">1</span> &lt; <span class="tok-number">2</span>) == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>小于或等于</td>
          <td><pre><code>a &lt;= b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a></li>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a></li>
            </ul>
          </td>
          <td>
              如果 a 小于或等于 b,返回 <code><span class="tok-null">true</span></code>,否则返回 <code><span class="tok-null">false</span></code>。
            对操作数调用<a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">对等类型解析</a>。
          </td>
          <td>
            <pre><code>(<span class="tok-number">1</span> &lt;= <span class="tok-number">2</span>) == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>数组拼接</td>
          <td><pre><code>a ++ b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Arrays">数组</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>仅在 <code>a</code> 和 <code>b</code> 的长度都是<a href="https://ziglang.org/documentation/0.15.2/#comptime">编译时已知</a>时可用。</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).mem;
<span class="tok-kw">const</span> array1 = [_]<span class="tok-type">u32</span>{<span class="tok-number">1</span>,<span class="tok-number">2</span>};
<span class="tok-kw">const</span> array2 = [_]<span class="tok-type">u32</span>{<span class="tok-number">3</span>,<span class="tok-number">4</span>};
<span class="tok-kw">const</span> together = array1 ++ array2;
mem.eql(<span class="tok-type">u32</span>, &amp;together, &amp;[_]<span class="tok-type">u32</span>{<span class="tok-number">1</span>,<span class="tok-number">2</span>,<span class="tok-number">3</span>,<span class="tok-number">4</span>})</code></pre>
          </td>
        </tr>
        <tr>
          <td>数组重复</td>
          <td><pre><code>a ** b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Arrays">数组</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>仅在 <code>a</code> 和 <code>b</code> 的长度是<a href="https://ziglang.org/documentation/0.15.2/#comptime">编译时已知</a>时可用。</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).mem;
<span class="tok-kw">const</span> pattern = <span class="tok-str">"ab"</span> ** <span class="tok-number">3</span>;
mem.eql(<span class="tok-type">u8</span>, pattern, <span class="tok-str">"ababab"</span>)</code></pre>
          </td>
        </tr>
        <tr>
          <td>指针解引用</td>
          <td><pre><code>a.*</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Pointers">指针</a></li>
            </ul>
          </td>
          <td>
            指针解引用。
          </td>
          <td>
            <pre><code><span class="tok-kw">const</span> x: <span class="tok-type">u32</span> = <span class="tok-number">1234</span>;
<span class="tok-kw">const</span> ptr = &amp;x;
ptr.* == <span class="tok-number">1234</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>取地址</td>
          <td><pre><code>&amp;a</code></pre></td>
          <td>
            所有类型
          </td>
          <td>
          </td>
          <td>
            <pre><code><span class="tok-kw">const</span> x: <span class="tok-type">u32</span> = <span class="tok-number">1234</span>;
<span class="tok-kw">const</span> ptr = &amp;x;
ptr.* == <span class="tok-number">1234</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>错误集合并</td>
          <td><pre><code>a || b</code></pre></td>
          <td>
            <ul>
              <li><a href="https://ziglang.org/documentation/0.15.2/#Error-Set-Type">错误集类型</a></li>
            </ul>
          </td>
          <td>
              <a href="https://ziglang.org/documentation/0.15.2/#Merging-Error-Sets">合并错误集</a>
          </td>
          <td>
            <pre><code><span class="tok-kw">const</span> A = <span class="tok-kw">error</span>{One};
<span class="tok-kw">const</span> B = <span class="tok-kw">error</span>{Two};
(A || B) == <span class="tok-kw">error</span>{One, Two}</code></pre>
          </td>
        </tr>
        </tbody>
      </table>
      </div>
      
      <h3 id="Precedence"><a href="https://ziglang.org/documentation/0.15.2/#toc-Precedence">优先级</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Precedence">§</a></h3>

      <pre><code>x() x[] x.y x.* x.?
a!b
x{}
!x -x -%x ~x &amp;x ?x
* / % ** *% *| ||
+ - ++ +% -% +| -|
&lt;&lt; &gt;&gt; &lt;&lt;|
&amp; ^ | <span class="tok-kw">orelse</span> <span class="tok-kw">catch</span>
== != &lt; &gt; &lt;= &gt;=
<span class="tok-kw">and</span>
<span class="tok-kw">or</span>
= *= *%= *|= /= %= += +%= +|= -= -%= -|= &lt;&lt;= &lt;&lt;|= &gt;&gt;= &amp;= ^= |=</code></pre>
      
      
      <h2 id="Arrays"><a href="https://ziglang.org/documentation/0.15.2/#toc-Arrays">数组</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Arrays">§</a></h2>

      <figure><figcaption class="zig-cap"><cite class="file">test_arrays.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;
<span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.assert;
<span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).mem;

<span class="tok-comment">// 数组字面量</span>
<span class="tok-kw">const</span> message = [_]<span class="tok-type">u8</span>{ <span class="tok-str">'h'</span>, <span class="tok-str">'e'</span>, <span class="tok-str">'l'</span>, <span class="tok-str">'l'</span>, <span class="tok-str">'o'</span> };

<span class="tok-comment">// 使用结果位置的替代初始化方式</span>
<span class="tok-kw">const</span> alt_message: [<span class="tok-number">5</span>]<span class="tok-type">u8</span> = .{ <span class="tok-str">'h'</span>, <span class="tok-str">'e'</span>, <span class="tok-str">'l'</span>, <span class="tok-str">'l'</span>, <span class="tok-str">'o'</span> };

<span class="tok-kw">comptime</span> {
    assert(mem.eql(<span class="tok-type">u8</span>, &amp;message, &amp;alt_message));
}

<span class="tok-comment">// 获取数组的大小</span>
<span class="tok-kw">comptime</span> {
    assert(message.len == <span class="tok-number">5</span>);
}

<span class="tok-comment">// 字符串字面量是指向数组的单项指针。</span>
<span class="tok-kw">const</span> same_message = <span class="tok-str">"hello"</span>;

<span class="tok-kw">comptime</span> {
    assert(mem.eql(<span class="tok-type">u8</span>, &amp;message, same_message));
}

<span class="tok-kw">test</span> <span class="tok-str">"iterate over an array"</span> {
    <span class="tok-kw">var</span> sum: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (message) |byte| {
        sum += byte;
    }
    <span class="tok-kw">try</span> expect(sum == <span class="tok-str">'h'</span> + <span class="tok-str">'e'</span> + <span class="tok-str">'l'</span> * <span class="tok-number">2</span> + <span class="tok-str">'o'</span>);
}

<span class="tok-comment">// 可修改数组</span>
<span class="tok-kw">var</span> some_integers: [<span class="tok-number">100</span>]<span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;

<span class="tok-kw">test</span> <span class="tok-str">"modify an array"</span> {
    <span class="tok-kw">for</span> (&amp;some_integers, <span class="tok-number">0</span>..) |*item, i| {
        item.* = <span class="tok-builtin">@intCast</span>(i);
    }
    <span class="tok-kw">try</span> expect(some_integers[<span class="tok-number">10</span>] == <span class="tok-number">10</span>);
    <span class="tok-kw">try</span> expect(some_integers[<span class="tok-number">99</span>] == <span class="tok-number">99</span>);
}

<span class="tok-comment">// 如果值在编译时已知,数组拼接可以工作</span>
<span class="tok-kw">const</span> part_one = [_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };
<span class="tok-kw">const</span> part_two = [_]<span class="tok-type">i32</span>{ <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span> };
<span class="tok-kw">const</span> all_of_it = part_one ++ part_two;
<span class="tok-kw">comptime</span> {
    assert(mem.eql(<span class="tok-type">i32</span>, &amp;all_of_it, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span> }));
}

<span class="tok-comment">// 记住字符串字面量是数组</span>
<span class="tok-kw">const</span> hello = <span class="tok-str">"hello"</span>;
<span class="tok-kw">const</span> world = <span class="tok-str">"world"</span>;
<span class="tok-kw">const</span> hello_world = hello ++ <span class="tok-str">" "</span> ++ world;
<span class="tok-kw">comptime</span> {
    assert(mem.eql(<span class="tok-type">u8</span>, hello_world, <span class="tok-str">"hello world"</span>));
}

<span class="tok-comment">// ** 用于重复模式</span>
<span class="tok-kw">const</span> pattern = <span class="tok-str">"ab"</span> ** <span class="tok-number">3</span>;
<span class="tok-kw">comptime</span> {
    assert(mem.eql(<span class="tok-type">u8</span>, pattern, <span class="tok-str">"ababab"</span>));
}

<span class="tok-comment">// 初始化数组为零</span>
<span class="tok-kw">const</span> all_zero = [_]<span class="tok-type">u16</span>{<span class="tok-number">0</span>} ** <span class="tok-number">10</span>;

<span class="tok-kw">comptime</span> {
    assert(all_zero.len == <span class="tok-number">10</span>);
    assert(all_zero[<span class="tok-number">5</span>] == <span class="tok-number">0</span>);
}

<span class="tok-comment">// 使用编译时代码初始化数组</span>
<span class="tok-kw">var</span> fancy_array = init: {
    <span class="tok-kw">var</span> initial_value: [<span class="tok-number">10</span>]Point = <span class="tok-null">undefined</span>;
    <span class="tok-kw">for</span> (&amp;initial_value, <span class="tok-number">0</span>..) |*pt, i| {
        pt.* = Point{
            .x = <span class="tok-builtin">@intCast</span>(i),
            .y = <span class="tok-builtin">@intCast</span>(i * <span class="tok-number">2</span>),
        };
    }
    <span class="tok-kw">break</span> :init initial_value;
};
<span class="tok-kw">const</span> Point = <span class="tok-kw">struct</span> {
    x: <span class="tok-type">i32</span>,
    y: <span class="tok-type">i32</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">"compile-time array initialization"</span> {
    <span class="tok-kw">try</span> expect(fancy_array[<span class="tok-number">4</span>].x == <span class="tok-number">4</span>);
    <span class="tok-kw">try</span> expect(fancy_array[<span class="tok-number">4</span>].y == <span class="tok-number">8</span>);
}

<span class="tok-comment">// 调用函数初始化数组</span>
<span class="tok-kw">var</span> more_points = [_]Point{makePoint(<span class="tok-number">3</span>)} ** <span class="tok-number">10</span>;
<span class="tok-kw">fn</span> <span class="tok-fn">makePoint</span>(x: <span class="tok-type">i32</span>) Point {
    <span class="tok-kw">return</span> Point{
        .x = x,
        .y = x * <span class="tok-number">2</span>,
    };
}
<span class="tok-kw">test</span> <span class="tok-str">"array initialization with function calls"</span> {
    <span class="tok-kw">try</span> expect(more_points[<span class="tok-number">4</span>].x == <span class="tok-number">3</span>);
    <span class="tok-kw">try</span> expect(more_points[<span class="tok-number">4</span>].y == <span class="tok-number">6</span>);
    <span class="tok-kw">try</span> expect(more_points.len == <span class="tok-number">10</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_arrays.zig</kbd>
1/4 test_arrays.test.iterate over an array...OK
2/4 test_arrays.test.modify an array...OK
3/4 test_arrays.test.compile-time array initialization...OK
4/4 test_arrays.test.array initialization with function calls...OK
All 4 tests passed.
</samp></pre></figure>

      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#for">for</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Slices">切片</a></li>
</ul>


      <h3 id="Multidimensional-Arrays"><a href="https://ziglang.org/documentation/0.15.2/#toc-Multidimensional-Arrays">多维数组</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Multidimensional-Arrays">§</a></h3>

      <p>
      多维数组可以通过嵌套数组创建:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_multidimensional_arrays.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;
<span class="tok-kw">const</span> expectEqual = std.testing.expectEqual;

<span class="tok-kw">const</span> mat4x5 = [<span class="tok-number">4</span>][<span class="tok-number">5</span>]<span class="tok-type">f32</span>{
    [_]<span class="tok-type">f32</span>{ <span class="tok-number">1.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">0.0</span> },
    [_]<span class="tok-type">f32</span>{ <span class="tok-number">0.0</span>, <span class="tok-number">1.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">1.0</span>, <span class="tok-number">0.0</span> },
    [_]<span class="tok-type">f32</span>{ <span class="tok-number">0.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">1.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">0.0</span> },
    [_]<span class="tok-type">f32</span>{ <span class="tok-number">0.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">1.0</span>, <span class="tok-number">9.9</span> },
};
<span class="tok-kw">test</span> <span class="tok-str">"multidimensional arrays"</span> {
    <span class="tok-comment">// mat4x5 本身是一个数组的一维数组。</span>
    <span class="tok-kw">try</span> expectEqual(mat4x5[<span class="tok-number">1</span>], [_]<span class="tok-type">f32</span>{ <span class="tok-number">0.0</span>, <span class="tok-number">1.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">1.0</span>, <span class="tok-number">0.0</span> });

    <span class="tok-comment">// 通过索引外层数组,然后索引内层数组来访问二维数组。</span>
    <span class="tok-kw">try</span> expect(mat4x5[<span class="tok-number">3</span>][<span class="tok-number">4</span>] == <span class="tok-number">9.9</span>);

    <span class="tok-comment">// 这里我们使用 for 循环进行迭代。</span>
    <span class="tok-kw">for</span> (mat4x5, <span class="tok-number">0</span>..) |row, row_index| {
        <span class="tok-kw">for</span> (row, <span class="tok-number">0</span>..) |cell, column_index| {
            <span class="tok-kw">if</span> (row_index == column_index) {
                <span class="tok-kw">try</span> expect(cell == <span class="tok-number">1.0</span>);
            }
        }
    }

    <span class="tok-comment">// 初始化一个多维数组为零。</span>
    <span class="tok-kw">const</span> all_zero: [<span class="tok-number">4</span>][<span class="tok-number">5</span>]<span class="tok-type">f32</span> = .{.{<span class="tok-number">0</span>} ** <span class="tok-number">5</span>} ** <span class="tok-number">4</span>;
    <span class="tok-kw">try</span> expect(all_zero[<span class="tok-number">0</span>][<span class="tok-number">0</span>] == <span class="tok-number">0</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_multidimensional_arrays.zig</kbd>
1/1 test_multidimensional_arrays.test.multidimensional arrays...OK
All 1 tests passed.
</samp></pre></figure>

      

      <h3 id="Sentinel-Terminated-Arrays"><a href="https://ziglang.org/documentation/0.15.2/#toc-Sentinel-Terminated-Arrays">哨兵终止数组</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Sentinel-Terminated-Arrays">§</a></h3>

      <p>
      语法 <code>[N:x]T</code> 描述了一个具有哨兵元素的数组,该元素的值为 <code>x</code>,位于对应于长度 <code>N</code> 的索引处。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_null_terminated_array.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"0-terminated sentinel array"</span> {
    <span class="tok-kw">const</span> array = [_:<span class="tok-number">0</span>]<span class="tok-type">u8</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };

    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(array) == [<span class="tok-number">4</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> expect(array.len == <span class="tok-number">4</span>);
    <span class="tok-kw">try</span> expect(array[<span class="tok-number">4</span>] == <span class="tok-number">0</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"extra 0s in 0-terminated sentinel array"</span> {
    <span class="tok-comment">// 哨兵值可能会提前出现,但不会影响编译时的 'len'。</span>
    <span class="tok-kw">const</span> array = [_:<span class="tok-number">0</span>]<span class="tok-type">u8</span>{ <span class="tok-number">1</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">4</span> };

    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(array) == [<span class="tok-number">4</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> expect(array.len == <span class="tok-number">4</span>);
    <span class="tok-kw">try</span> expect(array[<span class="tok-number">4</span>] == <span class="tok-number">0</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_null_terminated_array.zig</kbd>
1/2 test_null_terminated_array.test.0-terminated sentinel array...OK
2/2 test_null_terminated_array.test.extra 0s in 0-terminated sentinel array...OK
All 2 tests passed.
</samp></pre></figure>

      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Sentinel-Terminated-Pointers">哨兵终止指针</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Sentinel-Terminated-Slices">哨兵终止切片</a></li>
</ul>

      

      <h3 id="Destructuring-Arrays"><a href="https://ziglang.org/documentation/0.15.2/#toc-Destructuring-Arrays">解构数组</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Destructuring-Arrays">§</a></h3>

      <p>
        数组可以被解构:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">destructuring_arrays.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;

<span class="tok-kw">fn</span> <span class="tok-fn">swizzleRgbaToBgra</span>(rgba: [<span class="tok-number">4</span>]<span class="tok-type">u8</span>) [<span class="tok-number">4</span>]<span class="tok-type">u8</span> {
    <span class="tok-comment">// 通过解构实现可读的交换</span>
    <span class="tok-kw">const</span> r, <span class="tok-kw">const</span> g, <span class="tok-kw">const</span> b, <span class="tok-kw">const</span> a = rgba;
    <span class="tok-kw">return</span> .{ b, g, r, a };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> pos = [_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span> };
    <span class="tok-kw">const</span> x, <span class="tok-kw">const</span> y = pos;
    print(<span class="tok-str">"x = {}, y = {}\n"</span>, .{x, y});

    <span class="tok-kw">const</span> orange: [<span class="tok-number">4</span>]<span class="tok-type">u8</span> = .{ <span class="tok-number">255</span>, <span class="tok-number">165</span>, <span class="tok-number">0</span>, <span class="tok-number">255</span> };
    print(<span class="tok-str">"{any}\n"</span>, .{swizzleRgbaToBgra(orange)});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe destructuring_arrays.zig</kbd>
$ <kbd>./destructuring_arrays</kbd>
x = 1, y = 2
{ 0, 165, 255, 255 }
</samp></pre></figure>

      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Destructuring">解构</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Destructuring-Tuples">解构元组</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Destructuring-Vectors">解构向量</a></li>
</ul>

      
      

      <h2 id="Vectors"><a href="https://ziglang.org/documentation/0.15.2/#toc-Vectors">向量</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Vectors">§</a></h2>

      <p>
      向量是一组布尔值、<a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a>、<a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a>或<a href="https://ziglang.org/documentation/0.15.2/#Pointers">指针</a>,如果可能的话,使用 SIMD 指令并行操作。
      向量类型使用内置函数 <a href="https://ziglang.org/documentation/0.15.2/#Vector">@Vector</a> 创建。
      </p>
      <p>
      向量通常支持与其底层基类型相同的内置运算符。
      唯一的例外是布尔向量上的关键字 `and` 和 `or`,因为这些运算符会影响控制流,而这对于向量是不允许的。
      所有其他操作都是按元素执行的,并返回与输入向量相同长度的向量。这包括:
      </p>
      <ul>
          <li>算术运算 (<code>+</code>、<code>-</code>、<code>/</code>、<code>*</code>、
                         <code><span class="tok-builtin">@divFloor</span></code>、<code><span class="tok-builtin">@sqrt</span></code>、<code><span class="tok-builtin">@ceil</span></code>、
                         <code><span class="tok-builtin">@log</span></code> 等)</li>
          <li>位运算 (<code>&gt;&gt;</code>、<code>&lt;&lt;</code>、<code>&amp;</code>、
                                 <code>|</code>、<code>~</code> 等)</li>
          <li>比较运算符 (<code>&lt;</code>、<code>&gt;</code>、<code>==</code> 等)</li>
          <li>布尔取反 (<code>!</code>)</li>
      </ul>
      <p>
      禁止在标量(单个数字)和向量的混合体上使用数学运算符。Zig 提供了 <a href="https://ziglang.org/documentation/0.15.2/#splat">@splat</a> 内置函数来轻松地将标量转换为向量,并且它支持 <a href="https://ziglang.org/documentation/0.15.2/#reduce">@reduce</a> 和数组索引语法将向量转换为标量。向量还支持与编译时已知长度的固定长度数组之间的赋值。
      </p>
      <p>
      为了在向量内部和向量之间重新排列元素,Zig 提供了 <a href="https://ziglang.org/documentation/0.15.2/#shuffle">@shuffle</a> 和 <a href="https://ziglang.org/documentation/0.15.2/#select">@select</a> 函数。
      </p>
      <p>
      短于目标机器原生 SIMD 大小的向量操作通常会编译成单个 SIMD 指令,而长于目标机器原生 SIMD 大小的向量将编译成多个 SIMD 指令。如果给定操作在目标架构上没有 SIMD 支持,编译器将默认一次操作一个向量元素。Zig 支持任何编译时已知的向量长度,最高可达 2^32-1,尽管小的 2 的幂(2-64)是最典型的。注意,过长的向量长度(例如 2^20)可能会导致当前版本的 Zig 编译器崩溃。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_vector.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expectEqual = std.testing.expectEqual;

<span class="tok-kw">test</span> <span class="tok-str">"Basic vector usage"</span> {
    <span class="tok-comment">// 向量具有编译时已知的长度和基类型。</span>
    <span class="tok-kw">const</span> a = <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">i32</span>){ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };
    <span class="tok-kw">const</span> b = <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">i32</span>){ <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span> };

    <span class="tok-comment">// 数学运算按元素进行。</span>
    <span class="tok-kw">const</span> c = a + b;

    <span class="tok-comment">// 可以使用数组索引语法访问单个向量元素。</span>
    <span class="tok-kw">try</span> expectEqual(<span class="tok-number">6</span>, c[<span class="tok-number">0</span>]);
    <span class="tok-kw">try</span> expectEqual(<span class="tok-number">8</span>, c[<span class="tok-number">1</span>]);
    <span class="tok-kw">try</span> expectEqual(<span class="tok-number">10</span>, c[<span class="tok-number">2</span>]);
    <span class="tok-kw">try</span> expectEqual(<span class="tok-number">12</span>, c[<span class="tok-number">3</span>]);
}

<span class="tok-kw">test</span> <span class="tok-str">"Conversion between vectors, arrays, and slices"</span> {
    <span class="tok-comment">// 向量和固定长度数组可以自动相互赋值</span>
    <span class="tok-kw">const</span> arr1: [<span class="tok-number">4</span>]<span class="tok-type">f32</span> = [_]<span class="tok-type">f32</span>{ <span class="tok-number">1.1</span>, <span class="tok-number">3.2</span>, <span class="tok-number">4.5</span>, <span class="tok-number">5.6</span> };
    <span class="tok-kw">const</span> vec: <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">f32</span>) = arr1;
    <span class="tok-kw">const</span> arr2: [<span class="tok-number">4</span>]<span class="tok-type">f32</span> = vec;
    <span class="tok-kw">try</span> expectEqual(arr1, arr2);

    <span class="tok-comment">// 你也可以使用 .* 从编译时已知长度的切片赋值到向量</span>
    <span class="tok-kw">const</span> vec2: <span class="tok-builtin">@Vector</span>(<span class="tok-number">2</span>, <span class="tok-type">f32</span>) = arr1[<span class="tok-number">1</span>..<span class="tok-number">3</span>].*;

    <span class="tok-kw">const</span> slice: []<span class="tok-kw">const</span> <span class="tok-type">f32</span> = &amp;arr1;
    <span class="tok-kw">var</span> offset: <span class="tok-type">u32</span> = <span class="tok-number">1</span>; <span class="tok-comment">// var 使其为运行时已知</span>
    _ = &amp;offset; <span class="tok-comment">// 抑制 'var is never mutated' 错误</span>
    <span class="tok-comment">// 要从运行时已知的偏移量提取编译时已知的长度,</span>
    <span class="tok-comment">// 首先从起始偏移量提取一个新切片,然后提取一个</span>
    <span class="tok-comment">// 编译时已知长度的数组</span>
    <span class="tok-kw">const</span> vec3: <span class="tok-builtin">@Vector</span>(<span class="tok-number">2</span>, <span class="tok-type">f32</span>) = slice[offset..][<span class="tok-number">0</span>..<span class="tok-number">2</span>].*;
    <span class="tok-kw">try</span> expectEqual(slice[offset], vec2[<span class="tok-number">0</span>]);
    <span class="tok-kw">try</span> expectEqual(slice[offset + <span class="tok-number">1</span>], vec2[<span class="tok-number">1</span>]);
    <span class="tok-kw">try</span> expectEqual(vec2, vec3);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_vector.zig</kbd>
1/2 test_vector.test.Basic vector usage...OK
2/2 test_vector.test.Conversion between vectors, arrays, and slices...OK
All 2 tests passed.
</samp></pre></figure>

      <p>
      TODO 讨论 C ABI 互操作<br>
      TODO 考虑建议使用 std.MultiArrayList
      </p>
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#splat">@splat</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#shuffle">@shuffle</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#select">@select</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#reduce">@reduce</a></li>
</ul>


      <h3 id="Destructuring-Vectors"><a href="https://ziglang.org/documentation/0.15.2/#toc-Destructuring-Vectors">解构向量</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Destructuring-Vectors">§</a></h3>

      <p>
        向量可以被解构:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">destructuring_vectors.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;

<span class="tok-comment">// 模拟 punpckldq</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unpack</span>(x: <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">f32</span>), y: <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">f32</span>)) <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">f32</span>) {
    <span class="tok-kw">const</span> a, <span class="tok-kw">const</span> c, _, _ = x;
    <span class="tok-kw">const</span> b, <span class="tok-kw">const</span> d, _, _ = y;
    <span class="tok-kw">return</span> .{ a, b, c, d };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> x: <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">f32</span>) = .{ <span class="tok-number">1.0</span>, <span class="tok-number">2.0</span>, <span class="tok-number">3.0</span>, <span class="tok-number">4.0</span> };
    <span class="tok-kw">const</span> y: <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">f32</span>) = .{ <span class="tok-number">5.0</span>, <span class="tok-number">6.0</span>, <span class="tok-number">7.0</span>, <span class="tok-number">8.0</span> };
    print(<span class="tok-str">"{}"</span>, .{unpack(x, y)});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe destructuring_vectors.zig</kbd>
$ <kbd>./destructuring_vectors</kbd>
{ 1, 5, 2, 6 }
</samp></pre></figure>
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Destructuring">解构</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Destructuring-Tuples">解构元组</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Destructuring-Arrays">解构数组</a></li>
</ul>

      

      

      <h2 id="Pointers"><a href="https://ziglang.org/documentation/0.15.2/#toc-Pointers">指针</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Pointers">§</a></h2>

      <p>
      Zig 有两种指针:单项指针和多项指针。
      </p>
      <ul>
          <li><code>*T</code> - 指向恰好一个项的单项指针。
            <ul>
              <li>支持解引用语法:<code>ptr.*</code></li>
              <li>支持切片语法:<code>ptr[<span class="tok-number">0</span>..<span class="tok-number">1</span>]</code></li>
              <li>支持指针减法:<code>ptr - ptr</code></li>
            </ul>
          </li>
          <li><code>[*]T</code> - 指向未知数量项的多项指针。
            <ul>
              <li>支持索引语法:<code>ptr[i]</code></li>
              <li>支持切片语法:<code>ptr[start..end]</code> 和 <code>ptr[start..]</code></li>
              <li>支持指针-整数算术:<code>ptr + int</code>、<code>ptr - int</code></li>
              <li>支持指针减法:<code>ptr - ptr</code></li>
            </ul>
            <code>T</code> 必须具有已知大小,这意味着它不能是 <code><span class="tok-type">anyopaque</span></code> 或任何其他<a href="https://ziglang.org/documentation/0.15.2/#opaque">不透明类型</a>。
          </li>
      </ul>
      <p>这些类型与<a href="https://ziglang.org/documentation/0.15.2/#Arrays">数组</a>和<a href="https://ziglang.org/documentation/0.15.2/#Slices">切片</a>密切相关:</p>
        <ul>
            <li><code>*[N]T</code> - 指向 N 个项的指针,与指向数组的单项指针相同。
            <ul>
                <li>支持索引语法:<code>array_ptr[i]</code></li>
                <li>支持切片语法:<code>array_ptr[start..end]</code></li>
                <li>支持 len 属性:<code>array_ptr.len</code></li>
                <li>支持指针减法:<code>array_ptr - array_ptr</code></li>
            </ul>
            </li>
        </ul>
        <ul>
            <li><code>[]T</code> - 是一个切片(一个胖指针,包含一个类型为 <code>[*]T</code> 的指针和一个长度)。
            <ul>
                <li>支持索引语法:<code>slice[i]</code></li>
                <li>支持切片语法:<code>slice[start..end]</code></li>
                <li>支持 len 属性:<code>slice.len</code></li>
            </ul>
            </li>
        </ul>
        <p>使用 <code>&amp;x</code> 获取单项指针:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_single_item_pointer.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"address of syntax"</span> {
    <span class="tok-comment">// 获取变量的地址:</span>
    <span class="tok-kw">const</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    <span class="tok-kw">const</span> x_ptr = &amp;x;

    <span class="tok-comment">// 解引用指针:</span>
    <span class="tok-kw">try</span> expect(x_ptr.* == <span class="tok-number">1234</span>);

    <span class="tok-comment">// 当获取 const 变量的地址时,会得到一个 const 单项指针。</span>
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(x_ptr) == *<span class="tok-kw">const</span> <span class="tok-type">i32</span>);

    <span class="tok-comment">// 如果想修改值,需要获取可变变量的地址:</span>
    <span class="tok-kw">var</span> y: <span class="tok-type">i32</span> = <span class="tok-number">5678</span>;
    <span class="tok-kw">const</span> y_ptr = &amp;y;
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(y_ptr) == *<span class="tok-type">i32</span>);
    y_ptr.* += <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> expect(y_ptr.* == <span class="tok-number">5679</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"pointer array access"</span> {
    <span class="tok-comment">// 获取单个元素的地址会得到一个单项指针。</span>
    <span class="tok-comment">// 这种指针不支持指针算术。</span>
    <span class="tok-kw">var</span> array = [_]<span class="tok-type">u8</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span>, <span class="tok-number">9</span>, <span class="tok-number">10</span> };
    <span class="tok-kw">const</span> ptr = &amp;array[<span class="tok-number">2</span>];
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(ptr) == *<span class="tok-type">u8</span>);

    <span class="tok-kw">try</span> expect(array[<span class="tok-number">2</span>] == <span class="tok-number">3</span>);
    ptr.* += <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> expect(array[<span class="tok-number">2</span>] == <span class="tok-number">4</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"slice syntax"</span> {
    <span class="tok-comment">// 获取变量的指针:</span>
    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    <span class="tok-kw">const</span> x_ptr = &amp;x;

    <span class="tok-comment">// 使用切片语法转换为数组指针:</span>
    <span class="tok-kw">const</span> x_array_ptr = x_ptr[<span class="tok-number">0</span>..<span class="tok-number">1</span>];
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(x_array_ptr) == *[<span class="tok-number">1</span>]<span class="tok-type">i32</span>);

    <span class="tok-comment">// 强制转换为多项指针:</span>
    <span class="tok-kw">const</span> x_many_ptr: [*]<span class="tok-type">i32</span> = x_array_ptr;
    <span class="tok-kw">try</span> expect(x_many_ptr[<span class="tok-number">0</span>] == <span class="tok-number">1234</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_single_item_pointer.zig</kbd>
1/3 test_single_item_pointer.test.address of syntax...OK
2/3 test_single_item_pointer.test.pointer array access...OK
3/3 test_single_item_pointer.test.slice syntax...OK
All 3 tests passed.
</samp></pre></figure>

      <p>
       Zig 支持指针算术。最好将指针赋值给 <code>[*]T</code> 并递增该变量。例如,直接递增来自切片的指针会破坏它。
      </p>
<!-- ====== END CHUNK 3: new_03.html ====== -->

<!-- ====== BEGIN CHUNK 4: new_04.html ====== -->
<figure><figcaption class="zig-cap"><cite class="file">test_pointer_arithmetic.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"pointer arithmetic with many-item pointer"</span> {
    <span class="tok-kw">const</span> array = [_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };
    <span class="tok-kw">var</span> ptr: [*]<span class="tok-kw">const</span> <span class="tok-type">i32</span> = &amp;array;

    <span class="tok-kw">try</span> expect(ptr[<span class="tok-number">0</span>] == <span class="tok-number">1</span>);
    ptr += <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> expect(ptr[<span class="tok-number">0</span>] == <span class="tok-number">2</span>);

    <span class="tok-comment">// 对多项指针进行无结束位置的切片等同于</span>
    <span class="tok-comment">// 指针算术运算：`ptr[start..] == ptr + start`</span>
    <span class="tok-kw">try</span> expect(ptr[<span class="tok-number">1</span>..] == ptr + <span class="tok-number">1</span>);

    <span class="tok-comment">// 支持除切片外的任意两个指针之间基于元素大小的减法</span>
    <span class="tok-kw">try</span> expect(&amp;ptr[<span class="tok-number">1</span>] - &amp;ptr[<span class="tok-number">0</span>] == <span class="tok-number">1</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"pointer arithmetic with slices"</span> {
    <span class="tok-kw">var</span> array = [_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };
    <span class="tok-kw">var</span> length: <span class="tok-type">usize</span> = <span class="tok-number">0</span>; <span class="tok-comment">// 使用 var 使其在运行时已知</span>
    _ = &amp;length; <span class="tok-comment">// 抑制 'var is never mutated' 错误</span>
    <span class="tok-kw">var</span> slice = array[length..array.len];

    <span class="tok-kw">try</span> expect(slice[<span class="tok-number">0</span>] == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> expect(slice.len == <span class="tok-number">4</span>);

    slice.ptr += <span class="tok-number">1</span>;
    <span class="tok-comment">// 现在切片处于不良状态，因为 len 没有更新</span>

    <span class="tok-kw">try</span> expect(slice[<span class="tok-number">0</span>] == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> expect(slice.len == <span class="tok-number">4</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_pointer_arithmetic.zig</kbd>
1/2 test_pointer_arithmetic.test.pointer arithmetic with many-item pointer...OK
2/2 test_pointer_arithmetic.test.pointer arithmetic with slices...OK
All 2 tests passed.
</samp></pre></figure>

      <p>
        在 Zig 中，我们通常更喜欢使用<a href="https://ziglang.org/documentation/0.15.2/#Slices">切片</a>而不是<a href="https://ziglang.org/documentation/0.15.2/#Sentinel-Terminated-Pointers">哨兵终止指针</a>。
        您可以使用切片语法将数组或指针转换为切片。
      </p>
      <p>
        切片具有边界检查，因此可以防止此类非法行为。这是我们更喜欢切片而不是指针的原因之一。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_slice_bounds.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"pointer slicing"</span> {
    <span class="tok-kw">var</span> array = [_]<span class="tok-type">u8</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span>, <span class="tok-number">9</span>, <span class="tok-number">10</span> };
    <span class="tok-kw">var</span> start: <span class="tok-type">usize</span> = <span class="tok-number">2</span>; <span class="tok-comment">// 使用 var 使其在运行时已知</span>
    _ = &amp;start; <span class="tok-comment">// 抑制 'var is never mutated' 错误</span>
    <span class="tok-kw">const</span> slice = array[start..<span class="tok-number">4</span>];
    <span class="tok-kw">try</span> expect(slice.len == <span class="tok-number">2</span>);

    <span class="tok-kw">try</span> expect(array[<span class="tok-number">3</span>] == <span class="tok-number">4</span>);
    slice[<span class="tok-number">1</span>] += <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> expect(array[<span class="tok-number">3</span>] == <span class="tok-number">5</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_slice_bounds.zig</kbd>
1/1 test_slice_bounds.test.pointer slicing...OK
All 1 tests passed.
</samp></pre></figure>

      <p>指针在编译期也可以工作，只要代码不依赖于未定义的内存布局：</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_pointers.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"comptime pointers"</span> {
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
        <span class="tok-kw">const</span> ptr = &amp;x;
        ptr.* += <span class="tok-number">1</span>;
        x += <span class="tok-number">1</span>;
        <span class="tok-kw">try</span> expect(ptr.* == <span class="tok-number">3</span>);
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_pointers.zig</kbd>
1/1 test_comptime_pointers.test.comptime pointers...OK
All 1 tests passed.
</samp></pre></figure>

      <p>要将整数地址转换为指针，请使用 <code><span class="tok-builtin">@ptrFromInt</span></code>。
      要将指针转换为整数，请使用 <code><span class="tok-builtin">@intFromPtr</span></code>：</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_integer_pointer_conversion.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"@intFromPtr and @ptrFromInt"</span> {
    <span class="tok-kw">const</span> ptr: *<span class="tok-type">i32</span> = <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-number">0xdeadbee0</span>);
    <span class="tok-kw">const</span> addr = <span class="tok-builtin">@intFromPtr</span>(ptr);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(addr) == <span class="tok-type">usize</span>);
    <span class="tok-kw">try</span> expect(addr == <span class="tok-number">0xdeadbee0</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_integer_pointer_conversion.zig</kbd>
1/1 test_integer_pointer_conversion.test.@intFromPtr and @ptrFromInt...OK
All 1 tests passed.
</samp></pre></figure>

      <p>Zig 能够在编译期代码中保留内存地址，只要指针从未被解引用：</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_pointer_conversion.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"comptime @ptrFromInt"</span> {
    <span class="tok-kw">comptime</span> {
        <span class="tok-comment">// Zig 能够在编译期做到这一点，只要</span>
        <span class="tok-comment">// ptr 从未被解引用。</span>
        <span class="tok-kw">const</span> ptr: *<span class="tok-type">i32</span> = <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-number">0xdeadbee0</span>);
        <span class="tok-kw">const</span> addr = <span class="tok-builtin">@intFromPtr</span>(ptr);
        <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(addr) == <span class="tok-type">usize</span>);
        <span class="tok-kw">try</span> expect(addr == <span class="tok-number">0xdeadbee0</span>);
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_pointer_conversion.zig</kbd>
1/1 test_comptime_pointer_conversion.test.comptime @ptrFromInt...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      <a href="https://ziglang.org/documentation/0.15.2/#ptrCast">@ptrCast</a> 将指针的元素类型转换为另一种类型。这会创建一个新指针，根据通过它进行的加载和存储，可能会导致无法检测的非法行为。通常，如果可能的话，其他类型的类型转换比 <code><span class="tok-builtin">@ptrCast</span></code> 更可取。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_pointer_casting.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"pointer casting"</span> {
    <span class="tok-kw">const</span> bytes <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<span class="tok-type">u32</span>)) = [_]<span class="tok-type">u8</span>{ <span class="tok-number">0x12</span>, <span class="tok-number">0x12</span>, <span class="tok-number">0x12</span>, <span class="tok-number">0x12</span> };
    <span class="tok-kw">const</span> u32_ptr: *<span class="tok-kw">const</span> <span class="tok-type">u32</span> = <span class="tok-builtin">@ptrCast</span>(&amp;bytes);
    <span class="tok-kw">try</span> expect(u32_ptr.* == <span class="tok-number">0x12121212</span>);

    <span class="tok-comment">// 即使这个例子也是人为的 - 有比指针转换更好的方法来完成上述操作。</span>
    <span class="tok-comment">// 例如，使用切片收窄转换：</span>
    <span class="tok-kw">const</span> u32_value = std.mem.bytesAsSlice(<span class="tok-type">u32</span>, bytes[<span class="tok-number">0</span>..])[<span class="tok-number">0</span>];
    <span class="tok-kw">try</span> expect(u32_value == <span class="tok-number">0x12121212</span>);

    <span class="tok-comment">// 还有另一种方法，最直接的方法：</span>
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@bitCast</span>(bytes)) == <span class="tok-number">0x12121212</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"pointer child type"</span> {
    <span class="tok-comment">// 指针类型有一个 `child` 字段，它告诉你它们指向的类型。</span>
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@typeInfo</span>(*<span class="tok-type">u32</span>).pointer.child == <span class="tok-type">u32</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_pointer_casting.zig</kbd>
1/2 test_pointer_casting.test.pointer casting...OK
2/2 test_pointer_casting.test.pointer child type...OK
All 2 tests passed.
</samp></pre></figure>

      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Optional-Pointers">可选指针</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#ptrFromInt">@ptrFromInt</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#intFromPtr">@intFromPtr</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#C-Pointers">C 指针</a></li>
</ul>

      <h3 id="volatile"><a href="https://ziglang.org/documentation/0.15.2/#toc-volatile">volatile</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#volatile">§</a></h3>

      <p>加载和存储被假定为没有副作用。如果给定的加载或存储应该有副作用，例如内存映射输入/输出（MMIO），请使用 <code><span class="tok-kw">volatile</span></code>。
      在以下代码中，对 <code>mmio_ptr</code> 的加载和存储保证全部发生且与源代码中的顺序相同：</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_volatile.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"volatile"</span> {
    <span class="tok-kw">const</span> mmio_ptr: *<span class="tok-kw">volatile</span> <span class="tok-type">u8</span> = <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-number">0x12345678</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(mmio_ptr) == *<span class="tok-kw">volatile</span> <span class="tok-type">u8</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_volatile.zig</kbd>
1/1 test_volatile.test.volatile...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      请注意，<code><span class="tok-kw">volatile</span></code> 与并发和<a href="https://ziglang.org/documentation/0.15.2/#Atomics">原子操作</a>无关。
      如果您看到代码将 <code><span class="tok-kw">volatile</span></code> 用于内存映射输入/输出以外的用途，它可能是一个错误。
      </p>
      

      <h3 id="Alignment"><a href="https://ziglang.org/documentation/0.15.2/#toc-Alignment">对齐</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Alignment">§</a></h3>

      <p>
      每个类型都有一个<strong>对齐</strong> - 一个字节数，使得当该类型的值从内存加载或存储到内存时，内存地址必须能被这个数整除。您可以使用 <a href="https://ziglang.org/documentation/0.15.2/#alignOf">@alignOf</a> 找出任何类型的这个值。
      </p>
      <p>
      对齐取决于 CPU 架构，但始终是 2 的幂，且小于 <code><span class="tok-number">1</span> &lt;&lt; <span class="tok-number">29</span></code>。
      </p>
      <p>
      在 Zig 中，指针类型有一个对齐值。如果该值等于底层类型的对齐，则可以从类型中省略：
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_variable_alignment.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">"builtin"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"variable alignment"</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    <span class="tok-kw">const</span> align_of_i32 = <span class="tok-builtin">@alignOf</span>(<span class="tok-builtin">@TypeOf</span>(x));
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(&amp;x) == *<span class="tok-type">i32</span>);
    <span class="tok-kw">try</span> expect(*<span class="tok-type">i32</span> == *<span class="tok-kw">align</span>(align_of_i32) <span class="tok-type">i32</span>);
    <span class="tok-kw">if</span> (builtin.target.cpu.arch == .x86_64) {
        <span class="tok-kw">try</span> expect(<span class="tok-builtin">@typeInfo</span>(*<span class="tok-type">i32</span>).pointer.alignment == <span class="tok-number">4</span>);
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_variable_alignment.zig</kbd>
1/1 test_variable_alignment.test.variable alignment...OK
All 1 tests passed.
</samp></pre></figure>

      <p>与 <code>*<span class="tok-type">i32</span></code> 可以<a href="https://ziglang.org/documentation/0.15.2/#Type-Coercion">强制转换</a>为 <code>*<span class="tok-kw">const</span> <span class="tok-type">i32</span></code> 的方式相同，具有更大对齐的指针可以隐式转换为具有更小对齐的指针，但反之则不行。
      </p>
      <p>
      您可以在变量和函数上指定对齐。如果这样做，那么指向它们的指针将获得指定的对齐：
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_variable_func_alignment.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">var</span> foo: <span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-number">4</span>) = <span class="tok-number">100</span>;

<span class="tok-kw">test</span> <span class="tok-str">"global variable alignment"</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(&amp;foo)).pointer.alignment == <span class="tok-number">4</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(&amp;foo) == *<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">u8</span>);
    <span class="tok-kw">const</span> as_pointer_to_array: *<span class="tok-kw">align</span>(<span class="tok-number">4</span>) [<span class="tok-number">1</span>]<span class="tok-type">u8</span> = &amp;foo;
    <span class="tok-kw">const</span> as_slice: []<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">u8</span> = as_pointer_to_array;
    <span class="tok-kw">const</span> as_unaligned_slice: []<span class="tok-type">u8</span> = as_slice;
    <span class="tok-kw">try</span> expect(as_unaligned_slice[<span class="tok-number">0</span>] == <span class="tok-number">100</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">derp</span>() <span class="tok-kw">align</span>(<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) * <span class="tok-number">2</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> <span class="tok-number">1234</span>;
}
<span class="tok-kw">fn</span> <span class="tok-fn">noop1</span>() <span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-type">void</span> {}
<span class="tok-kw">fn</span> <span class="tok-fn">noop4</span>() <span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">void</span> {}

<span class="tok-kw">test</span> <span class="tok-str">"function alignment"</span> {
    <span class="tok-kw">try</span> expect(derp() == <span class="tok-number">1234</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(derp) == <span class="tok-kw">fn</span> () <span class="tok-type">i32</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(&amp;derp) == *<span class="tok-kw">align</span>(<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) * <span class="tok-number">2</span>) <span class="tok-kw">const</span> <span class="tok-kw">fn</span> () <span class="tok-type">i32</span>);

    noop1();
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(noop1) == <span class="tok-kw">fn</span> () <span class="tok-type">void</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(&amp;noop1) == *<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> <span class="tok-kw">fn</span> () <span class="tok-type">void</span>);

    noop4();
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(noop4) == <span class="tok-kw">fn</span> () <span class="tok-type">void</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(&amp;noop4) == *<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-kw">const</span> <span class="tok-kw">fn</span> () <span class="tok-type">void</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_variable_func_alignment.zig</kbd>
1/2 test_variable_func_alignment.test.global variable alignment...OK
2/2 test_variable_func_alignment.test.function alignment...OK
All 2 tests passed.
</samp></pre></figure>

      <p>
      如果您有一个对齐较小的指针或切片，但您知道它实际上具有更大的对齐，请使用 <a href="https://ziglang.org/documentation/0.15.2/#alignCast">@alignCast</a> 将指针更改为更对齐的指针。这在运行时是无操作的，但会插入<a href="https://ziglang.org/documentation/0.15.2/#Incorrect-Pointer-Alignment">安全检查</a>：
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_incorrect_pointer_alignment.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">test</span> <span class="tok-str">"pointer alignment safety"</span> {
    <span class="tok-kw">var</span> array <span class="tok-kw">align</span>(<span class="tok-number">4</span>) = [_]<span class="tok-type">u32</span>{ <span class="tok-number">0x11111111</span>, <span class="tok-number">0x11111111</span> };
    <span class="tok-kw">const</span> bytes = std.mem.sliceAsBytes(array[<span class="tok-number">0</span>..]);
    <span class="tok-kw">try</span> std.testing.expect(foo(bytes) == <span class="tok-number">0x11111111</span>);
}
<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(bytes: []<span class="tok-type">u8</span>) <span class="tok-type">u32</span> {
    <span class="tok-kw">const</span> slice4 = bytes[<span class="tok-number">1</span>..<span class="tok-number">5</span>];
    <span class="tok-kw">const</span> int_slice = std.mem.bytesAsSlice(<span class="tok-type">u32</span>, <span class="tok-builtin">@as</span>([]<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">u8</span>, <span class="tok-builtin">@alignCast</span>(slice4)));
    <span class="tok-kw">return</span> int_slice[<span class="tok-number">0</span>];
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_incorrect_pointer_alignment.zig</kbd>
1/1 test_incorrect_pointer_alignment.test.pointer alignment safety...thread 2895819 panic: incorrect alignment
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_incorrect_pointer_alignment.zig:10:68</span>: <span class="sgr-2m">0x102c2a8 in foo (test_incorrect_pointer_alignment.zig)</span>
    const int_slice = std.mem.bytesAsSlice(u32, @as([]align(4) u8, @alignCast(slice4)));
                                                                   <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_incorrect_pointer_alignment.zig:6:31</span>: <span class="sgr-2m">0x102c0d2 in test.pointer alignment safety (test_incorrect_pointer_alignment.zig)</span>
    try std.testing.expect(foo(bytes) == 0x11111111);
                              <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:218:25</span>: <span class="sgr-2m">0x115cf30 in mainTerminal (test_runner.zig)</span>
        if (test_fn.func()) |_| {
                        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:66:28</span>: <span class="sgr-2m">0x1156151 in main (test_runner.zig)</span>
        return mainTerminal();
                           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x114feed in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x114f781 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
error: the following test command crashed:
/home/andy/dev/zig/.zig-cache/o/9cb7896b3cdf812f518129da5e21dc23/test --seed=0x441e5edd
</samp></pre></figure>

      

      <h3 id="allowzero"><a href="https://ziglang.org/documentation/0.15.2/#toc-allowzero">allowzero</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#allowzero">§</a></h3>

      <p>
      此指针属性允许指针具有地址零。这仅在独立操作系统目标上需要，其中地址零是可映射的。如果您想表示空指针，请改用<a href="https://ziglang.org/documentation/0.15.2/#Optional-Pointers">可选指针</a>。带有 <code><span class="tok-kw">allowzero</span></code> 的<a href="https://ziglang.org/documentation/0.15.2/#Optional-Pointers">可选指针</a>与指针的大小不同。在此代码示例中，如果指针没有 <code><span class="tok-kw">allowzero</span></code> 属性，这将是<a href="https://ziglang.org/documentation/0.15.2/#Pointer-Cast-Invalid-Null">指针转换无效空值</a> panic：
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_allowzero.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"allowzero"</span> {
    <span class="tok-kw">var</span> zero: <span class="tok-type">usize</span> = <span class="tok-number">0</span>; <span class="tok-comment">// 使用 var 使其在运行时已知</span>
    _ = &amp;zero; <span class="tok-comment">// 抑制 'var is never mutated' 错误</span>
    <span class="tok-kw">const</span> ptr: *<span class="tok-kw">allowzero</span> <span class="tok-type">i32</span> = <span class="tok-builtin">@ptrFromInt</span>(zero);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromPtr</span>(ptr) == <span class="tok-number">0</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_allowzero.zig</kbd>
1/1 test_allowzero.test.allowzero...OK
All 1 tests passed.
</samp></pre></figure>

      

      <h3 id="Sentinel-Terminated-Pointers"><a href="https://ziglang.org/documentation/0.15.2/#toc-Sentinel-Terminated-Pointers">哨兵终止指针</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Sentinel-Terminated-Pointers">§</a></h3>

      <p>
      语法 <code>[*:x]T</code> 描述一个指针，其长度由哨兵值确定。这提供了防止缓冲区溢出和过度读取的保护。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">sentinel-terminated_pointer.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-comment">// 这也可以作为 `std.c.printf` 使用。</span>
<span class="tok-kw">pub</span> <span class="tok-kw">extern</span> <span class="tok-str">"c"</span> <span class="tok-kw">fn</span> <span class="tok-fn">printf</span>(format: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ...) <span class="tok-type">c_int</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {
    _ = printf(<span class="tok-str">"Hello, world!\n"</span>); <span class="tok-comment">// OK</span>

    <span class="tok-kw">const</span> msg = <span class="tok-str">"Hello, world!\n"</span>;
    <span class="tok-kw">const</span> non_null_terminated_msg: [msg.len]<span class="tok-type">u8</span> = msg.*;
    _ = printf(&amp;non_null_terminated_msg);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe sentinel-terminated_pointer.zig -lc</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/sentinel-terminated_pointer.zig:11:16: </span><span class="sgr-31m">error: </span><span class="sgr-1m">expected type '[*:0]const u8', found '*const [14]u8'
</span>    _ = printf(&amp;non_null_terminated_msg);
               <span class="sgr-32m">^~~~~~~~~~~~~~~~~~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/sentinel-terminated_pointer.zig:11:16: </span><span class="sgr-36m">note: </span><span class="sgr-1m">destination pointer requires '0' sentinel
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/sentinel-terminated_pointer.zig:4:34: </span><span class="sgr-36m">note: </span><span class="sgr-1m">parameter type declared here
</span>pub extern "c" fn printf(format: [*:0]const u8, ...) c_int;
                                 <span class="sgr-32m">^~~~~~~~~~~~~
</span><span class="sgr-2m">referenced by:
    callMain [inlined]: /home/andy/dev/zig/lib/std/start.zig:627:37
    callMainWithArgs [inlined]: /home/andy/dev/zig/lib/std/start.zig:587:20
    main: /home/andy/dev/zig/lib/std/start.zig:602:28
    1 reference(s) hidden; use '-freference-trace=4' to see all references
</span>
</samp></pre></figure>

      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Sentinel-Terminated-Slices">哨兵终止切片</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Sentinel-Terminated-Arrays">哨兵终止数组</a></li>
</ul>

      
      

      <h2 id="Slices"><a href="https://ziglang.org/documentation/0.15.2/#toc-Slices">切片</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Slices">§</a></h2>

      <p>
      切片是一个指针和一个长度。数组和切片之间的区别在于，数组的长度是类型的一部分，在编译期已知，而切片的长度在运行时已知。两者都可以使用 <code>len</code> 字段访问。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_basic_slices.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;
<span class="tok-kw">const</span> expectEqualSlices = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expectEqualSlices;

<span class="tok-kw">test</span> <span class="tok-str">"basic slices"</span> {
    <span class="tok-kw">var</span> array = [_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };
    <span class="tok-kw">var</span> known_at_runtime_zero: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    _ = &amp;known_at_runtime_zero;
    <span class="tok-kw">const</span> slice = array[known_at_runtime_zero..array.len];

    <span class="tok-comment">// 使用结果位置的替代初始化</span>
    <span class="tok-kw">const</span> alt_slice: []<span class="tok-kw">const</span> <span class="tok-type">i32</span> = &amp;.{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };

    <span class="tok-kw">try</span> expectEqualSlices(<span class="tok-type">i32</span>, slice, alt_slice);

    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(slice) == []<span class="tok-type">i32</span>);
    <span class="tok-kw">try</span> expect(&amp;slice[<span class="tok-number">0</span>] == &amp;array[<span class="tok-number">0</span>]);
    <span class="tok-kw">try</span> expect(slice.len == array.len);

    <span class="tok-comment">// 如果使用编译期已知的起始和结束位置进行切片，结果是</span>
    <span class="tok-comment">// 指向数组的指针，而不是切片。</span>
    <span class="tok-kw">const</span> array_ptr = array[<span class="tok-number">0</span>..array.len];
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(array_ptr) == *[array.len]<span class="tok-type">i32</span>);

    <span class="tok-comment">// 您可以通过两次切片来执行按长度切片。这允许编译器</span>
    <span class="tok-comment">// 执行某些优化，例如在起始位置仅在运行时已知时识别编译期已知的长度。</span>
    <span class="tok-kw">var</span> runtime_start: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;
    _ = &amp;runtime_start;
    <span class="tok-kw">const</span> length = <span class="tok-number">2</span>;
    <span class="tok-kw">const</span> array_ptr_len = array[runtime_start..][<span class="tok-number">0</span>..length];
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(array_ptr_len) == *[length]<span class="tok-type">i32</span>);

    <span class="tok-comment">// 在切片上使用取地址运算符可以得到单项指针。</span>
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(&amp;slice[<span class="tok-number">0</span>]) == *<span class="tok-type">i32</span>);
    <span class="tok-comment">// 使用 `ptr` 字段可以得到多项指针。</span>
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(slice.ptr) == [*]<span class="tok-type">i32</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromPtr</span>(slice.ptr) == <span class="tok-builtin">@intFromPtr</span>(&amp;slice[<span class="tok-number">0</span>]));

    <span class="tok-comment">// 切片具有数组边界检查。如果您尝试访问超出边界的内容，</span>
    <span class="tok-comment">// 您将收到安全检查失败：</span>
    slice[<span class="tok-number">10</span>] += <span class="tok-number">1</span>;

    <span class="tok-comment">// 请注意，`slice.ptr` 不调用安全检查，而 `&amp;slice[0]`</span>
    <span class="tok-comment">// 断言切片的 len &gt; 0。</span>

    <span class="tok-comment">// 可以像这样创建空切片：</span>
    <span class="tok-kw">const</span> empty1 = &amp;[<span class="tok-number">0</span>]<span class="tok-type">u8</span>{};
    <span class="tok-comment">// 如果类型已知，可以使用这个简写：</span>
    <span class="tok-kw">const</span> empty2: []<span class="tok-type">u8</span> = &amp;.{};
    <span class="tok-kw">try</span> expect(empty1.len == <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> expect(empty2.len == <span class="tok-number">0</span>);

    <span class="tok-comment">// 零长度初始化始终可用于创建空切片，即使切片是可变的。</span>
    <span class="tok-comment">// 这是因为指向的数据长度为零位，所以其不可变性是无关紧要的。</span>
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_basic_slices.zig</kbd>
1/1 test_basic_slices.test.basic slices...thread 2902466 panic: index out of bounds: index 10, len 4
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_basic_slices.zig:41:10</span>: <span class="sgr-2m">0x102e3c0 in test.basic slices (test_basic_slices.zig)</span>
    slice[10] += 1;
         <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:218:25</span>: <span class="sgr-2m">0x1160b60 in mainTerminal (test_runner.zig)</span>
        if (test_fn.func()) |_| {
                        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:66:28</span>: <span class="sgr-2m">0x1159d81 in main (test_runner.zig)</span>
        return mainTerminal();
                           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x1153b1d in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x11533b1 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
error: the following test command crashed:
/home/andy/dev/zig/.zig-cache/o/0e584e3dac6333a0b2d5158992704660/test --seed=0x665d12a2
</samp></pre></figure>

      <p>这是我们更喜欢切片而不是指针的原因之一。</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_slices.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;
<span class="tok-kw">const</span> mem = std.mem;
<span class="tok-kw">const</span> fmt = std.fmt;

<span class="tok-kw">test</span> <span class="tok-str">"using slices for strings"</span> {
    <span class="tok-comment">// Zig 没有字符串的概念。字符串字面量是指向</span>
    <span class="tok-comment">// 以空值终止的 u8 数组的常量指针，按照惯例，</span>
    <span class="tok-comment">// "字符串"参数预期为 UTF-8 编码的 u8 切片。</span>
    <span class="tok-comment">// 这里我们将 *const [5:0]u8 和 *const [6:0]u8 强制转换为 []const u8</span>
    <span class="tok-kw">const</span> hello: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">"hello"</span>;
    <span class="tok-kw">const</span> world: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">"世界"</span>;

    <span class="tok-kw">var</span> all_together: [<span class="tok-number">100</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-comment">// 您可以在数组上使用至少一个运行时已知索引的切片语法</span>
    <span class="tok-comment">// 将数组转换为切片。</span>
    <span class="tok-kw">var</span> start: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    _ = &amp;start;
    <span class="tok-kw">const</span> all_together_slice = all_together[start..];
    <span class="tok-comment">// 字符串连接示例。</span>
    <span class="tok-kw">const</span> hello_world = <span class="tok-kw">try</span> fmt.bufPrint(all_together_slice, <span class="tok-str">"{s} {s}"</span>, .{ hello, world });

    <span class="tok-comment">// 通常，您可以使用 UTF-8 而不用担心某些东西是否是</span>
    <span class="tok-comment">// 字符串。如果您不需要处理单个字符，则无需</span>
    <span class="tok-comment">// 解码。</span>
    <span class="tok-kw">try</span> expect(mem.eql(<span class="tok-type">u8</span>, hello_world, <span class="tok-str">"hello 世界"</span>));
}

<span class="tok-kw">test</span> <span class="tok-str">"slice pointer"</span> {
    <span class="tok-kw">var</span> array: [<span class="tok-number">10</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> ptr = &amp;array;
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(ptr) == *[<span class="tok-number">10</span>]<span class="tok-type">u8</span>);

    <span class="tok-comment">// 指向数组的指针可以像数组一样被切片：</span>
    <span class="tok-kw">var</span> start: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> end: <span class="tok-type">usize</span> = <span class="tok-number">5</span>;
    _ = .{ &amp;start, &amp;end };
    <span class="tok-kw">const</span> slice = ptr[start..end];
    <span class="tok-comment">// 切片是可变的，因为我们切片了一个可变指针。</span>
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(slice) == []<span class="tok-type">u8</span>);
    slice[<span class="tok-number">2</span>] = <span class="tok-number">3</span>;
    <span class="tok-kw">try</span> expect(array[<span class="tok-number">2</span>] == <span class="tok-number">3</span>);

    <span class="tok-comment">// 同样，使用编译期已知的索引进行切片将产生另一个指向</span>
    <span class="tok-comment">// 数组的指针：</span>
    <span class="tok-kw">const</span> ptr2 = slice[<span class="tok-number">2</span>..<span class="tok-number">3</span>];
    <span class="tok-kw">try</span> expect(ptr2.len == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> expect(ptr2[<span class="tok-number">0</span>] == <span class="tok-number">3</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(ptr2) == *[<span class="tok-number">1</span>]<span class="tok-type">u8</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_slices.zig</kbd>
1/2 test_slices.test.using slices for strings...OK
2/2 test_slices.test.slice pointer...OK
All 2 tests passed.
</samp></pre></figure>

      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Pointers">指针</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#for">for</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Arrays">数组</a></li>
</ul>


      <h3 id="Sentinel-Terminated-Slices"><a href="https://ziglang.org/documentation/0.15.2/#toc-Sentinel-Terminated-Slices">哨兵终止切片</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Sentinel-Terminated-Slices">§</a></h3>

      <p>
      语法 <code>[:x]T</code> 是一个具有运行时已知长度的切片，并且还保证在由长度索引的元素处有一个哨兵值。该类型不保证在此之前没有哨兵元素。哨兵终止切片允许对 <code>len</code> 索引进行元素访问。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_null_terminated_slice.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"0-terminated slice"</span> {
    <span class="tok-kw">const</span> slice: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">"hello"</span>;

    <span class="tok-kw">try</span> expect(slice.len == <span class="tok-number">5</span>);
    <span class="tok-kw">try</span> expect(slice[<span class="tok-number">5</span>] == <span class="tok-number">0</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_null_terminated_slice.zig</kbd>
1/1 test_null_terminated_slice.test.0-terminated slice...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      哨兵终止切片也可以使用切片语法的变体 <code>data[start..end :x]</code> 创建，其中 <code>data</code> 是多项指针、数组或切片，<code>x</code> 是哨兵值。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_null_terminated_slicing.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"0-terminated slicing"</span> {
    <span class="tok-kw">var</span> array = [_]<span class="tok-type">u8</span>{ <span class="tok-number">3</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span>, <span class="tok-number">3</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span> };
    <span class="tok-kw">var</span> runtime_length: <span class="tok-type">usize</span> = <span class="tok-number">3</span>;
    _ = &amp;runtime_length;
    <span class="tok-kw">const</span> slice = array[<span class="tok-number">0</span>..runtime_length :<span class="tok-number">0</span>];

    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(slice) == [:<span class="tok-number">0</span>]<span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> expect(slice.len == <span class="tok-number">3</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_null_terminated_slicing.zig</kbd>
1/1 test_null_terminated_slicing.test.0-terminated slicing...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      哨兵终止切片断言后备数据的哨兵位置中的元素实际上是哨兵值。如果不是这种情况，将导致安全检查的<a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_sentinel_mismatch.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"sentinel mismatch"</span> {
    <span class="tok-kw">var</span> array = [_]<span class="tok-type">u8</span>{ <span class="tok-number">3</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span> };

    <span class="tok-comment">// 从长度为 2 的数组创建哨兵终止切片</span>
    <span class="tok-comment">// 将导致值 `1` 占据哨兵元素位置。</span>
    <span class="tok-comment">// 这与指示的哨兵值 `0` 不匹配，并将导致</span>
    <span class="tok-comment">// 运行时 panic。</span>
    <span class="tok-kw">var</span> runtime_length: <span class="tok-type">usize</span> = <span class="tok-number">2</span>;
    _ = &amp;runtime_length;
    <span class="tok-kw">const</span> slice = array[<span class="tok-number">0</span>..runtime_length :<span class="tok-number">0</span>];

    _ = slice;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_sentinel_mismatch.zig</kbd>
1/1 test_sentinel_mismatch.test.sentinel mismatch...thread 2902472 panic: sentinel mismatch: expected 0, found 1
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_sentinel_mismatch.zig:13:24</span>: <span class="sgr-2m">0x102c117 in test.sentinel mismatch (test_sentinel_mismatch.zig)</span>
    const slice = array[0..runtime_length :0];
                       <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:218:25</span>: <span class="sgr-2m">0x115cc90 in mainTerminal (test_runner.zig)</span>
        if (test_fn.func()) |_| {
                        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:66:28</span>: <span class="sgr-2m">0x1155eb1 in main (test_runner.zig)</span>
        return mainTerminal();
                           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x114fc4d in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x114f4e1 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
error: the following test command crashed:
/home/andy/dev/zig/.zig-cache/o/12c6cfa0971ea7c724c8448a09f20f6b/test --seed=0xb506c876
</samp></pre></figure>

      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Sentinel-Terminated-Pointers">哨兵终止指针</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Sentinel-Terminated-Arrays">哨兵终止数组</a></li>
</ul>

      
      

      <h2 id="struct"><a href="https://ziglang.org/documentation/0.15.2/#toc-struct">struct</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#struct">§</a></h2>

      <figure><figcaption class="zig-cap"><cite class="file">test_structs.zig</cite></figcaption><pre><code><span class="tok-comment">// 声明一个结构体。</span>
<span class="tok-comment">// Zig 对字段的顺序和结构体的大小不做保证，但</span>
<span class="tok-comment">// 字段保证是 ABI 对齐的。</span>
<span class="tok-kw">const</span> Point = <span class="tok-kw">struct</span> {
    x: <span class="tok-type">f32</span>,
    y: <span class="tok-type">f32</span>,
};

<span class="tok-comment">// 声明结构体的实例。</span>
<span class="tok-kw">const</span> p: Point = .{
    .x = <span class="tok-number">0.12</span>,
    .y = <span class="tok-number">0.34</span>,
};

<span class="tok-comment">// 结构体命名空间中的函数可以使用点语法调用。</span>
<span class="tok-kw">const</span> Vec3 = <span class="tok-kw">struct</span> {
    x: <span class="tok-type">f32</span>,
    y: <span class="tok-type">f32</span>,
    z: <span class="tok-type">f32</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(x: <span class="tok-type">f32</span>, y: <span class="tok-type">f32</span>, z: <span class="tok-type">f32</span>) Vec3 {
        <span class="tok-kw">return</span> Vec3{
            .x = x,
            .y = y,
            .z = z,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dot</span>(self: Vec3, other: Vec3) <span class="tok-type">f32</span> {
        <span class="tok-kw">return</span> self.x * other.x + self.y * other.y + self.z * other.z;
    }
};

<span class="tok-kw">test</span> <span class="tok-str">"dot product"</span> {
    <span class="tok-kw">const</span> v1 = Vec3.init(<span class="tok-number">1.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">0.0</span>);
    <span class="tok-kw">const</span> v2 = Vec3.init(<span class="tok-number">0.0</span>, <span class="tok-number">1.0</span>, <span class="tok-number">0.0</span>);
    <span class="tok-kw">try</span> expect(v1.dot(v2) == <span class="tok-number">0.0</span>);

    <span class="tok-comment">// 除了可以使用点语法调用外，结构体方法</span>
    <span class="tok-comment">// 并不特殊。您可以像引用结构体内的任何其他声明一样</span>
    <span class="tok-comment">// 引用它们：</span>
    <span class="tok-kw">try</span> expect(Vec3.dot(v1, v2) == <span class="tok-number">0.0</span>);
}

<span class="tok-comment">// 结构体可以有声明。</span>
<span class="tok-comment">// 结构体可以有 0 个字段。</span>
<span class="tok-kw">const</span> Empty = <span class="tok-kw">struct</span> {
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> PI = <span class="tok-number">3.14</span>;
};
<span class="tok-kw">test</span> <span class="tok-str">"struct namespaced variable"</span> {
    <span class="tok-kw">try</span> expect(Empty.PI == <span class="tok-number">3.14</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@sizeOf</span>(Empty) == <span class="tok-number">0</span>);

    <span class="tok-comment">// 空结构体可以像往常一样实例化。</span>
    <span class="tok-kw">const</span> does_nothing: Empty = .{};

    _ = does_nothing;
}

<span class="tok-comment">// 结构体字段顺序由编译器决定，但是，基指针</span>
<span class="tok-comment">// 可以从字段指针计算出来：</span>
<span class="tok-kw">fn</span> <span class="tok-fn">setYBasedOnX</span>(x: *<span class="tok-type">f32</span>, y: <span class="tok-type">f32</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> point: *Point = <span class="tok-builtin">@fieldParentPtr</span>(<span class="tok-str">"x"</span>, x);
    point.y = y;
}
<span class="tok-kw">test</span> <span class="tok-str">"field parent pointer"</span> {
    <span class="tok-kw">var</span> point = Point{
        .x = <span class="tok-number">0.1234</span>,
        .y = <span class="tok-number">0.5678</span>,
    };
    setYBasedOnX(&amp;point.x, <span class="tok-number">0.9</span>);
    <span class="tok-kw">try</span> expect(point.y == <span class="tok-number">0.9</span>);
}

<span class="tok-comment">// 结构体可以从函数返回。</span>
<span class="tok-kw">fn</span> <span class="tok-fn">LinkedList</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Node = <span class="tok-kw">struct</span> {
            prev: ?*Node,
            next: ?*Node,
            data: T,
        };

        first: ?*Node,
        last: ?*Node,
        len: <span class="tok-type">usize</span>,
    };
}

<span class="tok-kw">test</span> <span class="tok-str">"linked list"</span> {
    <span class="tok-comment">// 在编译期调用的函数会被记忆化。</span>
    <span class="tok-kw">try</span> expect(LinkedList(<span class="tok-type">i32</span>) == LinkedList(<span class="tok-type">i32</span>));

    <span class="tok-kw">const</span> list = LinkedList(<span class="tok-type">i32</span>){
        .first = <span class="tok-null">null</span>,
        .last = <span class="tok-null">null</span>,
        .len = <span class="tok-number">0</span>,
    };
    <span class="tok-kw">try</span> expect(list.len == <span class="tok-number">0</span>);

    <span class="tok-comment">// 由于类型是一等值，您可以通过将类型</span>
    <span class="tok-comment">// 分配给变量来实例化类型：</span>
    <span class="tok-kw">const</span> ListOfInts = LinkedList(<span class="tok-type">i32</span>);
    <span class="tok-kw">try</span> expect(ListOfInts == LinkedList(<span class="tok-type">i32</span>));

    <span class="tok-kw">var</span> node = ListOfInts.Node{
        .prev = <span class="tok-null">null</span>,
        .next = <span class="tok-null">null</span>,
        .data = <span class="tok-number">1234</span>,
    };
    <span class="tok-kw">const</span> list2 = LinkedList(<span class="tok-type">i32</span>){
        .first = &amp;node,
        .last = &amp;node,
        .len = <span class="tok-number">1</span>,
    };

    <span class="tok-comment">// 当使用指向结构体的指针时，可以直接访问字段，</span>
    <span class="tok-comment">// 而无需显式解引用指针。</span>
    <span class="tok-comment">// 所以您可以这样做</span>
    <span class="tok-kw">try</span> expect(list2.first.?.data == <span class="tok-number">1234</span>);
    <span class="tok-comment">// 而不是 try expect(list2.first.?.*.data == 1234);</span>
}

<span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_structs.zig</kbd>
1/4 test_structs.test.dot product...OK
2/4 test_structs.test.struct namespaced variable...OK
3/4 test_structs.test.field parent pointer...OK
4/4 test_structs.test.linked list...OK
All 4 tests passed.
</samp></pre></figure>


      <h3 id="Default-Field-Values"><a href="https://ziglang.org/documentation/0.15.2/#toc-Default-Field-Values">默认字段值</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Default-Field-Values">§</a></h3>

      <p>
      每个结构体字段可能有一个表示默认字段值的表达式。此类表达式在<a href="https://ziglang.org/documentation/0.15.2/#comptime">编译期</a>执行，并允许在结构体字面量表达式中省略该字段：
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">struct_default_field_values.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Foo = <span class="tok-kw">struct</span> {
    a: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>,
    b: <span class="tok-type">i32</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">"default struct initialization fields"</span> {
    <span class="tok-kw">const</span> x: Foo = .{
        .b = <span class="tok-number">5</span>,
    };
    <span class="tok-kw">if</span> (x.a + x.b != <span class="tok-number">1239</span>) {
        <span class="tok-kw">comptime</span> <span class="tok-kw">unreachable</span>;
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test struct_default_field_values.zig</kbd>
1/1 struct_default_field_values.test.default struct initialization fields...OK
All 1 tests passed.
</samp></pre></figure>

      <h4 id="Faulty-Default-Field-Values"><a href="https://ziglang.org/documentation/0.15.2/#toc-Faulty-Default-Field-Values">错误的默认字段值</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Faulty-Default-Field-Values">§</a></h4>

      <p>
      默认字段值仅在从初始化中省略该字段不会违反结构体的数据不变量时才适用。
      </p>
      <p>
      例如，这里是对默认结构体字段初始化的不当使用：
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">bad_default_value.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Threshold = <span class="tok-kw">struct</span> {
    minimum: <span class="tok-type">f32</span> = <span class="tok-number">0.25</span>,
    maximum: <span class="tok-type">f32</span> = <span class="tok-number">0.75</span>,

    <span class="tok-kw">const</span> Category = <span class="tok-kw">enum</span> { low, medium, high };

    <span class="tok-kw">fn</span> <span class="tok-fn">categorize</span>(t: Threshold, value: <span class="tok-type">f32</span>) Category {
        assert(t.maximum &gt;= t.minimum);
        <span class="tok-kw">if</span> (value &lt; t.minimum) <span class="tok-kw">return</span> .low;
        <span class="tok-kw">if</span> (value &gt; t.maximum) <span class="tok-kw">return</span> .high;
        <span class="tok-kw">return</span> .medium;
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> threshold: Threshold = .{
        .maximum = <span class="tok-number">0.20</span>,
    };
    <span class="tok-kw">const</span> category = threshold.categorize(<span class="tok-number">0.90</span>);
    <span class="tok-kw">try</span> std.fs.File.stdout().writeAll(<span class="tok-builtin">@tagName</span>(category));
}

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> assert = std.debug.assert;</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe bad_default_value.zig</kbd>
$ <kbd>./bad_default_value</kbd>
thread 2895237 panic: reached unreachable code
<span class="sgr-1m">/home/andy/dev/zig/lib/std/debug.zig:559:14</span>: <span class="sgr-2m">0x1044179 in assert (std.zig)</span>
    if (!ok) unreachable; // assertion failure
             <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/bad_default_value.zig:8:15</span>: <span class="sgr-2m">0x113ec54 in categorize (bad_default_value.zig)</span>
        assert(t.maximum &gt;= t.minimum);
              <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/bad_default_value.zig:19:42</span>: <span class="sgr-2m">0x113d444 in main (bad_default_value.zig)</span>
    const category = threshold.categorize(0.90);
                                         <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:627:37</span>: <span class="sgr-2m">0x113dca9 in posixCallMainAndExit (std.zig)</span>
            const result = root.main() catch |err| {
                                    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      <p>
      上面您可以看到忽略此原则的危险。默认字段值导致数据不变量被违反，从而导致非法行为。
      </p>
      <p>
      要解决此问题，请从所有结构体字段中删除默认值，并提供一个命名的默认值：
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">struct_default_value.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Threshold = <span class="tok-kw">struct</span> {
    minimum: <span class="tok-type">f32</span>,
    maximum: <span class="tok-type">f32</span>,

    <span class="tok-kw">const</span> default: Threshold = .{
        .minimum = <span class="tok-number">0.25</span>,
        .maximum = <span class="tok-number">0.75</span>,
    };
};</code></pre></figure>

      <p>如果结构体值需要运行时已知的值才能在不违反数据不变量的情况下初始化，则使用接受这些运行时值的初始化方法，并填充其余字段。</p>
      
      

      <h3 id="extern-struct"><a href="https://ziglang.org/documentation/0.15.2/#toc-extern-struct">extern struct</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#extern-struct">§</a></h3>

      <p><code><span class="tok-kw">extern</span> <span class="tok-kw">struct</span></code> 具有与目标的 C ABI 匹配的内存布局。</p>
      <p>如果不需要明确定义的内存布局，<a href="https://ziglang.org/documentation/0.15.2/#struct">struct</a> 是更好的选择，因为它对编译器的限制较少。</p>
      <p>参见 <a href="https://ziglang.org/documentation/0.15.2/#packed-struct">packed struct</a>，它具有其后备整数的 ABI，这对于建模标志很有用。</p>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#extern-union">extern union</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#extern-enum">extern enum</a></li>
</ul>

      

      <h3 id="packed-struct"><a href="https://ziglang.org/documentation/0.15.2/#toc-packed-struct">packed struct</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#packed-struct">§</a></h3>

      <p>
      与 <code><span class="tok-kw">enum</span></code> 一样，<code><span class="tok-kw">packed</span></code> 结构体基于以不同方式解释整数的概念。所有紧凑结构体都有一个<strong>后备整数</strong>，该整数由字段的总位数隐式确定，或显式指定。紧凑结构体具有明确定义的内存布局 - 与其后备整数完全相同的 ABI。
      </p>
      <p>
      紧凑结构体的每个字段被解释为逻辑位序列，从最低有效位到最高有效位排列。允许的字段类型：
      </p>
      <ul>
        <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a>字段使用与其位宽完全相同的位数。例如，<code><span class="tok-type">u5</span></code> 将使用后备整数的 5 位。</li>
        <li><a href="https://ziglang.org/documentation/0.15.2/#Primitive-Types">bool</a> 字段恰好使用 1 位。</li>
        <li><a href="https://ziglang.org/documentation/0.15.2/#enum">enum</a> 字段恰好使用其整数标签类型的位宽。</li>
        <li><a href="https://ziglang.org/documentation/0.15.2/#packed-union">packed union</a> 字段恰好使用具有最大位宽的联合字段的位宽。</li>
        <li><code><span class="tok-kw">packed</span> <span class="tok-kw">struct</span></code> 字段使用其后备整数的位。</li>
      </ul>
      <p>
      这意味着 <code><span class="tok-kw">packed</span> <span class="tok-kw">struct</span></code> 可以参与 <a href="https://ziglang.org/documentation/0.15.2/#bitCast">@bitCast</a> 或 <a href="https://ziglang.org/documentation/0.15.2/#ptrCast">@ptrCast</a> 以重新解释内存。这甚至在<a href="https://ziglang.org/documentation/0.15.2/#comptime">编译期</a>也有效：
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_packed_structs.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> native_endian = <span class="tok-builtin">@import</span>(<span class="tok-str">"builtin"</span>).target.cpu.arch.endian();
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Full = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    number: <span class="tok-type">u16</span>,
};
<span class="tok-kw">const</span> Divided = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    half1: <span class="tok-type">u8</span>,
    quarter3: <span class="tok-type">u4</span>,
    quarter4: <span class="tok-type">u4</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">"@bitCast between packed structs"</span> {
    <span class="tok-kw">try</span> doTheTest();
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> doTheTest();
}

<span class="tok-kw">fn</span> <span class="tok-fn">doTheTest</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@sizeOf</span>(Full) == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@sizeOf</span>(Divided) == <span class="tok-number">2</span>);
    <span class="tok-kw">const</span> full = Full{ .number = <span class="tok-number">0x1234</span> };
    <span class="tok-kw">const</span> divided: Divided = <span class="tok-builtin">@bitCast</span>(full);
    <span class="tok-kw">try</span> expect(divided.half1 == <span class="tok-number">0x34</span>);
    <span class="tok-kw">try</span> expect(divided.quarter3 == <span class="tok-number">0x2</span>);
    <span class="tok-kw">try</span> expect(divided.quarter4 == <span class="tok-number">0x1</span>);

    <span class="tok-kw">const</span> ordered: [<span class="tok-number">2</span>]<span class="tok-type">u8</span> = <span class="tok-builtin">@bitCast</span>(full);
    <span class="tok-kw">switch</span> (native_endian) {
        .big =&gt; {
            <span class="tok-kw">try</span> expect(ordered[<span class="tok-number">0</span>] == <span class="tok-number">0x12</span>);
            <span class="tok-kw">try</span> expect(ordered[<span class="tok-number">1</span>] == <span class="tok-number">0x34</span>);
        },
        .little =&gt; {
            <span class="tok-kw">try</span> expect(ordered[<span class="tok-number">0</span>] == <span class="tok-number">0x34</span>);
            <span class="tok-kw">try</span> expect(ordered[<span class="tok-number">1</span>] == <span class="tok-number">0x12</span>);
        },
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_packed_structs.zig</kbd>
1/1 test_packed_structs.test.@bitCast between packed structs...OK
All 1 tests passed.
</samp></pre></figure>
      <p>
      后备整数可以被推断或显式提供。当推断时，它将是无符号的。当显式提供时，其位宽将在编译期强制执行，以完全匹配字段的总位宽：
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_missized_packed_struct.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">"missized packed struct"</span> {
    <span class="tok-kw">const</span> S = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u32</span>) { a: <span class="tok-type">u16</span>, b: <span class="tok-type">u8</span> };
    _ = S{ .a = <span class="tok-number">4</span>, .b = <span class="tok-number">2</span> };
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_missized_packed_struct.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_missized_packed_struct.zig:2:29: </span><span class="sgr-31m">error: </span><span class="sgr-1m">backing integer type 'u32' has bit size 32 but the struct fields have a total bit size of 24
</span>    const S = packed struct(u32) { a: u16, b: u8 };
                            <span class="sgr-32m">^~~
</span><span class="sgr-2m">referenced by:
    test.missized packed struct: /home/andy/dev/zig/doc/langref/test_missized_packed_struct.zig:2:22
</span>
</samp></pre></figure>

      <p>
      Zig 允许获取非字节对齐字段的地址：
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_pointer_to_non-byte_aligned_field.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> BitField = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    a: <span class="tok-type">u3</span>,
    b: <span class="tok-type">u3</span>,
    c: <span class="tok-type">u2</span>,
};

<span class="tok-kw">var</span> foo = BitField{
    .a = <span class="tok-number">1</span>,
    .b = <span class="tok-number">2</span>,
    .c = <span class="tok-number">3</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">"pointer to non-byte-aligned field"</span> {
    <span class="tok-kw">const</span> ptr = &amp;foo.b;
    <span class="tok-kw">try</span> expect(ptr.* == <span class="tok-number">2</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_pointer_to_non-byte_aligned_field.zig</kbd>
1/1 test_pointer_to_non-byte_aligned_field.test.pointer to non-byte-aligned field...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      然而，指向非字节对齐字段的指针具有特殊属性，在预期普通指针的地方不能传递：
      </p>
<!-- ====== END CHUNK 4: new_04.html ====== -->

<!-- ====== BEGIN CHUNK 5: new_05.html ====== -->
<figure><figcaption class="zig-cap"><cite class="file">test_misaligned_pointer.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> BitField = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    a: <span class="tok-type">u3</span>,
    b: <span class="tok-type">u3</span>,
    c: <span class="tok-type">u2</span>,
};

<span class="tok-kw">var</span> bit_field = BitField{
    .a = <span class="tok-number">1</span>,
    .b = <span class="tok-number">2</span>,
    .c = <span class="tok-number">3</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">"pointer to non-byte-aligned field"</span> {
    <span class="tok-kw">try</span> expect(bar(&amp;bit_field.b) == <span class="tok-number">2</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>(x: *<span class="tok-kw">const</span> <span class="tok-type">u3</span>) <span class="tok-type">u3</span> {
    <span class="tok-kw">return</span> x.*;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_misaligned_pointer.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_misaligned_pointer.zig:17:20: </span><span class="sgr-31m">error: </span><span class="sgr-1m">expected type '*const u3', found '*align(1:3:1) u3'
</span>    try expect(bar(&amp;bit_field.b) == 2);
                   <span class="sgr-32m">^~~~~~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_misaligned_pointer.zig:17:20: </span><span class="sgr-36m">note: </span><span class="sgr-1m">pointer host size '1' cannot cast into pointer host size '0'
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_misaligned_pointer.zig:17:20: </span><span class="sgr-36m">note: </span><span class="sgr-1m">pointer bit offset '3' cannot cast into pointer bit offset '0'
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_misaligned_pointer.zig:20:11: </span><span class="sgr-36m">note: </span><span class="sgr-1m">parameter type declared here
</span>fn bar(x: *const u3) u3 {
          <span class="sgr-32m">^~~~~~~~~
</span>
</samp></pre></figure>

      <p>
      在这种情况下,函数 <code>bar</code> 不能被调用,因为指向非 ABI 对齐字段的指针包含位偏移信息,但函数期望一个 ABI 对齐的指针。
      </p>
      <p>
      指向非 ABI 对齐字段的指针与其宿主整数内的其他字段共享相同的地址:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_packed_struct_field_address.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> BitField = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    a: <span class="tok-type">u3</span>,
    b: <span class="tok-type">u3</span>,
    c: <span class="tok-type">u2</span>,
};

<span class="tok-kw">var</span> bit_field = BitField{
    .a = <span class="tok-number">1</span>,
    .b = <span class="tok-number">2</span>,
    .c = <span class="tok-number">3</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">"pointers of sub-byte-aligned fields share addresses"</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromPtr</span>(&amp;bit_field.a) == <span class="tok-builtin">@intFromPtr</span>(&amp;bit_field.b));
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromPtr</span>(&amp;bit_field.a) == <span class="tok-builtin">@intFromPtr</span>(&amp;bit_field.c));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_packed_struct_field_address.zig</kbd>
1/1 test_packed_struct_field_address.test.pointers of sub-byte-aligned fields share addresses...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      这可以通过 <a href="https://ziglang.org/documentation/0.15.2/#bitOffsetOf">@bitOffsetOf</a> 和 <a href="https://ziglang.org/documentation/0.15.2/#offsetOf">offsetOf</a> 观察到:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_bitOffsetOf_offsetOf.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> BitField = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    a: <span class="tok-type">u3</span>,
    b: <span class="tok-type">u3</span>,
    c: <span class="tok-type">u2</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">"offsets of non-byte-aligned fields"</span> {
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">try</span> expect(<span class="tok-builtin">@bitOffsetOf</span>(BitField, <span class="tok-str">"a"</span>) == <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> expect(<span class="tok-builtin">@bitOffsetOf</span>(BitField, <span class="tok-str">"b"</span>) == <span class="tok-number">3</span>);
        <span class="tok-kw">try</span> expect(<span class="tok-builtin">@bitOffsetOf</span>(BitField, <span class="tok-str">"c"</span>) == <span class="tok-number">6</span>);

        <span class="tok-kw">try</span> expect(<span class="tok-builtin">@offsetOf</span>(BitField, <span class="tok-str">"a"</span>) == <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> expect(<span class="tok-builtin">@offsetOf</span>(BitField, <span class="tok-str">"b"</span>) == <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> expect(<span class="tok-builtin">@offsetOf</span>(BitField, <span class="tok-str">"c"</span>) == <span class="tok-number">0</span>);
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_bitOffsetOf_offsetOf.zig</kbd>
1/1 test_bitOffsetOf_offsetOf.test.offsets of non-byte-aligned fields...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      紧凑结构体的对齐方式与其后备整数相同,但是,指向紧凑结构体的过度对齐指针可以覆盖这一点:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_overaligned_packed_struct.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> S = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    a: <span class="tok-type">u32</span>,
    b: <span class="tok-type">u32</span>,
};
<span class="tok-kw">test</span> <span class="tok-str">"overaligned pointer to packed struct"</span> {
    <span class="tok-kw">var</span> foo: S <span class="tok-kw">align</span>(<span class="tok-number">4</span>) = .{ .a = <span class="tok-number">1</span>, .b = <span class="tok-number">2</span> };
    <span class="tok-kw">const</span> ptr: *<span class="tok-kw">align</span>(<span class="tok-number">4</span>) S = &amp;foo;
    <span class="tok-kw">const</span> ptr_to_b: *<span class="tok-type">u32</span> = &amp;ptr.b;
    <span class="tok-kw">try</span> expect(ptr_to_b.* == <span class="tok-number">2</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_overaligned_packed_struct.zig</kbd>
1/1 test_overaligned_packed_struct.test.overaligned pointer to packed struct...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      也可以设置结构体字段的对齐方式:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_aligned_struct_fields.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expectEqual = std.testing.expectEqual;

<span class="tok-kw">test</span> <span class="tok-str">"aligned struct fields"</span> {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        a: <span class="tok-type">u32</span> <span class="tok-kw">align</span>(<span class="tok-number">2</span>),
        b: <span class="tok-type">u32</span> <span class="tok-kw">align</span>(<span class="tok-number">64</span>),
    };
    <span class="tok-kw">var</span> foo = S{ .a = <span class="tok-number">1</span>, .b = <span class="tok-number">2</span> };

    <span class="tok-kw">try</span> expectEqual(<span class="tok-number">64</span>, <span class="tok-builtin">@alignOf</span>(S));
    <span class="tok-kw">try</span> expectEqual(*<span class="tok-kw">align</span>(<span class="tok-number">2</span>) <span class="tok-type">u32</span>, <span class="tok-builtin">@TypeOf</span>(&amp;foo.a));
    <span class="tok-kw">try</span> expectEqual(*<span class="tok-kw">align</span>(<span class="tok-number">64</span>) <span class="tok-type">u32</span>, <span class="tok-builtin">@TypeOf</span>(&amp;foo.b));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_aligned_struct_fields.zig</kbd>
1/1 test_aligned_struct_fields.test.aligned struct fields...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      比较紧凑结构体会导致比较后备整数,
      并且仅适用于 <code>==</code> 和 <code>!=</code> <a href="https://ziglang.org/documentation/0.15.2/#Operators">运算符</a>。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_packed_struct_equality.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"packed struct equality"</span> {
    <span class="tok-kw">const</span> S = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
        a: <span class="tok-type">u4</span>,
        b: <span class="tok-type">u4</span>,
    };
    <span class="tok-kw">const</span> x: S = .{ .a = <span class="tok-number">1</span>, .b = <span class="tok-number">2</span> };
    <span class="tok-kw">const</span> y: S = .{ .b = <span class="tok-number">2</span>, .a = <span class="tok-number">1</span> };
    <span class="tok-kw">try</span> expect(x == y);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_packed_struct_equality.zig</kbd>
1/1 test_packed_struct_equality.test.packed struct equality...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      字段访问和赋值可以理解为对后备整数进行位移操作的简写。这些操作不是<a href="https://ziglang.org/documentation/0.15.2/#Atomics">原子的</a>,
      因此在结合内存映射输入输出(MMIO)使用字段访问语法时要小心。不要在 <a href="https://ziglang.org/documentation/0.15.2/#volatile">volatile</a> <a href="https://ziglang.org/documentation/0.15.2/#Pointers">指针</a>上使用字段访问,
      而是先构造一个完整的新值,然后将该值写入 volatile 指针。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">packed_struct_mmio.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">const</span> GpioRegister = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u8</span>) {
    GPIO0: <span class="tok-type">bool</span>,
    GPIO1: <span class="tok-type">bool</span>,
    GPIO2: <span class="tok-type">bool</span>,
    GPIO3: <span class="tok-type">bool</span>,
    reserved: <span class="tok-type">u4</span> = <span class="tok-number">0</span>,
};

<span class="tok-kw">const</span> gpio: *<span class="tok-kw">volatile</span> GpioRegister = <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-number">0x0123</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeToGpio</span>(new_states: GpioRegister) <span class="tok-type">void</span> {
    <span class="tok-comment">// 不应该这样做的示例:</span>
    <span class="tok-comment">// 错误! gpio.GPIO0 = true; 错误!</span>

    <span class="tok-comment">// 而是这样做:</span>
    gpio.* = new_states;
}</code></pre></figure>
      

      <h3 id="Struct-Naming"><a href="https://ziglang.org/documentation/0.15.2/#toc-Struct-Naming">结构体命名</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Struct-Naming">§</a></h3>

      <p>由于所有结构体都是匿名的,Zig 会根据几条规则推断类型名称。</p>
      <ul>
          <li>如果结构体在变量的初始化表达式中,它将以该变量命名。</li>
          <li>如果结构体在 <code><span class="tok-kw">return</span></code> 表达式中,它将以它返回的函数命名,并附加序列化的参数值。</li>
          <li>否则,结构体将获得一个名称,如 <code>(filename.funcname__struct_ID)</code>。</li>
          <li>如果结构体在另一个结构体内声明,它将以父结构体和前述规则推断出的名称命名,用点分隔。</li>
      </ul>
      <figure><figcaption class="zig-cap"><cite class="file">struct_name.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> Foo = <span class="tok-kw">struct</span> {};
    std.debug.print(<span class="tok-str">"variable: {s}\n"</span>, .{<span class="tok-builtin">@typeName</span>(Foo)});
    std.debug.print(<span class="tok-str">"anonymous: {s}\n"</span>, .{<span class="tok-builtin">@typeName</span>(<span class="tok-kw">struct</span> {})});
    std.debug.print(<span class="tok-str">"function: {s}\n"</span>, .{<span class="tok-builtin">@typeName</span>(List(<span class="tok-type">i32</span>))});
}

<span class="tok-kw">fn</span> <span class="tok-fn">List</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        x: T,
    };
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe struct_name.zig</kbd>
$ <kbd>./struct_name</kbd>
variable: struct_name.main.Foo
anonymous: struct_name.main__struct_22691
function: struct_name.List(i32)
</samp></pre></figure>

      

      <h3 id="Anonymous-Struct-Literals"><a href="https://ziglang.org/documentation/0.15.2/#toc-Anonymous-Struct-Literals">匿名结构体字面量</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Anonymous-Struct-Literals">§</a></h3>

      <p>
      Zig 允许省略字面量的结构体类型。当结果被<a href="https://ziglang.org/documentation/0.15.2/#Type-Coercion">强制转换</a>时,
      结构体字面量将直接实例化<a href="https://ziglang.org/documentation/0.15.2/#Result-Location-Semantics">结果位置</a>,
      无需复制:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_struct_result.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Point = <span class="tok-kw">struct</span> { x: <span class="tok-type">i32</span>, y: <span class="tok-type">i32</span> };

<span class="tok-kw">test</span> <span class="tok-str">"anonymous struct literal"</span> {
    <span class="tok-kw">const</span> pt: Point = .{
        .x = <span class="tok-number">13</span>,
        .y = <span class="tok-number">67</span>,
    };
    <span class="tok-kw">try</span> expect(pt.x == <span class="tok-number">13</span>);
    <span class="tok-kw">try</span> expect(pt.y == <span class="tok-number">67</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_struct_result.zig</kbd>
1/1 test_struct_result.test.anonymous struct literal...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      结构体类型可以被推断。这里<a href="https://ziglang.org/documentation/0.15.2/#Result-Location-Semantics">结果位置</a>
      不包含类型,因此 Zig 推断类型:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_anonymous_struct.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"fully anonymous struct"</span> {
    <span class="tok-kw">try</span> check(.{
        .int = <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1234</span>),
        .float = <span class="tok-builtin">@as</span>(<span class="tok-type">f64</span>, <span class="tok-number">12.34</span>),
        .b = <span class="tok-null">true</span>,
        .s = <span class="tok-str">"hi"</span>,
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">check</span>(args: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> expect(args.int == <span class="tok-number">1234</span>);
    <span class="tok-kw">try</span> expect(args.float == <span class="tok-number">12.34</span>);
    <span class="tok-kw">try</span> expect(args.b);
    <span class="tok-kw">try</span> expect(args.s[<span class="tok-number">0</span>] == <span class="tok-str">'h'</span>);
    <span class="tok-kw">try</span> expect(args.s[<span class="tok-number">1</span>] == <span class="tok-str">'i'</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_anonymous_struct.zig</kbd>
1/1 test_anonymous_struct.test.fully anonymous struct...OK
All 1 tests passed.
</samp></pre></figure>

      

      <h3 id="Tuples"><a href="https://ziglang.org/documentation/0.15.2/#toc-Tuples">元组</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Tuples">§</a></h3>

      <p>
      匿名结构体可以在不指定字段名称的情况下创建,被称为"元组"。空元组看起来像 <code>.{}</code>,可以在其中一个<a href="https://ziglang.org/documentation/0.15.2/#Hello-World">Hello World 示例</a>中看到。
      </p>
      <p>
      字段使用从 0 开始的数字隐式命名。因为它们的名称是整数,
      所以不能使用 <code>.</code> 语法访问它们,除非也将它们包装在
      <code>@""</code> 中。<code>@""</code> 内的名称始终被识别为
      <a href="https://ziglang.org/documentation/0.15.2/#Identifiers">标识符</a>。
      </p>
      <p>
      与数组一样,元组有一个 .len 字段,可以被索引(前提是索引在编译时已知)
      并且可以与 ++ 和 ** 运算符一起使用。它们也可以使用 <a href="https://ziglang.org/documentation/0.15.2/#inline-for">inline for</a> 进行迭代。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_tuples.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"tuple"</span> {
    <span class="tok-kw">const</span> values = .{
        <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1234</span>),
        <span class="tok-builtin">@as</span>(<span class="tok-type">f64</span>, <span class="tok-number">12.34</span>),
        <span class="tok-null">true</span>,
        <span class="tok-str">"hi"</span>,
    } ++ .{<span class="tok-null">false</span>} ** <span class="tok-number">2</span>;
    <span class="tok-kw">try</span> expect(values[<span class="tok-number">0</span>] == <span class="tok-number">1234</span>);
    <span class="tok-kw">try</span> expect(values[<span class="tok-number">4</span>] == <span class="tok-null">false</span>);
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (values, <span class="tok-number">0</span>..) |v, i| {
        <span class="tok-kw">if</span> (i != <span class="tok-number">2</span>) <span class="tok-kw">continue</span>;
        <span class="tok-kw">try</span> expect(v);
    }
    <span class="tok-kw">try</span> expect(values.len == <span class="tok-number">6</span>);
    <span class="tok-kw">try</span> expect(values.@"3"[<span class="tok-number">0</span>] == <span class="tok-str">'h'</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_tuples.zig</kbd>
1/1 test_tuples.test.tuple...OK
All 1 tests passed.
</samp></pre></figure>

      <h4 id="Destructuring-Tuples"><a href="https://ziglang.org/documentation/0.15.2/#toc-Destructuring-Tuples">解构元组</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Destructuring-Tuples">§</a></h4>

      <p>
        元组可以被<a href="https://ziglang.org/documentation/0.15.2/#Destructuring">解构</a>。
      </p>
      <p>
        元组解构有助于从块中返回多个值:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">destructuring_block.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> digits = [_]<span class="tok-type">i8</span> { <span class="tok-number">3</span>, <span class="tok-number">8</span>, <span class="tok-number">9</span>, <span class="tok-number">0</span>, <span class="tok-number">7</span>, <span class="tok-number">4</span>, <span class="tok-number">1</span> };

    <span class="tok-kw">const</span> min, <span class="tok-kw">const</span> max = blk: {
        <span class="tok-kw">var</span> min: <span class="tok-type">i8</span> = <span class="tok-number">127</span>;
        <span class="tok-kw">var</span> max: <span class="tok-type">i8</span> = -<span class="tok-number">128</span>;

        <span class="tok-kw">for</span> (digits) |digit| {
            <span class="tok-kw">if</span> (digit &lt; min) min = digit;
            <span class="tok-kw">if</span> (digit &gt; max) max = digit;
        }

        <span class="tok-kw">break</span> :blk .{ min, max };
    };

    print(<span class="tok-str">"min = {}\n"</span>, .{ min });
    print(<span class="tok-str">"max = {}\n"</span>, .{ max });
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe destructuring_block.zig</kbd>
$ <kbd>./destructuring_block</kbd>
min = 0
max = 9
</samp></pre></figure>

      <p>
        元组解构有助于处理将多个值作为元组返回的函数和内置函数:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">destructuring_return_value.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;

<span class="tok-kw">fn</span> <span class="tok-fn">divmod</span>(numerator: <span class="tok-type">u32</span>, denominator: <span class="tok-type">u32</span>) <span class="tok-kw">struct</span> { <span class="tok-type">u32</span>, <span class="tok-type">u32</span> } {
    <span class="tok-kw">return</span> .{ numerator / denominator, numerator % denominator };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> div, <span class="tok-kw">const</span> mod = divmod(<span class="tok-number">10</span>, <span class="tok-number">3</span>);

    print(<span class="tok-str">"10 / 3 = {}\n"</span>, .{div});
    print(<span class="tok-str">"10 % 3 = {}\n"</span>, .{mod});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe destructuring_return_value.zig</kbd>
$ <kbd>./destructuring_return_value</kbd>
10 / 3 = 3
10 % 3 = 1
</samp></pre></figure>

      <p>另见:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Destructuring">解构</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Destructuring-Arrays">解构数组</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Destructuring-Vectors">解构向量</a></li>
</ul>

      
      
      <p>另见:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#fieldParentPtr">@fieldParentPtr</a></li>
</ul>

      
      <h2 id="enum"><a href="https://ziglang.org/documentation/0.15.2/#toc-enum">enum</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#enum">§</a></h2>

      <figure><figcaption class="zig-cap"><cite class="file">test_enums.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;
<span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).mem;

<span class="tok-comment">// 声明一个枚举。</span>
<span class="tok-kw">const</span> Type = <span class="tok-kw">enum</span> {
    ok,
    not_ok,
};

<span class="tok-comment">// 声明一个特定的枚举字段。</span>
<span class="tok-kw">const</span> c = Type.ok;

<span class="tok-comment">// 如果您想访问枚举的序数值,可以</span>
<span class="tok-comment">// 指定标签类型。</span>
<span class="tok-kw">const</span> Value = <span class="tok-kw">enum</span>(<span class="tok-type">u2</span>) {
    zero,
    one,
    two,
};
<span class="tok-comment">// 现在您可以在 u2 和 Value 之间进行转换。</span>
<span class="tok-comment">// 序数值从 0 开始,从前一个成员向上递增 1。</span>
<span class="tok-kw">test</span> <span class="tok-str">"enum ordinal value"</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value.zero) == <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value.one) == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value.two) == <span class="tok-number">2</span>);
}

<span class="tok-comment">// 您可以覆盖枚举的序数值。</span>
<span class="tok-kw">const</span> Value2 = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {
    hundred = <span class="tok-number">100</span>,
    thousand = <span class="tok-number">1000</span>,
    million = <span class="tok-number">1000000</span>,
};
<span class="tok-kw">test</span> <span class="tok-str">"set enum ordinal value"</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value2.hundred) == <span class="tok-number">100</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value2.thousand) == <span class="tok-number">1000</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value2.million) == <span class="tok-number">1000000</span>);
}

<span class="tok-comment">// 您也可以仅覆盖某些值。</span>
<span class="tok-kw">const</span> Value3 = <span class="tok-kw">enum</span>(<span class="tok-type">u4</span>) {
    a,
    b = <span class="tok-number">8</span>,
    c,
    d = <span class="tok-number">4</span>,
    e,
};
<span class="tok-kw">test</span> <span class="tok-str">"enum implicit ordinal values and overridden values"</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value3.a) == <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value3.b) == <span class="tok-number">8</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value3.c) == <span class="tok-number">9</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value3.d) == <span class="tok-number">4</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value3.e) == <span class="tok-number">5</span>);
}

<span class="tok-comment">// 枚举可以有方法,与结构体和联合体相同。</span>
<span class="tok-comment">// 枚举方法并不特殊,它们只是命名空间</span>
<span class="tok-comment">// 函数,您可以使用点语法调用。</span>
<span class="tok-kw">const</span> Suit = <span class="tok-kw">enum</span> {
    clubs,
    spades,
    diamonds,
    hearts,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isClubs</span>(self: Suit) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> self == Suit.clubs;
    }
};
<span class="tok-kw">test</span> <span class="tok-str">"enum method"</span> {
    <span class="tok-kw">const</span> p = Suit.spades;
    <span class="tok-kw">try</span> expect(!p.isClubs());
}

<span class="tok-comment">// 可以对枚举进行 switch。</span>
<span class="tok-kw">const</span> Foo = <span class="tok-kw">enum</span> {
    string,
    number,
    none,
};
<span class="tok-kw">test</span> <span class="tok-str">"enum switch"</span> {
    <span class="tok-kw">const</span> p = Foo.number;
    <span class="tok-kw">const</span> what_is_it = <span class="tok-kw">switch</span> (p) {
        Foo.string =&gt; <span class="tok-str">"this is a string"</span>,
        Foo.number =&gt; <span class="tok-str">"this is a number"</span>,
        Foo.none =&gt; <span class="tok-str">"this is a none"</span>,
    };
    <span class="tok-kw">try</span> expect(mem.eql(<span class="tok-type">u8</span>, what_is_it, <span class="tok-str">"this is a number"</span>));
}

<span class="tok-comment">// @typeInfo 可用于访问枚举的整数标签类型。</span>
<span class="tok-kw">const</span> Small = <span class="tok-kw">enum</span> {
    one,
    two,
    three,
    four,
};
<span class="tok-kw">test</span> <span class="tok-str">"std.meta.Tag"</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@typeInfo</span>(Small).@"enum".tag_type == <span class="tok-type">u2</span>);
}

<span class="tok-comment">// @typeInfo 告诉我们字段数量和字段名称:</span>
<span class="tok-kw">test</span> <span class="tok-str">"@typeInfo"</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@typeInfo</span>(Small).@"enum".fields.len == <span class="tok-number">4</span>);
    <span class="tok-kw">try</span> expect(mem.eql(<span class="tok-type">u8</span>, <span class="tok-builtin">@typeInfo</span>(Small).@"enum".fields[<span class="tok-number">1</span>].name, <span class="tok-str">"two"</span>));
}

<span class="tok-comment">// @tagName 给出枚举值的 [:0]const u8 表示:</span>
<span class="tok-kw">test</span> <span class="tok-str">"@tagName"</span> {
    <span class="tok-kw">try</span> expect(mem.eql(<span class="tok-type">u8</span>, <span class="tok-builtin">@tagName</span>(Small.three), <span class="tok-str">"three"</span>));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_enums.zig</kbd>
1/8 test_enums.test.enum ordinal value...OK
2/8 test_enums.test.set enum ordinal value...OK
3/8 test_enums.test.enum implicit ordinal values and overridden values...OK
4/8 test_enums.test.enum method...OK
5/8 test_enums.test.enum switch...OK
6/8 test_enums.test.std.meta.Tag...OK
7/8 test_enums.test.@typeInfo...OK
8/8 test_enums.test.@tagName...OK
All 8 tests passed.
</samp></pre></figure>

      <p>另见:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#typeInfo">@typeInfo</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#tagName">@tagName</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#sizeOf">@sizeOf</a></li>
</ul>


      <h3 id="extern-enum"><a href="https://ziglang.org/documentation/0.15.2/#toc-extern-enum">extern enum</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#extern-enum">§</a></h3>

      <p>
      默认情况下,枚举不保证与 C ABI 兼容:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">enum_export_error.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Foo = <span class="tok-kw">enum</span> { a, b, c };
<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">entry</span>(foo: Foo) <span class="tok-type">void</span> {
    _ = foo;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-obj enum_export_error.zig -target x86_64-linux</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/enum_export_error.zig:2:17: </span><span class="sgr-31m">error: </span><span class="sgr-1m">parameter of type 'enum_export_error.Foo' not allowed in function with calling convention 'x86_64_sysv'
</span>export fn entry(foo: Foo) void {
                <span class="sgr-32m">^~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/enum_export_error.zig:2:17: </span><span class="sgr-36m">note: </span><span class="sgr-1m">enum tag type 'u2' is not extern compatible
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/enum_export_error.zig:2:17: </span><span class="sgr-36m">note: </span><span class="sgr-1m">only integers with 0, 8, 16, 32, 64 and 128 bits are extern compatible
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/enum_export_error.zig:1:13: </span><span class="sgr-36m">note: </span><span class="sgr-1m">enum declared here
</span>const Foo = enum { a, b, c };
            <span class="sgr-32m">^~~~~~~~~~~~~~~~
</span><span class="sgr-2m">referenced by:
    root: /home/andy/dev/zig/lib/std/start.zig:3:22
    comptime: /home/andy/dev/zig/lib/std/start.zig:31:9
    2 reference(s) hidden; use '-freference-trace=4' to see all references
</span>
</samp></pre></figure>

      <p>
      对于 C ABI 兼容的枚举,为枚举提供显式标签类型:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">enum_export.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Foo = <span class="tok-kw">enum</span>(<span class="tok-type">c_int</span>) { a, b, c };
<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">entry</span>(foo: Foo) <span class="tok-type">void</span> {
    _ = foo;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-obj enum_export.zig</kbd>
</samp></pre></figure>

      

      <h3 id="Enum-Literals"><a href="https://ziglang.org/documentation/0.15.2/#toc-Enum-Literals">枚举字面量</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Enum-Literals">§</a></h3>

      <p>
      枚举字面量允许在不指定枚举类型的情况下指定枚举字段的名称:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_enum_literals.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Color = <span class="tok-kw">enum</span> {
    auto,
    off,
    on,
};

<span class="tok-kw">test</span> <span class="tok-str">"enum literals"</span> {
    <span class="tok-kw">const</span> color1: Color = .auto;
    <span class="tok-kw">const</span> color2 = Color.auto;
    <span class="tok-kw">try</span> expect(color1 == color2);
}

<span class="tok-kw">test</span> <span class="tok-str">"switch using enum literals"</span> {
    <span class="tok-kw">const</span> color = Color.on;
    <span class="tok-kw">const</span> result = <span class="tok-kw">switch</span> (color) {
        .auto =&gt; <span class="tok-null">false</span>,
        .on =&gt; <span class="tok-null">true</span>,
        .off =&gt; <span class="tok-null">false</span>,
    };
    <span class="tok-kw">try</span> expect(result);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_enum_literals.zig</kbd>
1/2 test_enum_literals.test.enum literals...OK
2/2 test_enum_literals.test.switch using enum literals...OK
All 2 tests passed.
</samp></pre></figure>

      

      <h3 id="Non-exhaustive-enum"><a href="https://ziglang.org/documentation/0.15.2/#toc-Non-exhaustive-enum">非穷尽枚举</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Non-exhaustive-enum">§</a></h3>

      <p>
      可以通过添加尾部 <code>_</code> 字段创建非穷尽枚举。
      枚举必须指定标签类型,并且不能消耗每个枚举值。
      </p>
      <p>
      对非穷尽枚举使用 <a href="https://ziglang.org/documentation/0.15.2/#enumFromInt">@enumFromInt</a> 涉及
      <a href="https://ziglang.org/documentation/0.15.2/#intCast">@intCast</a> 到整数标签类型的安全语义,但除此之外始终会产生
      定义良好的枚举值。
      </p>
      <p>
      对非穷尽枚举的 switch 可以包含 <code>_</code> 分支作为 <code><span class="tok-kw">else</span></code> 分支的替代。
      使用 <code>_</code> 分支时,如果 switch 未处理所有已知标签名称,编译器会报错。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_switch_non-exhaustive.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Number = <span class="tok-kw">enum</span>(<span class="tok-type">u8</span>) {
    one,
    two,
    three,
    _,
};

<span class="tok-kw">test</span> <span class="tok-str">"switch on non-exhaustive enum"</span> {
    <span class="tok-kw">const</span> number = Number.one;
    <span class="tok-kw">const</span> result = <span class="tok-kw">switch</span> (number) {
        .one =&gt; <span class="tok-null">true</span>,
        .two, .three =&gt; <span class="tok-null">false</span>,
        _ =&gt; <span class="tok-null">false</span>,
    };
    <span class="tok-kw">try</span> expect(result);
    <span class="tok-kw">const</span> is_one = <span class="tok-kw">switch</span> (number) {
        .one =&gt; <span class="tok-null">true</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
    };
    <span class="tok-kw">try</span> expect(is_one);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_switch_non-exhaustive.zig</kbd>
1/1 test_switch_non-exhaustive.test.switch on non-exhaustive enum...OK
All 1 tests passed.
</samp></pre></figure>

      
      

      <h2 id="union"><a href="https://ziglang.org/documentation/0.15.2/#toc-union">union</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#union">§</a></h2>

      <p>
      裸 <code><span class="tok-kw">union</span></code> 将值可以是的一组可能类型定义为字段列表。一次只能有一个字段处于活动状态。
      裸联合体的内存表示不受保证。
      裸联合体不能用于重新解释内存。为此,请使用 <a href="https://ziglang.org/documentation/0.15.2/#ptrCast">@ptrCast</a>,
      或使用具有保证内存布局的 <a href="https://ziglang.org/documentation/0.15.2/#extern-union">extern union</a> 或 <a href="https://ziglang.org/documentation/0.15.2/#packed-union">packed union</a>。
      <a href="https://ziglang.org/documentation/0.15.2/#Wrong-Union-Field-Access">访问非活动字段</a>是
      经过安全检查的<a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_wrong_union_access.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Payload = <span class="tok-kw">union</span> {
    int: <span class="tok-type">i64</span>,
    float: <span class="tok-type">f64</span>,
    boolean: <span class="tok-type">bool</span>,
};
<span class="tok-kw">test</span> <span class="tok-str">"simple union"</span> {
    <span class="tok-kw">var</span> payload = Payload{ .int = <span class="tok-number">1234</span> };
    payload.float = <span class="tok-number">12.34</span>;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_wrong_union_access.zig</kbd>
1/1 test_wrong_union_access.test.simple union...thread 2895385 panic: access of union field 'float' while field 'int' is active
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_wrong_union_access.zig:8:12</span>: <span class="sgr-2m">0x102c083 in test.simple union (test_wrong_union_access.zig)</span>
    payload.float = 12.34;
           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:218:25</span>: <span class="sgr-2m">0x115cdb0 in mainTerminal (test_runner.zig)</span>
        if (test_fn.func()) |_| {
                        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:66:28</span>: <span class="sgr-2m">0x1155fd1 in main (test_runner.zig)</span>
        return mainTerminal();
                           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x114fd6d in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x114f601 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
error: the following test command crashed:
/home/andy/dev/zig/.zig-cache/o/ceece336399a577bb1b9c6460feb4406/test --seed=0xa290ca33
</samp></pre></figure>

      <p>您可以通过赋值整个联合体来激活另一个字段:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_simple_union.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Payload = <span class="tok-kw">union</span> {
    int: <span class="tok-type">i64</span>,
    float: <span class="tok-type">f64</span>,
    boolean: <span class="tok-type">bool</span>,
};
<span class="tok-kw">test</span> <span class="tok-str">"simple union"</span> {
    <span class="tok-kw">var</span> payload = Payload{ .int = <span class="tok-number">1234</span> };
    <span class="tok-kw">try</span> expect(payload.int == <span class="tok-number">1234</span>);
    payload = Payload{ .float = <span class="tok-number">12.34</span> };
    <span class="tok-kw">try</span> expect(payload.float == <span class="tok-number">12.34</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_simple_union.zig</kbd>
1/1 test_simple_union.test.simple union...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      为了对联合体使用 <a href="https://ziglang.org/documentation/0.15.2/#switch">switch</a>,它必须是<a href="https://ziglang.org/documentation/0.15.2/#Tagged-union">标记联合体</a>。
      </p>
      <p>
      当标签是 <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a> 已知名称时,要初始化联合体,请参阅 <a href="https://ziglang.org/documentation/0.15.2/#unionInit">@unionInit</a>。
      </p>

      <h3 id="Tagged-union"><a href="https://ziglang.org/documentation/0.15.2/#toc-Tagged-union">标记联合体</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Tagged-union">§</a></h3>

      <p>联合体可以使用枚举标签类型声明。
      这会将联合体变成<em>标记</em>联合体,使其有资格
      与 <a href="https://ziglang.org/documentation/0.15.2/#switch">switch</a> 表达式一起使用。
      标记联合体强制转换为其标签类型:<a href="https://ziglang.org/documentation/0.15.2/#Type-Coercion-Unions-and-Enums">类型强制转换:联合体和枚举</a>。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_tagged_union.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> ComplexTypeTag = <span class="tok-kw">enum</span> {
    ok,
    not_ok,
};
<span class="tok-kw">const</span> ComplexType = <span class="tok-kw">union</span>(ComplexTypeTag) {
    ok: <span class="tok-type">u8</span>,
    not_ok: <span class="tok-type">void</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">"switch on tagged union"</span> {
    <span class="tok-kw">const</span> c = ComplexType{ .ok = <span class="tok-number">42</span> };
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@as</span>(ComplexTypeTag, c) == ComplexTypeTag.ok);

    <span class="tok-kw">switch</span> (c) {
        .ok =&gt; |value| <span class="tok-kw">try</span> expect(value == <span class="tok-number">42</span>),
        .not_ok =&gt; <span class="tok-kw">unreachable</span>,
    }
}

<span class="tok-kw">test</span> <span class="tok-str">"get tag type"</span> {
    <span class="tok-kw">try</span> expect(std.meta.Tag(ComplexType) == ComplexTypeTag);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_tagged_union.zig</kbd>
1/2 test_tagged_union.test.switch on tagged union...OK
2/2 test_tagged_union.test.get tag type...OK
All 2 tests passed.
</samp></pre></figure>

      <p>为了在 switch 表达式中修改标记联合体的有效负载,
      在变量名称前放置 <code>*</code> 使其成为指针:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_switch_modify_tagged_union.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> ComplexTypeTag = <span class="tok-kw">enum</span> {
    ok,
    not_ok,
};
<span class="tok-kw">const</span> ComplexType = <span class="tok-kw">union</span>(ComplexTypeTag) {
    ok: <span class="tok-type">u8</span>,
    not_ok: <span class="tok-type">void</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">"modify tagged union in switch"</span> {
    <span class="tok-kw">var</span> c = ComplexType{ .ok = <span class="tok-number">42</span> };

    <span class="tok-kw">switch</span> (c) {
        ComplexTypeTag.ok =&gt; |*value| value.* += <span class="tok-number">1</span>,
        ComplexTypeTag.not_ok =&gt; <span class="tok-kw">unreachable</span>,
    }

    <span class="tok-kw">try</span> expect(c.ok == <span class="tok-number">43</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_switch_modify_tagged_union.zig</kbd>
1/1 test_switch_modify_tagged_union.test.modify tagged union in switch...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      联合体可以推断枚举标签类型。
      此外,联合体可以像结构体和枚举一样具有方法。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_union_method.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Variant = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    int: <span class="tok-type">i32</span>,
    boolean: <span class="tok-type">bool</span>,

    <span class="tok-comment">// 推断枚举标签类型时可以省略 void。</span>
    none,

    <span class="tok-kw">fn</span> <span class="tok-fn">truthy</span>(self: Variant) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self) {
            Variant.int =&gt; |x_int| x_int != <span class="tok-number">0</span>,
            Variant.boolean =&gt; |x_bool| x_bool,
            Variant.none =&gt; <span class="tok-null">false</span>,
        };
    }
};

<span class="tok-kw">test</span> <span class="tok-str">"union method"</span> {
    <span class="tok-kw">var</span> v1: Variant = .{ .int = <span class="tok-number">1</span> };
    <span class="tok-kw">var</span> v2: Variant = .{ .boolean = <span class="tok-null">false</span> };
    <span class="tok-kw">var</span> v3: Variant = .none;

    <span class="tok-kw">try</span> expect(v1.truthy());
    <span class="tok-kw">try</span> expect(!v2.truthy());
    <span class="tok-kw">try</span> expect(!v3.truthy());
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_union_method.zig</kbd>
1/1 test_union_method.test.union method...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      具有推断枚举标签类型的联合体也可以为其推断标签分配序数值。
      这要求标签指定显式整数类型。
      <a href="https://ziglang.org/documentation/0.15.2/#intFromEnum">@intFromEnum</a> 可用于访问与活动字段对应的序数值。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_tagged_union_with_tag_values.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Tagged = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>(<span class="tok-type">u32</span>)) {
    int: <span class="tok-type">i64</span> = <span class="tok-number">123</span>,
    boolean: <span class="tok-type">bool</span> = <span class="tok-number">67</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">"tag values"</span> {
    <span class="tok-kw">const</span> int: Tagged = .{ .int = -<span class="tok-number">40</span> };
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(int) == <span class="tok-number">123</span>);

    <span class="tok-kw">const</span> boolean: Tagged = .{ .boolean = <span class="tok-null">false</span> };
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(boolean) == <span class="tok-number">67</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_tagged_union_with_tag_values.zig</kbd>
1/1 test_tagged_union_with_tag_values.test.tag values...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      <a href="https://ziglang.org/documentation/0.15.2/#tagName">@tagName</a> 可用于返回表示字段名称的 <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a>
      <code>[:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code> 值:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_tagName.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Small2 = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    a: <span class="tok-type">i32</span>,
    b: <span class="tok-type">bool</span>,
    c: <span class="tok-type">u8</span>,
};
<span class="tok-kw">test</span> <span class="tok-str">"@tagName"</span> {
    <span class="tok-kw">try</span> expect(std.mem.eql(<span class="tok-type">u8</span>, <span class="tok-builtin">@tagName</span>(Small2.a), <span class="tok-str">"a"</span>));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_tagName.zig</kbd>
1/1 test_tagName.test.@tagName...OK
All 1 tests passed.
</samp></pre></figure>

      

      <h3 id="extern-union"><a href="https://ziglang.org/documentation/0.15.2/#toc-extern-union">extern union</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#extern-union">§</a></h3>

      <p>
      <code><span class="tok-kw">extern</span> <span class="tok-kw">union</span></code> 的内存布局保证与目标 C ABI 兼容。
      </p>
      <p>另见:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#extern-struct">extern struct</a></li>
</ul>

      

      <h3 id="packed-union"><a href="https://ziglang.org/documentation/0.15.2/#toc-packed-union">packed union</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#packed-union">§</a></h3>

      <p><code><span class="tok-kw">packed</span> <span class="tok-kw">union</span></code> 具有定义良好的内存布局,并且有资格
          位于 <a href="https://ziglang.org/documentation/0.15.2/#packed-struct">packed struct</a> 中。</p>
      

      <h3 id="Anonymous-Union-Literals"><a href="https://ziglang.org/documentation/0.15.2/#toc-Anonymous-Union-Literals">匿名联合体字面量</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Anonymous-Union-Literals">§</a></h3>

      <p><a href="https://ziglang.org/documentation/0.15.2/#Anonymous-Struct-Literals">匿名结构体字面量</a>语法可用于在不指定类型的情况下初始化联合体:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_anonymous_union.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Number = <span class="tok-kw">union</span> {
    int: <span class="tok-type">i32</span>,
    float: <span class="tok-type">f64</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">"anonymous union literal syntax"</span> {
    <span class="tok-kw">const</span> i: Number = .{ .int = <span class="tok-number">42</span> };
    <span class="tok-kw">const</span> f = makeNumber();
    <span class="tok-kw">try</span> expect(i.int == <span class="tok-number">42</span>);
    <span class="tok-kw">try</span> expect(f.float == <span class="tok-number">12.34</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">makeNumber</span>() Number {
    <span class="tok-kw">return</span> .{ .float = <span class="tok-number">12.34</span> };
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_anonymous_union.zig</kbd>
1/1 test_anonymous_union.test.anonymous union literal syntax...OK
All 1 tests passed.
</samp></pre></figure>

      

      

      <h2 id="opaque"><a href="https://ziglang.org/documentation/0.15.2/#toc-opaque">opaque</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#opaque">§</a></h2>

      <p>
      <code><span class="tok-kw">opaque</span> {}</code> 声明一个具有未知(但非零)大小和对齐方式的新类型。
      它可以包含与 <a href="https://ziglang.org/documentation/0.15.2/#struct">structs</a>、<a href="https://ziglang.org/documentation/0.15.2/#union">unions</a> 和
      <a href="https://ziglang.org/documentation/0.15.2/#enum">enums</a> 相同的声明。
      </p>
      <p>
      这通常用于与不公开结构体详细信息的 C 代码交互时的类型安全。
      示例:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_opaque.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Derp = <span class="tok-kw">opaque</span> {};
<span class="tok-kw">const</span> Wat = <span class="tok-kw">opaque</span> {};

<span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">bar</span>(d: *Derp) <span class="tok-type">void</span>;
<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(w: *Wat) <span class="tok-kw">callconv</span>(.c) <span class="tok-type">void</span> {
    bar(w);
}

<span class="tok-kw">test</span> <span class="tok-str">"call foo"</span> {
    foo(<span class="tok-null">undefined</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_opaque.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_opaque.zig:6:9: </span><span class="sgr-31m">error: </span><span class="sgr-1m">expected type '*test_opaque.Derp', found '*test_opaque.Wat'
</span>    bar(w);
        <span class="sgr-32m">^
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_opaque.zig:6:9: </span><span class="sgr-36m">note: </span><span class="sgr-1m">pointer type child 'test_opaque.Wat' cannot cast into pointer type child 'test_opaque.Derp'
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_opaque.zig:2:13: </span><span class="sgr-36m">note: </span><span class="sgr-1m">opaque declared here
</span>const Wat = opaque {};
            <span class="sgr-32m">^~~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_opaque.zig:1:14: </span><span class="sgr-36m">note: </span><span class="sgr-1m">opaque declared here
</span>const Derp = opaque {};
             <span class="sgr-32m">^~~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_opaque.zig:4:18: </span><span class="sgr-36m">note: </span><span class="sgr-1m">parameter type declared here
</span>extern fn bar(d: *Derp) void;
                 <span class="sgr-32m">^~~~~
</span><span class="sgr-2m">referenced by:
    test.call foo: /home/andy/dev/zig/doc/langref/test_opaque.zig:10:8
</span>
</samp></pre></figure>

      

      <h2 id="Blocks"><a href="https://ziglang.org/documentation/0.15.2/#toc-Blocks">块</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Blocks">§</a></h2>

      <p>
      块用于限制变量声明的作用域:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_blocks.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">"access variable after block scope"</span> {
    {
        <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
        _ = &amp;x;
    }
    x += <span class="tok-number">1</span>;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_blocks.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_blocks.zig:6:5: </span><span class="sgr-31m">error: </span><span class="sgr-1m">use of undeclared identifier 'x'
</span>    x += 1;
    <span class="sgr-32m">^
</span>
</samp></pre></figure>

      <p>块是表达式。当带有标签时,<code><span class="tok-kw">break</span></code> 可用于
      从块返回值:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_labeled_break.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"labeled break from labeled block expression"</span> {
    <span class="tok-kw">var</span> y: <span class="tok-type">i32</span> = <span class="tok-number">123</span>;

    <span class="tok-kw">const</span> x = blk: {
        y += <span class="tok-number">1</span>;
        <span class="tok-kw">break</span> :blk y;
    };
    <span class="tok-kw">try</span> expect(x == <span class="tok-number">124</span>);
    <span class="tok-kw">try</span> expect(y == <span class="tok-number">124</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_labeled_break.zig</kbd>
1/1 test_labeled_break.test.labeled break from labeled block expression...OK
All 1 tests passed.
</samp></pre></figure>

      <p>这里,<code>blk</code> 可以是任何名称。</p>
      <p>另见:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Labeled-while">带标签的 while</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Labeled-for">带标签的 for</a></li>
</ul>


      <h3 id="Shadowing"><a href="https://ziglang.org/documentation/0.15.2/#toc-Shadowing">遮蔽</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Shadowing">§</a></h3>

      <p><a href="https://ziglang.org/documentation/0.15.2/#Identifiers">标识符</a>永远不允许通过使用相同名称来"隐藏"其他标识符:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_shadowing.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> pi = <span class="tok-number">3.14</span>;

<span class="tok-kw">test</span> <span class="tok-str">"inside test block"</span> {
    <span class="tok-comment">// 让我们甚至进入另一个块</span>
    {
        <span class="tok-kw">var</span> pi: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_shadowing.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_shadowing.zig:6:13: </span><span class="sgr-31m">error: </span><span class="sgr-1m">local variable shadows declaration of 'pi'
</span>        var pi: i32 = 1234;
            <span class="sgr-32m">^~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_shadowing.zig:1:1: </span><span class="sgr-36m">note: </span><span class="sgr-1m">declared here
</span>const pi = 3.14;
<span class="sgr-32m">^~~~~~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>
      因此,当您阅读 Zig 代码时,您始终可以依赖标识符在其定义的作用域内始终如一地表示相同的含义。但是请注意,如果
      作用域是分开的,则可以使用相同的名称:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_scopes.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">"separate scopes"</span> {
    {
        <span class="tok-kw">const</span> pi = <span class="tok-number">3.14</span>;
        _ = pi;
    }
    {
        <span class="tok-kw">var</span> pi: <span class="tok-type">bool</span> = <span class="tok-null">true</span>;
        _ = &amp;pi;
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_scopes.zig</kbd>
1/1 test_scopes.test.separate scopes...OK
All 1 tests passed.
</samp></pre></figure>

      

      <h3 id="Empty-Blocks"><a href="https://ziglang.org/documentation/0.15.2/#toc-Empty-Blocks">空块</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Empty-Blocks">§</a></h3>

      <p>空块等同于 <code><span class="tok-type">void</span>{}</code>:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_empty_block.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> {
    <span class="tok-kw">const</span> a = {};
    <span class="tok-kw">const</span> b = <span class="tok-type">void</span>{};
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(a) == <span class="tok-type">void</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(b) == <span class="tok-type">void</span>);
    <span class="tok-kw">try</span> expect(a == b);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_empty_block.zig</kbd>
1/1 test_empty_block.test_0...OK
All 1 tests passed.
</samp></pre></figure>

      
      

      <h2 id="switch"><a href="https://ziglang.org/documentation/0.15.2/#toc-switch">switch</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#switch">§</a></h2>

      <figure><figcaption class="zig-cap"><cite class="file">test_switch.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">"builtin"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"switch simple"</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">u64</span> = <span class="tok-number">10</span>;
    <span class="tok-kw">const</span> zz: <span class="tok-type">u64</span> = <span class="tok-number">103</span>;

    <span class="tok-comment">// switch 表达式的所有分支必须能够被强制转换为</span>
    <span class="tok-comment">// 通用类型。</span>
    <span class="tok-comment">//</span>
    <span class="tok-comment">// 分支不能贯穿。如果需要贯穿行为,请组合</span>
    <span class="tok-comment">// case 并使用 if。</span>
    <span class="tok-kw">const</span> b = <span class="tok-kw">switch</span> (a) {
        <span class="tok-comment">// 可以通过 ',' 组合多个 case</span>
        <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span> =&gt; <span class="tok-number">0</span>,

        <span class="tok-comment">// 可以使用 ... 语法指定范围。这些范围包含</span>
        <span class="tok-comment">// 两端。</span>
        <span class="tok-number">5</span>...<span class="tok-number">100</span> =&gt; <span class="tok-number">1</span>,

        <span class="tok-comment">// 分支可以任意复杂。</span>
        <span class="tok-number">101</span> =&gt; blk: {
            <span class="tok-kw">const</span> c: <span class="tok-type">u64</span> = <span class="tok-number">5</span>;
            <span class="tok-kw">break</span> :blk c * <span class="tok-number">2</span> + <span class="tok-number">1</span>;
        },

        <span class="tok-comment">// 允许对任意表达式进行 switch,只要该</span>
        <span class="tok-comment">// 表达式在编译时已知。</span>
        zz =&gt; zz,
        blk: {
            <span class="tok-kw">const</span> d: <span class="tok-type">u32</span> = <span class="tok-number">5</span>;
            <span class="tok-kw">const</span> e: <span class="tok-type">u32</span> = <span class="tok-number">100</span>;
            <span class="tok-kw">break</span> :blk d + e;
        } =&gt; <span class="tok-number">107</span>,

        <span class="tok-comment">// else 分支捕获所有尚未捕获的内容。</span>
        <span class="tok-comment">// 除非处理整个值范围,否则 else 分支是</span>
        <span class="tok-comment">// 强制性的。</span>
        <span class="tok-kw">else</span> =&gt; <span class="tok-number">9</span>,
    };

    <span class="tok-kw">try</span> expect(b == <span class="tok-number">1</span>);
}

<span class="tok-comment">// Switch 表达式可以在函数外部使用:</span>
<span class="tok-kw">const</span> os_msg = <span class="tok-kw">switch</span> (builtin.target.os.tag) {
    .linux =&gt; <span class="tok-str">"we found a linux user"</span>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-str">"not a linux user"</span>,
};

<span class="tok-comment">// 在函数内部,如果目标表达式在编译时已知,</span>
<span class="tok-comment">// switch 语句会隐式地在编译时求值。</span>
<span class="tok-kw">test</span> <span class="tok-str">"switch inside function"</span> {
    <span class="tok-kw">switch</span> (builtin.target.os.tag) {
        .fuchsia =&gt; {
            <span class="tok-comment">// 在 fuchsia 以外的操作系统上,块甚至不会被分析,</span>
            <span class="tok-comment">// 因此不会触发此编译错误。</span>
            <span class="tok-comment">// 在 fuchsia 上会触发此编译错误。</span>
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">"fuchsia not supported"</span>);
        },
        <span class="tok-kw">else</span> =&gt; {},
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_switch.zig</kbd>
1/2 test_switch.test.switch simple...OK
2/2 test_switch.test.switch inside function...OK
All 2 tests passed.
</samp></pre></figure>

      <p>
      <code><span class="tok-kw">switch</span></code> 可用于捕获<a href="https://ziglang.org/documentation/0.15.2/#Tagged-union">标记联合体</a>的字段值。可以通过在捕获变量名称前放置 <code>*</code> 来修改字段值,
      将其转换为指针。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_switch_tagged_union.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"switch on tagged union"</span> {
    <span class="tok-kw">const</span> Point = <span class="tok-kw">struct</span> {
        x: <span class="tok-type">u8</span>,
        y: <span class="tok-type">u8</span>,
    };
    <span class="tok-kw">const</span> Item = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        a: <span class="tok-type">u32</span>,
        c: Point,
        d,
        e: <span class="tok-type">u32</span>,
    };

    <span class="tok-kw">var</span> a = Item{ .c = Point{ .x = <span class="tok-number">1</span>, .y = <span class="tok-number">2</span> } };

    <span class="tok-comment">// 允许对更复杂的枚举进行 switch。</span>
    <span class="tok-kw">const</span> b = <span class="tok-kw">switch</span> (a) {
        <span class="tok-comment">// 匹配允许使用捕获组,并将返回匹配的枚举</span>
        <span class="tok-comment">// 值。如果两个 case 的有效负载类型相同,</span>
        <span class="tok-comment">// 它们可以放入同一个 switch 分支。</span>
        Item.a, Item.e =&gt; |item| item,

        <span class="tok-comment">// 可以使用 `*` 语法获取匹配值的引用。</span>
        Item.c =&gt; |*item| blk: {
            item.*.x += <span class="tok-number">1</span>;
            <span class="tok-kw">break</span> :blk <span class="tok-number">6</span>;
        },

        <span class="tok-comment">// 如果 case 类型穷尽处理,则不需要 else</span>
        Item.d =&gt; <span class="tok-number">8</span>,
    };

    <span class="tok-kw">try</span> expect(b == <span class="tok-number">6</span>);
    <span class="tok-kw">try</span> expect(a.c.x == <span class="tok-number">2</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_switch_tagged_union.zig</kbd>
1/1 test_switch_tagged_union.test.switch on tagged union...OK
All 1 tests passed.
</samp></pre></figure>

      <p>另见:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#enum">enum</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#compileError">@compileError</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Compile-Variables">编译变量</a></li>
</ul>


      <h3 id="Exhaustive-Switching"><a href="https://ziglang.org/documentation/0.15.2/#toc-Exhaustive-Switching">穷尽 Switch</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Exhaustive-Switching">§</a></h3>

      <p>
      当 <code><span class="tok-kw">switch</span></code> 表达式没有 <code><span class="tok-kw">else</span></code> 子句时,
      它必须穷尽地列出所有可能的值。不这样做会导致编译错误:
      </p>
<!-- ====== END CHUNK 5: new_05.html ====== -->

<!-- ====== BEGIN CHUNK 6: new_06.html ====== -->
<figure><figcaption class="zig-cap"><cite class="file">test_unhandled_enumeration_value.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Color = <span class="tok-kw">enum</span> {
    auto,
    off,
    on,
};

<span class="tok-kw">test</span> <span class="tok-str">"穷尽切换"</span> {
    <span class="tok-kw">const</span> color = Color.off;
    <span class="tok-kw">switch</span> (color) {
        Color.auto =&gt; {},
        Color.on =&gt; {},
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_unhandled_enumeration_value.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_unhandled_enumeration_value.zig:9:5: </span><span class="sgr-31m">error: </span><span class="sgr-1m">switch 必须处理所有可能性
</span>    switch (color) {
    <span class="sgr-32m">^~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_unhandled_enumeration_value.zig:3:5: </span><span class="sgr-36m">note: </span><span class="sgr-1m">未处理的枚举值: 'off'
</span>    off,
    <span class="sgr-32m">^~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_unhandled_enumeration_value.zig:1:15: </span><span class="sgr-36m">note: </span><span class="sgr-1m">枚举 'test_unhandled_enumeration_value.Color' 在此声明
</span>const Color = enum {
              <span class="sgr-32m">^~~~
</span>
</samp></pre></figure>

      

      <h3 id="Switching-with-Enum-Literals"><a href="https://ziglang.org/documentation/0.15.2/#toc-Switching-with-Enum-Literals">使用枚举字面量进行切换</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Switching-with-Enum-Literals">§</a></h3>

      <p>
      <a href="https://ziglang.org/documentation/0.15.2/#Enum-Literals">枚举字面量</a>可以方便地与 <code><span class="tok-kw">switch</span></code> 一起使用，以避免
      重复指定<a href="https://ziglang.org/documentation/0.15.2/#enum">枚举</a>或<a href="https://ziglang.org/documentation/0.15.2/#union">联合</a>类型:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_exhaustive_switch.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Color = <span class="tok-kw">enum</span> {
    auto,
    off,
    on,
};

<span class="tok-kw">test</span> <span class="tok-str">"switch 中的枚举字面量"</span> {
    <span class="tok-kw">const</span> color = Color.off;
    <span class="tok-kw">const</span> result = <span class="tok-kw">switch</span> (color) {
        .auto =&gt; <span class="tok-null">false</span>,
        .on =&gt; <span class="tok-null">false</span>,
        .off =&gt; <span class="tok-null">true</span>,
    };
    <span class="tok-kw">try</span> expect(result);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_exhaustive_switch.zig</kbd>
1/1 test_exhaustive_switch.test.switch 中的枚举字面量...OK
All 1 tests passed.
</samp></pre></figure>

      

      <h3 id="Labeled-switch"><a href="https://ziglang.org/documentation/0.15.2/#toc-Labeled-switch">带标签的 switch</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Labeled-switch">§</a></h3>

      <p>
      当 switch 语句带有标签时，可以从
      <code><span class="tok-kw">break</span></code> 或 <code><span class="tok-kw">continue</span></code> 中引用它。
      <code><span class="tok-kw">break</span></code> 将从 <code><span class="tok-kw">switch</span></code> 返回一个值。
      </p>
      <p>
      针对 switch 的 <code><span class="tok-kw">continue</span></code> 必须有一个
      操作数。当执行时，它将跳转到匹配的分支，就好像
      <code><span class="tok-kw">switch</span></code> 使用 <code><span class="tok-kw">continue</span></code> 的操作数替换初始 switch 值再次执行一样。
      </p>

      <figure><figcaption class="zig-cap"><cite class="file">test_switch_continue.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">test</span> <span class="tok-str">"switch continue"</span> {
    sw: <span class="tok-kw">switch</span> (<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">5</span>)) {
        <span class="tok-number">5</span> =&gt; <span class="tok-kw">continue</span> :sw <span class="tok-number">4</span>,

        <span class="tok-comment">// `continue` 可以在单个 switch 分支中多次出现。</span>
        <span class="tok-number">2</span>...<span class="tok-number">4</span> =&gt; |v| {
            <span class="tok-kw">if</span> (v &gt; <span class="tok-number">3</span>) {
                <span class="tok-kw">continue</span> :sw <span class="tok-number">2</span>;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (v == <span class="tok-number">3</span>) {

                <span class="tok-comment">// `break` 可以针对带标签的循环。</span>
                <span class="tok-kw">break</span> :sw;
            }

            <span class="tok-kw">continue</span> :sw <span class="tok-number">1</span>;
        },

        <span class="tok-number">1</span> =&gt; <span class="tok-kw">return</span>,

        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_switch_continue.zig</kbd>
1/1 test_switch_continue.test.switch continue...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      从语义上讲，这等价于以下循环:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_switch_continue_equivalent.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">test</span> <span class="tok-str">"switch continue, 等价循环"</span> {
    <span class="tok-kw">var</span> sw: <span class="tok-type">i32</span> = <span class="tok-number">5</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">switch</span> (sw) {
            <span class="tok-number">5</span> =&gt; {
                sw = <span class="tok-number">4</span>;
                <span class="tok-kw">continue</span>;
            },
            <span class="tok-number">2</span>...<span class="tok-number">4</span> =&gt; |v| {
                <span class="tok-kw">if</span> (v &gt; <span class="tok-number">3</span>) {
                    sw = <span class="tok-number">2</span>;
                    <span class="tok-kw">continue</span>;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (v == <span class="tok-number">3</span>) {
                    <span class="tok-kw">break</span>;
                }

                sw = <span class="tok-number">1</span>;
                <span class="tok-kw">continue</span>;
            },
            <span class="tok-number">1</span> =&gt; <span class="tok-kw">return</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_switch_continue_equivalent.zig</kbd>
1/1 test_switch_continue_equivalent.test.switch continue, 等价循环...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      这可以提高(例如)状态机的清晰度，其中语法 <code><span class="tok-kw">continue</span> :sw .next_state</code> 是明确的、显式的且易于理解。
      </p>
      <p>
      然而，这个功能的设计初衷是对数组的每个元素进行 switch，其中使用单个 switch 可以提高清晰度和性能:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_switch_dispatch_loop.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expectEqual = std.testing.expectEqual;

<span class="tok-kw">const</span> Instruction = <span class="tok-kw">enum</span> {
    add,
    mul,
    end,
};

<span class="tok-kw">fn</span> <span class="tok-fn">evaluate</span>(initial_stack: []<span class="tok-kw">const</span> <span class="tok-type">i32</span>, code: []<span class="tok-kw">const</span> Instruction) !<span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> buffer: [<span class="tok-number">8</span>]<span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> stack = std.ArrayListUnmanaged(<span class="tok-type">i32</span>).initBuffer(&amp;buffer);
    <span class="tok-kw">try</span> stack.appendSliceBounded(initial_stack);
    <span class="tok-kw">var</span> ip: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

    <span class="tok-kw">return</span> vm: <span class="tok-kw">switch</span> (code[ip]) {
        <span class="tok-comment">// 因为 `continue` 之后的所有代码都是不可达的，这个分支不会</span>
        <span class="tok-comment">// 提供结果。</span>
        .add =&gt; {
            <span class="tok-kw">try</span> stack.appendBounded(stack.pop().? + stack.pop().?);

            ip += <span class="tok-number">1</span>;
            <span class="tok-kw">continue</span> :vm code[ip];
        },
        .mul =&gt; {
            <span class="tok-kw">try</span> stack.appendBounded(stack.pop().? * stack.pop().?);

            ip += <span class="tok-number">1</span>;
            <span class="tok-kw">continue</span> :vm code[ip];
        },
        .end =&gt; stack.pop().?,
    };
}

<span class="tok-kw">test</span> <span class="tok-str">"evaluate"</span> {
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> evaluate(&amp;.{ <span class="tok-number">7</span>, <span class="tok-number">2</span>, -<span class="tok-number">3</span> }, &amp;.{ .mul, .add, .end });
    <span class="tok-kw">try</span> expectEqual(<span class="tok-number">1</span>, result);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_switch_dispatch_loop.zig</kbd>
1/1 test_switch_dispatch_loop.test.evaluate...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      如果 <code><span class="tok-kw">continue</span></code> 的操作数是
      <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a> 已知的，那么它可以被降低为对相关 case 的无条件分支。这样的分支被完美预测，因此
      通常执行速度非常快。
      </p>

      <p>
      如果操作数是运行时已知的，每个 <code><span class="tok-kw">continue</span></code> 都可以
      内联嵌入条件分支(理想情况下通过跳转表)，这
      允许 CPU 独立于任何其他分支预测其目标。基于
      循环的降低会强制每个分支通过相同的分派点，阻碍分支预测。
      </p>


      

      <h3 id="Inline-Switch-Prongs"><a href="https://ziglang.org/documentation/0.15.2/#toc-Inline-Switch-Prongs">内联 Switch 分支</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Inline-Switch-Prongs">§</a></h3>

      <p>
      Switch 分支可以标记为 <code><span class="tok-kw">inline</span></code> 以为其可能具有的每个值生成
      该分支的主体，使捕获的值成为<a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a>。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_inline_switch.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;
<span class="tok-kw">const</span> expectError = std.testing.expectError;

<span class="tok-kw">fn</span> <span class="tok-fn">isFieldOptional</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, field_index: <span class="tok-type">usize</span>) !<span class="tok-type">bool</span> {
    <span class="tok-kw">const</span> fields = <span class="tok-builtin">@typeInfo</span>(T).@"struct".fields;
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (field_index) {
        <span class="tok-comment">// 这个分支被分析两次，每次 `idx` 都是一个</span>
        <span class="tok-comment">// 编译期已知的值。</span>
        <span class="tok-kw">inline</span> <span class="tok-number">0</span>, <span class="tok-number">1</span> =&gt; |idx| <span class="tok-builtin">@typeInfo</span>(fields[idx].<span class="tok-type">type</span>) == .optional,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IndexOutOfBounds,
    };
}

<span class="tok-kw">const</span> Struct1 = <span class="tok-kw">struct</span> { a: <span class="tok-type">u32</span>, b: ?<span class="tok-type">u32</span> };

<span class="tok-kw">test</span> <span class="tok-str">"将 @typeInfo 用于运行时值"</span> {
    <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">try</span> expect(!<span class="tok-kw">try</span> isFieldOptional(Struct1, index));
    index += <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> expect(<span class="tok-kw">try</span> isFieldOptional(Struct1, index));
    index += <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> expectError(<span class="tok-kw">error</span>.IndexOutOfBounds, isFieldOptional(Struct1, index));
}

<span class="tok-comment">// 对 `Struct1` 的 `isFieldOptional` 调用被展开为等价于</span>
<span class="tok-comment">// 这个函数:</span>
<span class="tok-kw">fn</span> <span class="tok-fn">isFieldOptionalUnrolled</span>(field_index: <span class="tok-type">usize</span>) !<span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (field_index) {
        <span class="tok-number">0</span> =&gt; <span class="tok-null">false</span>,
        <span class="tok-number">1</span> =&gt; <span class="tok-null">true</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IndexOutOfBounds,
    };
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_inline_switch.zig</kbd>
1/1 test_inline_switch.test.将 @typeInfo 用于运行时值...OK
All 1 tests passed.
</samp></pre></figure>

      <p><code><span class="tok-kw">inline</span></code> 关键字也可以与范围结合使用:</p>
      <figure><figcaption class="zig-cap"><cite class="file">inline_prong_range.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">isFieldOptional</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, field_index: <span class="tok-type">usize</span>) !<span class="tok-type">bool</span> {
    <span class="tok-kw">const</span> fields = <span class="tok-builtin">@typeInfo</span>(T).@"struct".fields;
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (field_index) {
        <span class="tok-kw">inline</span> <span class="tok-number">0</span>...fields.len - <span class="tok-number">1</span> =&gt; |idx| <span class="tok-builtin">@typeInfo</span>(fields[idx].<span class="tok-type">type</span>) == .optional,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IndexOutOfBounds,
    };
}</code></pre></figure>

      <p>
      <code><span class="tok-kw">inline</span> <span class="tok-kw">else</span></code> 分支可以用作
      <code><span class="tok-kw">inline</span> <span class="tok-kw">for</span></code> 循环的类型安全替代:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_inline_else.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> SliceTypeA = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
    len: <span class="tok-type">usize</span>,
    ptr: [*]<span class="tok-type">u32</span>,
};
<span class="tok-kw">const</span> SliceTypeB = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
    ptr: [*]SliceTypeA,
    len: <span class="tok-type">usize</span>,
};
<span class="tok-kw">const</span> AnySlice = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    a: SliceTypeA,
    b: SliceTypeB,
    c: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    d: []AnySlice,
};

<span class="tok-kw">fn</span> <span class="tok-fn">withFor</span>(any: AnySlice) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> Tag = <span class="tok-builtin">@typeInfo</span>(AnySlice).@"union".tag_type.?;
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(Tag).@"enum".fields) |field| {
        <span class="tok-comment">// 使用 `inline for` 函数被生成为</span>
        <span class="tok-comment">// 一系列 `if` 语句，依赖优化器</span>
        <span class="tok-comment">// 将其转换为 switch。</span>
        <span class="tok-kw">if</span> (field.value == <span class="tok-builtin">@intFromEnum</span>(any)) {
            <span class="tok-kw">return</span> <span class="tok-builtin">@field</span>(any, field.name).len;
        }
    }
    <span class="tok-comment">// 当使用 `inline for` 时，编译器不知道每个</span>
    <span class="tok-comment">// 可能的情况都已处理，需要显式的 `unreachable`。</span>
    <span class="tok-kw">unreachable</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">withSwitch</span>(any: AnySlice) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (any) {
        <span class="tok-comment">// 使用 `inline else` 函数被显式生成为</span>
        <span class="tok-comment">// 所需的 switch，编译器可以检查</span>
        <span class="tok-comment">// 每个可能的情况是否已处理。</span>
        <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |slice| slice.len,
    };
}

<span class="tok-kw">test</span> <span class="tok-str">"inline for 和 inline else 的相似性"</span> {
    <span class="tok-kw">const</span> any = AnySlice{ .c = <span class="tok-str">"hello"</span> };
    <span class="tok-kw">try</span> expect(withFor(any) == <span class="tok-number">5</span>);
    <span class="tok-kw">try</span> expect(withSwitch(any) == <span class="tok-number">5</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_inline_else.zig</kbd>
1/1 test_inline_else.test.inline for 和 inline else 的相似性...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      当对联合使用内联分支时，可以使用额外的捕获来获取联合的枚举标签值。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_inline_switch_union_tag.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> U = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    a: <span class="tok-type">u32</span>,
    b: <span class="tok-type">f32</span>,
};

<span class="tok-kw">fn</span> <span class="tok-fn">getNum</span>(u: U) <span class="tok-type">u32</span> {
    <span class="tok-kw">switch</span> (u) {
        <span class="tok-comment">// 这里 `num` 是一个运行时已知值，它要么是</span>
        <span class="tok-comment">// `u.a` 要么是 `u.b`，而 `tag` 是 `u` 的编译期已知标签值。</span>
        <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |num, tag| {
            <span class="tok-kw">if</span> (tag == .b) {
                <span class="tok-kw">return</span> <span class="tok-builtin">@intFromFloat</span>(num);
            }
            <span class="tok-kw">return</span> num;
        },
    }
}

<span class="tok-kw">test</span> <span class="tok-str">"test"</span> {
    <span class="tok-kw">const</span> u = U{ .b = <span class="tok-number">42</span> };
    <span class="tok-kw">try</span> expect(getNum(u) == <span class="tok-number">42</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_inline_switch_union_tag.zig</kbd>
1/1 test_inline_switch_union_tag.test.test...OK
All 1 tests passed.
</samp></pre></figure>

      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#inline-while">内联 while</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#inline-for">内联 for</a></li>
</ul>

      
      

      <h2 id="while"><a href="https://ziglang.org/documentation/0.15.2/#toc-while">while</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#while">§</a></h2>

      <p>
      while 循环用于重复执行表达式，直到某个条件不再为真。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_while.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"while 基础"</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">10</span>) {
        i += <span class="tok-number">1</span>;
    }
    <span class="tok-kw">try</span> expect(i == <span class="tok-number">10</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_while.zig</kbd>
1/1 test_while.test.while 基础...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      使用 <code><span class="tok-kw">break</span></code> 提前退出 while 循环。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_while_break.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"while break"</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">if</span> (i == <span class="tok-number">10</span>)
            <span class="tok-kw">break</span>;
        i += <span class="tok-number">1</span>;
    }
    <span class="tok-kw">try</span> expect(i == <span class="tok-number">10</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_while_break.zig</kbd>
1/1 test_while_break.test.while break...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      使用 <code><span class="tok-kw">continue</span></code> 跳回循环的开头。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_while_continue.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"while continue"</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        i += <span class="tok-number">1</span>;
        <span class="tok-kw">if</span> (i &lt; <span class="tok-number">10</span>)
            <span class="tok-kw">continue</span>;
        <span class="tok-kw">break</span>;
    }
    <span class="tok-kw">try</span> expect(i == <span class="tok-number">10</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_while_continue.zig</kbd>
1/1 test_while_continue.test.while continue...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      while 循环支持 continue 表达式，它在循环继续时执行。<code><span class="tok-kw">continue</span></code> 关键字会遵守这个表达式。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_while_continue_expression.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"while 循环 continue 表达式"</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">10</span>) : (i += <span class="tok-number">1</span>) {}
    <span class="tok-kw">try</span> expect(i == <span class="tok-number">10</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"while 循环 continue 表达式, 更复杂"</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">var</span> j: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">while</span> (i * j &lt; <span class="tok-number">2000</span>) : ({
        i *= <span class="tok-number">2</span>;
        j *= <span class="tok-number">3</span>;
    }) {
        <span class="tok-kw">const</span> my_ij = i * j;
        <span class="tok-kw">try</span> expect(my_ij &lt; <span class="tok-number">2000</span>);
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_while_continue_expression.zig</kbd>
1/2 test_while_continue_expression.test.while 循环 continue 表达式...OK
2/2 test_while_continue_expression.test.while 循环 continue 表达式, 更复杂...OK
All 2 tests passed.
</samp></pre></figure>

      <p>
      while 循环是表达式。表达式的结果是 while 循环的 <code><span class="tok-kw">else</span></code> 子句的结果，该子句在 while 循环的条件测试为 false 时执行。
      </p>
      <p>
      <code><span class="tok-kw">break</span></code>，类似于 <code><span class="tok-kw">return</span></code>，接受一个值参数。这是 <code><span class="tok-kw">while</span></code> 表达式的结果。
                  当你从 while 循环 <code><span class="tok-kw">break</span></code> 时，<code><span class="tok-kw">else</span></code> 分支不会被求值。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_while_else.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"while else"</span> {
    <span class="tok-kw">try</span> expect(rangeHasNumber(<span class="tok-number">0</span>, <span class="tok-number">10</span>, <span class="tok-number">5</span>));
    <span class="tok-kw">try</span> expect(!rangeHasNumber(<span class="tok-number">0</span>, <span class="tok-number">10</span>, <span class="tok-number">15</span>));
}

<span class="tok-kw">fn</span> <span class="tok-fn">rangeHasNumber</span>(begin: <span class="tok-type">usize</span>, end: <span class="tok-type">usize</span>, number: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">var</span> i = begin;
    <span class="tok-kw">return</span> <span class="tok-kw">while</span> (i &lt; end) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (i == number) {
            <span class="tok-kw">break</span> <span class="tok-null">true</span>;
        }
    } <span class="tok-kw">else</span> <span class="tok-null">false</span>;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_while_else.zig</kbd>
1/1 test_while_else.test.while else...OK
All 1 tests passed.
</samp></pre></figure>

      <h3 id="Labeled-while"><a href="https://ziglang.org/documentation/0.15.2/#toc-Labeled-while">带标签的 while</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Labeled-while">§</a></h3>

      <p>当 <code><span class="tok-kw">while</span></code> 循环带有标签时，可以从嵌套循环内的 <code><span class="tok-kw">break</span></code>
              或 <code><span class="tok-kw">continue</span></code> 中引用它:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_while_nested_break.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">"嵌套 break"</span> {
    outer: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">break</span> :outer;
        }
    }
}

<span class="tok-kw">test</span> <span class="tok-str">"嵌套 continue"</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    outer: <span class="tok-kw">while</span> (i &lt; <span class="tok-number">10</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">continue</span> :outer;
        }
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_while_nested_break.zig</kbd>
1/2 test_while_nested_break.test.嵌套 break...OK
2/2 test_while_nested_break.test.嵌套 continue...OK
All 2 tests passed.
</samp></pre></figure>

      
      <h3 id="while-with-Optionals"><a href="https://ziglang.org/documentation/0.15.2/#toc-while-with-Optionals">while 与可选值</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#while-with-Optionals">§</a></h3>

      <p>
      就像 <a href="https://ziglang.org/documentation/0.15.2/#if">if</a> 表达式一样，while 循环可以将可选值作为条件并捕获负载。当遇到 <a href="https://ziglang.org/documentation/0.15.2/#null">null</a> 时循环退出。
      </p>
      <p>
      当 <code>|x|</code> 语法出现在 <code><span class="tok-kw">while</span></code> 表达式上时，
      while 条件必须具有<a href="https://ziglang.org/documentation/0.15.2/#Optional-Type">可选类型</a>。
      </p>
      <p>
      <code><span class="tok-kw">else</span></code> 分支在可选迭代中是允许的。在这种情况下，它将在遇到第一个 null 值时执行。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_while_null_capture.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"while null 捕获"</span> {
    <span class="tok-kw">var</span> sum1: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    numbers_left = <span class="tok-number">3</span>;
    <span class="tok-kw">while</span> (eventuallyNullSequence()) |value| {
        sum1 += value;
    }
    <span class="tok-kw">try</span> expect(sum1 == <span class="tok-number">3</span>);

    <span class="tok-comment">// null 捕获与 else 块</span>
    <span class="tok-kw">var</span> sum2: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    numbers_left = <span class="tok-number">3</span>;
    <span class="tok-kw">while</span> (eventuallyNullSequence()) |value| {
        sum2 += value;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">try</span> expect(sum2 == <span class="tok-number">3</span>);
    }

    <span class="tok-comment">// null 捕获与 continue 表达式</span>
    <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> sum3: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    numbers_left = <span class="tok-number">3</span>;
    <span class="tok-kw">while</span> (eventuallyNullSequence()) |value| : (i += <span class="tok-number">1</span>) {
        sum3 += value;
    }
    <span class="tok-kw">try</span> expect(i == <span class="tok-number">3</span>);
}

<span class="tok-kw">var</span> numbers_left: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;
<span class="tok-kw">fn</span> <span class="tok-fn">eventuallyNullSequence</span>() ?<span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (numbers_left == <span class="tok-number">0</span>) <span class="tok-null">null</span> <span class="tok-kw">else</span> blk: {
        numbers_left -= <span class="tok-number">1</span>;
        <span class="tok-kw">break</span> :blk numbers_left;
    };
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_while_null_capture.zig</kbd>
1/1 test_while_null_capture.test.while null 捕获...OK
All 1 tests passed.
</samp></pre></figure>

      

      <h3 id="while-with-Error-Unions"><a href="https://ziglang.org/documentation/0.15.2/#toc-while-with-Error-Unions">while 与错误联合</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#while-with-Error-Unions">§</a></h3>

      <p>
      就像 <a href="https://ziglang.org/documentation/0.15.2/#if">if</a> 表达式一样，while 循环可以将错误联合作为条件并捕获负载或错误代码。当条件导致错误代码时，else 分支被求值并且循环结束。
      </p>
      <p>
      当 <code><span class="tok-kw">else</span> |x|</code> 语法出现在 <code><span class="tok-kw">while</span></code> 表达式上时，
      while 条件必须具有<a href="https://ziglang.org/documentation/0.15.2/#Error-Union-Type">错误联合类型</a>。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_while_error_capture.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"while 错误联合捕获"</span> {
    <span class="tok-kw">var</span> sum1: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    numbers_left = <span class="tok-number">3</span>;
    <span class="tok-kw">while</span> (eventuallyErrorSequence()) |value| {
        sum1 += value;
    } <span class="tok-kw">else</span> |err| {
        <span class="tok-kw">try</span> expect(err == <span class="tok-kw">error</span>.ReachedZero);
    }
}

<span class="tok-kw">var</span> numbers_left: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;

<span class="tok-kw">fn</span> <span class="tok-fn">eventuallyErrorSequence</span>() <span class="tok-type">anyerror</span>!<span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (numbers_left == <span class="tok-number">0</span>) <span class="tok-kw">error</span>.ReachedZero <span class="tok-kw">else</span> blk: {
        numbers_left -= <span class="tok-number">1</span>;
        <span class="tok-kw">break</span> :blk numbers_left;
    };
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_while_error_capture.zig</kbd>
1/1 test_while_error_capture.test.while 错误联合捕获...OK
All 1 tests passed.
</samp></pre></figure>

      

      <h3 id="inline-while"><a href="https://ziglang.org/documentation/0.15.2/#toc-inline-while">内联 while</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#inline-while">§</a></h3>

      <p>
      while 循环可以被内联。这会导致循环被展开，这允许代码执行一些只能在编译时完成的操作，例如将类型用作一等值。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_inline_while.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"内联 while 循环"</span> {
    <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> i = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> sum: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">inline</span> <span class="tok-kw">while</span> (i &lt; <span class="tok-number">3</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> T = <span class="tok-kw">switch</span> (i) {
            <span class="tok-number">0</span> =&gt; <span class="tok-type">f32</span>,
            <span class="tok-number">1</span> =&gt; <span class="tok-type">i8</span>,
            <span class="tok-number">2</span> =&gt; <span class="tok-type">bool</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        };
        sum += typeNameLength(T);
    }
    <span class="tok-kw">try</span> expect(sum == <span class="tok-number">9</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">typeNameLength</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@typeName</span>(T).len;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_inline_while.zig</kbd>
1/1 test_inline_while.test.内联 while 循环...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      建议仅出于以下原因之一使用 <code><span class="tok-kw">inline</span></code> 循环:
      </p>
      <ul>
        <li>你需要循环在<a href="https://ziglang.org/documentation/0.15.2/#comptime">编译期</a>执行才能使语义生效。</li>
        <li>
        你有基准测试证明以这种方式强制展开循环可测量地更快。
        </li>
      </ul>
      
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#if">if</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Optionals">可选值</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Errors">错误</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#unreachable">unreachable</a></li>
</ul>

      
      <h2 id="for"><a href="https://ziglang.org/documentation/0.15.2/#toc-for">for</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#for">§</a></h2>

      <figure><figcaption class="zig-cap"><cite class="file">test_for.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"for 基础"</span> {
    <span class="tok-kw">const</span> items = [_]<span class="tok-type">i32</span>{ <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">0</span> };
    <span class="tok-kw">var</span> sum: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;

    <span class="tok-comment">// For 循环迭代切片和数组。</span>
    <span class="tok-kw">for</span> (items) |value| {
        <span class="tok-comment">// 支持 Break 和 continue。</span>
        <span class="tok-kw">if</span> (value == <span class="tok-number">0</span>) {
            <span class="tok-kw">continue</span>;
        }
        sum += value;
    }
    <span class="tok-kw">try</span> expect(sum == <span class="tok-number">16</span>);

    <span class="tok-comment">// 要迭代切片的一部分，请重新切片。</span>
    <span class="tok-kw">for</span> (items[<span class="tok-number">0</span>..<span class="tok-number">1</span>]) |value| {
        sum += value;
    }
    <span class="tok-kw">try</span> expect(sum == <span class="tok-number">20</span>);

    <span class="tok-comment">// 要访问迭代索引，请指定第二个条件以及</span>
    <span class="tok-comment">// 第二个捕获值。</span>
    <span class="tok-kw">var</span> sum2: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (items, <span class="tok-number">0</span>..) |_, i| {
        <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(i) == <span class="tok-type">usize</span>);
        sum2 += <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-builtin">@intCast</span>(i));
    }
    <span class="tok-kw">try</span> expect(sum2 == <span class="tok-number">10</span>);

    <span class="tok-comment">// 要迭代连续整数，请使用范围语法。</span>
    <span class="tok-comment">// 无界范围始终是编译错误。</span>
    <span class="tok-kw">var</span> sum3: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<span class="tok-number">5</span>) |i| {
        sum3 += i;
    }
    <span class="tok-kw">try</span> expect(sum3 == <span class="tok-number">10</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"多对象 for"</span> {
    <span class="tok-kw">const</span> items = [_]<span class="tok-type">usize</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span> };
    <span class="tok-kw">const</span> items2 = [_]<span class="tok-type">usize</span>{ <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span> };
    <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

    <span class="tok-comment">// 迭代多个对象。</span>
    <span class="tok-comment">// 所有长度在循环开始时必须相等，否则会发生可检测的</span>
    <span class="tok-comment">// 非法行为。</span>
    <span class="tok-kw">for</span> (items, items2) |i, j| {
        count += i + j;
    }

    <span class="tok-kw">try</span> expect(count == <span class="tok-number">21</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"for 引用"</span> {
    <span class="tok-kw">var</span> items = [_]<span class="tok-type">i32</span>{ <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">2</span> };

    <span class="tok-comment">// 通过引用迭代切片，方法是</span>
    <span class="tok-comment">// 指定捕获值是指针。</span>
    <span class="tok-kw">for</span> (&amp;items) |*value| {
        value.* += <span class="tok-number">1</span>;
    }

    <span class="tok-kw">try</span> expect(items[<span class="tok-number">0</span>] == <span class="tok-number">4</span>);
    <span class="tok-kw">try</span> expect(items[<span class="tok-number">1</span>] == <span class="tok-number">5</span>);
    <span class="tok-kw">try</span> expect(items[<span class="tok-number">2</span>] == <span class="tok-number">3</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"for else"</span> {
    <span class="tok-comment">// For 允许附加一个 else，与 while 循环相同。</span>
    <span class="tok-kw">const</span> items = [_]?<span class="tok-type">i32</span>{ <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-null">null</span>, <span class="tok-number">5</span> };

    <span class="tok-comment">// For 循环也可以用作表达式。</span>
    <span class="tok-comment">// 与 while 循环类似，当你从 for 循环中断时，else 分支不会被求值。</span>
    <span class="tok-kw">var</span> sum: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> result = <span class="tok-kw">for</span> (items) |value| {
        <span class="tok-kw">if</span> (value != <span class="tok-null">null</span>) {
            sum += value.?;
        }
    } <span class="tok-kw">else</span> blk: {
        <span class="tok-kw">try</span> expect(sum == <span class="tok-number">12</span>);
        <span class="tok-kw">break</span> :blk sum;
    };
    <span class="tok-kw">try</span> expect(result == <span class="tok-number">12</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_for.zig</kbd>
1/4 test_for.test.for 基础...OK
2/4 test_for.test.多对象 for...OK
3/4 test_for.test.for 引用...OK
4/4 test_for.test.for else...OK
All 4 tests passed.
</samp></pre></figure>

      <h3 id="Labeled-for"><a href="https://ziglang.org/documentation/0.15.2/#toc-Labeled-for">带标签的 for</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Labeled-for">§</a></h3>

      <p>当 <code><span class="tok-kw">for</span></code> 循环带有标签时，可以从嵌套循环内的 <code><span class="tok-kw">break</span></code>
              或 <code><span class="tok-kw">continue</span></code> 中引用它:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_for_nested_break.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"嵌套 break"</span> {
    <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    outer: <span class="tok-kw">for</span> (<span class="tok-number">1</span>..<span class="tok-number">6</span>) |_| {
        <span class="tok-kw">for</span> (<span class="tok-number">1</span>..<span class="tok-number">6</span>) |_| {
            count += <span class="tok-number">1</span>;
            <span class="tok-kw">break</span> :outer;
        }
    }
    <span class="tok-kw">try</span> expect(count == <span class="tok-number">1</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"嵌套 continue"</span> {
    <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    outer: <span class="tok-kw">for</span> (<span class="tok-number">1</span>..<span class="tok-number">9</span>) |_| {
        <span class="tok-kw">for</span> (<span class="tok-number">1</span>..<span class="tok-number">6</span>) |_| {
            count += <span class="tok-number">1</span>;
            <span class="tok-kw">continue</span> :outer;
        }
    }

    <span class="tok-kw">try</span> expect(count == <span class="tok-number">8</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_for_nested_break.zig</kbd>
1/2 test_for_nested_break.test.嵌套 break...OK
2/2 test_for_nested_break.test.嵌套 continue...OK
All 2 tests passed.
</samp></pre></figure>

      
      <h3 id="inline-for"><a href="https://ziglang.org/documentation/0.15.2/#toc-inline-for">内联 for</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#inline-for">§</a></h3>

      <p>
      for 循环可以被内联。这会导致循环被展开，这允许代码执行一些只能在编译时完成的操作，例如将类型用作一等值。
      内联 for 循环的捕获值和迭代器值是编译期已知的。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_inline_for.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"内联 for 循环"</span> {
    <span class="tok-kw">const</span> nums = [_]<span class="tok-type">i32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">6</span> };
    <span class="tok-kw">var</span> sum: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (nums) |i| {
        <span class="tok-kw">const</span> T = <span class="tok-kw">switch</span> (i) {
            <span class="tok-number">2</span> =&gt; <span class="tok-type">f32</span>,
            <span class="tok-number">4</span> =&gt; <span class="tok-type">i8</span>,
            <span class="tok-number">6</span> =&gt; <span class="tok-type">bool</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        };
        sum += typeNameLength(T);
    }
    <span class="tok-kw">try</span> expect(sum == <span class="tok-number">9</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">typeNameLength</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@typeName</span>(T).len;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_inline_for.zig</kbd>
1/1 test_inline_for.test.内联 for 循环...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      建议仅出于以下原因之一使用 <code><span class="tok-kw">inline</span></code> 循环:
      </p>
      <ul>
        <li>你需要循环在<a href="https://ziglang.org/documentation/0.15.2/#comptime">编译期</a>执行才能使语义生效。</li>
        <li>
        你有基准测试证明以这种方式强制展开循环可测量地更快。
        </li>
      </ul>
      
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#while">while</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Arrays">数组</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Slices">切片</a></li>
</ul>

      
      <h2 id="if"><a href="https://ziglang.org/documentation/0.15.2/#toc-if">if</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#if">§</a></h2>

      <figure><figcaption class="zig-cap"><cite class="file">test_if.zig</cite></figcaption><pre><code><span class="tok-comment">// If 表达式有三种用法，对应三种类型:</span>
<span class="tok-comment">// * bool</span>
<span class="tok-comment">// * ?T</span>
<span class="tok-comment">// * anyerror!T</span>

<span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"if 表达式"</span> {
    <span class="tok-comment">// If 表达式用于代替三元表达式。</span>
    <span class="tok-kw">const</span> a: <span class="tok-type">u32</span> = <span class="tok-number">5</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">u32</span> = <span class="tok-number">4</span>;
    <span class="tok-kw">const</span> result = <span class="tok-kw">if</span> (a != b) <span class="tok-number">47</span> <span class="tok-kw">else</span> <span class="tok-number">3089</span>;
    <span class="tok-kw">try</span> expect(result == <span class="tok-number">47</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"if 布尔值"</span> {
    <span class="tok-comment">// If 表达式测试布尔条件。</span>
    <span class="tok-kw">const</span> a: <span class="tok-type">u32</span> = <span class="tok-number">5</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">u32</span> = <span class="tok-number">4</span>;
    <span class="tok-kw">if</span> (a != b) {
        <span class="tok-kw">try</span> expect(<span class="tok-null">true</span>);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a == <span class="tok-number">9</span>) {
        <span class="tok-kw">unreachable</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">unreachable</span>;
    }
}

<span class="tok-kw">test</span> <span class="tok-str">"if 错误联合"</span> {
    <span class="tok-comment">// If 表达式测试错误。</span>
    <span class="tok-comment">// 注意 else 上的 |err| 捕获。</span>

    <span class="tok-kw">const</span> a: <span class="tok-type">anyerror</span>!<span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (a) |value| {
        <span class="tok-kw">try</span> expect(value == <span class="tok-number">0</span>);
    } <span class="tok-kw">else</span> |err| {
        _ = err;
        <span class="tok-kw">unreachable</span>;
    }

    <span class="tok-kw">const</span> b: <span class="tok-type">anyerror</span>!<span class="tok-type">u32</span> = <span class="tok-kw">error</span>.BadValue;
    <span class="tok-kw">if</span> (b) |value| {
        _ = value;
        <span class="tok-kw">unreachable</span>;
    } <span class="tok-kw">else</span> |err| {
        <span class="tok-kw">try</span> expect(err == <span class="tok-kw">error</span>.BadValue);
    }

    <span class="tok-comment">// else 和 |err| 捕获是严格要求的。</span>
    <span class="tok-kw">if</span> (a) |value| {
        <span class="tok-kw">try</span> expect(value == <span class="tok-number">0</span>);
    } <span class="tok-kw">else</span> |_| {}

    <span class="tok-comment">// 要仅检查错误值，请使用空块表达式。</span>
    <span class="tok-kw">if</span> (b) |_| {} <span class="tok-kw">else</span> |err| {
        <span class="tok-kw">try</span> expect(err == <span class="tok-kw">error</span>.BadValue);
    }

    <span class="tok-comment">// 使用指针捕获通过引用访问值。</span>
    <span class="tok-kw">var</span> c: <span class="tok-type">anyerror</span>!<span class="tok-type">u32</span> = <span class="tok-number">3</span>;
    <span class="tok-kw">if</span> (c) |*value| {
        value.* = <span class="tok-number">9</span>;
    } <span class="tok-kw">else</span> |_| {
        <span class="tok-kw">unreachable</span>;
    }

    <span class="tok-kw">if</span> (c) |value| {
        <span class="tok-kw">try</span> expect(value == <span class="tok-number">9</span>);
    } <span class="tok-kw">else</span> |_| {
        <span class="tok-kw">unreachable</span>;
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_if.zig</kbd>
1/3 test_if.test.if 表达式...OK
2/3 test_if.test.if 布尔值...OK
3/3 test_if.test.if 错误联合...OK
All 3 tests passed.
</samp></pre></figure>

      <h3 id="if-with-Optionals"><a href="https://ziglang.org/documentation/0.15.2/#toc-if-with-Optionals">if 与可选值</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#if-with-Optionals">§</a></h3>


      <figure><figcaption class="zig-cap"><cite class="file">test_if_optionals.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"if 可选值"</span> {
    <span class="tok-comment">// If 表达式测试 null。</span>

    <span class="tok-kw">const</span> a: ?<span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (a) |value| {
        <span class="tok-kw">try</span> expect(value == <span class="tok-number">0</span>);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">unreachable</span>;
    }

    <span class="tok-kw">const</span> b: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (b) |_| {
        <span class="tok-kw">unreachable</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">try</span> expect(<span class="tok-null">true</span>);
    }

    <span class="tok-comment">// else 不是必需的。</span>
    <span class="tok-kw">if</span> (a) |value| {
        <span class="tok-kw">try</span> expect(value == <span class="tok-number">0</span>);
    }

    <span class="tok-comment">// 要仅测试 null，请使用二进制相等运算符。</span>
    <span class="tok-kw">if</span> (b == <span class="tok-null">null</span>) {
        <span class="tok-kw">try</span> expect(<span class="tok-null">true</span>);
    }

    <span class="tok-comment">// 使用指针捕获通过引用访问值。</span>
    <span class="tok-kw">var</span> c: ?<span class="tok-type">u32</span> = <span class="tok-number">3</span>;
    <span class="tok-kw">if</span> (c) |*value| {
        value.* = <span class="tok-number">2</span>;
    }

    <span class="tok-kw">if</span> (c) |value| {
        <span class="tok-kw">try</span> expect(value == <span class="tok-number">2</span>);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">unreachable</span>;
    }
}

<span class="tok-kw">test</span> <span class="tok-str">"if 错误联合与可选值"</span> {
    <span class="tok-comment">// If 表达式在展开可选值之前先测试错误。</span>
    <span class="tok-comment">// |optional_value| 捕获的类型是 ?u32。</span>

    <span class="tok-kw">const</span> a: <span class="tok-type">anyerror</span>!?<span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (a) |optional_value| {
        <span class="tok-kw">try</span> expect(optional_value.? == <span class="tok-number">0</span>);
    } <span class="tok-kw">else</span> |err| {
        _ = err;
        <span class="tok-kw">unreachable</span>;
    }

    <span class="tok-kw">const</span> b: <span class="tok-type">anyerror</span>!?<span class="tok-type">u32</span> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (b) |optional_value| {
        <span class="tok-kw">try</span> expect(optional_value == <span class="tok-null">null</span>);
    } <span class="tok-kw">else</span> |_| {
        <span class="tok-kw">unreachable</span>;
    }

    <span class="tok-kw">const</span> c: <span class="tok-type">anyerror</span>!?<span class="tok-type">u32</span> = <span class="tok-kw">error</span>.BadValue;
    <span class="tok-kw">if</span> (c) |optional_value| {
        _ = optional_value;
        <span class="tok-kw">unreachable</span>;
    } <span class="tok-kw">else</span> |err| {
        <span class="tok-kw">try</span> expect(err == <span class="tok-kw">error</span>.BadValue);
    }

    <span class="tok-comment">// 每次使用指针捕获通过引用访问值。</span>
    <span class="tok-kw">var</span> d: <span class="tok-type">anyerror</span>!?<span class="tok-type">u32</span> = <span class="tok-number">3</span>;
    <span class="tok-kw">if</span> (d) |*optional_value| {
        <span class="tok-kw">if</span> (optional_value.*) |*value| {
            value.* = <span class="tok-number">9</span>;
        }
    } <span class="tok-kw">else</span> |_| {
        <span class="tok-kw">unreachable</span>;
    }

    <span class="tok-kw">if</span> (d) |optional_value| {
        <span class="tok-kw">try</span> expect(optional_value.? == <span class="tok-number">9</span>);
    } <span class="tok-kw">else</span> |_| {
        <span class="tok-kw">unreachable</span>;
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_if_optionals.zig</kbd>
1/2 test_if_optionals.test.if 可选值...OK
2/2 test_if_optionals.test.if 错误联合与可选值...OK
All 2 tests passed.
</samp></pre></figure>

      
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Optionals">可选值</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Errors">错误</a></li>
</ul>

      
      <h2 id="defer"><a href="https://ziglang.org/documentation/0.15.2/#toc-defer">defer</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#defer">§</a></h2>

      <p>在作用域退出时无条件执行表达式。</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_defer.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;
<span class="tok-kw">const</span> print = std.debug.print;

<span class="tok-kw">fn</span> <span class="tok-fn">deferExample</span>() !<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;

    {
        <span class="tok-kw">defer</span> a = <span class="tok-number">2</span>;
        a = <span class="tok-number">1</span>;
    }
    <span class="tok-kw">try</span> expect(a == <span class="tok-number">2</span>);

    a = <span class="tok-number">5</span>;
    <span class="tok-kw">return</span> a;
}

<span class="tok-kw">test</span> <span class="tok-str">"defer 基础"</span> {
    <span class="tok-kw">try</span> expect((<span class="tok-kw">try</span> deferExample()) == <span class="tok-number">5</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_defer.zig</kbd>
1/1 test_defer.test.defer 基础...OK
All 1 tests passed.
</samp></pre></figure>

      <p>Defer 表达式按相反顺序求值。</p>
      <figure><figcaption class="zig-cap"><cite class="file">defer_unwind.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> print = std.debug.print;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    print(<span class="tok-str">"\n"</span>, .{});

    <span class="tok-kw">defer</span> {
        print(<span class="tok-str">"1 "</span>, .{});
    }
    <span class="tok-kw">defer</span> {
        print(<span class="tok-str">"2 "</span>, .{});
    }
    <span class="tok-kw">if</span> (<span class="tok-null">false</span>) {
        <span class="tok-comment">// 如果 defer 从未执行，则它们不会运行。</span>
        <span class="tok-kw">defer</span> {
            print(<span class="tok-str">"3 "</span>, .{});
        }
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe defer_unwind.zig</kbd>
$ <kbd>./defer_unwind</kbd>

2 1
</samp></pre></figure>

      <p>在 defer 表达式内不允许使用 return 语句。</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_invalid_defer.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">deferInvalidExample</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">defer</span> {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DeferError;
    }

    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DeferError;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_invalid_defer.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_invalid_defer.zig:3:9: </span><span class="sgr-31m">error: </span><span class="sgr-1m">不能从 defer 表达式返回
</span>        return error.DeferError;
        <span class="sgr-32m">^~~~~~~~~~~~~~~~~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_invalid_defer.zig:2:5: </span><span class="sgr-36m">note: </span><span class="sgr-1m">defer 表达式在此
</span>    defer {
    <span class="sgr-32m">^~~~~
</span>
</samp></pre></figure>

      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Errors">错误</a></li>
</ul>

      
      <h2 id="unreachable"><a href="https://ziglang.org/documentation/0.15.2/#toc-unreachable">unreachable</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#unreachable">§</a></h2>

      <p>
      在<a href="https://ziglang.org/documentation/0.15.2/#Debug">调试</a>和<a href="https://ziglang.org/documentation/0.15.2/#ReleaseSafe">ReleaseSafe</a>模式下，
      <code><span class="tok-kw">unreachable</span></code> 会发出对 <code>panic</code> 的调用，消息为 <code>reached unreachable code</code>。
      </p>
      <p>
      在<a href="https://ziglang.org/documentation/0.15.2/#ReleaseFast">ReleaseFast</a>和<a href="https://ziglang.org/documentation/0.15.2/#ReleaseSmall">ReleaseSmall</a>模式下，优化器使用永远不会命中 <code><span class="tok-kw">unreachable</span></code> 代码的假设来执行优化。
      </p>
      <h3 id="Basics"><a href="https://ziglang.org/documentation/0.15.2/#toc-Basics">基础</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Basics">§</a></h3>

      <figure><figcaption class="zig-cap"><cite class="file">test_unreachable.zig</cite></figcaption><pre><code><span class="tok-comment">// unreachable 用于断言控制流永远不会到达特定位置:</span>
<span class="tok-kw">test</span> <span class="tok-str">"基础数学"</span> {
    <span class="tok-kw">const</span> x = <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> y = <span class="tok-number">2</span>;
    <span class="tok-kw">if</span> (x + y != <span class="tok-number">3</span>) {
        <span class="tok-kw">unreachable</span>;
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_unreachable.zig</kbd>
1/1 test_unreachable.test.基础数学...OK
All 1 tests passed.
</samp></pre></figure>

      <p>实际上，这就是 <code>std.debug.assert</code> 的实现方式:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_assertion_failure.zig</cite></figcaption><pre><code><span class="tok-comment">// 这是 std.debug.assert 的实现方式</span>
<span class="tok-kw">fn</span> <span class="tok-fn">assert</span>(ok: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!ok) <span class="tok-kw">unreachable</span>; <span class="tok-comment">// 断言失败</span>
}

<span class="tok-comment">// 这个测试将失败，因为我们命中了 unreachable。</span>
<span class="tok-kw">test</span> <span class="tok-str">"这将失败"</span> {
    assert(<span class="tok-null">false</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_assertion_failure.zig</kbd>
1/1 test_assertion_failure.test.这将失败...thread 2902460 panic: reached unreachable code
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_assertion_failure.zig:3:14</span>: <span class="sgr-2m">0x102c039 in assert (test_assertion_failure.zig)</span>
    if (!ok) unreachable; // 断言失败
             <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_assertion_failure.zig:8:11</span>: <span class="sgr-2m">0x102c00e in test.这将失败 (test_assertion_failure.zig)</span>
    assert(false);
          <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:218:25</span>: <span class="sgr-2m">0x115cb50 in mainTerminal (test_runner.zig)</span>
        if (test_fn.func()) |_| {
                        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:66:28</span>: <span class="sgr-2m">0x1155d71 in main (test_runner.zig)</span>
        return mainTerminal();
                           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x114fb0d in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x114f3a1 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
error: the following test command crashed:
/home/andy/dev/zig/.zig-cache/o/2d8b23c255add16f67e238437a2ca75f/test --seed=0xf5bf1bba
</samp></pre></figure>

      
      <h3 id="At-Compile-Time"><a href="https://ziglang.org/documentation/0.15.2/#toc-At-Compile-Time">在编译时</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#At-Compile-Time">§</a></h3>

      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_unreachable.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">"unreachable 的类型"</span> {
    <span class="tok-kw">comptime</span> {
        <span class="tok-comment">// unreachable 的类型是 noreturn。</span>

        <span class="tok-comment">// 然而，这个断言仍然会编译失败，因为</span>
        <span class="tok-comment">// unreachable 表达式是编译错误。</span>

        assert(<span class="tok-builtin">@TypeOf</span>(<span class="tok-kw">unreachable</span>) == <span class="tok-type">noreturn</span>);
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_unreachable.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_unreachable.zig:10:16: </span><span class="sgr-31m">error: </span><span class="sgr-1m">不可达代码
</span>        assert(@TypeOf(unreachable) == noreturn);
               <span class="sgr-32m">^~~~~~~~~~~~~~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_unreachable.zig:10:24: </span><span class="sgr-36m">note: </span><span class="sgr-1m">控制流在此处被转移
</span>        assert(@TypeOf(unreachable) == noreturn);
                       <span class="sgr-32m">^~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Zig-Test">Zig 测试</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Build-Mode">构建模式</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a></li>
</ul>

      
      
      <h2 id="noreturn"><a href="https://ziglang.org/documentation/0.15.2/#toc-noreturn">noreturn</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#noreturn">§</a></h2>

      <p>
      <code><span class="tok-type">noreturn</span></code> 是以下的类型:
      </p>
      <ul>
          <li><code><span class="tok-kw">break</span></code></li>
          <li><code><span class="tok-kw">continue</span></code></li>
          <li><code><span class="tok-kw">return</span></code></li>
          <li><code><span class="tok-kw">unreachable</span></code></li>
          <li><code><span class="tok-kw">while</span> (<span class="tok-null">true</span>) {}</code></li>
      </ul>
      <p>当一起解析类型时，例如 <code><span class="tok-kw">if</span></code> 子句或 <code><span class="tok-kw">switch</span></code> 分支，
              <code><span class="tok-type">noreturn</span></code> 类型与所有其他类型兼容。考虑:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_noreturn.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(condition: <span class="tok-type">bool</span>, b: <span class="tok-type">u32</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> a = <span class="tok-kw">if</span> (condition) b <span class="tok-kw">else</span> <span class="tok-kw">return</span>;
    _ = a;
    <span class="tok-builtin">@panic</span>(<span class="tok-str">"用 a 做些什么"</span>);
}
<span class="tok-kw">test</span> <span class="tok-str">"noreturn"</span> {
    foo(<span class="tok-null">false</span>, <span class="tok-number">1</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_noreturn.zig</kbd>
1/1 test_noreturn.test.noreturn...OK
All 1 tests passed.
</samp></pre></figure>
<!-- ====== END CHUNK 6: new_06.html ====== -->

<!-- ====== BEGIN CHUNK 7: new_07.html ====== -->
<p><code><span class="tok-type">noreturn</span></code> 的另一个用例是 <code>exit</code> 函数:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_noreturn_from_exit.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">"builtin"</span>);
<span class="tok-kw">const</span> native_arch = builtin.cpu.arch;
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> WINAPI: std.builtin.CallingConvention = <span class="tok-kw">if</span> (native_arch == .x86) .{ .x86_stdcall = .{} } <span class="tok-kw">else</span> .c;
<span class="tok-kw">extern</span> <span class="tok-str">"kernel32"</span> <span class="tok-kw">fn</span> <span class="tok-fn">ExitProcess</span>(exit_code: <span class="tok-type">c_uint</span>) <span class="tok-kw">callconv</span>(WINAPI) <span class="tok-type">noreturn</span>;

<span class="tok-kw">test</span> <span class="tok-str">"foo"</span> {
    <span class="tok-kw">const</span> value = bar() <span class="tok-kw">catch</span> ExitProcess(<span class="tok-number">1</span>);
    <span class="tok-kw">try</span> expect(value == <span class="tok-number">1234</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>() <span class="tok-type">anyerror</span>!<span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> <span class="tok-number">1234</span>;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_noreturn_from_exit.zig -target x86_64-windows --test-no-exec</kbd>
</samp></pre></figure>

      

      <h2 id="Functions"><a href="https://ziglang.org/documentation/0.15.2/#toc-Functions">函数</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Functions">§</a></h2>

      <figure><figcaption class="zig-cap"><cite class="file">test_functions.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">"builtin"</span>);
<span class="tok-kw">const</span> native_arch = builtin.cpu.arch;
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-comment">// 函数这样声明</span>
<span class="tok-kw">fn</span> <span class="tok-fn">add</span>(a: <span class="tok-type">i8</span>, b: <span class="tok-type">i8</span>) <span class="tok-type">i8</span> {
    <span class="tok-kw">if</span> (a == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> b;
    }

    <span class="tok-kw">return</span> a + b;
}

<span class="tok-comment">// export 修饰符使函数在生成的目标文件中外部可见,并使其使用 C ABI。</span>
<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">sub</span>(a: <span class="tok-type">i8</span>, b: <span class="tok-type">i8</span>) <span class="tok-type">i8</span> {
    <span class="tok-kw">return</span> a - b;
}

<span class="tok-comment">// extern 修饰符用于声明一个函数,该函数将在静态链接时在链接时解析,或</span>
<span class="tok-comment">// 在动态链接时在运行时解析。extern 关键字后的引号标识符指定包含该函数的</span>
<span class="tok-comment">// 库。(例如 "c" -&gt; libc.so)</span>
<span class="tok-comment">// callconv 修饰符改变函数的调用约定。</span>
<span class="tok-kw">extern</span> <span class="tok-str">"kernel32"</span> <span class="tok-kw">fn</span> <span class="tok-fn">ExitProcess</span>(exit_code: <span class="tok-type">u32</span>) <span class="tok-kw">callconv</span>(.winapi) <span class="tok-type">noreturn</span>;
<span class="tok-kw">extern</span> <span class="tok-str">"c"</span> <span class="tok-kw">fn</span> <span class="tok-fn">atan2</span>(a: <span class="tok-type">f64</span>, b: <span class="tok-type">f64</span>) <span class="tok-type">f64</span>;

<span class="tok-comment">// @branchHint 内置函数可用于告诉优化器某个函数很少被调用("cold")。</span>
<span class="tok-kw">fn</span> <span class="tok-fn">abort</span>() <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {}
}

<span class="tok-comment">// naked 调用约定使函数没有任何函数序言或尾声。</span>
<span class="tok-comment">// 这在与汇编集成时很有用。</span>
<span class="tok-kw">fn</span> <span class="tok-fn">_start</span>() <span class="tok-kw">callconv</span>(.naked) <span class="tok-type">noreturn</span> {
    abort();
}

<span class="tok-comment">// inline 调用约定强制函数在所有调用点内联。</span>
<span class="tok-comment">// 如果函数无法内联,则是编译时错误。</span>
<span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftLeftOne</span>(a: <span class="tok-type">u32</span>) <span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> a &lt;&lt; <span class="tok-number">1</span>;
}

<span class="tok-comment">// pub 修饰符允许在导入时函数可见。</span>
<span class="tok-comment">// 另一个文件可以使用 @import 并调用 sub2</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sub2</span>(a: <span class="tok-type">i8</span>, b: <span class="tok-type">i8</span>) <span class="tok-type">i8</span> {
    <span class="tok-kw">return</span> a - b;
}

<span class="tok-comment">// 函数指针以 `*const ` 为前缀。</span>
<span class="tok-kw">const</span> Call2Op = *<span class="tok-kw">const</span> <span class="tok-kw">fn</span> (a: <span class="tok-type">i8</span>, b: <span class="tok-type">i8</span>) <span class="tok-type">i8</span>;
<span class="tok-kw">fn</span> <span class="tok-fn">doOp</span>(fnCall: Call2Op, op1: <span class="tok-type">i8</span>, op2: <span class="tok-type">i8</span>) <span class="tok-type">i8</span> {
    <span class="tok-kw">return</span> fnCall(op1, op2);
}

<span class="tok-kw">test</span> <span class="tok-str">"function"</span> {
    <span class="tok-kw">try</span> expect(doOp(add, <span class="tok-number">5</span>, <span class="tok-number">6</span>) == <span class="tok-number">11</span>);
    <span class="tok-kw">try</span> expect(doOp(sub2, <span class="tok-number">5</span>, <span class="tok-number">6</span>) == -<span class="tok-number">1</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_functions.zig</kbd>
1/1 test_functions.test.function...OK
All 1 tests passed.
</samp></pre></figure>

      <p>函数<em>体</em>和函数<em>指针</em>之间有所不同。
      函数体是 <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a> 专用类型,而函数<a href="https://ziglang.org/documentation/0.15.2/#Pointers">指针</a>可以在运行时已知。</p>
      <h3 id="Pass-by-value-Parameters"><a href="https://ziglang.org/documentation/0.15.2/#toc-Pass-by-value-Parameters">传值参数</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Pass-by-value-Parameters">§</a></h3>

      <p>
      作为参数传递的基本类型,如<a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a>和<a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a>,会被复制,然后副本在函数体中可用。这称为"传值"。
      复制基本类型基本上是免费的,通常只需要设置一个寄存器即可。
      </p>
      <p>
      结构体、联合体和数组有时可以更高效地以引用方式传递,因为复制可能会根据大小而变得任意昂贵。当这些类型作为参数传递时,Zig 可能会选择复制并传值,或者传引用,Zig 会决定哪种方式更快。
      这在一定程度上是因为参数是不可变的。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_pass_by_reference_or_value.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Point = <span class="tok-kw">struct</span> {
    x: <span class="tok-type">i32</span>,
    y: <span class="tok-type">i32</span>,
};

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(point: Point) <span class="tok-type">i32</span> {
    <span class="tok-comment">// 这里,`point` 可能是引用,也可能是副本。函数体</span>
    <span class="tok-comment">// 可以忽略差异并将其视为值。获取参数地址时要非常小心 -</span>
    <span class="tok-comment">// 应该将其视为当函数返回时地址将失效。</span>
    <span class="tok-kw">return</span> point.x + point.y;
}

<span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"pass struct to function"</span> {
    <span class="tok-kw">try</span> expect(foo(Point{ .x = <span class="tok-number">1</span>, .y = <span class="tok-number">2</span> }) == <span class="tok-number">3</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_pass_by_reference_or_value.zig</kbd>
1/1 test_pass_by_reference_or_value.test.pass struct to function...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      对于外部函数,Zig 遵循 C ABI 以传值方式传递结构体和联合体。
      </p>
      
      <h3 id="Function-Parameter-Type-Inference"><a href="https://ziglang.org/documentation/0.15.2/#toc-Function-Parameter-Type-Inference">函数参数类型推断</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Function-Parameter-Type-Inference">§</a></h3>

      <p>
      函数参数可以用 <code><span class="tok-kw">anytype</span></code> 代替类型声明。
      在这种情况下,参数类型将在调用函数时推断。
      使用 <a href="https://ziglang.org/documentation/0.15.2/#TypeOf">@TypeOf</a> 和 <a href="https://ziglang.org/documentation/0.15.2/#typeInfo">@typeInfo</a> 获取有关推断类型的信息。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_fn_type_inference.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">fn</span> <span class="tok-fn">addFortyTwo</span>(x: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(x) {
    <span class="tok-kw">return</span> x + <span class="tok-number">42</span>;
}

<span class="tok-kw">test</span> <span class="tok-str">"fn type inference"</span> {
    <span class="tok-kw">try</span> expect(addFortyTwo(<span class="tok-number">1</span>) == <span class="tok-number">43</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(addFortyTwo(<span class="tok-number">1</span>)) == <span class="tok-type">comptime_int</span>);
    <span class="tok-kw">const</span> y: <span class="tok-type">i64</span> = <span class="tok-number">2</span>;
    <span class="tok-kw">try</span> expect(addFortyTwo(y) == <span class="tok-number">44</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(addFortyTwo(y)) == <span class="tok-type">i64</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_fn_type_inference.zig</kbd>
1/1 test_fn_type_inference.test.fn type inference...OK
All 1 tests passed.
</samp></pre></figure>


      

      <h3 id="inline-fn"><a href="https://ziglang.org/documentation/0.15.2/#toc-inline-fn">inline fn</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#inline-fn">§</a></h3>

      <p>
      在函数定义中添加 <code><span class="tok-kw">inline</span></code> 关键字会使该函数在调用点<em>语义内联</em>。这不是一个可能被优化过程观察到的提示,而是对函数调用中涉及的类型和值有影响。
      </p>
      <p>
      与普通函数调用不同,内联函数调用点的编译时已知的参数被视为<a href="https://ziglang.org/documentation/0.15.2/#Compile-Time-Parameters">编译时参数</a>。这可能会一直传播到返回值:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">inline_call.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (foo(<span class="tok-number">1200</span>, <span class="tok-number">34</span>) != <span class="tok-number">1234</span>) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">"bad"</span>);
    }
}

<span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(a: <span class="tok-type">i32</span>, b: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    std.debug.print(<span class="tok-str">"runtime a = {} b = {}"</span>, .{ a, b });
    <span class="tok-kw">return</span> a + b;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe inline_call.zig</kbd>
$ <kbd>./inline_call</kbd>
runtime a = 1200 b = 34
</samp></pre></figure>

      <p>如果移除 <code><span class="tok-kw">inline</span></code>,测试将失败并产生编译错误而不是通过。</p>
      <p>通常最好让编译器决定何时内联函数,除了以下场景:</p>
      <ul>
        <li>为了调试目的改变调用栈中的栈帧数量。</li>
        <li>强制参数的编译时性传播到函数的返回值,如上例所示。</li>
        <li>实际性能测量要求这样做。</li>
      </ul>
      <p>注意 <code><span class="tok-kw">inline</span></code> 实际上<em>限制了</em>编译器被允许做的事情。这可能会损害二进制大小、编译速度,甚至运行时性能。</p>
      

      <h3 id="Function-Reflection"><a href="https://ziglang.org/documentation/0.15.2/#toc-Function-Reflection">函数反射</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Function-Reflection">§</a></h3>

      <figure><figcaption class="zig-cap"><cite class="file">test_fn_reflection.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> math = std.math;
<span class="tok-kw">const</span> testing = std.testing;

<span class="tok-kw">test</span> <span class="tok-str">"fn reflection"</span> {
    <span class="tok-kw">try</span> testing.expect(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(testing.expect)).@"fn".params[<span class="tok-number">0</span>].<span class="tok-type">type</span>.? == <span class="tok-type">bool</span>);
    <span class="tok-kw">try</span> testing.expect(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(testing.tmpDir)).@"fn".return_type.? == testing.TmpDir);

    <span class="tok-kw">try</span> testing.expect(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(math.Log2Int)).@"fn".is_generic);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_fn_reflection.zig</kbd>
1/1 test_fn_reflection.test.fn reflection...OK
All 1 tests passed.
</samp></pre></figure>

      
      
      <h2 id="Errors"><a href="https://ziglang.org/documentation/0.15.2/#toc-Errors">错误</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Errors">§</a></h2>

      <h3 id="Error-Set-Type"><a href="https://ziglang.org/documentation/0.15.2/#toc-Error-Set-Type">错误集类型</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Error-Set-Type">§</a></h3>

      <p>
      错误集类似于 <a href="https://ziglang.org/documentation/0.15.2/#enum">enum</a>。
      然而,整个编译过程中的每个错误名称都被分配一个大于 0 的无符号整数。你可以多次声明相同的错误名称,如果这样做,它会被分配相同的整数值。
      </p>
      <p>
      错误集类型默认为 <code><span class="tok-type">u16</span></code>,但如果通过命令行参数 <kbd>--error-limit [num]</kbd> 提供了不同错误值的最大数量,则会使用能够表示所有错误值所需的最小位数的整数类型。
      </p>
      <p>
      你可以将错误从子集<a href="https://ziglang.org/documentation/0.15.2/#Type-Coercion">强制转换</a>为超集:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_coerce_error_subset_to_superset.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">const</span> FileOpenError = <span class="tok-kw">error</span>{
    AccessDenied,
    OutOfMemory,
    FileNotFound,
};

<span class="tok-kw">const</span> AllocationError = <span class="tok-kw">error</span>{
    OutOfMemory,
};

<span class="tok-kw">test</span> <span class="tok-str">"coerce subset to superset"</span> {
    <span class="tok-kw">const</span> err = foo(AllocationError.OutOfMemory);
    <span class="tok-kw">try</span> std.testing.expect(err == FileOpenError.OutOfMemory);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(err: AllocationError) FileOpenError {
    <span class="tok-kw">return</span> err;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_coerce_error_subset_to_superset.zig</kbd>
1/1 test_coerce_error_subset_to_superset.test.coerce subset to superset...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      但你不能将错误从超集<a href="https://ziglang.org/documentation/0.15.2/#Type-Coercion">强制转换</a>为子集:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_coerce_error_superset_to_subset.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> FileOpenError = <span class="tok-kw">error</span>{
    AccessDenied,
    OutOfMemory,
    FileNotFound,
};

<span class="tok-kw">const</span> AllocationError = <span class="tok-kw">error</span>{
    OutOfMemory,
};

<span class="tok-kw">test</span> <span class="tok-str">"coerce superset to subset"</span> {
    foo(FileOpenError.OutOfMemory) <span class="tok-kw">catch</span> {};
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(err: FileOpenError) AllocationError {
    <span class="tok-kw">return</span> err;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_coerce_error_superset_to_subset.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_coerce_error_superset_to_subset.zig:16:12: </span><span class="sgr-31m">error: </span><span class="sgr-1m">expected type 'error{OutOfMemory}', found 'error{AccessDenied,FileNotFound,OutOfMemory}'
</span>    return err;
           <span class="sgr-32m">^~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_coerce_error_superset_to_subset.zig:16:12: </span><span class="sgr-36m">note: </span><span class="sgr-1m">'error.AccessDenied' not a member of destination error set
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_coerce_error_superset_to_subset.zig:16:12: </span><span class="sgr-36m">note: </span><span class="sgr-1m">'error.FileNotFound' not a member of destination error set
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_coerce_error_superset_to_subset.zig:15:28: </span><span class="sgr-36m">note: </span><span class="sgr-1m">function return type declared here
</span>fn foo(err: FileOpenError) AllocationError {
                           <span class="sgr-32m">^~~~~~~~~~~~~~~
</span><span class="sgr-2m">referenced by:
    test.coerce superset to subset: /home/andy/dev/zig/doc/langref/test_coerce_error_superset_to_subset.zig:12:8
</span>
</samp></pre></figure>

      <p>
      有一个声明只有 1 个值的错误集的快捷方式,然后获取该值:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">single_value_error_set_shortcut.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> err = <span class="tok-kw">error</span>.FileNotFound;</code></pre></figure>

      <p>这等价于:</p>
      <figure><figcaption class="zig-cap"><cite class="file">single_value_error_set.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> err = (<span class="tok-kw">error</span>{FileNotFound}).FileNotFound;</code></pre></figure>

      <p>
      这在使用<a href="https://ziglang.org/documentation/0.15.2/#Inferred-Error-Sets">推断错误集</a>时变得有用。
      </p>
      <h4 id="The-Global-Error-Set"><a href="https://ziglang.org/documentation/0.15.2/#toc-The-Global-Error-Set">全局错误集</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#The-Global-Error-Set">§</a></h4>

      <p><code><span class="tok-type">anyerror</span></code> 指的是全局错误集。
      这是包含整个编译单元中所有错误的错误集,即它是所有其他错误集的并集。
      </p>
      <p>
      你可以将任何错误集<a href="https://ziglang.org/documentation/0.15.2/#Type-Coercion">强制转换</a>为全局错误集,你也可以显式地将全局错误集的错误转换为非全局错误集。这会插入一个语言级断言以确保错误值确实在目标错误集中。
      </p>
      <p>
      通常应该避免使用全局错误集,因为它阻止编译器在编译时知道可能的错误。在编译时知道错误集对于生成的文档和有用的错误消息更好,例如在 <a href="https://ziglang.org/documentation/0.15.2/#switch">switch</a> 中忘记可能的错误值。
      </p>
      
      
      <h3 id="Error-Union-Type"><a href="https://ziglang.org/documentation/0.15.2/#toc-Error-Union-Type">错误联合类型</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Error-Union-Type">§</a></h3>

      <p>
      错误集类型和普通类型可以用 <code>!</code> 二元运算符组合成错误联合类型。你使用错误联合类型的频率可能比单独使用错误集类型更高。
      </p>
      <p>
      这是一个将字符串解析为 64 位整数的函数:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">error_union_parsing_u64.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> maxInt = std.math.maxInt;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseU64</span>(buf: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, radix: <span class="tok-type">u8</span>) !<span class="tok-type">u64</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;

    <span class="tok-kw">for</span> (buf) |c| {
        <span class="tok-kw">const</span> digit = charToDigit(c);

        <span class="tok-kw">if</span> (digit &gt;= radix) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidChar;
        }

        <span class="tok-comment">// x *= radix</span>
        <span class="tok-kw">var</span> ov = <span class="tok-builtin">@mulWithOverflow</span>(x, radix);
        <span class="tok-kw">if</span> (ov[<span class="tok-number">1</span>] != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OverFlow;

        <span class="tok-comment">// x += digit</span>
        ov = <span class="tok-builtin">@addWithOverflow</span>(ov[<span class="tok-number">0</span>], digit);
        <span class="tok-kw">if</span> (ov[<span class="tok-number">1</span>] != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OverFlow;
        x = ov[<span class="tok-number">0</span>];
    }

    <span class="tok-kw">return</span> x;
}

<span class="tok-kw">fn</span> <span class="tok-fn">charToDigit</span>(c: <span class="tok-type">u8</span>) <span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (c) {
        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; c - <span class="tok-str">'0'</span>,
        <span class="tok-str">'A'</span>...<span class="tok-str">'Z'</span> =&gt; c - <span class="tok-str">'A'</span> + <span class="tok-number">10</span>,
        <span class="tok-str">'a'</span>...<span class="tok-str">'z'</span> =&gt; c - <span class="tok-str">'a'</span> + <span class="tok-number">10</span>,
        <span class="tok-kw">else</span> =&gt; maxInt(<span class="tok-type">u8</span>),
    };
}

<span class="tok-kw">test</span> <span class="tok-str">"parse u64"</span> {
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> parseU64(<span class="tok-str">"1234"</span>, <span class="tok-number">10</span>);
    <span class="tok-kw">try</span> std.testing.expect(result == <span class="tok-number">1234</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test error_union_parsing_u64.zig</kbd>
1/1 error_union_parsing_u64.test.parse u64...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      注意返回类型是 <code>!<span class="tok-type">u64</span></code>。这意味着函数要么返回一个无符号 64 位整数,要么返回一个错误。我们在 <code>!</code> 左侧省略了错误集,因此错误集是推断的。
      </p>
      <p>
      在函数定义中,你可以看到一些返回错误的 return 语句,在底部有一个返回 <code><span class="tok-type">u64</span></code> 的 return 语句。
          两种类型都<a href="https://ziglang.org/documentation/0.15.2/#Type-Coercion">强制转换</a>为 <code><span class="tok-type">anyerror</span>!<span class="tok-type">u64</span></code>。
      </p>
      <p>
      如何使用这个函数取决于你想要做什么。以下是几种情况之一:
      </p>
      <ul>
        <li>如果返回了错误,你想提供一个默认值。</li>
        <li>如果返回了错误,那么你想返回相同的错误。</li>
        <li>你完全确定它不会返回错误,所以想无条件地解包它。</li>
        <li>你想对每个可能的错误采取不同的行动。</li>
      </ul>
      <h4 id="catch"><a href="https://ziglang.org/documentation/0.15.2/#toc-catch">catch</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#catch">§</a></h4>

      <p>如果你想提供一个默认值,可以使用 <code><span class="tok-kw">catch</span></code> 二元运算符:</p>
      <figure><figcaption class="zig-cap"><cite class="file">catch.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> parseU64 = <span class="tok-builtin">@import</span>(<span class="tok-str">"error_union_parsing_u64.zig"</span>).parseU64;

<span class="tok-kw">fn</span> <span class="tok-fn">doAThing</span>(str: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> number = parseU64(str, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-number">13</span>;
    _ = number; <span class="tok-comment">// ...</span>
}</code></pre></figure>

      <p>
      在这段代码中,<code>number</code> 将等于成功解析的字符串,或者默认值 13。二元 <code><span class="tok-kw">catch</span></code> 运算符右侧的类型必须匹配解包后的错误联合类型,或者是 <code><span class="tok-type">noreturn</span></code> 类型。
      </p>
     <p>
      如果你想在使用 <code><span class="tok-kw">catch</span></code> 后执行一些逻辑后提供默认值,你可以将 <code><span class="tok-kw">catch</span></code> 与命名<a href="https://ziglang.org/documentation/0.15.2/#Blocks">块</a>结合使用:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">handle_error_with_catch_block.zig.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> parseU64 = <span class="tok-builtin">@import</span>(<span class="tok-str">"error_union_parsing_u64.zig"</span>).parseU64;

<span class="tok-kw">fn</span> <span class="tok-fn">doAThing</span>(str: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> number = parseU64(str, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> blk: {
        <span class="tok-comment">// do things</span>
        <span class="tok-kw">break</span> :blk <span class="tok-number">13</span>;
    };
    _ = number; <span class="tok-comment">// number is now initialized</span>
}</code></pre></figure>

      
      <h4 id="try"><a href="https://ziglang.org/documentation/0.15.2/#toc-try">try</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#try">§</a></h4>

      <p>假设你想在得到错误时返回该错误,否则继续函数逻辑:</p>
      <figure><figcaption class="zig-cap"><cite class="file">catch_err_return.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> parseU64 = <span class="tok-builtin">@import</span>(<span class="tok-str">"error_union_parsing_u64.zig"</span>).parseU64;

<span class="tok-kw">fn</span> <span class="tok-fn">doAThing</span>(str: []<span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> number = parseU64(str, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">return</span> err;
    _ = number; <span class="tok-comment">// ...</span>
}</code></pre></figure>

      <p>
      有一个快捷方式。<code><span class="tok-kw">try</span></code> 表达式:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">try.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> parseU64 = <span class="tok-builtin">@import</span>(<span class="tok-str">"error_union_parsing_u64.zig"</span>).parseU64;

<span class="tok-kw">fn</span> <span class="tok-fn">doAThing</span>(str: []<span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> number = <span class="tok-kw">try</span> parseU64(str, <span class="tok-number">10</span>);
    _ = number; <span class="tok-comment">// ...</span>
}</code></pre></figure>

      <p>
      <code><span class="tok-kw">try</span></code> 计算一个错误联合表达式。如果它是一个错误,则从当前函数返回相同的错误。否则,表达式的结果是解包后的值。
      </p>
      
      <p>
        也许你完全确定一个表达式永远不会是错误。
        在这种情况下,你可以这样做:
      </p>
      <code><span class="tok-kw">const</span> number = parseU64(<span class="tok-str">"1234"</span>, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</code>
      <p>
      这里我们确信 "1234" 将成功解析。所以我们在右侧放置 <code><span class="tok-kw">unreachable</span></code> 值。
      <code><span class="tok-kw">unreachable</span></code> 调用安全检查的<a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>,所以在 <a href="https://ziglang.org/documentation/0.15.2/#Debug">Debug</a> 和 <a href="https://ziglang.org/documentation/0.15.2/#ReleaseSafe">ReleaseSafe</a> 模式下,默认触发安全恐慌。因此,当我们调试应用程序时,如果这里<em>确实</em>有意外错误,应用程序会适当地崩溃。
      </p>
      <p>
      你可能想对每种情况采取不同的行动。为此,我们结合 <a href="https://ziglang.org/documentation/0.15.2/#if">if</a> 和 <a href="https://ziglang.org/documentation/0.15.2/#switch">switch</a> 表达式:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">handle_all_error_scenarios.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">doAThing</span>(str: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (parseU64(str, <span class="tok-number">10</span>)) |number| {
        doSomethingWithNumber(number);
    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.Overflow =&gt; {
            <span class="tok-comment">// handle overflow...</span>
        },
        <span class="tok-comment">// we promise that InvalidChar won't happen (or crash in debug mode if it does)</span>
        <span class="tok-kw">error</span>.InvalidChar =&gt; <span class="tok-kw">unreachable</span>,
    }
}</code></pre></figure>
      <p>
      最后,你可能只想处理某些错误。为此,你可以在 <code><span class="tok-kw">else</span></code> 分支中捕获未处理的错误,现在它包含一个更窄的错误集:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">handle_some_error_scenarios.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">doAnotherThing</span>(str: []<span class="tok-type">u8</span>) <span class="tok-kw">error</span>{InvalidChar}!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (parseU64(str, <span class="tok-number">10</span>)) |number| {
        doSomethingWithNumber(number);
    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.Overflow =&gt; {
            <span class="tok-comment">// handle overflow...</span>
        },
        <span class="tok-kw">else</span> =&gt; |leftover_err| <span class="tok-kw">return</span> leftover_err,
    }
}</code></pre></figure>
      <p>
      你必须使用变量捕获语法。如果你不需要变量,可以用 <code>_</code> 捕获并避免使用 <code><span class="tok-kw">switch</span></code>。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">handle_no_error_scenarios.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">doADifferentThing</span>(str: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (parseU64(str, <span class="tok-number">10</span>)) |number| {
        doSomethingWithNumber(number);
    } <span class="tok-kw">else</span> |_| {
        <span class="tok-comment">// do as you'd like</span>
    }
}</code></pre></figure>
      <h4 id="errdefer"><a href="https://ziglang.org/documentation/0.15.2/#toc-errdefer">errdefer</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#errdefer">§</a></h4>

      <p>
      错误处理的另一个组件是 defer 语句。
      除了无条件的 <a href="https://ziglang.org/documentation/0.15.2/#defer">defer</a>,Zig 还有 <code><span class="tok-kw">errdefer</span></code>,它在块退出路径上当且仅当函数从块返回错误时计算延迟表达式。
      </p>
      <p>
      示例:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">errdefer_example.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">createFoo</span>(param: <span class="tok-type">i32</span>) !Foo {
    <span class="tok-kw">const</span> foo = <span class="tok-kw">try</span> tryToAllocateFoo();
    <span class="tok-comment">// 现在我们已经分配了 foo。如果函数失败,我们需要释放它。</span>
    <span class="tok-comment">// 但如果函数成功,我们想返回它。</span>
    <span class="tok-kw">errdefer</span> deallocateFoo(foo);

    <span class="tok-kw">const</span> tmp_buf = allocateTmpBuffer() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory;
    <span class="tok-comment">// tmp_buf 确实是一个临时资源,我们肯定想在这个块离开作用域之前清理它</span>
    <span class="tok-kw">defer</span> deallocateTmpBuffer(tmp_buf);

    <span class="tok-kw">if</span> (param &gt; <span class="tok-number">1337</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidParam;

    <span class="tok-comment">// 这里 errdefer 不会运行,因为我们从函数返回成功。</span>
    <span class="tok-comment">// 但是 defer 会运行!</span>
    <span class="tok-kw">return</span> foo;
}</code></pre></figure>
      <p>
      这样做的好处是,你可以获得健壮的错误处理,而不会有冗长和认知开销,不用试图确保覆盖每个退出路径。释放代码总是直接跟随分配代码。
      </p>
      <p>
      <code><span class="tok-kw">errdefer</span></code> 语句可以选择性地捕获错误:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_errdefer_capture.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">fn</span> <span class="tok-fn">captureError</span>(captured: *?<span class="tok-type">anyerror</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">errdefer</span> |err| {
        captured.* = err;
    }
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.GeneralFailure;
}

<span class="tok-kw">test</span> <span class="tok-str">"errdefer capture"</span> {
    <span class="tok-kw">var</span> captured: ?<span class="tok-type">anyerror</span> = <span class="tok-null">null</span>;

    <span class="tok-kw">if</span> (captureError(&amp;captured)) <span class="tok-kw">unreachable</span> <span class="tok-kw">else</span> |err| {
        <span class="tok-kw">try</span> std.testing.expectEqual(<span class="tok-kw">error</span>.GeneralFailure, captured.?);
        <span class="tok-kw">try</span> std.testing.expectEqual(<span class="tok-kw">error</span>.GeneralFailure, err);
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_errdefer_capture.zig</kbd>
1/1 test_errdefer_capture.test.errdefer capture...OK
All 1 tests passed.
</samp></pre></figure>
      
      <p>
      关于错误处理的其他一些要点:
      </p>
      <ul>
        <li>这些原语提供了足够的表现力,使得未能检查错误成为编译错误是完全实用的。如果你真的想忽略错误,可以添加 <code><span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span></code>,并在 Debug 和 ReleaseSafe 模式下如果你的假设错误时获得崩溃的额外好处。
        </li>
        <li>
          由于 Zig 理解错误类型,它可以预先加权分支以支持不发生错误。这只是一个小的优化好处,在其他语言中是无法获得的。
        </li>
      </ul>
      <p>另见:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#defer">defer</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#if">if</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#switch">switch</a></li>
</ul>


      <p>错误联合使用 <code>!</code> 二元运算符创建。
      你可以使用编译时反射来访问错误联合的子类型:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_error_union.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"error union"</span> {
    <span class="tok-kw">var</span> foo: <span class="tok-type">anyerror</span>!<span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;

    <span class="tok-comment">// 从错误联合的子类型强制转换:</span>
    foo = <span class="tok-number">1234</span>;

    <span class="tok-comment">// 从错误集强制转换:</span>
    foo = <span class="tok-kw">error</span>.SomeError;

    <span class="tok-comment">// 使用编译时反射访问错误联合的负载类型:</span>
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> expect(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(foo)).error_union.payload == <span class="tok-type">i32</span>);

    <span class="tok-comment">// 使用编译时反射访问错误联合的错误集类型:</span>
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> expect(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(foo)).error_union.error_set == <span class="tok-type">anyerror</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_error_union.zig</kbd>
1/1 test_error_union.test.error union...OK
All 1 tests passed.
</samp></pre></figure>

      <h4 id="Merging-Error-Sets"><a href="https://ziglang.org/documentation/0.15.2/#toc-Merging-Error-Sets">合并错误集</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Merging-Error-Sets">§</a></h4>

      <p>
      使用 <code>||</code> 运算符将两个错误集合并在一起。结果错误集包含两个错误集的错误。左侧的文档注释覆盖右侧的文档注释。在这个例子中,<code>C.PathNotFound</code> 的文档注释是 <code>A doc comment</code>。
      </p>
      <p>
      这对于根据 <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a> 分支返回不同错误集的函数特别有用。例如,Zig 标准库使用 <code>LinuxFileOpenError || WindowsFileOpenError</code> 作为打开文件的错误集。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_merging_error_sets.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> A = <span class="tok-kw">error</span>{
    NotDir,

    <span class="tok-comment">/// A doc comment</span>
    PathNotFound,
};
<span class="tok-kw">const</span> B = <span class="tok-kw">error</span>{
    OutOfMemory,

    <span class="tok-comment">/// B doc comment</span>
    PathNotFound,
};

<span class="tok-kw">const</span> C = A || B;

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() C!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir;
}

<span class="tok-kw">test</span> <span class="tok-str">"merge error sets"</span> {
    <span class="tok-kw">if</span> (foo()) {
        <span class="tok-builtin">@panic</span>(<span class="tok-str">"unexpected"</span>);
    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">"unexpected"</span>),
        <span class="tok-kw">error</span>.PathNotFound =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">"unexpected"</span>),
        <span class="tok-kw">error</span>.NotDir =&gt; {},
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_merging_error_sets.zig</kbd>
1/1 test_merging_error_sets.test.merge error sets...OK
All 1 tests passed.
</samp></pre></figure>

      
      <h4 id="Inferred-Error-Sets"><a href="https://ziglang.org/documentation/0.15.2/#toc-Inferred-Error-Sets">推断错误集</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Inferred-Error-Sets">§</a></h4>

      <p>
      因为 Zig 中的许多函数都返回可能的错误,Zig 支持推断错误集。
      要推断函数的错误集,在函数的返回类型前加上 <code>!</code> 运算符,如 <code>!T</code>:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_inferred_error_sets.zig</cite></figcaption><pre><code><span class="tok-comment">// 使用推断的错误集</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add_inferred</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T) !T {
    <span class="tok-kw">const</span> ov = <span class="tok-builtin">@addWithOverflow</span>(a, b);
    <span class="tok-kw">if</span> (ov[<span class="tok-number">1</span>] != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
    <span class="tok-kw">return</span> ov[<span class="tok-number">0</span>];
}

<span class="tok-comment">// 使用显式的错误集</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add_explicit</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T) Error!T {
    <span class="tok-kw">const</span> ov = <span class="tok-builtin">@addWithOverflow</span>(a, b);
    <span class="tok-kw">if</span> (ov[<span class="tok-number">1</span>] != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
    <span class="tok-kw">return</span> ov[<span class="tok-number">0</span>];
}

<span class="tok-kw">const</span> Error = <span class="tok-kw">error</span>{
    Overflow,
};

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">test</span> <span class="tok-str">"inferred error set"</span> {
    <span class="tok-kw">if</span> (add_inferred(<span class="tok-type">u8</span>, <span class="tok-number">255</span>, <span class="tok-number">1</span>)) |_| <span class="tok-kw">unreachable</span> <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.Overflow =&gt; {}, <span class="tok-comment">// ok</span>
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_inferred_error_sets.zig</kbd>
1/1 test_inferred_error_sets.test.inferred error set...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      当函数具有推断的错误集时,该函数变为泛型,因此使用它做某些事情变得更加困难,例如获取函数指针,或拥有在不同构建目标之间一致的错误集。此外,推断的错误集与递归不兼容。
      </p>
      <p>
      在这些情况下,建议使用显式错误集。你通常可以从空错误集开始,让编译错误引导你完成该集合。
      </p>
      <p>
      这些限制可能会在 Zig 的未来版本中克服。
      </p>
      
      
      <h3 id="Error-Return-Traces"><a href="https://ziglang.org/documentation/0.15.2/#toc-Error-Return-Traces">错误返回跟踪</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Error-Return-Traces">§</a></h3>

      <p>
      错误返回跟踪显示了代码中错误返回到调用函数的所有点。这使得在任何地方使用 <a href="https://ziglang.org/documentation/0.15.2/#try">try</a> 变得实用,然后如果错误最终从应用程序中冒出来,仍然能够知道发生了什么。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">error_return_trace.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> foo(<span class="tok-number">12</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(x: <span class="tok-type">i32</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (x &gt;= <span class="tok-number">5</span>) {
        <span class="tok-kw">try</span> bar();
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">try</span> bang2();
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (baz()) {
        <span class="tok-kw">try</span> quux();
    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">try</span> hello(),
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">baz</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> bang1();
}

<span class="tok-kw">fn</span> <span class="tok-fn">quux</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> bang2();
}

<span class="tok-kw">fn</span> <span class="tok-fn">hello</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> bang2();
}

<span class="tok-kw">fn</span> <span class="tok-fn">bang1</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound;
}

<span class="tok-kw">fn</span> <span class="tok-fn">bang2</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe error_return_trace.zig</kbd>
$ <kbd>./error_return_trace</kbd>
error: PermissionDenied
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/error_return_trace.zig:34:5</span>: <span class="sgr-2m">0x113d36c in bang1 (error_return_trace.zig)</span>
    return error.FileNotFound;
    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/error_return_trace.zig:22:5</span>: <span class="sgr-2m">0x113d3b6 in baz (error_return_trace.zig)</span>
    try bang1();
    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/error_return_trace.zig:38:5</span>: <span class="sgr-2m">0x113d3ec in bang2 (error_return_trace.zig)</span>
    return error.PermissionDenied;
    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/error_return_trace.zig:30:5</span>: <span class="sgr-2m">0x113d496 in hello (error_return_trace.zig)</span>
    try bang2();
    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/error_return_trace.zig:17:31</span>: <span class="sgr-2m">0x113d56e in bar (error_return_trace.zig)</span>
        error.FileNotFound =&gt; try hello(),
                              <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/error_return_trace.zig:7:9</span>: <span class="sgr-2m">0x113d654 in foo (error_return_trace.zig)</span>
        try bar();
        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/error_return_trace.zig:2:5</span>: <span class="sgr-2m">0x113d71b in main (error_return_trace.zig)</span>
    try foo(12);
    <span class="sgr-32m">^</span>
</samp></pre></figure>

      <p>
      仔细看这个例子。这不是栈跟踪。
      </p>
      <p>
      你可以看到最终冒出来的错误是 <code>PermissionDenied</code>,
          但最初引发这一切的错误是 <code>FileNotFound</code>。在 <code>bar</code> 函数中,代码处理了原始错误代码,然后从 switch 语句返回另一个错误。错误返回跟踪清楚地显示了这一点,而栈跟踪看起来像这样:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">stack_trace.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    foo(<span class="tok-number">12</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(x: <span class="tok-type">i32</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (x &gt;= <span class="tok-number">5</span>) {
        bar();
    } <span class="tok-kw">else</span> {
        bang2();
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (baz()) {
        quux();
    } <span class="tok-kw">else</span> {
        hello();
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">baz</span>() <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> bang1();
}

<span class="tok-kw">fn</span> <span class="tok-fn">quux</span>() <span class="tok-type">void</span> {
    bang2();
}

<span class="tok-kw">fn</span> <span class="tok-fn">hello</span>() <span class="tok-type">void</span> {
    bang2();
}

<span class="tok-kw">fn</span> <span class="tok-fn">bang1</span>() <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">bang2</span>() <span class="tok-type">void</span> {
    <span class="tok-builtin">@panic</span>(<span class="tok-str">"PermissionDenied"</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe stack_trace.zig</kbd>
$ <kbd>./stack_trace</kbd>
thread 2902479 panic: PermissionDenied
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/stack_trace.zig:38:5</span>: <span class="sgr-2m">0x1140e6c in bang2 (stack_trace.zig)</span>
    @panic("PermissionDenied");
    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/stack_trace.zig:30:10</span>: <span class="sgr-2m">0x11414ac in hello (stack_trace.zig)</span>
    bang2();
         <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/stack_trace.zig:17:14</span>: <span class="sgr-2m">0x1140e23 in bar (stack_trace.zig)</span>
        hello();
             <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/stack_trace.zig:7:12</span>: <span class="sgr-2m">0x1140ab8 in foo (stack_trace.zig)</span>
        bar();
           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/stack_trace.zig:2:8</span>: <span class="sgr-2m">0x113f871 in main (stack_trace.zig)</span>
    foo(12);
       <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113eabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113e351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      <p>
      这里,栈跟踪没有解释 <code>bar</code> 中的控制流如何到达 <code>hello()</code> 调用。
      必须打开调试器或进一步检测应用程序才能找出原因。另一方面,错误返回跟踪确切地显示了错误是如何冒出来的。
      </p>
      <p>
      这个调试功能使得在健壮处理所有错误条件的代码上快速迭代变得更容易。这意味着 Zig 开发人员会自然而然地发现自己编写正确、健壮的代码,以提高开发速度。
      </p>
      <p>
      错误返回跟踪在 <a href="https://ziglang.org/documentation/0.15.2/#Debug">Debug</a> 构建中默认启用,在 <a href="https://ziglang.org/documentation/0.15.2/#ReleaseFast">ReleaseFast</a>、<a href="https://ziglang.org/documentation/0.15.2/#ReleaseSafe">ReleaseSafe</a> 和 <a href="https://ziglang.org/documentation/0.15.2/#ReleaseSmall">ReleaseSmall</a> 构建中默认禁用。
      </p>
      <p>
      有几种方法可以激活此错误返回跟踪功能:
      </p>
      <ul>
        <li>从 main 返回一个错误</li>
        <li>错误最终到达 <code><span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span></code> 且你没有覆盖默认的 panic 处理程序</li>
        <li>使用 <a href="https://ziglang.org/documentation/0.15.2/#errorReturnTrace">errorReturnTrace</a> 访问当前返回跟踪。你可以使用 <code>std.debug.dumpStackTrace</code> 打印它。当在没有错误返回跟踪支持的情况下构建时,此函数返回编译时已知的 <a href="https://ziglang.org/documentation/0.15.2/#null">null</a>。</li>
      </ul>
      <h4 id="Implementation-Details"><a href="https://ziglang.org/documentation/0.15.2/#toc-Implementation-Details">实现细节</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Implementation-Details">§</a></h4>

      <p>
      要分析性能成本,有两种情况:
      </p>
      <ul>
        <li>当没有返回错误时</li>
        <li>当返回错误时</li>
      </ul>
      <p>
      对于没有返回错误的情况,成本是单个内存写操作,仅在调用图中第一个调用可失败函数的不可失败函数中,即当返回 <code><span class="tok-type">void</span></code> 的函数调用返回 <code><span class="tok-kw">error</span></code> 的函数时。
      这是为了在栈内存中初始化此结构:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">stack_trace_struct.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">const</span> StackTrace = <span class="tok-kw">struct</span> {
    index: <span class="tok-type">usize</span>,
    instruction_addresses: [N]<span class="tok-type">usize</span>,
};</code></pre></figure>
      <p>
      这里,N 是由调用图分析确定的最大函数调用深度。递归被忽略并计为 2。
      </p>
      <p>
      指向 <code>StackTrace</code> 的指针作为秘密参数传递给每个可以返回错误的函数,但它总是第一个参数,所以它可能位于寄存器中并保持在那里。
      </p>
      <p>
      对于没有发生错误的路径来说就是这样。在性能方面实际上是免费的。
      </p>
      <p>
      当为返回错误的函数生成代码时,就在 <code><span class="tok-kw">return</span></code> 语句之前(仅对于返回错误的 <code><span class="tok-kw">return</span></code> 语句),Zig 生成对此函数的调用:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">zig_return_error_fn.zig</cite></figcaption><pre><code><span class="tok-comment">// 在 LLVM IR 中标记为 "no-inline"</span>
<span class="tok-kw">fn</span> <span class="tok-fn">__zig_return_error</span>(stack_trace: *StackTrace) <span class="tok-type">void</span> {
    stack_trace.instruction_addresses[stack_trace.index] = <span class="tok-builtin">@returnAddress</span>();
    stack_trace.index = (stack_trace.index + <span class="tok-number">1</span>) % N;
}</code></pre></figure>
      <p>
      成本是 2 个数学操作加上一些内存读写。访问的内存受到限制,应该在错误返回冒泡期间保持缓存。
      </p>
      <p>
      至于代码大小成本,return 语句之前的 1 个函数调用没什么大不了的。即便如此,我也有<a href="https://github.com/ziglang/zig/issues/690">计划</a>将对 <code>__zig_return_error</code> 的调用变为尾调用,这将代码大小成本降低到实际为零。在没有错误返回跟踪的代码中是 return 语句的内容,在有错误返回跟踪的代码中可以变成跳转指令。
      </p>
      
      
      
      <h2 id="Optionals"><a href="https://ziglang.org/documentation/0.15.2/#toc-Optionals">可选值</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Optionals">§</a></h2>

      <p>
      Zig 在不影响效率或可读性的情况下提供安全的一个领域是可选类型。
      </p>
      <p>
      问号象征可选类型。你可以通过在类型前面放一个问号将类型转换为可选类型,像这样:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">optional_integer.zig</cite></figcaption><pre><code><span class="tok-comment">// 普通整数</span>
<span class="tok-kw">const</span> normal_int: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;

<span class="tok-comment">// 可选整数</span>
<span class="tok-kw">const</span> optional_int: ?<span class="tok-type">i32</span> = <span class="tok-number">5678</span>;</code></pre></figure>

      <p>
      现在变量 <code>optional_int</code> 可以是 <code><span class="tok-type">i32</span></code>,或者 <code><span class="tok-null">null</span></code>。
      </p>
      <p>
      与其说整数,不如说指针。空引用是许多运行时异常的来源,甚至被指责为<a href="https://www.lucidchart.com/techblog/2015/08/31/the-worst-mistake-of-computer-science/">计算机科学的最大错误</a>。
      </p>
      <p>Zig 没有它们。</p>
      <p>
      相反,你可以使用可选指针。这在内部编译为普通指针,因为我们知道可以将 0 用作可选类型的 null 值。但编译器可以检查你的工作并确保你不会将 null 分配给不能为 null 的东西。
      </p>
      <p>
      通常没有 null 的缺点是它使代码编写起来更冗长。但是,让我们比较一些等效的 C 代码和 Zig 代码。
      </p>
      <p>
      任务:调用 malloc,如果结果为 null,返回 null。
      </p>
      <p>C 代码</p>
      <figure><figcaption class="c-cap"><cite class="file">call_malloc_in_c.c</cite></figcaption><pre><code>// malloc 原型包含在内以供参考
void *malloc(size_t size);

struct Foo *do_a_thing(void) {
    char *ptr = malloc(1234);
    if (!ptr) return NULL;
    // ...
}</code></pre></figure>
      <p>Zig 代码</p>
      <figure><figcaption class="zig-cap"><cite class="file">call_malloc_from_zig.zig</cite></figcaption><pre><code><span class="tok-comment">// malloc 原型包含在内以供参考</span>
<span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">malloc</span>(size: <span class="tok-type">usize</span>) ?[*]<span class="tok-type">u8</span>;

<span class="tok-kw">fn</span> <span class="tok-fn">doAThing</span>() ?*Foo {
    <span class="tok-kw">const</span> ptr = malloc(<span class="tok-number">1234</span>) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    _ = ptr; <span class="tok-comment">// ...</span>
}</code></pre></figure>
      <p>
        这里,Zig 至少和 C 一样方便,如果不是更方便的话。并且,"ptr" 的类型是 <code>[*]<span class="tok-type">u8</span></code> <em>而不是</em> <code>?[*]<span class="tok-type">u8</span></code>。<code><span class="tok-kw">orelse</span></code> 关键字解包了可选类型,因此 <code>ptr</code> 在函数中使用的任何地方都保证是非 null 的。
      </p>
      <p>
        你可能看到的另一种形式的 NULL 检查看起来像这样:
      </p>
      <figure><figcaption class="c-cap"><cite class="file">checking_null_in_c.c</cite></figcaption><pre><code>void do_a_thing(struct Foo *foo) {
    // do some stuff

    if (foo) {
        do_something_with_foo(foo);
    }

    // do some stuff
}</code></pre></figure>
      <p>
        在 Zig 中你可以完成同样的事情:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">checking_null_in_zig.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Foo = <span class="tok-kw">struct</span> {};
<span class="tok-kw">fn</span> <span class="tok-fn">doSomethingWithFoo</span>(foo: *Foo) <span class="tok-type">void</span> {
    _ = foo;
}

<span class="tok-kw">fn</span> <span class="tok-fn">doAThing</span>(optional_foo: ?*Foo) <span class="tok-type">void</span> {
    <span class="tok-comment">// do some stuff</span>

    <span class="tok-kw">if</span> (optional_foo) |foo| {
        doSomethingWithFoo(foo);
    }

    <span class="tok-comment">// do some stuff</span>
}</code></pre></figure>

      <p>
      再次,这里值得注意的是,在 if 块内,<code>foo</code> 不再是可选指针,它是一个指针,不能为 null。
      </p>
      <p>
      这样做的一个好处是,将指针作为参数的函数可以使用 "nonnull" 属性注释 - 在 <a href="https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Function-Attributes.html">GCC</a> 中是 <code>__attribute__((nonnull))</code>。
      优化器有时可以根据指针参数不能为 null 做出更好的决策。
      </p>
      <h3 id="Optional-Type"><a href="https://ziglang.org/documentation/0.15.2/#toc-Optional-Type">可选类型</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Optional-Type">§</a></h3>

      <p>可选值通过在类型前面放置 <code>?</code> 创建。你可以使用编译时反射访问可选值的子类型:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_optional_type.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"optional type"</span> {
    <span class="tok-comment">// 声明一个可选值并从 null 强制转换:</span>
    <span class="tok-kw">var</span> foo: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>;

    <span class="tok-comment">// 从可选值的子类型强制转换</span>
    foo = <span class="tok-number">1234</span>;

    <span class="tok-comment">// 使用编译时反射访问可选值的子类型:</span>
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> expect(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(foo)).optional.child == <span class="tok-type">i32</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_optional_type.zig</kbd>
1/1 test_optional_type.test.optional type...OK
All 1 tests passed.
</samp></pre></figure>

      
      <h3 id="null"><a href="https://ziglang.org/documentation/0.15.2/#toc-null">null</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#null">§</a></h3>

      <p>
      就像 <a href="https://ziglang.org/documentation/0.15.2/#undefined">undefined</a> 一样,<code><span class="tok-null">null</span></code> 有自己的类型,使用它的唯一方法是将其转换为不同的类型:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">null.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> optional_value: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>;</code></pre></figure>

      
      <h3 id="Optional-Pointers"><a href="https://ziglang.org/documentation/0.15.2/#toc-Optional-Pointers">可选指针</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Optional-Pointers">§</a></h3>

      <p>可选指针保证与指针大小相同。可选值的 <code><span class="tok-null">null</span></code> 保证是地址 0。</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_optional_pointer.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"optional pointers"</span> {
    <span class="tok-comment">// 指针不能为 null。如果你想要一个 null 指针,使用可选</span>
    <span class="tok-comment">// 前缀 `?` 使指针类型成为可选的。</span>
    <span class="tok-kw">var</span> ptr: ?*<span class="tok-type">i32</span> = <span class="tok-null">null</span>;

    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
    ptr = &amp;x;

    <span class="tok-kw">try</span> expect(ptr.?.* == <span class="tok-number">1</span>);

    <span class="tok-comment">// 可选指针与普通指针大小相同,因为指针值 0 用作 null 值。</span>
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@sizeOf</span>(?*<span class="tok-type">i32</span>) == <span class="tok-builtin">@sizeOf</span>(*<span class="tok-type">i32</span>));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_optional_pointer.zig</kbd>
1/1 test_optional_pointer.test.optional pointers...OK
All 1 tests passed.
</samp></pre></figure>

      

      <p>另见:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#while-with-Optionals">while 与可选值</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#if-with-Optionals">if 与可选值</a></li>
</ul>

      
      <h2 id="Casting"><a href="https://ziglang.org/documentation/0.15.2/#toc-Casting">类型转换</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Casting">§</a></h2>

      <p>
      <strong>类型转换</strong>将一种类型的值转换为另一种类型。
      Zig 对已知完全安全且明确的转换使用<a href="https://ziglang.org/documentation/0.15.2/#Type-Coercion">类型强制转换</a>,对不希望意外发生的转换使用<a href="https://ziglang.org/documentation/0.15.2/#Explicit-Casts">显式转换</a>。
      还有第三种类型转换,称为<a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">同级类型解析</a>,用于在给定多个操作数类型的情况下必须决定结果类型的情况。
      </p>
      <h3 id="Type-Coercion"><a href="https://ziglang.org/documentation/0.15.2/#toc-Type-Coercion">类型强制转换</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Type-Coercion">§</a></h3>

      <p>
      当需要一种类型,但提供了不同的类型时,就会发生类型强制转换:
      </p>
<!-- ====== END CHUNK 7: new_07.html ====== -->

<!-- ====== BEGIN CHUNK 8: new_08.html ====== -->
<figure><figcaption class="zig-cap"><cite class="file">test_type_coercion.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">"类型强制转换 - 变量声明"</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">u8</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">u16</span> = a;
    _ = b;
}

<span class="tok-kw">test</span> <span class="tok-str">"类型强制转换 - 函数调用"</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">u8</span> = <span class="tok-number">1</span>;
    foo(a);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(b: <span class="tok-type">u16</span>) <span class="tok-type">void</span> {
    _ = b;
}

<span class="tok-kw">test</span> <span class="tok-str">"类型强制转换 - @as 内置函数"</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">u8</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> b = <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, a);
    _ = b;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_type_coercion.zig</kbd>
1/3 test_type_coercion.test.type coercion - variable declaration...OK
2/3 test_type_coercion.test.type coercion - function call...OK
3/3 test_type_coercion.test.type coercion - @as builtin...OK
All 3 tests passed.
</samp></pre></figure>

      <p>
      只有在如何从一种类型转换到另一种类型完全明确且转换保证安全时,才允许类型强制转换。有一个例外,即 <a href="https://ziglang.org/documentation/0.15.2/#C-Pointers">C 指针</a>。
      </p>
      <h4 id="Type-Coercion-Stricter-Qualification"><a href="https://ziglang.org/documentation/0.15.2/#toc-Type-Coercion-Stricter-Qualification">类型强制转换:更严格的限定</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Type-Coercion-Stricter-Qualification">§</a></h4>

      <p>
      在运行时具有相同表示的值可以被转换以增加限定符的严格性,无论限定符嵌套多深:
      </p>
      <ul>
          <li><code><span class="tok-kw">const</span></code> - 允许从非 const 转换到 const</li>
          <li><code><span class="tok-kw">volatile</span></code> - 允许从非 volatile 转换到 volatile</li>
          <li><code><span class="tok-kw">align</span></code> - 允许从较大对齐转换到较小对齐 </li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#Error-Set-Type">错误集</a> 到超集是允许的</li>
      </ul>
      <p>
      这些转换在运行时是无操作的,因为值的表示不会改变。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_no_op_casts.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">"类型强制转换 - const 限定"</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> b: *<span class="tok-type">i32</span> = &amp;a;
    foo(b);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(_: *<span class="tok-kw">const</span> <span class="tok-type">i32</span>) <span class="tok-type">void</span> {}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_no_op_casts.zig</kbd>
1/1 test_no_op_casts.test.type coercion - const qualification...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      此外,指针可以强制转换为 const 可选指针:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_pointer_coerce_const_optional.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;
<span class="tok-kw">const</span> mem = std.mem;

<span class="tok-kw">test</span> <span class="tok-str">"将 *[1][*:0]const u8 转换为 []const ?[*:0]const u8"</span> {
    <span class="tok-kw">const</span> window_name = [<span class="tok-number">1</span>][*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{<span class="tok-str">"window name"</span>};
    <span class="tok-kw">const</span> x: []<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;window_name;
    <span class="tok-kw">try</span> expect(mem.eql(<span class="tok-type">u8</span>, mem.span(x[<span class="tok-number">0</span>].?), <span class="tok-str">"window name"</span>));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_pointer_coerce_const_optional.zig</kbd>
1/1 test_pointer_coerce_const_optional.test.cast *[1][*:0]const u8 to []const ?[*:0]const u8...OK
All 1 tests passed.
</samp></pre></figure>

      
      <h4 id="Type-Coercion-Integer-and-Float-Widening"><a href="https://ziglang.org/documentation/0.15.2/#toc-Type-Coercion-Integer-and-Float-Widening">类型强制转换:整数和浮点数拓宽</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Type-Coercion-Integer-and-Float-Widening">§</a></h4>

      <p>
      <a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a> 可以强制转换为能够表示旧类型所有值的整数类型,同样地,<a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a> 可以强制转换为能够表示旧类型所有值的浮点类型。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_integer_widening.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">"builtin"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;
<span class="tok-kw">const</span> mem = std.mem;

<span class="tok-kw">test</span> <span class="tok-str">"整数拓宽"</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">u8</span> = <span class="tok-number">250</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">u16</span> = a;
    <span class="tok-kw">const</span> c: <span class="tok-type">u32</span> = b;
    <span class="tok-kw">const</span> d: <span class="tok-type">u64</span> = c;
    <span class="tok-kw">const</span> e: <span class="tok-type">u64</span> = d;
    <span class="tok-kw">const</span> f: <span class="tok-type">u128</span> = e;
    <span class="tok-kw">try</span> expect(f == a);
}

<span class="tok-kw">test</span> <span class="tok-str">"无符号整数隐式转换为有符号整数"</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">u8</span> = <span class="tok-number">250</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">i16</span> = a;
    <span class="tok-kw">try</span> expect(b == <span class="tok-number">250</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"浮点数拓宽"</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">f16</span> = <span class="tok-number">12.34</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">f32</span> = a;
    <span class="tok-kw">const</span> c: <span class="tok-type">f64</span> = b;
    <span class="tok-kw">const</span> d: <span class="tok-type">f128</span> = c;
    <span class="tok-kw">try</span> expect(d == a);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_integer_widening.zig</kbd>
1/3 test_integer_widening.test.integer widening...OK
2/3 test_integer_widening.test.implicit unsigned integer to signed integer...OK
3/3 test_integer_widening.test.float widening...OK
All 3 tests passed.
</samp></pre></figure>

      
      <h4 id="Type-Coercion-Float-to-Int"><a href="https://ziglang.org/documentation/0.15.2/#toc-Type-Coercion-Float-to-Int">类型强制转换:浮点数到整数</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Type-Coercion-Float-to-Int">§</a></h4>

      <p>
      编译错误是合适的,因为这个有歧义的表达式给编译器留下了两种关于强制转换的选择。
      </p>
      <ul>
        <li>将 <code><span class="tok-number">54.0</span></code> 转换为 <code><span class="tok-type">comptime_int</span></code> 得到 <code><span class="tok-builtin">@as</span>(<span class="tok-type">comptime_int</span>, <span class="tok-number">10</span>)</code>,再转换为 <code><span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-number">10</span>)</code></li>
        <li>将 <code><span class="tok-number">5</span></code> 转换为 <code><span class="tok-type">comptime_float</span></code> 得到 <code><span class="tok-builtin">@as</span>(<span class="tok-type">comptime_float</span>, <span class="tok-number">10.8</span>)</code>,再转换为 <code><span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-number">10.8</span>)</code></li>
      </ul>
      <figure><figcaption class="zig-cap"><cite class="file">test_ambiguous_coercion.zig</cite></figcaption><pre><code><span class="tok-comment">// 浮点数到整数的编译时强制转换</span>
<span class="tok-kw">test</span> <span class="tok-str">"隐式转换为 comptime_int"</span> {
    <span class="tok-kw">const</span> f: <span class="tok-type">f32</span> = <span class="tok-number">54.0</span> / <span class="tok-number">5</span>;
    _ = f;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_ambiguous_coercion.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_ambiguous_coercion.zig:3:25: </span><span class="sgr-31m">error: </span><span class="sgr-1m">ambiguous coercion of division operands 'comptime_float' and 'comptime_int'; non-zero remainder '4'
</span>    const f: f32 = 54.0 / 5;
                   <span class="sgr-32m">~~~~~^~~
</span>
</samp></pre></figure>

      
      <h4 id="Type-Coercion-Slices-Arrays-and-Pointers"><a href="https://ziglang.org/documentation/0.15.2/#toc-Type-Coercion-Slices-Arrays-and-Pointers">类型强制转换:切片、数组和指针</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Type-Coercion-Slices-Arrays-and-Pointers">§</a></h4>

      <figure><figcaption class="zig-cap"><cite class="file">test_coerce_slices_arrays_and_pointers.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-comment">// 您可以将数组的常量指针赋值给带有元素类型 const 修饰符的切片。</span>
<span class="tok-comment">// 这对于字符串字面量特别有用。</span>
<span class="tok-kw">test</span> <span class="tok-str">"*const [N]T 转换为 []const T"</span> {
    <span class="tok-kw">const</span> x1: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">"hello"</span>;
    <span class="tok-kw">const</span> x2: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;[<span class="tok-number">5</span>]<span class="tok-type">u8</span>{ <span class="tok-str">'h'</span>, <span class="tok-str">'e'</span>, <span class="tok-str">'l'</span>, <span class="tok-str">'l'</span>, <span class="tok-number">111</span> };
    <span class="tok-kw">try</span> expect(std.mem.eql(<span class="tok-type">u8</span>, x1, x2));

    <span class="tok-kw">const</span> y: []<span class="tok-kw">const</span> <span class="tok-type">f32</span> = &amp;[<span class="tok-number">2</span>]<span class="tok-type">f32</span>{ <span class="tok-number">1.2</span>, <span class="tok-number">3.4</span> };
    <span class="tok-kw">try</span> expect(y[<span class="tok-number">0</span>] == <span class="tok-number">1.2</span>);
}

<span class="tok-comment">// 同样,当目标类型是错误联合类型时,它也适用。</span>
<span class="tok-kw">test</span> <span class="tok-str">"*const [N]T 转换为 E![]const T"</span> {
    <span class="tok-kw">const</span> x1: <span class="tok-type">anyerror</span>![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">"hello"</span>;
    <span class="tok-kw">const</span> x2: <span class="tok-type">anyerror</span>![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;[<span class="tok-number">5</span>]<span class="tok-type">u8</span>{ <span class="tok-str">'h'</span>, <span class="tok-str">'e'</span>, <span class="tok-str">'l'</span>, <span class="tok-str">'l'</span>, <span class="tok-number">111</span> };
    <span class="tok-kw">try</span> expect(std.mem.eql(<span class="tok-type">u8</span>, <span class="tok-kw">try</span> x1, <span class="tok-kw">try</span> x2));

    <span class="tok-kw">const</span> y: <span class="tok-type">anyerror</span>![]<span class="tok-kw">const</span> <span class="tok-type">f32</span> = &amp;[<span class="tok-number">2</span>]<span class="tok-type">f32</span>{ <span class="tok-number">1.2</span>, <span class="tok-number">3.4</span> };
    <span class="tok-kw">try</span> expect((<span class="tok-kw">try</span> y)[<span class="tok-number">0</span>] == <span class="tok-number">1.2</span>);
}

<span class="tok-comment">// 同样,当目标类型是可选类型时,它也适用。</span>
<span class="tok-kw">test</span> <span class="tok-str">"*const [N]T 转换为 ?[]const T"</span> {
    <span class="tok-kw">const</span> x1: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">"hello"</span>;
    <span class="tok-kw">const</span> x2: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;[<span class="tok-number">5</span>]<span class="tok-type">u8</span>{ <span class="tok-str">'h'</span>, <span class="tok-str">'e'</span>, <span class="tok-str">'l'</span>, <span class="tok-str">'l'</span>, <span class="tok-number">111</span> };
    <span class="tok-kw">try</span> expect(std.mem.eql(<span class="tok-type">u8</span>, x1.?, x2.?));

    <span class="tok-kw">const</span> y: ?[]<span class="tok-kw">const</span> <span class="tok-type">f32</span> = &amp;[<span class="tok-number">2</span>]<span class="tok-type">f32</span>{ <span class="tok-number">1.2</span>, <span class="tok-number">3.4</span> };
    <span class="tok-kw">try</span> expect(y.?[<span class="tok-number">0</span>] == <span class="tok-number">1.2</span>);
}

<span class="tok-comment">// 在这种转换中,数组长度成为切片长度。</span>
<span class="tok-kw">test</span> <span class="tok-str">"*[N]T 转换为 []T"</span> {
    <span class="tok-kw">var</span> buf: [<span class="tok-number">5</span>]<span class="tok-type">u8</span> = <span class="tok-str">"hello"</span>.*;
    <span class="tok-kw">const</span> x: []<span class="tok-type">u8</span> = &amp;buf;
    <span class="tok-kw">try</span> expect(std.mem.eql(<span class="tok-type">u8</span>, x, <span class="tok-str">"hello"</span>));

    <span class="tok-kw">const</span> buf2 = [<span class="tok-number">2</span>]<span class="tok-type">f32</span>{ <span class="tok-number">1.2</span>, <span class="tok-number">3.4</span> };
    <span class="tok-kw">const</span> x2: []<span class="tok-kw">const</span> <span class="tok-type">f32</span> = &amp;buf2;
    <span class="tok-kw">try</span> expect(std.mem.eql(<span class="tok-type">f32</span>, x2, &amp;[<span class="tok-number">2</span>]<span class="tok-type">f32</span>{ <span class="tok-number">1.2</span>, <span class="tok-number">3.4</span> }));
}

<span class="tok-comment">// 数组的单项指针可以强制转换为多项指针。</span>
<span class="tok-kw">test</span> <span class="tok-str">"*[N]T 转换为 [*]T"</span> {
    <span class="tok-kw">var</span> buf: [<span class="tok-number">5</span>]<span class="tok-type">u8</span> = <span class="tok-str">"hello"</span>.*;
    <span class="tok-kw">const</span> x: [*]<span class="tok-type">u8</span> = &amp;buf;
    <span class="tok-kw">try</span> expect(x[<span class="tok-number">4</span>] == <span class="tok-str">'o'</span>);
    <span class="tok-comment">// x[5] 会是未捕获的越界指针解引用!</span>
}

<span class="tok-comment">// 同样,当目标类型是可选类型时,它也适用。</span>
<span class="tok-kw">test</span> <span class="tok-str">"*[N]T 转换为 ?[*]T"</span> {
    <span class="tok-kw">var</span> buf: [<span class="tok-number">5</span>]<span class="tok-type">u8</span> = <span class="tok-str">"hello"</span>.*;
    <span class="tok-kw">const</span> x: ?[*]<span class="tok-type">u8</span> = &amp;buf;
    <span class="tok-kw">try</span> expect(x.?[<span class="tok-number">4</span>] == <span class="tok-str">'o'</span>);
}

<span class="tok-comment">// 单项指针可以转换为长度为 1 的单项数组。</span>
<span class="tok-kw">test</span> <span class="tok-str">"*T 转换为 *[1]T"</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    <span class="tok-kw">const</span> y: *[<span class="tok-number">1</span>]<span class="tok-type">i32</span> = &amp;x;
    <span class="tok-kw">const</span> z: [*]<span class="tok-type">i32</span> = y;
    <span class="tok-kw">try</span> expect(z[<span class="tok-number">0</span>] == <span class="tok-number">1234</span>);
}

<span class="tok-comment">// 哨兵终止的切片可以强制转换为哨兵终止的指针</span>
<span class="tok-kw">test</span> <span class="tok-str">"[:x]T 转换为 [*:x]T"</span> {
    <span class="tok-kw">const</span> buf: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">"hello"</span>;
    <span class="tok-kw">const</span> buf2: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = buf;
    <span class="tok-kw">try</span> expect(buf2[<span class="tok-number">4</span>] == <span class="tok-str">'o'</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_coerce_slices_arrays_and_pointers.zig</kbd>
1/8 test_coerce_slices_arrays_and_pointers.test.*const [N]T to []const T...OK
2/8 test_coerce_slices_arrays_and_pointers.test.*const [N]T to E![]const T...OK
3/8 test_coerce_slices_arrays_and_pointers.test.*const [N]T to ?[]const T...OK
4/8 test_coerce_slices_arrays_and_pointers.test.*[N]T to []T...OK
5/8 test_coerce_slices_arrays_and_pointers.test.*[N]T to [*]T...OK
6/8 test_coerce_slices_arrays_and_pointers.test.*[N]T to ?[*]T...OK
7/8 test_coerce_slices_arrays_and_pointers.test.*T to *[1]T...OK
8/8 test_coerce_slices_arrays_and_pointers.test.[:x]T to [*:x]T...OK
All 8 tests passed.
</samp></pre></figure>

      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#C-Pointers">C 指针</a></li>
</ul>

      
      <h4 id="Type-Coercion-Optionals"><a href="https://ziglang.org/documentation/0.15.2/#toc-Type-Coercion-Optionals">类型强制转换:可选类型</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Type-Coercion-Optionals">§</a></h4>

      <p>
      <a href="https://ziglang.org/documentation/0.15.2/#Optionals">可选类型</a> 的载荷类型,以及 <a href="https://ziglang.org/documentation/0.15.2/#null">null</a>,可以强制转换为可选类型。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_coerce_optionals.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"强制转换为可选类型"</span> {
    <span class="tok-kw">const</span> x: ?<span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    <span class="tok-kw">const</span> y: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>;

    <span class="tok-kw">try</span> expect(x.? == <span class="tok-number">1234</span>);
    <span class="tok-kw">try</span> expect(y == <span class="tok-null">null</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_coerce_optionals.zig</kbd>
1/1 test_coerce_optionals.test.coerce to optionals...OK
All 1 tests passed.
</samp></pre></figure>

      <p>可选类型在 <a href="https://ziglang.org/documentation/0.15.2/#Error-Union-Type">错误联合类型</a> 内部嵌套时也有效:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_coerce_optional_wrapped_error_union.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"强制转换为错误联合类型包装的可选类型"</span> {
    <span class="tok-kw">const</span> x: <span class="tok-type">anyerror</span>!?<span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    <span class="tok-kw">const</span> y: <span class="tok-type">anyerror</span>!?<span class="tok-type">i32</span> = <span class="tok-null">null</span>;

    <span class="tok-kw">try</span> expect((<span class="tok-kw">try</span> x).? == <span class="tok-number">1234</span>);
    <span class="tok-kw">try</span> expect((<span class="tok-kw">try</span> y) == <span class="tok-null">null</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_coerce_optional_wrapped_error_union.zig</kbd>
1/1 test_coerce_optional_wrapped_error_union.test.coerce to optionals wrapped in error union...OK
All 1 tests passed.
</samp></pre></figure>

      
      <h4 id="Type-Coercion-Error-Unions"><a href="https://ziglang.org/documentation/0.15.2/#toc-Type-Coercion-Error-Unions">类型强制转换:错误联合类型</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Type-Coercion-Error-Unions">§</a></h4>

      <p><a href="https://ziglang.org/documentation/0.15.2/#Error-Union-Type">错误联合类型</a> 的载荷类型,以及 <a href="https://ziglang.org/documentation/0.15.2/#Error-Set-Type">错误集类型</a>,可以强制转换为错误联合类型:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_coerce_to_error_union.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"强制转换为错误联合类型"</span> {
    <span class="tok-kw">const</span> x: <span class="tok-type">anyerror</span>!<span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    <span class="tok-kw">const</span> y: <span class="tok-type">anyerror</span>!<span class="tok-type">i32</span> = <span class="tok-kw">error</span>.Failure;

    <span class="tok-kw">try</span> expect((<span class="tok-kw">try</span> x) == <span class="tok-number">1234</span>);
    <span class="tok-kw">try</span> std.testing.expectError(<span class="tok-kw">error</span>.Failure, y);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_coerce_to_error_union.zig</kbd>
1/1 test_coerce_to_error_union.test.coercion to error unions...OK
All 1 tests passed.
</samp></pre></figure>

      
      <h4 id="Type-Coercion-Compile-Time-Known-Numbers"><a href="https://ziglang.org/documentation/0.15.2/#toc-Type-Coercion-Compile-Time-Known-Numbers">类型强制转换:编译时已知数字</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Type-Coercion-Compile-Time-Known-Numbers">§</a></h4>

      <p>当一个数字在 <a href="https://ziglang.org/documentation/0.15.2/#comptime">编译时</a> 已知可以在目标类型中表示时,它可以被强制转换:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_coerce_large_to_small.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"当值在编译时已知适合时,将较大的整数类型强制转换为较小的类型"</span> {
    <span class="tok-kw">const</span> x: <span class="tok-type">u64</span> = <span class="tok-number">255</span>;
    <span class="tok-kw">const</span> y: <span class="tok-type">u8</span> = x;
    <span class="tok-kw">try</span> expect(y == <span class="tok-number">255</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_coerce_large_to_small.zig</kbd>
1/1 test_coerce_large_to_small.test.coercing large integer type to smaller one when value is comptime-known to fit...OK
All 1 tests passed.
</samp></pre></figure>

      
      <h4 id="Type-Coercion-Unions-and-Enums"><a href="https://ziglang.org/documentation/0.15.2/#toc-Type-Coercion-Unions-and-Enums">类型强制转换:联合类型和枚举</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Type-Coercion-Unions-and-Enums">§</a></h4>

      <p>标记联合类型可以强制转换为枚举,而枚举可以强制转换为标记联合类型,前提是它们在 <a href="https://ziglang.org/documentation/0.15.2/#comptime">编译时</a> 已知是联合类型的一个字段,该字段只有一个可能的值,例如 <a href="https://ziglang.org/documentation/0.15.2/#void">void</a>:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_coerce_unions_enums.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> E = <span class="tok-kw">enum</span> {
    one,
    two,
    three,
};

<span class="tok-kw">const</span> U = <span class="tok-kw">union</span>(E) {
    one: <span class="tok-type">i32</span>,
    two: <span class="tok-type">f32</span>,
    three,
};

<span class="tok-kw">const</span> U2 = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    a: <span class="tok-type">void</span>,
    b: <span class="tok-type">f32</span>,

    <span class="tok-kw">fn</span> <span class="tok-fn">tag</span>(self: U2) <span class="tok-type">usize</span> {
        <span class="tok-kw">switch</span> (self) {
            .a =&gt; <span class="tok-kw">return</span> <span class="tok-number">1</span>,
            .b =&gt; <span class="tok-kw">return</span> <span class="tok-number">2</span>,
        }
    }
};

<span class="tok-kw">test</span> <span class="tok-str">"联合类型和枚举之间的强制转换"</span> {
    <span class="tok-kw">const</span> u = U{ .two = <span class="tok-number">12.34</span> };
    <span class="tok-kw">const</span> e: E = u; <span class="tok-comment">// 将联合类型强制转换为枚举</span>
    <span class="tok-kw">try</span> expect(e == E.two);

    <span class="tok-kw">const</span> three = E.three;
    <span class="tok-kw">const</span> u_2: U = three; <span class="tok-comment">// 将枚举强制转换为联合类型</span>
    <span class="tok-kw">try</span> expect(u_2 == E.three);

    <span class="tok-kw">const</span> u_3: U = .three; <span class="tok-comment">// 将枚举字面量强制转换为联合类型</span>
    <span class="tok-kw">try</span> expect(u_3 == E.three);

    <span class="tok-kw">const</span> u_4: U2 = .a; <span class="tok-comment">// 将枚举字面量强制转换为具有推断枚举标记类型的联合类型。</span>
    <span class="tok-kw">try</span> expect(u_4.tag() == <span class="tok-number">1</span>);

    <span class="tok-comment">// 以下示例无效。</span>
    <span class="tok-comment">// error: coercion from enum '@TypeOf(.enum_literal)' to union 'test_coerce_unions_enum.U2' must initialize 'f32' field 'b'</span>
    <span class="tok-comment">//var u_5: U2 = .b;</span>
    <span class="tok-comment">//try expect(u_5.tag() == 2);</span>
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_coerce_unions_enums.zig</kbd>
1/1 test_coerce_unions_enums.test.coercion between unions and enums...OK
All 1 tests passed.
</samp></pre></figure>

      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#union">union</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#enum">enum</a></li>
</ul>

      
      <h4 id="Type-Coercion-undefined"><a href="https://ziglang.org/documentation/0.15.2/#toc-Type-Coercion-undefined">类型强制转换:undefined</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Type-Coercion-undefined">§</a></h4>

      <p><a href="https://ziglang.org/documentation/0.15.2/#undefined">undefined</a> 可以强制转换为任何类型。</p>
      

      <h4 id="Type-Coercion-Tuples-to-Arrays"><a href="https://ziglang.org/documentation/0.15.2/#toc-Type-Coercion-Tuples-to-Arrays">类型强制转换:元组到数组</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Type-Coercion-Tuples-to-Arrays">§</a></h4>

      <p><a href="https://ziglang.org/documentation/0.15.2/#Tuples">元组</a> 可以强制转换为数组,如果所有字段都具有相同的类型。</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_coerce_tuples_arrays.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Tuple = <span class="tok-kw">struct</span> { <span class="tok-type">u8</span>, <span class="tok-type">u8</span> };
<span class="tok-kw">test</span> <span class="tok-str">"从同质元组强制转换为数组"</span> {
    <span class="tok-kw">const</span> tuple: Tuple = .{ <span class="tok-number">5</span>, <span class="tok-number">6</span> };
    <span class="tok-kw">const</span> array: [<span class="tok-number">2</span>]<span class="tok-type">u8</span> = tuple;
    _ = array;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_coerce_tuples_arrays.zig</kbd>
1/1 test_coerce_tuples_arrays.test.coercion from homogeneous tuple to array...OK
All 1 tests passed.
</samp></pre></figure>

      
      

      <h3 id="Explicit-Casts"><a href="https://ziglang.org/documentation/0.15.2/#toc-Explicit-Casts">显式转换</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Explicit-Casts">§</a></h3>

      <p>
      显式转换通过 <a href="https://ziglang.org/documentation/0.15.2/#Builtin-Functions">内置函数</a> 执行。
      有些显式转换是安全的;有些则不是。
      有些显式转换执行语言级断言;有些则不执行。
      有些显式转换在运行时是无操作的;有些则不是。
      </p>
      <ul>
          <li><a href="https://ziglang.org/documentation/0.15.2/#bitCast">@bitCast</a> - 改变类型但保持位表示</li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#alignCast">@alignCast</a> - 使指针具有更大的对齐</li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#enumFromInt">@enumFromInt</a> - 根据整数标记值获取枚举值</li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#errorFromInt">@errorFromInt</a> - 根据整数值获取错误代码</li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#errorCast">@errorCast</a> - 转换为更小的错误集</li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#floatCast">@floatCast</a> - 将较大的浮点数转换为较小的浮点数</li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#floatFromInt">@floatFromInt</a> - 将整数转换为浮点数值</li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#intCast">@intCast</a> - 在整数类型之间转换</li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#intFromBool">@intFromBool</a> - 将 true 转换为 1,false 转换为 0</li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#intFromEnum">@intFromEnum</a> - 获取枚举或标记联合类型的整数标记值</li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#intFromError">@intFromError</a> - 获取错误代码的整数值</li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#intFromFloat">@intFromFloat</a> - 获取浮点数值的整数部分</li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#intFromPtr">@intFromPtr</a> - 获取指针的地址</li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#ptrFromInt">@ptrFromInt</a> - 将地址转换为指针</li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#ptrCast">@ptrCast</a> - 在指针类型之间转换</li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#truncate">@truncate</a> - 在整数类型之间转换,截断位</li>
      </ul>
      

      <h3 id="Peer-Type-Resolution"><a href="https://ziglang.org/documentation/0.15.2/#toc-Peer-Type-Resolution">对等类型解析</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">§</a></h3>

      <p>对等类型解析发生在以下位置:</p>
      <ul>
        <li><a href="https://ziglang.org/documentation/0.15.2/#switch">switch</a> 表达式</li>
        <li><a href="https://ziglang.org/documentation/0.15.2/#if">if</a> 表达式</li>
        <li><a href="https://ziglang.org/documentation/0.15.2/#while">while</a> 表达式</li>
        <li><a href="https://ziglang.org/documentation/0.15.2/#for">for</a> 表达式</li>
        <li>块中的多个 break 语句</li>
        <li>一些 <a href="https://ziglang.org/documentation/0.15.2/#Table-of-Operators">二元操作</a></li>
      </ul>
      <p>
      这种类型解析选择一个所有对等类型都可以强制转换为的类型。以下是一些示例:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_peer_type_resolution.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;
<span class="tok-kw">const</span> mem = std.mem;

<span class="tok-kw">test</span> <span class="tok-str">"对等解析整数拓宽"</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">i8</span> = <span class="tok-number">12</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">i16</span> = <span class="tok-number">34</span>;
    <span class="tok-kw">const</span> c = a + b;
    <span class="tok-kw">try</span> expect(c == <span class="tok-number">46</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(c) == <span class="tok-type">i16</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"对等解析不同大小的数组为 const 切片"</span> {
    <span class="tok-kw">try</span> expect(mem.eql(<span class="tok-type">u8</span>, boolToStr(<span class="tok-null">true</span>), <span class="tok-str">"true"</span>));
    <span class="tok-kw">try</span> expect(mem.eql(<span class="tok-type">u8</span>, boolToStr(<span class="tok-null">false</span>), <span class="tok-str">"false"</span>));
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> expect(mem.eql(<span class="tok-type">u8</span>, boolToStr(<span class="tok-null">true</span>), <span class="tok-str">"true"</span>));
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> expect(mem.eql(<span class="tok-type">u8</span>, boolToStr(<span class="tok-null">false</span>), <span class="tok-str">"false"</span>));
}
<span class="tok-kw">fn</span> <span class="tok-fn">boolToStr</span>(b: <span class="tok-type">bool</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (b) <span class="tok-str">"true"</span> <span class="tok-kw">else</span> <span class="tok-str">"false"</span>;
}

<span class="tok-kw">test</span> <span class="tok-str">"对等解析数组和 const 切片"</span> {
    <span class="tok-kw">try</span> testPeerResolveArrayConstSlice(<span class="tok-null">true</span>);
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> testPeerResolveArrayConstSlice(<span class="tok-null">true</span>);
}
<span class="tok-kw">fn</span> <span class="tok-fn">testPeerResolveArrayConstSlice</span>(b: <span class="tok-type">bool</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> value1 = <span class="tok-kw">if</span> (b) <span class="tok-str">"aoeu"</span> <span class="tok-kw">else</span> <span class="tok-builtin">@as</span>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-str">"zz"</span>);
    <span class="tok-kw">const</span> value2 = <span class="tok-kw">if</span> (b) <span class="tok-builtin">@as</span>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-str">"zz"</span>) <span class="tok-kw">else</span> <span class="tok-str">"aoeu"</span>;
    <span class="tok-kw">try</span> expect(mem.eql(<span class="tok-type">u8</span>, value1, <span class="tok-str">"aoeu"</span>));
    <span class="tok-kw">try</span> expect(mem.eql(<span class="tok-type">u8</span>, value2, <span class="tok-str">"zz"</span>));
}

<span class="tok-kw">test</span> <span class="tok-str">"对等类型解析: ?T 和 T"</span> {
    <span class="tok-kw">try</span> expect(peerTypeTAndOptionalT(<span class="tok-null">true</span>, <span class="tok-null">false</span>).? == <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> expect(peerTypeTAndOptionalT(<span class="tok-null">false</span>, <span class="tok-null">false</span>).? == <span class="tok-number">3</span>);
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">try</span> expect(peerTypeTAndOptionalT(<span class="tok-null">true</span>, <span class="tok-null">false</span>).? == <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> expect(peerTypeTAndOptionalT(<span class="tok-null">false</span>, <span class="tok-null">false</span>).? == <span class="tok-number">3</span>);
    }
}
<span class="tok-kw">fn</span> <span class="tok-fn">peerTypeTAndOptionalT</span>(c: <span class="tok-type">bool</span>, b: <span class="tok-type">bool</span>) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (c) {
        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (b) <span class="tok-null">null</span> <span class="tok-kw">else</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>);
    }

    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">3</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"对等类型解析: *[0]u8 和 []const u8"</span> {
    <span class="tok-kw">try</span> expect(peerTypeEmptyArrayAndSlice(<span class="tok-null">true</span>, <span class="tok-str">"hi"</span>).len == <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> expect(peerTypeEmptyArrayAndSlice(<span class="tok-null">false</span>, <span class="tok-str">"hi"</span>).len == <span class="tok-number">1</span>);
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">try</span> expect(peerTypeEmptyArrayAndSlice(<span class="tok-null">true</span>, <span class="tok-str">"hi"</span>).len == <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> expect(peerTypeEmptyArrayAndSlice(<span class="tok-null">false</span>, <span class="tok-str">"hi"</span>).len == <span class="tok-number">1</span>);
    }
}
<span class="tok-kw">fn</span> <span class="tok-fn">peerTypeEmptyArrayAndSlice</span>(a: <span class="tok-type">bool</span>, slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (a) {
        <span class="tok-kw">return</span> &amp;[_]<span class="tok-type">u8</span>{};
    }

    <span class="tok-kw">return</span> slice[<span class="tok-number">0</span>..<span class="tok-number">1</span>];
}
<span class="tok-kw">test</span> <span class="tok-str">"对等类型解析: *[0]u8, []const u8, 和 anyerror![]u8"</span> {
    {
        <span class="tok-kw">var</span> data = <span class="tok-str">"hi"</span>.*;
        <span class="tok-kw">const</span> slice = data[<span class="tok-number">0</span>..];
        <span class="tok-kw">try</span> expect((<span class="tok-kw">try</span> peerTypeEmptyArrayAndSliceAndError(<span class="tok-null">true</span>, slice)).len == <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> expect((<span class="tok-kw">try</span> peerTypeEmptyArrayAndSliceAndError(<span class="tok-null">false</span>, slice)).len == <span class="tok-number">1</span>);
    }
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">var</span> data = <span class="tok-str">"hi"</span>.*;
        <span class="tok-kw">const</span> slice = data[<span class="tok-number">0</span>..];
        <span class="tok-kw">try</span> expect((<span class="tok-kw">try</span> peerTypeEmptyArrayAndSliceAndError(<span class="tok-null">true</span>, slice)).len == <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> expect((<span class="tok-kw">try</span> peerTypeEmptyArrayAndSliceAndError(<span class="tok-null">false</span>, slice)).len == <span class="tok-number">1</span>);
    }
}
<span class="tok-kw">fn</span> <span class="tok-fn">peerTypeEmptyArrayAndSliceAndError</span>(a: <span class="tok-type">bool</span>, slice: []<span class="tok-type">u8</span>) <span class="tok-type">anyerror</span>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (a) {
        <span class="tok-kw">return</span> &amp;[_]<span class="tok-type">u8</span>{};
    }

    <span class="tok-kw">return</span> slice[<span class="tok-number">0</span>..<span class="tok-number">1</span>];
}

<span class="tok-kw">test</span> <span class="tok-str">"对等类型解析: *const T 和 ?*T"</span> {
    <span class="tok-kw">const</span> a: *<span class="tok-kw">const</span> <span class="tok-type">usize</span> = <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-number">0x123456780</span>);
    <span class="tok-kw">const</span> b: ?*<span class="tok-type">usize</span> = <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-number">0x123456780</span>);
    <span class="tok-kw">try</span> expect(a == b);
    <span class="tok-kw">try</span> expect(b == a);
}

<span class="tok-kw">test</span> <span class="tok-str">"对等类型解析: 错误联合类型 switch"</span> {
    <span class="tok-comment">// 只有当错误情况仅是 switch 表达式时,非错误和错误情况才是对等的;</span>
    <span class="tok-comment">// 模式 `if (x) {...} else |err| blk: { switch (err) {...} }` 不认为</span>
    <span class="tok-comment">// 非错误和错误情况是对等的。</span>
    <span class="tok-kw">var</span> a: <span class="tok-kw">error</span>{ A, B, C }!<span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    _ = &amp;a;
    <span class="tok-kw">const</span> b = <span class="tok-kw">if</span> (a) |x|
        x + <span class="tok-number">3</span>
    <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.A =&gt; <span class="tok-number">0</span>,
        <span class="tok-kw">error</span>.B =&gt; <span class="tok-number">1</span>,
        <span class="tok-kw">error</span>.C =&gt; <span class="tok-null">null</span>,
    };
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(b) == ?<span class="tok-type">u32</span>);

    <span class="tok-comment">// 只有当错误情况仅是 switch 表达式时,非错误和错误情况才是对等的;</span>
    <span class="tok-comment">// 模式 `x catch |err| blk: { switch (err) {...} }` 不认为解包的 `x`</span>
    <span class="tok-comment">// 和错误情况是对等的。</span>
    <span class="tok-kw">const</span> c = a <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.A =&gt; <span class="tok-number">0</span>,
        <span class="tok-kw">error</span>.B =&gt; <span class="tok-number">1</span>,
        <span class="tok-kw">error</span>.C =&gt; <span class="tok-null">null</span>,
    };
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(c) == ?<span class="tok-type">u32</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_peer_type_resolution.zig</kbd>
1/8 test_peer_type_resolution.test.peer resolve int widening...OK
2/8 test_peer_type_resolution.test.peer resolve arrays of different size to const slice...OK
3/8 test_peer_type_resolution.test.peer resolve array and const slice...OK
4/8 test_peer_type_resolution.test.peer type resolution: ?T and T...OK
5/8 test_peer_type_resolution.test.peer type resolution: *[0]u8 and []const u8...OK
6/8 test_peer_type_resolution.test.peer type resolution: *[0]u8, []const u8, and anyerror![]u8...OK
7/8 test_peer_type_resolution.test.peer type resolution: *const T and ?*T...OK
8/8 test_peer_type_resolution.test.peer type resolution: error union switch...OK
All 8 tests passed.
</samp></pre></figure>

      
      

      <h2 id="Zero-Bit-Types"><a href="https://ziglang.org/documentation/0.15.2/#toc-Zero-Bit-Types">零位类型</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Zero-Bit-Types">§</a></h2>

      <p>对于某些类型,<a href="https://ziglang.org/documentation/0.15.2/#sizeOf">@sizeOf</a> 为 0:</p>
      <ul>
          <li><a href="https://ziglang.org/documentation/0.15.2/#void">void</a></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a> <code><span class="tok-type">u0</span></code> 和 <code><span class="tok-type">i0</span></code>。</li>
          <li>长度为 0 的 <a href="https://ziglang.org/documentation/0.15.2/#Arrays">数组</a> 和 <a href="https://ziglang.org/documentation/0.15.2/#Vectors">向量</a>,或元素类型为零位类型的数组和向量。</li>
          <li>只有一个标签的 <a href="https://ziglang.org/documentation/0.15.2/#enum">enum</a>。</li>
          <li>所有字段都是零位类型的 <a href="https://ziglang.org/documentation/0.15.2/#struct">struct</a>。</li>
          <li>只有一个字段且该字段为零位类型的 <a href="https://ziglang.org/documentation/0.15.2/#union">union</a>。</li>
      </ul>
      <p>
      这些类型只能有一个可能的值,因此需要 0 位来表示。使用这些类型的代码不会包含在最终生成的代码中:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">zero_bit_types.zig</cite></figcaption><pre><code><span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">entry</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">void</span> = {};
    <span class="tok-kw">var</span> y: <span class="tok-type">void</span> = {};
    x = y;
    y = x;
}</code></pre></figure>

      <p>当这转换成机器代码时,<code>entry</code> 的主体中不生成代码,即使在 <a href="https://ziglang.org/documentation/0.15.2/#Debug">Debug</a> 模式下也是如此。例如,在 x86_64 上:</p>
      <pre><code>0000000000000010 &lt;entry&gt;:
  10:	55                   	push   %rbp
  11:	48 89 e5             	mov    %rsp,%rbp
  14:	5d                   	pop    %rbp
  15:	c3                   	retq   </code></pre>
      <p>这些汇编指令没有与 void 值相关联的任何代码 - 它们只执行函数调用序言和尾声。</p>

      <h3 id="void"><a href="https://ziglang.org/documentation/0.15.2/#toc-void">void</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#void">§</a></h3>

      <p>
      <code><span class="tok-type">void</span></code> 可用于实例化泛型类型。例如,给定一个 <code>Map(Key, Value)</code>,可以为 <code>Value</code> 类型传递 <code><span class="tok-type">void</span></code> 来使其变成一个 <code>Set</code>:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_void_in_hashmap.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"使用 void 将 HashMap 转换为集合"</span> {
    <span class="tok-kw">var</span> map = std.AutoHashMap(<span class="tok-type">i32</span>, <span class="tok-type">void</span>).init(std.testing.allocator);
    <span class="tok-kw">defer</span> map.deinit();

    <span class="tok-kw">try</span> map.put(<span class="tok-number">1</span>, {});
    <span class="tok-kw">try</span> map.put(<span class="tok-number">2</span>, {});

    <span class="tok-kw">try</span> expect(map.contains(<span class="tok-number">2</span>));
    <span class="tok-kw">try</span> expect(!map.contains(<span class="tok-number">3</span>));

    _ = map.remove(<span class="tok-number">2</span>);
    <span class="tok-kw">try</span> expect(!map.contains(<span class="tok-number">2</span>));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_void_in_hashmap.zig</kbd>
1/1 test_void_in_hashmap.test.turn HashMap into a set with void...OK
All 1 tests passed.
</samp></pre></figure>

      <p>注意,这与为哈希映射值使用虚拟值不同。通过使用 <code><span class="tok-type">void</span></code> 作为值的类型,哈希映射条目类型没有值字段,因此哈希映射占用的空间更少。此外,所有处理存储和加载值的代码都被删除,如上所示。
      </p>
      <p>
      <code><span class="tok-type">void</span></code> 不同于 <code><span class="tok-type">anyopaque</span></code>。
      <code><span class="tok-type">void</span></code> 的已知大小为 0 字节,而 <code><span class="tok-type">anyopaque</span></code> 的大小未知但非零。
      </p>
      <p>
      类型为 <code><span class="tok-type">void</span></code> 的表达式是唯一可以忽略其值的表达式。例如,忽略非 <code><span class="tok-type">void</span></code> 表达式会导致编译错误:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_expression_ignored.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">"忽略表达式值"</span> {
    foo();
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> <span class="tok-number">1234</span>;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_expression_ignored.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_expression_ignored.zig:2:8: </span><span class="sgr-31m">error: </span><span class="sgr-1m">value of type 'i32' ignored
</span>    foo();
    <span class="sgr-32m">~~~^~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_expression_ignored.zig:2:8: </span><span class="sgr-36m">note: </span><span class="sgr-1m">all non-void values must be used
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_expression_ignored.zig:2:8: </span><span class="sgr-36m">note: </span><span class="sgr-1m">to discard the value, assign it to '_'
</span>
</samp></pre></figure>

      <p>但是,如果表达式的类型为 <code><span class="tok-type">void</span></code>,则不会有错误。表达式结果可以通过将它们赋值给 <code>_</code> 来显式忽略。 </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_void_ignored.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">"void 被忽略"</span> {
    returnsVoid();
}

<span class="tok-kw">test</span> <span class="tok-str">"显式忽略表达式值"</span> {
    _ = foo();
}

<span class="tok-kw">fn</span> <span class="tok-fn">returnsVoid</span>() <span class="tok-type">void</span> {}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> <span class="tok-number">1234</span>;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_void_ignored.zig</kbd>
1/2 test_void_ignored.test.void is ignored...OK
2/2 test_void_ignored.test.explicitly ignoring expression value...OK
All 2 tests passed.
</samp></pre></figure>

      
      

      <h2 id="Result-Location-Semantics"><a href="https://ziglang.org/documentation/0.15.2/#toc-Result-Location-Semantics">结果位置语义</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Result-Location-Semantics">§</a></h2>

      <p>
      在编译期间,每个 Zig 表达式和子表达式都被分配可选的结果位置信息。这些信息规定了表达式应具有的类型(其结果类型),以及结果值应放置在内存中的位置(其结果位置)。该信息是可选的,因为并非每个表达式都有这些信息:例如,赋值给 <code>_</code> 既不提供关于表达式类型的任何信息,也不提供具体的内存位置来放置它。
      </p>
      <p>
      作为一个激励性示例,考虑语句 <code><span class="tok-kw">const</span> x: <span class="tok-type">u32</span> = <span class="tok-number">42</span>;</code>。这里的类型注释为初始化表达式 <code><span class="tok-number">42</span></code> 提供了 <code><span class="tok-type">u32</span></code> 的结果类型,指示编译器将此整数(最初类型为 <code><span class="tok-type">comptime_int</span></code>)强制转换为此类型。我们很快会看到更多示例。
      </p>
      <p>
      这不是实现细节:上面概述的逻辑被编码到 Zig 语言规范中,是该语言中类型推断的主要机制。该系统统称为"结果位置语义"。
      </p>
      <h3 id="Result-Types"><a href="https://ziglang.org/documentation/0.15.2/#toc-Result-Types">结果类型</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Result-Types">§</a></h3>

      <p>
      结果类型在可能的情况下通过表达式递归传播。例如,如果表达式 <code>&amp;e</code> 的结果类型为 <code>*<span class="tok-type">u32</span></code>,则 <code>e</code> 被赋予 <code><span class="tok-type">u32</span></code> 的结果类型,允许语言在获取引用之前执行此强制转换。
      </p>
      <p>
      结果类型机制被诸如 <code><span class="tok-builtin">@intCast</span></code> 之类的转换内置函数所使用。这些内置函数不是以类型作为参数来指定要转换到的类型,而是使用它们的结果类型来确定此信息。结果类型通常从上下文中得知;在不知道的情况下,可以使用 <code><span class="tok-builtin">@as</span></code> 内置函数来显式提供结果类型。
      </p>
      <p>
      我们可以如下分解简单表达式的每个组成部分的结果类型:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">result_type_propagation.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expectEqual = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expectEqual;
<span class="tok-kw">test</span> <span class="tok-str">"结果类型通过结构体初始化器传播"</span> {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> { x: <span class="tok-type">u32</span> };
    <span class="tok-kw">const</span> val: <span class="tok-type">u64</span> = <span class="tok-number">123</span>;
    <span class="tok-kw">const</span> s: S = .{ .x = <span class="tok-builtin">@intCast</span>(val) };
    <span class="tok-comment">// .{ .x = @intCast(val) }   由于类型注释,结果类型为 `S`</span>
    <span class="tok-comment">//         @intCast(val)     由于字段 `S.x` 的类型,结果类型为 `u32`</span>
    <span class="tok-comment">//                  val      没有结果类型,因为它允许是任何整数类型</span>
    <span class="tok-kw">try</span> expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">123</span>), s.x);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test result_type_propagation.zig</kbd>
1/1 result_type_propagation.test.result type propagates through struct initializer...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      此结果类型信息对于上述转换内置函数以及避免构造强制转换前的值和在某些情况下避免显式类型强制转换都很有用。下表详细说明了一些常见表达式如何传播结果类型,其中 <code>x</code> 和 <code>y</code> 是任意子表达式。
      </p>
      <div class="table-wrapper">
      <table>
        <thead>
          <tr>
            <th scope="col">表达式</th>
            <th scope="col">父结果类型</th>
            <th scope="col">子表达式结果类型</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <th scope="row"><code><span class="tok-kw">const</span> val: T = x</code></th>
            <td>-</td>
            <td><code>x</code> 是 <code>T</code></td>
          </tr>
          <tr>
            <th scope="row"><code><span class="tok-kw">var</span> val: T = x</code></th>
            <td>-</td>
            <td><code>x</code> 是 <code>T</code></td>
          </tr>
          <tr>
            <th scope="row"><code>val = x</code></th>
            <td>-</td>
            <td><code>x</code> 是 <code><span class="tok-builtin">@TypeOf</span>(val)</code></td>
          </tr>
          <tr>
            <th scope="row"><code><span class="tok-builtin">@as</span>(T, x)</code></th>
            <td>-</td>
            <td><code>x</code> 是 <code>T</code></td>
          </tr>
          <tr>
            <th scope="row"><code>&amp;x</code></th>
            <td><code>*T</code></td>
            <td><code>x</code> 是 <code>T</code></td>
          </tr>
          <tr>
            <th scope="row"><code>&amp;x</code></th>
            <td><code>[]T</code></td>
            <td><code>x</code> 是 <code>T</code> 的某个数组</td>
          </tr>
          <tr>
            <th scope="row"><code>f(x)</code></th>
            <td>-</td>
            <td><code>x</code> 具有 <code>f</code> 的第一个参数的类型</td>
          </tr>
          <tr>
            <th scope="row"><code>.{x}</code></th>
            <td><code>T</code></td>
            <td><code>x</code> 是 <code><span class="tok-builtin">@FieldType</span>(T, <span class="tok-str">"0"</span>)</code></td>
          </tr>
          <tr>
            <th scope="row"><code>.{ .a = x }</code></th>
            <td><code>T</code></td>
            <td><code>x</code> 是 <code><span class="tok-builtin">@FieldType</span>(T, <span class="tok-str">"a"</span>)</code></td>
          </tr>
          <tr>
            <th scope="row"><code>T{x}</code></th>
            <td>-</td>
            <td><code>x</code> 是 <code><span class="tok-builtin">@FieldType</span>(T, <span class="tok-str">"0"</span>)</code></td>
          </tr>
          <tr>
            <th scope="row"><code>T{ .a = x }</code></th>
            <td>-</td>
            <td><code>x</code> 是 <code><span class="tok-builtin">@FieldType</span>(T, <span class="tok-str">"a"</span>)</code></td>
          </tr>
          <tr>
            <th scope="row"><code><span class="tok-builtin">@Type</span>(x)</code></th>
            <td>-</td>
            <td><code>x</code> 是 <code>std.builtin.Type</code></td>
          </tr>
          <tr>
            <th scope="row"><code><span class="tok-builtin">@typeInfo</span>(x)</code></th>
            <td>-</td>
            <td><code>x</code> 是 <code><span class="tok-type">type</span></code></td>
          </tr>
          <tr>
            <th scope="row"><code>x &lt;&lt; y</code></th>
            <td>-</td>
            <td><code>y</code> 是 <code>std.math.Log2IntCeil(<span class="tok-builtin">@TypeOf</span>(x))</code></td>
          </tr>
        </tbody>
      </table>
      </div>
      
      <h3 id="Result-Locations"><a href="https://ziglang.org/documentation/0.15.2/#toc-Result-Locations">结果位置</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Result-Locations">§</a></h3>

      <p>
      除了结果类型信息之外,每个表达式还可以被可选地分配一个结果位置:值必须直接写入的指针。该系统可用于在初始化数据结构时防止中间副本,这对于必须具有固定内存地址("固定"类型)的类型可能很重要。
      </p>
      <p>
      当编译简单的赋值表达式 <code>x = e</code> 时,许多语言会在栈上创建临时值 <code>e</code>,然后将其赋值给 <code>x</code>,在此过程中可能执行类型强制转换。Zig 采用不同的方法。表达式 <code>e</code> 被赋予与 <code>x</code> 的类型匹配的结果类型,以及 <code>&amp;x</code> 的结果位置。对于许多 <code>e</code> 的语法形式,这没有实际影响。但是,在使用更复杂的语法形式时,它可能产生重要的语义效果。
      </p>
      <p>
      例如,如果表达式 <code>.{ .a = x, .b = y }</code> 的结果位置为 <code>ptr</code>,则 <code>x</code> 被赋予 <code>&amp;ptr.a</code> 的结果位置,<code>y</code> 被赋予 <code>&amp;ptr.b</code> 的结果位置。如果没有这个系统,这个表达式将完全在栈上构造一个临时结构体值,然后才将其复制到目标地址。本质上,Zig 将赋值 <code>foo = .{ .a = x, .b = y }</code> 解糖为两个语句 <code>foo.a = x; foo.b = y;</code>。
      </p>
      <p>
      当赋值聚合值时,如果初始化表达式依赖于聚合的前一个值,这有时可能很重要。最容易演示这一点的方法是尝试交换结构体或数组的字段 - 以下逻辑看起来合理,但实际上不是:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">result_location_interfering_with_swap.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;
<span class="tok-kw">test</span> <span class="tok-str">"尝试使用数组初始化器交换数组元素"</span> {
    <span class="tok-kw">var</span> arr: [<span class="tok-number">2</span>]<span class="tok-type">u32</span> = .{ <span class="tok-number">1</span>, <span class="tok-number">2</span> };
    arr = .{ arr[<span class="tok-number">1</span>], arr[<span class="tok-number">0</span>] };
    <span class="tok-comment">// 前一行等价于以下两行:</span>
    <span class="tok-comment">//   arr[0] = arr[1];</span>
    <span class="tok-comment">//   arr[1] = arr[0];</span>
    <span class="tok-comment">// 所以这失败了!</span>
    <span class="tok-kw">try</span> expect(arr[<span class="tok-number">0</span>] == <span class="tok-number">2</span>); <span class="tok-comment">// 成功</span>
    <span class="tok-kw">try</span> expect(arr[<span class="tok-number">1</span>] == <span class="tok-number">1</span>); <span class="tok-comment">// 失败</span>
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test result_location_interfering_with_swap.zig</kbd>
1/1 result_location_interfering_with_swap.test.attempt to swap array elements with array initializer...FAIL (TestUnexpectedResult)
<span class="sgr-1m">/home/andy/dev/zig/lib/std/testing.zig:607:14</span>: <span class="sgr-2m">0x102f019 in expect (std.zig)</span>
    if (!ok) return error.TestUnexpectedResult;
             <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/result_location_interfering_with_swap.zig:10:5</span>: <span class="sgr-2m">0x102f144 in test.attempt to swap array elements with array initializer (result_location_interfering_with_swap.zig)</span>
    try expect(arr[1] == 1); // fails
    <span class="sgr-32m">^</span>
0 passed; 0 skipped; 1 failed.
error: the following test command failed with exit code 1:
/home/andy/dev/zig/.zig-cache/o/d439bc8d3e0f685e13e3c778e438793a/test --seed=0x9b2332d1
</samp></pre></figure>

      <p>
      下表详细说明了一些常见表达式如何传播结果位置,其中 <code>x</code> 和 <code>y</code> 是任意子表达式。请注意,某些表达式即使它们本身具有结果位置,也无法向子表达式提供有意义的结果位置。
      </p>
      <div class="table-wrapper">
      <table>
        <thead>
          <tr>
            <th scope="col">表达式</th>
            <th scope="col">结果位置</th>
            <th scope="col">子表达式结果位置</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <th scope="row"><code><span class="tok-kw">const</span> val: T = x</code></th>
            <td>-</td>
            <td><code>x</code> 的结果位置为 <code>&amp;val</code></td>
          </tr>
          <tr>
            <th scope="row"><code><span class="tok-kw">var</span> val: T = x</code></th>
            <td>-</td>
            <td><code>x</code> 的结果位置为 <code>&amp;val</code></td>
          </tr>
          <tr>
            <th scope="row"><code>val = x</code></th>
            <td>-</td>
            <td><code>x</code> 的结果位置为 <code>&amp;val</code></td>
          </tr>
          <tr>
            <th scope="row"><code><span class="tok-builtin">@as</span>(T, x)</code></th>
            <td><code>ptr</code></td>
            <td><code>x</code> 没有结果位置</td>
          </tr>
          <tr>
            <th scope="row"><code>&amp;x</code></th>
            <td><code>ptr</code></td>
            <td><code>x</code> 没有结果位置</td>
          </tr>
          <tr>
            <th scope="row"><code>f(x)</code></th>
            <td><code>ptr</code></td>
            <td><code>x</code> 没有结果位置</td>
          </tr>
          <tr>
            <th scope="row"><code>.{x}</code></th>
            <td><code>ptr</code></td>
            <td><code>x</code> 的结果位置为 <code>&amp;ptr[<span class="tok-number">0</span>]</code></td>
          </tr>
          <tr>
            <th scope="row"><code>.{ .a = x }</code></th>
            <td><code>ptr</code></td>
            <td><code>x</code> 的结果位置为 <code>&amp;ptr.a</code></td>
          </tr>
          <tr>
            <th scope="row"><code>T{x}</code></th>
            <td><code>ptr</code></td>
            <td><code>x</code> 没有结果位置(类型初始化器不传播结果位置)</td>
          </tr>
          <tr>
            <th scope="row"><code>T{ .a = x }</code></th>
            <td><code>ptr</code></td>
            <td><code>x</code> 没有结果位置(类型初始化器不传播结果位置)</td>
          </tr>
          <tr>
            <th scope="row"><code><span class="tok-builtin">@Type</span>(x)</code></th>
            <td><code>ptr</code></td>
            <td><code>x</code> 没有结果位置</td>
          </tr>
          <tr>
            <th scope="row"><code><span class="tok-builtin">@typeInfo</span>(x)</code></th>
            <td><code>ptr</code></td>
            <td><code>x</code> 没有结果位置</td>
          </tr>
          <tr>
            <th scope="row"><code>x &lt;&lt; y</code></th>
            <td><code>ptr</code></td>
            <td><code>x</code> 和 <code>y</code> 没有结果位置</td>
          </tr>
        </tbody>
      </table>
      </div>
      
      

      <h2 id="comptime"><a href="https://ziglang.org/documentation/0.15.2/#toc-comptime">comptime</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#comptime">§</a></h2>

      <p>
      Zig 重视表达式是否在编译时已知的概念。
      这个概念在几个不同的地方使用,这些构建块用于保持语言的小巧、可读和强大。
      </p>
      <h3 id="Introducing-the-Compile-Time-Concept"><a href="https://ziglang.org/documentation/0.15.2/#toc-Introducing-the-Compile-Time-Concept">介绍编译时概念</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Introducing-the-Compile-Time-Concept">§</a></h3>

      <h4 id="Compile-Time-Parameters"><a href="https://ziglang.org/documentation/0.15.2/#toc-Compile-Time-Parameters">编译时参数</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Compile-Time-Parameters">§</a></h4>

      <p>
      编译时参数是 Zig 实现泛型的方式。它是编译时鸭子类型。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">compile-time_duck_typing.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">max</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T) T {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (a &gt; b) a <span class="tok-kw">else</span> b;
}
<span class="tok-kw">fn</span> <span class="tok-fn">gimmeTheBiggerFloat</span>(a: <span class="tok-type">f32</span>, b: <span class="tok-type">f32</span>) <span class="tok-type">f32</span> {
    <span class="tok-kw">return</span> max(<span class="tok-type">f32</span>, a, b);
}
<span class="tok-kw">fn</span> <span class="tok-fn">gimmeTheBiggerInteger</span>(a: <span class="tok-type">u64</span>, b: <span class="tok-type">u64</span>) <span class="tok-type">u64</span> {
    <span class="tok-kw">return</span> max(<span class="tok-type">u64</span>, a, b);
}</code></pre></figure>

      <p>
      在 Zig 中,类型是一等公民。它们可以被赋值给变量,作为参数传递给函数,并从函数返回。但是,它们只能在<em>编译时</em>已知的表达式中使用,这就是为什么上述片段中的参数 <code>T</code> 必须用 <code><span class="tok-kw">comptime</span></code> 标记。
      </p>
      <p>
      <code><span class="tok-kw">comptime</span></code> 参数意味着:
      </p>
      <ul>
        <li>在调用点,该值必须在编译时已知,否则会导致编译错误。</li>
        <li>在函数定义中,该值在编译时已知。</li>
      </ul>
      <p>
      例如,如果我们向上述片段引入另一个函数:
      </p>
<!-- ====== END CHUNK 8: new_08.html ====== -->

<!-- ====== BEGIN CHUNK 9: new_09.html ====== -->
<figure><figcaption class="zig-cap"><cite class="file">test_unresolved_comptime_value.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">max</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T) T {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (a &gt; b) a <span class="tok-kw">else</span> b;
}
<span class="tok-kw">test</span> <span class="tok-str">"try to pass a runtime type"</span> {
    foo(<span class="tok-null">false</span>);
}
<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(condition: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = max(<span class="tok-kw">if</span> (condition) <span class="tok-type">f32</span> <span class="tok-kw">else</span> <span class="tok-type">u64</span>, <span class="tok-number">1234</span>, <span class="tok-number">5678</span>);
    _ = result;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_unresolved_comptime_value.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_unresolved_comptime_value.zig:8:28: </span><span class="sgr-31m">error: </span><span class="sgr-1m">unable to resolve comptime value
</span>    const result = max(if (condition) f32 else u64, 1234, 5678);
                           <span class="sgr-32m">^~~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_unresolved_comptime_value.zig:8:24: </span><span class="sgr-36m">note: </span><span class="sgr-1m">argument to comptime parameter must be comptime-known
</span>    const result = max(if (condition) f32 else u64, 1234, 5678);
                       <span class="sgr-32m">^~~~~~~~~~~~~~~~~~~~~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_unresolved_comptime_value.zig:1:8: </span><span class="sgr-36m">note: </span><span class="sgr-1m">parameter declared comptime here
</span>fn max(comptime T: type, a: T, b: T) T {
       <span class="sgr-32m">^~~~~~~~
</span><span class="sgr-2m">referenced by:
    test.try to pass a runtime type: /home/andy/dev/zig/doc/langref/test_unresolved_comptime_value.zig:5:8
</span>
</samp></pre></figure>

      <p>
      这是一个错误,因为程序员尝试将仅在运行时已知的值传递给期望编译时已知值的函数。
      </p>
      <p>
      另一种导致错误的情况是,如果我们传递的类型在分析函数时违反了类型检查器的规则。这就是<em>编译时鸭子类型</em>的含义。
      </p>
      <p>
      例如:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_mismatched_type.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">max</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T) T {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (a &gt; b) a <span class="tok-kw">else</span> b;
}
<span class="tok-kw">test</span> <span class="tok-str">"try to compare bools"</span> {
    _ = max(<span class="tok-type">bool</span>, <span class="tok-null">true</span>, <span class="tok-null">false</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_mismatched_type.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_mismatched_type.zig:2:18: </span><span class="sgr-31m">error: </span><span class="sgr-1m">operator &gt; not allowed for type 'bool'
</span>    return if (a &gt; b) a else b;
               <span class="sgr-32m">~~^~~
</span><span class="sgr-2m">referenced by:
    test.try to compare bools: /home/andy/dev/zig/doc/langref/test_comptime_mismatched_type.zig:5:12
</span>
</samp></pre></figure>

      <p>
      另一方面,在带有 <code><span class="tok-kw">comptime</span></code> 参数的函数定义内部,该值在编译时是已知的。这意味着如果我们愿意,实际上可以让它对 bool 类型起作用:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_max_with_bool.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">max</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T) T {
    <span class="tok-kw">if</span> (T == <span class="tok-type">bool</span>) {
        <span class="tok-kw">return</span> a <span class="tok-kw">or</span> b;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a &gt; b) {
        <span class="tok-kw">return</span> a;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> b;
    }
}
<span class="tok-kw">test</span> <span class="tok-str">"try to compare bools"</span> {
    <span class="tok-kw">try</span> <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect(max(<span class="tok-type">bool</span>, <span class="tok-null">false</span>, <span class="tok-null">true</span>) == <span class="tok-null">true</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_max_with_bool.zig</kbd>
1/1 test_comptime_max_with_bool.test.try to compare bools...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      这可以工作,因为当条件在编译时已知时,Zig 会隐式内联 <code><span class="tok-kw">if</span></code> 表达式,并且编译器保证它将跳过对未采用分支的分析。
      </p>
      <p>
      这意味着在这种情况下为 <code>max</code> 生成的实际函数如下所示:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">compiler_generated_function.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">max</span>(a: <span class="tok-type">bool</span>, b: <span class="tok-type">bool</span>) <span class="tok-type">bool</span> {
    {
        <span class="tok-kw">return</span> a <span class="tok-kw">or</span> b;
    }
}</code></pre></figure>

      <p>
      所有处理编译时已知值的代码都被消除了,我们只剩下完成任务所需的运行时代码。
      </p>
      <p>
      对于 <code><span class="tok-kw">switch</span></code> 表达式也是如此 - 当目标表达式在编译时已知时,它们会被隐式内联。
      </p>
      
      <h4 id="Compile-Time-Variables"><a href="https://ziglang.org/documentation/0.15.2/#toc-Compile-Time-Variables">编译时变量</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Compile-Time-Variables">§</a></h4>

      <p>
      在 Zig 中,程序员可以将变量标记为 <code><span class="tok-kw">comptime</span></code>。这向编译器保证变量的每次加载和存储都在编译时执行。任何违反此规则的行为都会导致编译错误。
      </p>
      <p>
      这与我们可以 <code><span class="tok-kw">inline</span></code> 循环的事实相结合,使我们能够编写部分在编译时求值、部分在运行时求值的函数。
      </p>
      <p>
      例如:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_evaluation.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">const</span> CmdFn = <span class="tok-kw">struct</span> {
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    func: <span class="tok-kw">fn</span> (<span class="tok-type">i32</span>) <span class="tok-type">i32</span>,
};

<span class="tok-kw">const</span> cmd_fns = [_]CmdFn{
    CmdFn{ .name = <span class="tok-str">"one"</span>, .func = one },
    CmdFn{ .name = <span class="tok-str">"two"</span>, .func = two },
    CmdFn{ .name = <span class="tok-str">"three"</span>, .func = three },
};
<span class="tok-kw">fn</span> <span class="tok-fn">one</span>(value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> value + <span class="tok-number">1</span>;
}
<span class="tok-kw">fn</span> <span class="tok-fn">two</span>(value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> value + <span class="tok-number">2</span>;
}
<span class="tok-kw">fn</span> <span class="tok-fn">three</span>(value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> value + <span class="tok-number">3</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">performFn</span>(<span class="tok-kw">comptime</span> prefix_char: <span class="tok-type">u8</span>, start_value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> result: <span class="tok-type">i32</span> = start_value;
    <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> i = <span class="tok-number">0</span>;
    <span class="tok-kw">inline</span> <span class="tok-kw">while</span> (i &lt; cmd_fns.len) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (cmd_fns[i].name[<span class="tok-number">0</span>] == prefix_char) {
            result = cmd_fns[i].func(result);
        }
    }
    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">test</span> <span class="tok-str">"perform fn"</span> {
    <span class="tok-kw">try</span> expect(performFn(<span class="tok-str">'t'</span>, <span class="tok-number">1</span>) == <span class="tok-number">6</span>);
    <span class="tok-kw">try</span> expect(performFn(<span class="tok-str">'o'</span>, <span class="tok-number">0</span>) == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> expect(performFn(<span class="tok-str">'w'</span>, <span class="tok-number">99</span>) == <span class="tok-number">99</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_evaluation.zig</kbd>
1/1 test_comptime_evaluation.test.perform fn...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      这个例子有点牵强,因为编译时求值组件是不必要的;如果全部在运行时完成,此代码也能正常工作。但它确实生成了不同的代码。在这个例子中,函数 <code>performFn</code> 针对提供的不同 <code>prefix_char</code> 值生成了三次:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">performFn_1</cite></figcaption><pre><code><span class="tok-comment">// 来自这一行:</span>
<span class="tok-comment">// expect(performFn('t', 1) == 6);</span>
<span class="tok-kw">fn</span> <span class="tok-fn">performFn</span>(start_value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> result: <span class="tok-type">i32</span> = start_value;
    result = two(result);
    result = three(result);
    <span class="tok-kw">return</span> result;
}</code></pre></figure>
      <figure><figcaption class="zig-cap"><cite class="file">performFn_2</cite></figcaption><pre><code><span class="tok-comment">// 来自这一行:</span>
<span class="tok-comment">// expect(performFn('o', 0) == 1);</span>
<span class="tok-kw">fn</span> <span class="tok-fn">performFn</span>(start_value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> result: <span class="tok-type">i32</span> = start_value;
    result = one(result);
    <span class="tok-kw">return</span> result;
}</code></pre></figure>
      <figure><figcaption class="zig-cap"><cite class="file">performFn_3</cite></figcaption><pre><code><span class="tok-comment">// 来自这一行:</span>
<span class="tok-comment">// expect(performFn('w', 99) == 99);</span>
<span class="tok-kw">fn</span> <span class="tok-fn">performFn</span>(start_value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> result: <span class="tok-type">i32</span> = start_value;
    _ = &amp;result;
    <span class="tok-kw">return</span> result;
}</code></pre></figure>
      <p>
      注意,即使在调试构建中也会发生这种情况。
      这不是一种编写更优化代码的方式,而是一种确保<em>应该</em>在编译时发生的事情<em>确实</em>在编译时发生的方式。这可以捕获更多错误并允许表达能力,在其他语言中需要使用宏、生成的代码或预处理器才能实现。
      </p>
      
      <h4 id="Compile-Time-Expressions"><a href="https://ziglang.org/documentation/0.15.2/#toc-Compile-Time-Expressions">编译时表达式</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Compile-Time-Expressions">§</a></h4>

      <p>
      在 Zig 中,给定表达式是在编译时已知还是在运行时已知很重要。程序员可以使用 <code><span class="tok-kw">comptime</span></code> 表达式来保证表达式将在编译时求值。如果无法做到这一点,编译器将发出错误。例如:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_call_extern_function.zig</cite></figcaption><pre><code><span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">exit</span>() <span class="tok-type">noreturn</span>;

<span class="tok-kw">test</span> <span class="tok-str">"foo"</span> {
    <span class="tok-kw">comptime</span> {
        exit();
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_call_extern_function.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_call_extern_function.zig:5:13: </span><span class="sgr-31m">error: </span><span class="sgr-1m">comptime call of extern function
</span>        exit();
        <span class="sgr-32m">~~~~^~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_call_extern_function.zig:4:5: </span><span class="sgr-36m">note: </span><span class="sgr-1m">'comptime' keyword forces comptime evaluation
</span>    comptime {
    <span class="sgr-32m">^~~~~~~~
</span>
</samp></pre></figure>

      <p>
      程序在编译时调用 <code>exit()</code>(或任何其他外部函数)是没有意义的,所以这是一个编译错误。然而,<code><span class="tok-kw">comptime</span></code> 表达式的作用远不止有时会导致编译错误。
      </p>
      <p>
      在 <code><span class="tok-kw">comptime</span></code> 表达式中:
      </p>
      <ul>
          <li>所有变量都是 <code><span class="tok-kw">comptime</span></code> 变量。</li>
          <li>所有 <code><span class="tok-kw">if</span></code>、<code><span class="tok-kw">while</span></code>、<code><span class="tok-kw">for</span></code> 和 <code><span class="tok-kw">switch</span></code>
          表达式在编译时求值,或者如果无法做到则发出编译错误。</li>
          <li>所有 <code><span class="tok-kw">return</span></code> 和 <code><span class="tok-kw">try</span></code> 表达式都是无效的(除非函数本身在编译时调用)。</li>
          <li>所有具有运行时副作用或依赖于运行时值的代码都会发出编译错误。</li>
          <li>所有函数调用都会导致编译器在编译时解释函数,如果函数试图做具有全局运行时副作用的事情,则发出编译错误。</li>
      </ul>
      <p>
      这意味着程序员可以创建一个在编译时和运行时都被调用的函数,而无需对函数进行修改。
      </p>
      <p>
      让我们看一个例子:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_fibonacci_recursion.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">fn</span> <span class="tok-fn">fibonacci</span>(index: <span class="tok-type">u32</span>) <span class="tok-type">u32</span> {
    <span class="tok-kw">if</span> (index &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> index;
    <span class="tok-kw">return</span> fibonacci(index - <span class="tok-number">1</span>) + fibonacci(index - <span class="tok-number">2</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"fibonacci"</span> {
    <span class="tok-comment">// 在运行时测试 fibonacci</span>
    <span class="tok-kw">try</span> expect(fibonacci(<span class="tok-number">7</span>) == <span class="tok-number">13</span>);

    <span class="tok-comment">// 在编译时测试 fibonacci</span>
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> expect(fibonacci(<span class="tok-number">7</span>) == <span class="tok-number">13</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_fibonacci_recursion.zig</kbd>
1/1 test_fibonacci_recursion.test.fibonacci...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      想象一下,如果我们忘记了递归函数的基本情况并尝试运行测试:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_fibonacci_comptime_overflow.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">fn</span> <span class="tok-fn">fibonacci</span>(index: <span class="tok-type">u32</span>) <span class="tok-type">u32</span> {
    <span class="tok-comment">//if (index &lt; 2) return index;</span>
    <span class="tok-kw">return</span> fibonacci(index - <span class="tok-number">1</span>) + fibonacci(index - <span class="tok-number">2</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"fibonacci"</span> {
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> expect(fibonacci(<span class="tok-number">7</span>) == <span class="tok-number">13</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_fibonacci_comptime_overflow.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_fibonacci_comptime_overflow.zig:5:28: </span><span class="sgr-31m">error: </span><span class="sgr-1m">overflow of integer type 'u32' with value '-1'
</span>    return fibonacci(index - 1) + fibonacci(index - 2);
                     <span class="sgr-32m">~~~~~~^~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_fibonacci_comptime_overflow.zig:5:21: </span><span class="sgr-36m">note: </span><span class="sgr-1m">called at comptime here</span><span class="sgr-2m"> (7 times)
</span>    return fibonacci(index - 1) + fibonacci(index - 2);
           <span class="sgr-32m">~~~~~~~~~^~~~~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_fibonacci_comptime_overflow.zig:9:34: </span><span class="sgr-36m">note: </span><span class="sgr-1m">called at comptime here
</span>    try comptime expect(fibonacci(7) == 13);
                        <span class="sgr-32m">~~~~~~~~~^~~
</span>
</samp></pre></figure>

      <p>
      编译器产生一个错误,这是尝试在编译时求值函数的堆栈跟踪。
      </p>
      <p>
      幸运的是,我们使用了无符号整数,所以当我们尝试从 0 减去 1 时,它触发了<a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>,如果编译器知道它发生了,这总是一个编译错误。
      但是如果我们使用有符号整数会发生什么?
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">fibonacci_comptime_infinite_recursion.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.assert;

<span class="tok-kw">fn</span> <span class="tok-fn">fibonacci</span>(index: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-comment">//if (index &lt; 2) return index;</span>
    <span class="tok-kw">return</span> fibonacci(index - <span class="tok-number">1</span>) + fibonacci(index - <span class="tok-number">2</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"fibonacci"</span> {
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> assert(fibonacci(<span class="tok-number">7</span>) == <span class="tok-number">13</span>);
}</code></pre></figure>

      <p>
      编译器应该注意到在编译时求值此函数花费了超过 1000 个分支,因此发出错误并放弃。如果程序员想要增加编译时计算的预算,他们可以使用名为 <a href="https://ziglang.org/documentation/0.15.2/#setEvalBranchQuota">@setEvalBranchQuota</a> 的内置函数将默认数字 1000 更改为其他值。
      </p>
      <p>
      然而,<a href="https://github.com/ziglang/zig/issues/13724">编译器中存在一个设计缺陷</a>,导致它发生栈溢出而不是在这里表现出正确的行为。对此我深感抱歉。我希望在下一个版本之前解决这个问题。
      </p>
      <p>
      如果我们修复了基本情况,但在 <code>expect</code> 行中放入了错误的值会怎样?
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_fibonacci_comptime_unreachable.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.assert;

<span class="tok-kw">fn</span> <span class="tok-fn">fibonacci</span>(index: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">if</span> (index &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> index;
    <span class="tok-kw">return</span> fibonacci(index - <span class="tok-number">1</span>) + fibonacci(index - <span class="tok-number">2</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"fibonacci"</span> {
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> assert(fibonacci(<span class="tok-number">7</span>) == <span class="tok-number">99999</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_fibonacci_comptime_unreachable.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/debug.zig:559:14: </span><span class="sgr-31m">error: </span><span class="sgr-1m">reached unreachable code
</span>    if (!ok) unreachable; // assertion failure
             <span class="sgr-32m">^~~~~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_fibonacci_comptime_unreachable.zig:9:24: </span><span class="sgr-36m">note: </span><span class="sgr-1m">called at comptime here
</span>    try comptime assert(fibonacci(7) == 99999);
                 <span class="sgr-32m">~~~~~~^~~~~~~~~~~~~~~~~~~~~~~
</span>
</samp></pre></figure>


      <p>
      在<a href="https://ziglang.org/documentation/0.15.2/#Containers">容器</a>级别(在任何函数之外),所有表达式都隐式地是 <code><span class="tok-kw">comptime</span></code> 表达式。这意味着我们可以使用函数来初始化复杂的静态数据。例如:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_container-level_comptime_expressions.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> first_25_primes = firstNPrimes(<span class="tok-number">25</span>);
<span class="tok-kw">const</span> sum_of_first_25_primes = sum(&amp;first_25_primes);

<span class="tok-kw">fn</span> <span class="tok-fn">firstNPrimes</span>(<span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) [n]<span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> prime_list: [n]<span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> next_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> test_number: <span class="tok-type">i32</span> = <span class="tok-number">2</span>;
    <span class="tok-kw">while</span> (next_index &lt; prime_list.len) : (test_number += <span class="tok-number">1</span>) {
        <span class="tok-kw">var</span> test_prime_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> is_prime = <span class="tok-null">true</span>;
        <span class="tok-kw">while</span> (test_prime_index &lt; next_index) : (test_prime_index += <span class="tok-number">1</span>) {
            <span class="tok-kw">if</span> (test_number % prime_list[test_prime_index] == <span class="tok-number">0</span>) {
                is_prime = <span class="tok-null">false</span>;
                <span class="tok-kw">break</span>;
            }
        }
        <span class="tok-kw">if</span> (is_prime) {
            prime_list[next_index] = test_number;
            next_index += <span class="tok-number">1</span>;
        }
    }
    <span class="tok-kw">return</span> prime_list;
}

<span class="tok-kw">fn</span> <span class="tok-fn">sum</span>(numbers: []<span class="tok-kw">const</span> <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> result: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (numbers) |x| {
        result += x;
    }
    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">test</span> <span class="tok-str">"variable values"</span> {
    <span class="tok-kw">try</span> <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect(sum_of_first_25_primes == <span class="tok-number">1060</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_container-level_comptime_expressions.zig</kbd>
1/1 test_container-level_comptime_expressions.test.variable values...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      当我们编译这个程序时,Zig 生成的常量带有预先计算好的答案。以下是生成的 LLVM IR 中的行:
      </p>
      <pre><code class="llvm">@0 = internal unnamed_addr constant [25 x i32] [i32 2, i32 3, i32 5, i32 7, i32 11, i32 13, i32 17, i32 19, i32 23, i32 29, i32 31, i32 37, i32 41, i32 43, i32 47, i32 53, i32 59, i32 61, i32 67, i32 71, i32 73, i32 79, i32 83, i32 89, i32 97]
@1 = internal unnamed_addr constant i32 1060</code></pre>
      <p>
      请注意,我们不需要对这些函数的语法做任何特殊处理。例如,我们可以按原样使用 <code>sum</code> 函数调用一个长度和值仅在运行时已知的数字切片。
      </p>
      
      
      <h3 id="Generic-Data-Structures"><a href="https://ziglang.org/documentation/0.15.2/#toc-Generic-Data-Structures">泛型数据结构</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Generic-Data-Structures">§</a></h3>

      <p>
      Zig 使用编译时能力来实现泛型数据结构,而不引入任何特殊情况语法。
      </p>
      <p>
			这是一个泛型 <code>List</code> 数据结构的例子。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">generic_data_structure.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">List</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        items: []T,
        len: <span class="tok-type">usize</span>,
    };
}

<span class="tok-comment">// 可以通过传入一个类型来实例化泛型 List 数据结构:</span>
<span class="tok-kw">var</span> buffer: [<span class="tok-number">10</span>]<span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;
<span class="tok-kw">var</span> list = List(<span class="tok-type">i32</span>){
    .items = &amp;buffer,
    .len = <span class="tok-number">0</span>,
};</code></pre></figure>

      <p>
      就是这样。它是一个返回匿名 <code><span class="tok-kw">struct</span></code> 的函数。
      出于错误消息和调试的目的,Zig 从创建匿名结构时调用的函数名称和参数推断出名称 <code><span class="tok-str">"List(i32)"</span></code>。
      </p>
      <p>
      要显式地为类型命名,我们将其分配给一个常量。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">anonymous_struct_name.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Node = <span class="tok-kw">struct</span> {
    next: ?*Node,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
};

<span class="tok-kw">var</span> node_a = Node{
    .next = <span class="tok-null">null</span>,
    .name = <span class="tok-str">"Node A"</span>,
};

<span class="tok-kw">var</span> node_b = Node{
    .next = &amp;node_a,
    .name = <span class="tok-str">"Node B"</span>,
};</code></pre></figure>

      <p>
      在这个例子中,<code>Node</code> 结构引用了自己。
      这可以工作,因为所有顶层声明都是顺序无关的。
      只要编译器可以确定结构的大小,它就可以自由引用自己。
      在这种情况下,<code>Node</code> 作为指针引用自己,指针在编译时具有明确定义的大小,所以它可以正常工作。
      </p>
      
      <h3 id="Case-Study-print-in-Zig"><a href="https://ziglang.org/documentation/0.15.2/#toc-Case-Study-print-in-Zig">案例研究:Zig 中的 print</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Case-Study-print-in-Zig">§</a></h3>

      <p>
      将所有这些结合在一起,让我们看看 <code>print</code> 在 Zig 中是如何工作的。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">print.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;

<span class="tok-kw">const</span> a_number: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
<span class="tok-kw">const</span> a_string = <span class="tok-str">"foobar"</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    print(<span class="tok-str">"here is a string: '{s}' here is a number: {}\n"</span>, .{ a_string, a_number });
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe print.zig</kbd>
$ <kbd>./print</kbd>
here is a string: 'foobar' here is a number: 1234
</samp></pre></figure>


      <p>
      让我们深入了解这个实现,看看它是如何工作的:
      </p>

      <figure><figcaption class="zig-cap"><cite class="file">poc_print_fn.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Writer = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// 调用 print 然后刷新缓冲区。</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">print</span>(self: *Writer, <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> State = <span class="tok-kw">enum</span> {
            start,
            open_brace,
            close_brace,
        };

        <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> start_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> state = State.start;
        <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> next_arg: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (format, <span class="tok-number">0</span>..) |c, i| {
            <span class="tok-kw">switch</span> (state) {
                State.start =&gt; <span class="tok-kw">switch</span> (c) {
                    <span class="tok-str">'{'</span> =&gt; {
                        <span class="tok-kw">if</span> (start_index &lt; i) <span class="tok-kw">try</span> self.write(format[start_index..i]);
                        state = State.open_brace;
                    },
                    <span class="tok-str">'}'</span> =&gt; {
                        <span class="tok-kw">if</span> (start_index &lt; i) <span class="tok-kw">try</span> self.write(format[start_index..i]);
                        state = State.close_brace;
                    },
                    <span class="tok-kw">else</span> =&gt; {},
                },
                State.open_brace =&gt; <span class="tok-kw">switch</span> (c) {
                    <span class="tok-str">'{'</span> =&gt; {
                        state = State.start;
                        start_index = i;
                    },
                    <span class="tok-str">'}'</span> =&gt; {
                        <span class="tok-kw">try</span> self.printValue(args[next_arg]);
                        next_arg += <span class="tok-number">1</span>;
                        state = State.start;
                        start_index = i + <span class="tok-number">1</span>;
                    },
                    <span class="tok-str">'s'</span> =&gt; {
                        <span class="tok-kw">continue</span>;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">"Unknown format character: "</span> ++ [<span class="tok-number">1</span>]<span class="tok-type">u8</span>{c}),
                },
                State.close_brace =&gt; <span class="tok-kw">switch</span> (c) {
                    <span class="tok-str">'}'</span> =&gt; {
                        state = State.start;
                        start_index = i;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">"Single '}' encountered in format string"</span>),
                },
            }
        }
        <span class="tok-kw">comptime</span> {
            <span class="tok-kw">if</span> (args.len != next_arg) {
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">"Unused arguments"</span>);
            }
            <span class="tok-kw">if</span> (state != State.start) {
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">"Incomplete format string: "</span> ++ format);
            }
        }
        <span class="tok-kw">if</span> (start_index &lt; format.len) {
            <span class="tok-kw">try</span> self.write(format[start_index..format.len]);
        }
        <span class="tok-kw">try</span> self.flush();
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(self: *Writer, value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
        _ = self;
        _ = value;
    }
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">printValue</span>(self: *Writer, value: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
        _ = self;
        _ = value;
    }
    <span class="tok-kw">fn</span> <span class="tok-fn">flush</span>(self: *Writer) !<span class="tok-type">void</span> {
        _ = self;
    }
};</code></pre></figure>

      <p>
      这是一个概念验证实现;标准库中的实际函数具有更多格式化功能。
      </p>
      <p>
      请注意,这不是硬编码到 Zig 编译器中的;这是标准库中的用户代码。
      </p>
      <p>
      当从上面的示例代码分析此函数时,Zig 部分求值该函数并生成一个实际上看起来像这样的函数:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">生成的 print 函数</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">print</span>(self: *Writer, arg0: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, arg1: <span class="tok-type">i32</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.write(<span class="tok-str">"here is a string: '"</span>);
    <span class="tok-kw">try</span> self.printValue(arg0);
    <span class="tok-kw">try</span> self.write(<span class="tok-str">"' here is a number: "</span>);
    <span class="tok-kw">try</span> self.printValue(arg1);
    <span class="tok-kw">try</span> self.write(<span class="tok-str">"\n"</span>);
    <span class="tok-kw">try</span> self.flush();
}</code></pre></figure>
      <p>
      <code>printValue</code> 是一个接受任意类型参数的函数,并根据类型执行不同的操作:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">poc_printValue_fn.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Writer = <span class="tok-kw">struct</span> {
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">printValue</span>(self: *Writer, value: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(value))) {
            .int =&gt; {
                <span class="tok-kw">return</span> self.writeInt(value);
            },
            .float =&gt; {
                <span class="tok-kw">return</span> self.writeFloat(value);
            },
            .pointer =&gt; {
                <span class="tok-kw">return</span> self.write(value);
            },
            <span class="tok-kw">else</span> =&gt; {
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">"Unable to print type '"</span> ++ <span class="tok-builtin">@typeName</span>(<span class="tok-builtin">@TypeOf</span>(value)) ++ <span class="tok-str">"'"</span>);
            },
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(self: *Writer, value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
        _ = self;
        _ = value;
    }
    <span class="tok-kw">fn</span> <span class="tok-fn">writeInt</span>(self: *Writer, value: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
        _ = self;
        _ = value;
    }
    <span class="tok-kw">fn</span> <span class="tok-fn">writeFloat</span>(self: *Writer, value: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
        _ = self;
        _ = value;
    }
};</code></pre></figure>

      <p>
      现在,如果我们给 <code>print</code> 传递太多参数会发生什么?
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_print_too_many_args.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;

<span class="tok-kw">const</span> a_number: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
<span class="tok-kw">const</span> a_string = <span class="tok-str">"foobar"</span>;

<span class="tok-kw">test</span> <span class="tok-str">"print too many arguments"</span> {
    print(<span class="tok-str">"here is a string: '{s}' here is a number: {}\n"</span>, .{
        a_string,
        a_number,
        a_number,
    });
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_print_too_many_args.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/Io/Writer.zig:717:18: </span><span class="sgr-31m">error: </span><span class="sgr-1m">unused argument in 'here is a string: '{s}' here is a number: {}
                                                        '
</span>            1 =&gt; @compileError("unused argument in '" ++ fmt ++ "'"),
                 <span class="sgr-32m">^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</span><span class="sgr-2m">referenced by:
    print__anon_454: /home/andy/dev/zig/lib/std/debug.zig:231:23
    test.print too many arguments: /home/andy/dev/zig/doc/langref/test_print_too_many_args.zig:7:10
</span>
</samp></pre></figure>

      <p>
      Zig 为程序员提供了防止自己犯错所需的工具。
      </p>
      <p>
      Zig 不关心格式参数是否是字符串字面量,只关心它是可以强制转换为 <code>[]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code> 的编译时已知值:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">print_comptime-known_format.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;

<span class="tok-kw">const</span> a_number: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
<span class="tok-kw">const</span> a_string = <span class="tok-str">"foobar"</span>;
<span class="tok-kw">const</span> fmt = <span class="tok-str">"here is a string: '{s}' here is a number: {}\n"</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    print(fmt, .{ a_string, a_number });
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe print_comptime-known_format.zig</kbd>
$ <kbd>./print_comptime-known_format</kbd>
here is a string: 'foobar' here is a number: 1234
</samp></pre></figure>

      <p>
      这可以正常工作。
      </p>
      <p>
      Zig 不会在编译器中对字符串格式化进行特殊处理,而是公开足够的能力来在用户空间完成此任务。它这样做而不在 Zig 之上引入另一种语言,例如宏语言或预处理器语言。它完全是 Zig。
      </p>
      
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#inline-while">inline while</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#inline-for">inline for</a></li>
</ul>

      
      <h2 id="Assembly"><a href="https://ziglang.org/documentation/0.15.2/#toc-Assembly">汇编</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Assembly">§</a></h2>

      <p>
      对于某些用例,可能需要直接控制 Zig 程序生成的机器码,而不是依赖于 Zig 的代码生成。对于这些情况,可以使用内联汇编。以下是在 x86_64 Linux 上使用内联汇编实现 Hello, World 的示例:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">inline_assembly.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">noreturn</span> {
    <span class="tok-kw">const</span> msg = <span class="tok-str">"hello world\n"</span>;
    _ = syscall3(SYS_write, STDOUT_FILENO, <span class="tok-builtin">@intFromPtr</span>(msg), msg.len);
    _ = syscall1(SYS_exit, <span class="tok-number">0</span>);
    <span class="tok-kw">unreachable</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SYS_write = <span class="tok-number">1</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SYS_exit = <span class="tok-number">60</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> STDOUT_FILENO = <span class="tok-number">1</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">syscall1</span>(number: <span class="tok-type">usize</span>, arg1: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (<span class="tok-str">"syscall"</span>
        : [ret] <span class="tok-str">"={rax}"</span> (-&gt; <span class="tok-type">usize</span>),
        : [number] <span class="tok-str">"{rax}"</span> (number),
          [arg1] <span class="tok-str">"{rdi}"</span> (arg1),
        : .{ .rcx = <span class="tok-null">true</span>, .r11 = <span class="tok-null">true</span> });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">syscall3</span>(number: <span class="tok-type">usize</span>, arg1: <span class="tok-type">usize</span>, arg2: <span class="tok-type">usize</span>, arg3: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (<span class="tok-str">"syscall"</span>
        : [ret] <span class="tok-str">"={rax}"</span> (-&gt; <span class="tok-type">usize</span>),
        : [number] <span class="tok-str">"{rax}"</span> (number),
          [arg1] <span class="tok-str">"{rdi}"</span> (arg1),
          [arg2] <span class="tok-str">"{rsi}"</span> (arg2),
          [arg3] <span class="tok-str">"{rdx}"</span> (arg3),
        : .{ .rcx = <span class="tok-null">true</span>, .r11 = <span class="tok-null">true</span> });
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe inline_assembly.zig -target x86_64-linux</kbd>
$ <kbd>./inline_assembly</kbd>
hello world
</samp></pre></figure>

      <p>
      剖析语法:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">汇编语法说明.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">syscall1</span>(number: <span class="tok-type">usize</span>, arg1: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-comment">// 内联汇编是一个返回值的表达式。</span>
    <span class="tok-comment">// `asm` 关键字开始表达式。</span>
    <span class="tok-kw">return</span> <span class="tok-kw">asm</span>
    <span class="tok-comment">// `volatile` 是一个可选修饰符,告诉 Zig 这个</span>
    <span class="tok-comment">// 内联汇编表达式有副作用。没有</span>
    <span class="tok-comment">// `volatile`,如果结果未使用,Zig 允许删除内联汇编</span>
    <span class="tok-comment">// 代码。</span>
    <span class="tok-kw">volatile</span> (
    <span class="tok-comment">// 接下来是一个编译时字符串,即汇编代码。</span>
    <span class="tok-comment">// 在此字符串中,可以在需要寄存器的地方使用 `%[ret]`、`%[number]`</span>
    <span class="tok-comment">// 或 `%[arg1]`,以指定</span>
    <span class="tok-comment">// Zig 用于参数或返回值的寄存器,</span>
    <span class="tok-comment">// 如果使用寄存器约束字符串。但在</span>
    <span class="tok-comment">// 下面的代码中,没有使用这个。可以通过</span>
    <span class="tok-comment">// 双百分号转义来获得字面 `%`: `%%`。</span>
    <span class="tok-comment">// 多行字符串语法在这里通常很方便。</span>
        <span class="tok-str">\\syscall</span>
        <span class="tok-comment">// 接下来是输出。将来 Zig 可能</span>
        <span class="tok-comment">// 支持多个输出,取决于</span>
        <span class="tok-comment">// https://github.com/ziglang/zig/issues/215 如何解决。</span>
        <span class="tok-comment">// 允许没有输出,在这种情况下</span>
        <span class="tok-comment">// 这个冒号将直接跟在输入的冒号后面。</span>
        :
        <span class="tok-comment">// 这指定了在上面汇编字符串的 `%[ret]` 语法中</span>
        <span class="tok-comment">// 要使用的名称。此示例不使用它,</span>
        <span class="tok-comment">// 但语法是强制性的。</span>
          [ret]
          <span class="tok-comment">// 接下来是输出约束字符串。此功能在</span>
          <span class="tok-comment">// Zig 中仍被视为不稳定,因此必须使用 LLVM/GCC 文档</span>
          <span class="tok-comment">// 来理解语义。</span>
          <span class="tok-comment">// http://releases.llvm.org/10.0.0/docs/LangRef.html#inline-asm-constraint-string</span>
          <span class="tok-comment">// https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html</span>
          <span class="tok-comment">// 在此示例中,约束字符串表示"此</span>
          <span class="tok-comment">// 内联汇编指令的结果值是 $rax 中的任何值"。</span>
          <span class="tok-str">"={rax}"</span>
          <span class="tok-comment">// 接下来是值绑定,或 `-&gt;` 然后是类型。</span>
          <span class="tok-comment">// 类型是内联汇编表达式的结果类型。</span>
          <span class="tok-comment">// 如果是值绑定,则会使用 `%[ret]` 语法</span>
          <span class="tok-comment">// 来引用绑定到该值的寄存器。</span>
          (-&gt; <span class="tok-type">usize</span>),
          <span class="tok-comment">// 接下来是输入列表。</span>
          <span class="tok-comment">// 这些输入的约束意味着,"当执行汇编代码时,</span>
          <span class="tok-comment">// $rax 应具有 `number` 的值,$rdi 应具有</span>
          <span class="tok-comment">// `arg1` 的值"。允许任意数量的输入参数,</span>
          <span class="tok-comment">// 包括无。</span>
        : [number] <span class="tok-str">"{rax}"</span> (number),
          [arg1] <span class="tok-str">"{rdi}"</span> (arg1),
          <span class="tok-comment">// 接下来是破坏列表。这些声明一组寄存器,</span>
          <span class="tok-comment">// 执行此汇编代码后其值将不会保留。</span>
          <span class="tok-comment">// 这些不包括输出或输入寄存器。特殊破坏</span>
          <span class="tok-comment">// 值 "memory" 表示汇编写入任意未声明的</span>
          <span class="tok-comment">// 内存位置 - 不仅是声明的间接</span>
          <span class="tok-comment">// 输出指向的内存。在此示例中,我们列出了 $rcx 和 $r11,因为已知</span>
          <span class="tok-comment">// 内核系统调用不保留这些寄存器。</span>
        : .{ .rcx = <span class="tok-null">true</span>, .r11 = <span class="tok-null">true</span> });
}</code></pre></figure>

      <p>
      对于 x86 和 x86_64 目标,语法是 AT&amp;T 语法,而不是更流行的 Intel 语法。这是由于技术限制;汇编解析由 LLVM 提供,其对 Intel 语法的支持有问题且测试不充分。
      </p>
      <p>
      有一天 Zig 可能会有自己的汇编器。这将允许它更无缝地集成到语言中,并兼容流行的 NASM 语法。在 1.0.0 发布之前,本文档部分将更新,对 AT&amp;T 与 Intel/NASM 语法的状态给出决定性的声明。
      </p>
      <h3 id="Output-Constraints"><a href="https://ziglang.org/documentation/0.15.2/#toc-Output-Constraints">输出约束</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Output-Constraints">§</a></h3>

      <p>
      输出约束在 Zig 中仍被视为不稳定,因此必须使用
      <a href="http://releases.llvm.org/10.0.0/docs/LangRef.html#inline-asm-constraint-string">LLVM 文档</a>
      和
      <a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">GCC 文档</a>
      来理解语义。
      </p>
      <p>
      请注意,计划通过 <a href="https://github.com/ziglang/zig/issues/215">issue #215</a> 对输出约束进行一些破坏性更改。
      </p>
      

      <h3 id="Input-Constraints"><a href="https://ziglang.org/documentation/0.15.2/#toc-Input-Constraints">输入约束</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Input-Constraints">§</a></h3>

      <p>
      输入约束在 Zig 中仍被视为不稳定,因此必须使用
      <a href="http://releases.llvm.org/10.0.0/docs/LangRef.html#inline-asm-constraint-string">LLVM 文档</a>
      和
      <a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">GCC 文档</a>
      来理解语义。
      </p>
      <p>
      请注意,计划通过 <a href="https://github.com/ziglang/zig/issues/215">issue #215</a> 对输入约束进行一些破坏性更改。
      </p>
      

      <h3 id="Clobbers"><a href="https://ziglang.org/documentation/0.15.2/#toc-Clobbers">破坏</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Clobbers">§</a></h3>

      <p>
      破坏是执行汇编代码后其值将不会保留的寄存器集。这些不包括输出或输入寄存器。特殊破坏值 <code><span class="tok-str">"memory"</span></code> 表示汇编导致写入任意未声明的内存位置 - 不仅是声明的间接输出指向的内存。
      </p>
      <p>
      对于给定的内联汇编表达式,未能声明完整的破坏集是未检查的<a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>。
      </p>
      

      <h3 id="Global-Assembly"><a href="https://ziglang.org/documentation/0.15.2/#toc-Global-Assembly">全局汇编</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Global-Assembly">§</a></h3>

      <p>
      当汇编表达式出现在<a href="https://ziglang.org/documentation/0.15.2/#Containers">容器</a>级别的 <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a> 块中时,这是<strong>全局汇编</strong>。
      </p>
      <p>
      这种汇编与内联汇编有不同的规则。首先,<code><span class="tok-kw">volatile</span></code> 无效,因为所有全局汇编都无条件包含。
      其次,没有输入、输出或破坏。所有全局汇编都逐字连接成一个长字符串并一起汇编。内联汇编表达式中关于 <code>%</code> 的模板替换规则不适用。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_global_assembly.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">comptime</span> {
    <span class="tok-kw">asm</span> (
        <span class="tok-str">\\.global my_func;</span>
        <span class="tok-str">\\.type my_func, @function;</span>
        <span class="tok-str">\\my_func:</span>
        <span class="tok-str">\\  lea (%rdi,%rsi,1),%eax</span>
        <span class="tok-str">\\  retq</span>
    );
}

<span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">my_func</span>(a: <span class="tok-type">i32</span>, b: <span class="tok-type">i32</span>) <span class="tok-type">i32</span>;

<span class="tok-kw">test</span> <span class="tok-str">"global assembly"</span> {
    <span class="tok-kw">try</span> expect(my_func(<span class="tok-number">12</span>, <span class="tok-number">34</span>) == <span class="tok-number">46</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_global_assembly.zig -target x86_64-linux -fllvm</kbd>
1/1 test_global_assembly.test.global assembly...OK
All 1 tests passed.
</samp></pre></figure>

      
      

      <h2 id="Atomics"><a href="https://ziglang.org/documentation/0.15.2/#toc-Atomics">原子操作</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Atomics">§</a></h2>

      <p>TODO: @atomic rmw</p>
      <p>TODO: 内置原子内存排序枚举</p>

      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#atomicLoad">@atomicLoad</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#atomicStore">@atomicStore</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#atomicRmw">@atomicRmw</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cmpxchgWeak">@cmpxchgWeak</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cmpxchgStrong">@cmpxchgStrong</a></li>
</ul>


      

      <h2 id="Async-Functions"><a href="https://ziglang.org/documentation/0.15.2/#toc-Async-Functions">异步函数</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Async-Functions">§</a></h2>

      <p>异步函数在 0.11.0 版本发布时出现了回归。目前的计划是将它们作为支持 I/O 实现的更低级别原语重新引入。</p>
      <p>跟踪问题: <a href="https://github.com/ziglang/zig/issues/23446">提案:无栈协程作为低级原语</a></p>
      

      <h2 id="Builtin-Functions"><a href="https://ziglang.org/documentation/0.15.2/#toc-Builtin-Functions">内置函数</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Builtin-Functions">§</a></h2>

      <p>
      内置函数由编译器提供,并以 <code>@</code> 为前缀。
      参数上的 <code><span class="tok-kw">comptime</span></code> 关键字表示该参数必须在编译时已知。
      </p>
      <h3 id="addrSpaceCast"><a href="https://ziglang.org/documentation/0.15.2/#toc-addrSpaceCast">@addrSpaceCast</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#addrSpaceCast">§</a></h3>

      <pre><code><span class="tok-builtin">@addrSpaceCast</span>(ptr: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      将指针从一个地址空间转换到另一个地址空间。新的地址空间根据结果类型推断。根据当前目标和地址空间,此转换可能是无操作、复杂操作或非法的。如果转换合法,则生成的指针指向与指针操作数相同的内存位置。在相同地址空间之间转换指针始终有效。
      </p>
      
      <h3 id="addWithOverflow"><a href="https://ziglang.org/documentation/0.15.2/#toc-addWithOverflow">@addWithOverflow</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#addWithOverflow">§</a></h3>

      <pre><code><span class="tok-builtin">@addWithOverflow</span>(a: <span class="tok-kw">anytype</span>, b: <span class="tok-kw">anytype</span>) <span class="tok-kw">struct</span> { <span class="tok-builtin">@TypeOf</span>(a, b), <span class="tok-type">u1</span> }</code></pre>
      <p>
      执行 <code>a + b</code> 并返回包含结果和可能的溢出位的元组。
      </p>
      
      <h3 id="alignCast"><a href="https://ziglang.org/documentation/0.15.2/#toc-alignCast">@alignCast</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#alignCast">§</a></h3>

      <pre><code><span class="tok-builtin">@alignCast</span>(ptr: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      <code>ptr</code> 可以是 <code>*T</code>、<code>?*T</code> 或 <code>[]T</code>。
			改变指针的对齐方式。要使用的对齐方式根据结果类型推断。
      </p>
      <p>向生成的代码添加<a href="https://ziglang.org/documentation/0.15.2/#Incorrect-Pointer-Alignment">指针对齐安全检查</a>,以确保指针如承诺的那样对齐。</p>

      
      <h3 id="alignOf"><a href="https://ziglang.org/documentation/0.15.2/#toc-alignOf">@alignOf</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#alignOf">§</a></h3>

      <pre><code><span class="tok-builtin">@alignOf</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">comptime_int</span></code></pre>
      <p>
      此函数返回此类型在当前目标上应对齐到的字节数,以匹配 C ABI。当指针的子类型具有此对齐方式时,可以从类型中省略对齐方式。
      </p>
      <pre><code><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.assert;
<span class="tok-kw">comptime</span> {
    assert(*<span class="tok-type">u32</span> == *<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<span class="tok-type">u32</span>)) <span class="tok-type">u32</span>);
}</code></pre>
      <p>
      结果是特定于目标的编译时常量。保证小于或等于 <a href="https://ziglang.org/documentation/0.15.2/#sizeOf">@sizeOf(T)</a>。
      </p>
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Alignment">对齐</a></li>
</ul>

      

      <h3 id="as"><a href="https://ziglang.org/documentation/0.15.2/#toc-as">@as</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#as">§</a></h3>

      <pre><code><span class="tok-builtin">@as</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, expression) T</code></pre>
      <p>
      执行<a href="https://ziglang.org/documentation/0.15.2/#Type-Coercion">类型强制转换</a>。当转换明确且安全时允许此转换,并且是在可能的情况下在类型之间转换的首选方式。
      </p>
      

      <h3 id="atomicLoad"><a href="https://ziglang.org/documentation/0.15.2/#toc-atomicLoad">@atomicLoad</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#atomicLoad">§</a></h3>

      <pre><code><span class="tok-builtin">@atomicLoad</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *<span class="tok-kw">const</span> T, <span class="tok-kw">comptime</span> ordering: AtomicOrder) T</code></pre>
      <p>
      此内置函数原子地解引用指向 <code>T</code> 的指针并返回值。
      </p>
      <p>
      <code>T</code> 必须是指针、<code><span class="tok-type">bool</span></code>、浮点数、整数、枚举或打包结构。
      </p>
      <p><code>AtomicOrder</code> 可以通过 <code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).builtin.AtomicOrder</code> 找到。</p>
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#atomicStore">@atomicStore</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#atomicRmw">@atomicRmw</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cmpxchgWeak">@cmpxchgWeak</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cmpxchgStrong">@cmpxchgStrong</a></li>
</ul>

      

      <h3 id="atomicRmw"><a href="https://ziglang.org/documentation/0.15.2/#toc-atomicRmw">@atomicRmw</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#atomicRmw">§</a></h3>

      <pre><code><span class="tok-builtin">@atomicRmw</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *T, <span class="tok-kw">comptime</span> op: AtomicRmwOp, operand: T, <span class="tok-kw">comptime</span> ordering: AtomicOrder) T</code></pre>
      <p>
      此内置函数解引用指向 <code>T</code> 的指针,原子地修改值并返回先前的值。
      </p>
      <p>
      <code>T</code> 必须是指针、<code><span class="tok-type">bool</span></code>、浮点数、整数、枚举或打包结构。
      </p>
      <p><code>AtomicOrder</code> 可以通过 <code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).builtin.AtomicOrder</code> 找到。</p>
      <p><code>AtomicRmwOp</code> 可以通过 <code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).builtin.AtomicRmwOp</code> 找到。</p>
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#atomicStore">@atomicStore</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#atomicLoad">@atomicLoad</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cmpxchgWeak">@cmpxchgWeak</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cmpxchgStrong">@cmpxchgStrong</a></li>
</ul>

      

      <h3 id="atomicStore"><a href="https://ziglang.org/documentation/0.15.2/#toc-atomicStore">@atomicStore</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#atomicStore">§</a></h3>

      <pre><code><span class="tok-builtin">@atomicStore</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *T, value: T, <span class="tok-kw">comptime</span> ordering: AtomicOrder) <span class="tok-type">void</span></code></pre>
      <p>
      此内置函数解引用指向 <code>T</code> 的指针并原子地存储给定的值。
      </p>
      <p>
      <code>T</code> 必须是指针、<code><span class="tok-type">bool</span></code>、浮点数、整数、枚举或打包结构。
      </p>
      <p><code>AtomicOrder</code> 可以通过 <code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).builtin.AtomicOrder</code> 找到。</p>
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#atomicLoad">@atomicLoad</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#atomicRmw">@atomicRmw</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cmpxchgWeak">@cmpxchgWeak</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cmpxchgStrong">@cmpxchgStrong</a></li>
</ul>

      

      <h3 id="bitCast"><a href="https://ziglang.org/documentation/0.15.2/#toc-bitCast">@bitCast</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#bitCast">§</a></h3>

      <pre><code><span class="tok-builtin">@bitCast</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      将一种类型的值转换为另一种类型。返回类型是推断的结果类型。
      </p>
      <p>
      断言 <code><span class="tok-builtin">@sizeOf</span>(<span class="tok-builtin">@TypeOf</span>(value)) == <span class="tok-builtin">@sizeOf</span>(DestType)</code>。
      </p>
      <p>
      断言 <code><span class="tok-builtin">@typeInfo</span>(DestType) != .pointer</code>。如果需要这个,请使用 <code><span class="tok-builtin">@ptrCast</span></code> 或 <code><span class="tok-builtin">@ptrFromInt</span></code>。
      </p>
      <p>
      例如可用于这些事情:
      </p>
      <ul>
          <li>将 <code><span class="tok-type">f32</span></code> 转换为 <code><span class="tok-type">u32</span></code> 位</li>
          <li>将 <code><span class="tok-type">i32</span></code> 转换为 <code><span class="tok-type">u32</span></code> 保留二进制补码</li>
      </ul>
      <p>
      如果 <code>value</code> 在编译时已知,则在编译时工作。对未定义布局的值进行位转换是编译错误;这意味着,除了具有专用转换内置函数的类型(枚举、指针、错误集)的限制之外,裸结构、错误联合、切片、可选类型以及任何其他没有明确定义内存布局的类型也不能在此操作中使用。
      </p>
      

      <h3 id="bitOffsetOf"><a href="https://ziglang.org/documentation/0.15.2/#toc-bitOffsetOf">@bitOffsetOf</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#bitOffsetOf">§</a></h3>

      <pre><code><span class="tok-builtin">@bitOffsetOf</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">comptime_int</span></code></pre>
      <p>
      返回字段相对于其包含结构的位偏移量。
      </p>
      <p>
      对于非<a href="https://ziglang.org/documentation/0.15.2/#packed-struct">打包结构</a>,这将始终能被 <code><span class="tok-number">8</span></code> 整除。
      对于打包结构,非字节对齐的字段将共享一个字节偏移量,但它们将有不同的位偏移量。
      </p>
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#offsetOf">@offsetOf</a></li>
</ul>

      

      <h3 id="bitSizeOf"><a href="https://ziglang.org/documentation/0.15.2/#toc-bitSizeOf">@bitSizeOf</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#bitSizeOf">§</a></h3>

      <pre><code><span class="tok-builtin">@bitSizeOf</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">comptime_int</span></code></pre>
      <p>
      此函数返回在内存中存储 <code>T</code> 所需的位数,如果该类型是打包结构/联合中的字段。
      结果是特定于目标的编译时常量。
      </p>
      <p>
      此函数在运行时测量大小。对于在运行时不允许的类型,例如 <code><span class="tok-type">comptime_int</span></code> 和 <code><span class="tok-type">type</span></code>,结果为 <code><span class="tok-number">0</span></code>。
      </p>
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#sizeOf">@sizeOf</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#typeInfo">@typeInfo</a></li>
</ul>

      

      <h3 id="branchHint"><a href="https://ziglang.org/documentation/0.15.2/#toc-branchHint">@branchHint</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#branchHint">§</a></h3>

      <pre><code><span class="tok-builtin">@branchHint</span>(hint: BranchHint) <span class="tok-type">void</span></code></pre>
      <p>向优化器提示给定控制流分支被到达的可能性。</p>
      <p><code>BranchHint</code> 可以通过 <code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).builtin.BranchHint</code> 找到。</p>
      <p>此函数仅在控制流分支的第一条语句或函数的第一条语句中有效。</p>
      

      <h3 id="breakpoint"><a href="https://ziglang.org/documentation/0.15.2/#toc-breakpoint">@breakpoint</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#breakpoint">§</a></h3>

      <pre><code><span class="tok-builtin">@breakpoint</span>() <span class="tok-type">void</span></code></pre>
      <p>
      此函数插入特定于平台的调试陷阱指令,导致调试器在此处中断。
      与 <code><span class="tok-builtin">@trap</span>()</code> 不同,如果程序恢复,执行可能会在此点之后继续。
      </p>
      <p>
      此函数仅在函数作用域内有效。
      </p>
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#trap">@trap</a></li>
</ul>

      

      <h3 id="mulAdd"><a href="https://ziglang.org/documentation/0.15.2/#toc-mulAdd">@mulAdd</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#mulAdd">§</a></h3>

      <pre><code><span class="tok-builtin">@mulAdd</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T, c: T) T</code></pre>
      <p>
      融合乘加,类似于 <code>(a * b) + c</code>,但只舍入一次,因此更准确。
      </p>
      <p>
      支持<a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a>和<a href="https://ziglang.org/documentation/0.15.2/#Vectors">浮点数向量</a>。
      </p>
      

      <h3 id="byteSwap"><a href="https://ziglang.org/documentation/0.15.2/#toc-byteSwap">@byteSwap</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#byteSwap">§</a></h3>
<!-- ====== END CHUNK 9: new_09.html ====== -->

<!-- ====== BEGIN CHUNK 10: new_10.html ====== -->
<pre><code><span class="tok-builtin">@byteSwap</span>(operand: <span class="tok-kw">anytype</span>) T</code></pre>
      <p><code><span class="tok-builtin">@TypeOf</span>(operand)</code> 必须是整数类型或位计数能被 8 整除的整数向量类型。</p>
      <p><code>operand</code> 可以是 <a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a> 或 <a href="https://ziglang.org/documentation/0.15.2/#Vectors">向量</a>。</p>
      <p>
      交换整数的字节序。这会将大端整数转换为小端整数，
      并将小端整数转换为大端整数。
      </p>
      <p>
      注意，对于与字节序相关的内存布局，整数类型应该
      与 <a href="https://ziglang.org/documentation/0.15.2/#sizeOf">@sizeOf</a> 报告的字节数相关。这在
      <code><span class="tok-type">u24</span></code> 中得到了演示。<code><span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u24</span>) == <span class="tok-number">4</span></code>，这意味着
      存储在内存中的 <code><span class="tok-type">u24</span></code> 占用 4 个字节，这 4 个字节是在
      小端与大端系统上被交换的。另一方面，如果 <code>T</code> 被指定为
      <code><span class="tok-type">u24</span></code>，则只反转 3 个字节。
      </p>
      

      <h3 id="bitReverse"><a href="https://ziglang.org/documentation/0.15.2/#toc-bitReverse">@bitReverse</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#bitReverse">§</a></h3>

      <pre><code><span class="tok-builtin">@bitReverse</span>(integer: <span class="tok-kw">anytype</span>) T</code></pre>
      <p><code><span class="tok-builtin">@TypeOf</span>(<span class="tok-kw">anytype</span>)</code> 接受任何整数类型或整数向量类型。</p>
      <p>
      反转整数值的位模式，包括符号位（如果适用）。
      </p>
      <p>
      例如 0b10110110 (<code><span class="tok-type">u8</span> = <span class="tok-number">182</span></code>, <code><span class="tok-type">i8</span> = -<span class="tok-number">74</span></code>)
      变为 0b01101101 (<code><span class="tok-type">u8</span> = <span class="tok-number">109</span></code>, <code><span class="tok-type">i8</span> = <span class="tok-number">109</span></code>)。
      </p>
      

      <h3 id="offsetOf"><a href="https://ziglang.org/documentation/0.15.2/#toc-offsetOf">@offsetOf</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#offsetOf">§</a></h3>

      <pre><code><span class="tok-builtin">@offsetOf</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">comptime_int</span></code></pre>
      <p>
      返回字段相对于其包含结构的字节偏移量。
      </p>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#bitOffsetOf">@bitOffsetOf</a></li>
</ul>

      

      <h3 id="call"><a href="https://ziglang.org/documentation/0.15.2/#toc-call">@call</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#call">§</a></h3>

      <pre><code><span class="tok-builtin">@call</span>(modifier: std.builtin.CallModifier, function: <span class="tok-kw">anytype</span>, args: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      调用函数，方式与使用括号调用表达式相同：
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_call_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"noinline function call"</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@call</span>(.auto, add, .{ <span class="tok-number">3</span>, <span class="tok-number">9</span> }) == <span class="tok-number">12</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">add</span>(a: <span class="tok-type">i32</span>, b: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> a + b;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_call_builtin.zig</kbd>
1/1 test_call_builtin.test.noinline function call...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      <code><span class="tok-builtin">@call</span></code> 允许比普通函数调用语法更大的灵活性。
      <code>CallModifier</code> 枚举在此重现：
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">builtin.CallModifier struct.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CallModifier = <span class="tok-kw">enum</span> {
    <span class="tok-comment">/// 等同于函数调用语法。</span>
    auto,

    <span class="tok-comment">/// 等同于与函数调用语法一起使用的 async 关键字。</span>
    async_kw,

    <span class="tok-comment">/// 阻止尾调用优化。这保证返回</span>
    <span class="tok-comment">/// 地址将指向调用点，而不是调用点的</span>
    <span class="tok-comment">/// 调用点。如果调用在其他情况下需要尾调用</span>
    <span class="tok-comment">/// 或内联，则会发出编译错误。</span>
    never_tail,

    <span class="tok-comment">/// 保证调用不会被内联。如果调用</span>
    <span class="tok-comment">/// 在其他情况下需要内联，则会发出编译错误。</span>
    never_inline,

    <span class="tok-comment">/// 断言函数调用不会挂起。这允许</span>
    <span class="tok-comment">/// 非异步函数调用异步函数。</span>
    no_async,

    <span class="tok-comment">/// 保证调用将通过尾调用优化生成。</span>
    <span class="tok-comment">/// 如果这不可能，则会发出编译错误。</span>
    always_tail,

    <span class="tok-comment">/// 保证调用将在调用点内联。</span>
    <span class="tok-comment">/// 如果这不可能，则会发出编译错误。</span>
    always_inline,

    <span class="tok-comment">/// 在编译时评估调用。如果调用无法在</span>
    <span class="tok-comment">/// 编译时完成，则会发出编译错误。</span>
    compile_time,
};</code></pre></figure>

      

      <h3 id="cDefine"><a href="https://ziglang.org/documentation/0.15.2/#toc-cDefine">@cDefine</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#cDefine">§</a></h3>

      <pre><code><span class="tok-builtin">@cDefine</span>(<span class="tok-kw">comptime</span> name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, value) <span class="tok-type">void</span></code></pre>
      <p>
      此函数只能在 <code><span class="tok-builtin">@cImport</span></code> 内部出现。
      </p>
      <p>
      这会将 <code>#define $name $value</code> 追加到 <code><span class="tok-builtin">@cImport</span></code>
      临时缓冲区。
      </p>
      <p>
      要定义没有值的宏，像这样：
      </p>
      <pre><code class="c">#define _GNU_SOURCE</code></pre>
      <p>
      使用 void 值，像这样：
      </p>
      <pre><code><span class="tok-builtin">@cDefine</span>(<span class="tok-str">"_GNU_SOURCE"</span>, {})</code></pre>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Import-from-C-Header-File">从 C 头文件导入</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cInclude">@cInclude</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cImport">@cImport</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cUndef">@cUndef</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#void">void</a></li>
</ul>

      
      <h3 id="cImport"><a href="https://ziglang.org/documentation/0.15.2/#toc-cImport">@cImport</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#cImport">§</a></h3>

      <pre><code><span class="tok-builtin">@cImport</span>(expression) <span class="tok-type">type</span></code></pre>
      <p>
      此函数解析 C 代码并将函数、类型、变量
      和兼容的宏定义导入到新的空结构类型中，然后
      返回该类型。
      </p>
      <p>
      <code>expression</code> 在编译时被解释。内建函数
          <code><span class="tok-builtin">@cInclude</span></code>、<code><span class="tok-builtin">@cDefine</span></code> 和 <code><span class="tok-builtin">@cUndef</span></code> 在
      此表达式中工作，追加到临时缓冲区，然后将其解析为 C 代码。
      </p>
      <p>
      通常您应该在整个应用程序中只有一个 <code><span class="tok-builtin">@cImport</span></code>，因为它可以避免编译器
      多次调用 clang，并防止内联函数重复。
      </p>
      <p>
      拥有多个 <code><span class="tok-builtin">@cImport</span></code> 表达式的原因是：
      </p>
      <ul>
          <li>为了避免符号冲突，例如如果 foo.h 和 bar.h 都 <code>#define CONNECTION_COUNT</code></li>
        <li>使用不同的预处理器定义分析 C 代码</li>
      </ul>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Import-from-C-Header-File">从 C 头文件导入</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cInclude">@cInclude</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cDefine">@cDefine</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cUndef">@cUndef</a></li>
</ul>

      
      <h3 id="cInclude"><a href="https://ziglang.org/documentation/0.15.2/#toc-cInclude">@cInclude</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#cInclude">§</a></h3>

      <pre><code><span class="tok-builtin">@cInclude</span>(<span class="tok-kw">comptime</span> path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre>
      <p>
      此函数只能在 <code><span class="tok-builtin">@cImport</span></code> 内部出现。
      </p>
      <p>
      这会将 <code>#include &lt;$path&gt;\n</code> 追加到 <code>c_import</code>
      临时缓冲区。
      </p>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Import-from-C-Header-File">从 C 头文件导入</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cImport">@cImport</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cDefine">@cDefine</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cUndef">@cUndef</a></li>
</ul>

      

      <h3 id="clz"><a href="https://ziglang.org/documentation/0.15.2/#toc-clz">@clz</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#clz">§</a></h3>

      <pre><code><span class="tok-builtin">@clz</span>(operand: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p><code><span class="tok-builtin">@TypeOf</span>(operand)</code> 必须是整数类型或整数向量类型。</p>
      <p><code>operand</code> 可以是 <a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a> 或 <a href="https://ziglang.org/documentation/0.15.2/#Vectors">向量</a>。</p>
      <p>
      计算整数中最高有效位（大端意义上的前导）零的数量 - "计数前导零"。
      </p>
      <p>
      返回类型是无符号整数或无符号整数向量，具有可以表示整数类型位数的
      最少位数。
      </p>
      <p>
      如果 <code>operand</code> 为零，<code><span class="tok-builtin">@clz</span></code> 返回
      整数类型 <code>T</code> 的位宽。
      </p>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#ctz">@ctz</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#popCount">@popCount</a></li>
</ul>

      

      <h3 id="cmpxchgStrong"><a href="https://ziglang.org/documentation/0.15.2/#toc-cmpxchgStrong">@cmpxchgStrong</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#cmpxchgStrong">§</a></h3>

      <pre><code><span class="tok-builtin">@cmpxchgStrong</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *T, expected_value: T, new_value: T, success_order: AtomicOrder, fail_order: AtomicOrder) ?T</code></pre>
      <p>
      此函数执行强原子比较交换操作，如果当前值是给定的期望值，
      则返回 <code><span class="tok-null">null</span></code>。它等同于以下代码，
      除了是原子的：
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">not_atomic_cmpxchgStrong.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">cmpxchgStrongButNotAtomic</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *T, expected_value: T, new_value: T) ?T {
    <span class="tok-kw">const</span> old_value = ptr.*;
    <span class="tok-kw">if</span> (old_value == expected_value) {
        ptr.* = new_value;
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> old_value;
    }
}</code></pre></figure>

      <p>
      如果您在重试循环中使用 cmpxchg，<a href="https://ziglang.org/documentation/0.15.2/#cmpxchgWeak">@cmpxchgWeak</a> 是更好的选择，因为它可以
      在机器指令中更有效地实现。
      </p>
      <p>
      <code>T</code> 必须是指针、<code><span class="tok-type">bool</span></code>、
      整数、枚举或紧缩结构。
      </p>
      <p><code><span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(ptr)).pointer.alignment</code> 必须 <code>&gt;= <span class="tok-builtin">@sizeOf</span>(T).</code></p>
      <p><code>AtomicOrder</code> 可以通过 <code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).builtin.AtomicOrder</code> 找到。</p>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#atomicStore">@atomicStore</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#atomicLoad">@atomicLoad</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#atomicRmw">@atomicRmw</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cmpxchgWeak">@cmpxchgWeak</a></li>
</ul>

      

      <h3 id="cmpxchgWeak"><a href="https://ziglang.org/documentation/0.15.2/#toc-cmpxchgWeak">@cmpxchgWeak</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#cmpxchgWeak">§</a></h3>

      <pre><code><span class="tok-builtin">@cmpxchgWeak</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *T, expected_value: T, new_value: T, success_order: AtomicOrder, fail_order: AtomicOrder) ?T</code></pre>
      <p>
      此函数执行弱原子比较交换操作，如果当前值是给定的期望值，
      则返回 <code><span class="tok-null">null</span></code>。它等同于以下代码，
      除了是原子的：
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">cmpxchgWeakButNotAtomic</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">cmpxchgWeakButNotAtomic</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *T, expected_value: T, new_value: T) ?T {
    <span class="tok-kw">const</span> old_value = ptr.*;
    <span class="tok-kw">if</span> (old_value == expected_value <span class="tok-kw">and</span> usuallyTrueButSometimesFalse()) {
        ptr.* = new_value;
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> old_value;
    }
}</code></pre></figure>
      <p>
      如果您在重试循环中使用 cmpxchg，偶发的失败不会有问题，并且 <code>cmpxchgWeak</code>
      是更好的选择，因为它可以在机器指令中更有效地实现。
      但是，如果您需要更强的保证，请使用 <a href="https://ziglang.org/documentation/0.15.2/#cmpxchgStrong">@cmpxchgStrong</a>。
      </p>
      <p>
      <code>T</code> 必须是指针、<code><span class="tok-type">bool</span></code>、
      整数、枚举或紧缩结构。
      </p>
      <p><code><span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(ptr)).pointer.alignment</code> 必须 <code>&gt;= <span class="tok-builtin">@sizeOf</span>(T).</code></p>
      <p><code>AtomicOrder</code> 可以通过 <code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).builtin.AtomicOrder</code> 找到。</p>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#atomicStore">@atomicStore</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#atomicLoad">@atomicLoad</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#atomicRmw">@atomicRmw</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cmpxchgStrong">@cmpxchgStrong</a></li>
</ul>

      

      <h3 id="compileError"><a href="https://ziglang.org/documentation/0.15.2/#toc-compileError">@compileError</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#compileError">§</a></h3>

      <pre><code><span class="tok-builtin">@compileError</span>(<span class="tok-kw">comptime</span> msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">noreturn</span></code></pre>
      <p>
      此函数在语义分析时会导致编译错误，
      错误消息为 <code>msg</code>。
      </p>
      <p>
      有几种方法可以避免代码被语义检查，例如
      使用带有编译时常量的 <code><span class="tok-kw">if</span></code> 或 <code><span class="tok-kw">switch</span></code>，
              以及 <code><span class="tok-kw">comptime</span></code> 函数。
      </p>
      

      <h3 id="compileLog"><a href="https://ziglang.org/documentation/0.15.2/#toc-compileLog">@compileLog</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#compileLog">§</a></h3>

      <pre><code><span class="tok-builtin">@compileLog</span>(...) <span class="tok-type">void</span></code></pre>
      <p>
      此函数在编译时打印传递给它的参数。
      </p>
      <p>
      为了防止意外地在代码库中留下编译日志语句，
      会向构建中添加编译错误，指向编译
      日志语句。此错误阻止代码生成，但
      不会干扰分析。
      </p>
      <p>
      此函数可用于对
      编译时执行的代码进行"printf 调试"。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_compileLog_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;

<span class="tok-kw">const</span> num1 = blk: {
    <span class="tok-kw">var</span> val1: <span class="tok-type">i32</span> = <span class="tok-number">99</span>;
    <span class="tok-builtin">@compileLog</span>(<span class="tok-str">"comptime val1 = "</span>, val1);
    val1 = val1 + <span class="tok-number">1</span>;
    <span class="tok-kw">break</span> :blk val1;
};

<span class="tok-kw">test</span> <span class="tok-str">"main"</span> {
    <span class="tok-builtin">@compileLog</span>(<span class="tok-str">"comptime in main"</span>);

    print(<span class="tok-str">"Runtime in main, num1 = {}.\n"</span>, .{num1});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_compileLog_builtin.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_compileLog_builtin.zig:5:5: </span><span class="sgr-31m">error: </span><span class="sgr-1m">found compile log statement
</span>    @compileLog("comptime val1 = ", val1);
    <span class="sgr-32m">^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_compileLog_builtin.zig:11:5: </span><span class="sgr-36m">note: </span><span class="sgr-1m">also here
</span>    @compileLog("comptime in main");
    <span class="sgr-32m">^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</span><span class="sgr-2m">referenced by:
    test.main: /home/andy/dev/zig/doc/langref/test_compileLog_builtin.zig:13:46
</span>
Compile Log Output:
@as(*const [16:0]u8, "comptime val1 = "), @as(i32, 99)
@as(*const [16:0]u8, "comptime in main")
</samp></pre></figure>

      

      <h3 id="constCast"><a href="https://ziglang.org/documentation/0.15.2/#toc-constCast">@constCast</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#constCast">§</a></h3>

      <pre><code><span class="tok-builtin">@constCast</span>(value: <span class="tok-kw">anytype</span>) DestType</code></pre>
      <p>
      从指针中移除 <code><span class="tok-kw">const</span></code> 限定符。
      </p>
      

      <h3 id="ctz"><a href="https://ziglang.org/documentation/0.15.2/#toc-ctz">@ctz</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#ctz">§</a></h3>

      <pre><code><span class="tok-builtin">@ctz</span>(operand: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p><code><span class="tok-builtin">@TypeOf</span>(operand)</code> 必须是整数类型或整数向量类型。</p>
      <p><code>operand</code> 可以是 <a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a> 或 <a href="https://ziglang.org/documentation/0.15.2/#Vectors">向量</a>。</p>
      <p>
      计算整数中最低有效位（大端意义上的尾随）零的数量 - "计数尾随零"。
      </p>
      <p>
      返回类型是无符号整数或无符号整数向量，具有可以表示整数类型位数的
      最少位数。
      </p>
      <p>
      如果 <code>operand</code> 为零，<code><span class="tok-builtin">@ctz</span></code> 返回
      整数类型 <code>T</code> 的位宽。
      </p>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#clz">@clz</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#popCount">@popCount</a></li>
</ul>

      

      <h3 id="cUndef"><a href="https://ziglang.org/documentation/0.15.2/#toc-cUndef">@cUndef</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#cUndef">§</a></h3>

      <pre><code><span class="tok-builtin">@cUndef</span>(<span class="tok-kw">comptime</span> name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre>
      <p>
      此函数只能在 <code><span class="tok-builtin">@cImport</span></code> 内部出现。
      </p>
      <p>
      这会将 <code>#undef $name</code> 追加到 <code><span class="tok-builtin">@cImport</span></code>
      临时缓冲区。
      </p>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Import-from-C-Header-File">从 C 头文件导入</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cImport">@cImport</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cDefine">@cDefine</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cInclude">@cInclude</a></li>
</ul>

      

      <h3 id="cVaArg"><a href="https://ziglang.org/documentation/0.15.2/#toc-cVaArg">@cVaArg</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#cVaArg">§</a></h3>

      <pre><code><span class="tok-builtin">@cVaArg</span>(operand: *std.builtin.VaList, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) T</code></pre>
      <p>
      实现 C 宏 <code>va_arg</code>。
      </p>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#cVaCopy">@cVaCopy</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cVaEnd">@cVaEnd</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cVaStart">@cVaStart</a></li>
</ul>

      
      <h3 id="cVaCopy"><a href="https://ziglang.org/documentation/0.15.2/#toc-cVaCopy">@cVaCopy</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#cVaCopy">§</a></h3>

      <pre><code><span class="tok-builtin">@cVaCopy</span>(src: *std.builtin.VaList) std.builtin.VaList</code></pre>
      <p>
      实现 C 宏 <code>va_copy</code>。
      </p>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#cVaArg">@cVaArg</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cVaEnd">@cVaEnd</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cVaStart">@cVaStart</a></li>
</ul>

      
      <h3 id="cVaEnd"><a href="https://ziglang.org/documentation/0.15.2/#toc-cVaEnd">@cVaEnd</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#cVaEnd">§</a></h3>

      <pre><code><span class="tok-builtin">@cVaEnd</span>(src: *std.builtin.VaList) <span class="tok-type">void</span></code></pre>
      <p>
      实现 C 宏 <code>va_end</code>。
      </p>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#cVaArg">@cVaArg</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cVaCopy">@cVaCopy</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cVaStart">@cVaStart</a></li>
</ul>

      
      <h3 id="cVaStart"><a href="https://ziglang.org/documentation/0.15.2/#toc-cVaStart">@cVaStart</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#cVaStart">§</a></h3>

      <pre><code><span class="tok-builtin">@cVaStart</span>() std.builtin.VaList</code></pre>
      <p>
      实现 C 宏 <code>va_start</code>。仅在可变参数函数内有效。
      </p>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#cVaArg">@cVaArg</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cVaCopy">@cVaCopy</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cVaEnd">@cVaEnd</a></li>
</ul>

      

      <h3 id="divExact"><a href="https://ziglang.org/documentation/0.15.2/#toc-divExact">@divExact</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#divExact">§</a></h3>

      <pre><code><span class="tok-builtin">@divExact</span>(numerator: T, denominator: T) T</code></pre>
      <p>
      精确除法。调用者保证 <code>denominator != <span class="tok-number">0</span></code> 并且
          <code><span class="tok-builtin">@divTrunc</span>(numerator, denominator) * denominator == numerator</code>。
      </p>
      <ul>
          <li><code><span class="tok-builtin">@divExact</span>(<span class="tok-number">6</span>, <span class="tok-number">3</span>) == <span class="tok-number">2</span></code></li>
          <li><code><span class="tok-builtin">@divExact</span>(a, b) * b == a</code></li>
      </ul>
      <p>对于返回可能错误代码的函数，请使用 <code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).math.divExact</code>。</p>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#divTrunc">@divTrunc</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#divFloor">@divFloor</a></li>
</ul>

      
      <h3 id="divFloor"><a href="https://ziglang.org/documentation/0.15.2/#toc-divFloor">@divFloor</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#divFloor">§</a></h3>

      <pre><code><span class="tok-builtin">@divFloor</span>(numerator: T, denominator: T) T</code></pre>
      <p>
      向下取整除法。向负无穷方向舍入。对于无符号整数，它与
      <code>numerator / denominator</code> 相同。调用者保证 <code>denominator != <span class="tok-number">0</span></code> 并且
              <code>!(<span class="tok-builtin">@typeInfo</span>(T) == .int <span class="tok-kw">and</span> T.is_signed <span class="tok-kw">and</span> numerator == std.math.minInt(T) <span class="tok-kw">and</span> denominator == -<span class="tok-number">1</span>)</code>。
      </p>
      <ul>
          <li><code><span class="tok-builtin">@divFloor</span>(-<span class="tok-number">5</span>, <span class="tok-number">3</span>) == -<span class="tok-number">2</span></code></li>
          <li><code>(<span class="tok-builtin">@divFloor</span>(a, b) * b) + <span class="tok-builtin">@mod</span>(a, b) == a</code></li>
      </ul>
      <p>对于返回可能错误代码的函数，请使用 <code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).math.divFloor</code>。</p>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#divTrunc">@divTrunc</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#divExact">@divExact</a></li>
</ul>

      
      <h3 id="divTrunc"><a href="https://ziglang.org/documentation/0.15.2/#toc-divTrunc">@divTrunc</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#divTrunc">§</a></h3>

      <pre><code><span class="tok-builtin">@divTrunc</span>(numerator: T, denominator: T) T</code></pre>
      <p>
      截断除法。向零方向舍入。对于无符号整数，它与
      <code>numerator / denominator</code> 相同。调用者保证 <code>denominator != <span class="tok-number">0</span></code> 并且
              <code>!(<span class="tok-builtin">@typeInfo</span>(T) == .int <span class="tok-kw">and</span> T.is_signed <span class="tok-kw">and</span> numerator == std.math.minInt(T) <span class="tok-kw">and</span> denominator == -<span class="tok-number">1</span>)</code>。
      </p>
      <ul>
          <li><code><span class="tok-builtin">@divTrunc</span>(-<span class="tok-number">5</span>, <span class="tok-number">3</span>) == -<span class="tok-number">1</span></code></li>
          <li><code>(<span class="tok-builtin">@divTrunc</span>(a, b) * b) + <span class="tok-builtin">@rem</span>(a, b) == a</code></li>
      </ul>
      <p>对于返回可能错误代码的函数，请使用 <code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).math.divTrunc</code>。</p>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#divFloor">@divFloor</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#divExact">@divExact</a></li>
</ul>

      

      <h3 id="embedFile"><a href="https://ziglang.org/documentation/0.15.2/#toc-embedFile">@embedFile</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#embedFile">§</a></h3>

      <pre><code><span class="tok-builtin">@embedFile</span>(<span class="tok-kw">comptime</span> path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<span class="tok-kw">const</span> [N:<span class="tok-number">0</span>]<span class="tok-type">u8</span></code></pre>
      <p>
      此函数返回一个编译时常量指针，指向以 null 结尾的固定大小数组，
      其长度等于 <code>path</code> 给定文件的字节数。数组的内容是文件的内容。
      这等同于具有文件内容的<a href="https://ziglang.org/documentation/0.15.2/#String-Literals-and-Unicode-Code-Point-Literals">字符串字面量</a>。
      </p>
      <p>
      <code>path</code> 是绝对路径或相对于当前文件的路径，就像 <code><span class="tok-builtin">@import</span></code> 一样。
      </p>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#import">@import</a></li>
</ul>

      

      <h3 id="enumFromInt"><a href="https://ziglang.org/documentation/0.15.2/#toc-enumFromInt">@enumFromInt</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#enumFromInt">§</a></h3>

      <pre><code><span class="tok-builtin">@enumFromInt</span>(integer: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      将整数转换为 <a href="https://ziglang.org/documentation/0.15.2/#enum">枚举</a> 值。返回类型是推断的结果类型。
      </p>
      <p>
      尝试转换在枚举中没有相应值的整数会调用
      安全检查的<a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>。
      注意，<a href="https://ziglang.org/documentation/0.15.2/#Non-exhaustive-enum">非穷尽枚举</a>对于枚举整数标签类型中的所有
      整数都有相应的值：<code>_</code> 值表示枚举标签类型中所有剩余的未命名整数。
      </p>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#intFromEnum">@intFromEnum</a></li>
</ul>

      

      <h3 id="errorFromInt"><a href="https://ziglang.org/documentation/0.15.2/#toc-errorFromInt">@errorFromInt</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#errorFromInt">§</a></h3>

      <pre><code><span class="tok-builtin">@errorFromInt</span>(value: std.meta.Int(.unsigned, <span class="tok-builtin">@bitSizeOf</span>(<span class="tok-type">anyerror</span>))) <span class="tok-type">anyerror</span></code></pre>
      <p>
      从错误的整数表示形式转换为<a href="https://ziglang.org/documentation/0.15.2/#The-Global-Error-Set">全局错误集</a>类型。
      </p>
      <p>
      通常建议避免此
      转换，因为错误的整数表示形式在源代码更改时不稳定。
      </p>
      <p>
      尝试转换不对应于任何错误的整数会导致
      安全检查的<a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>。
      </p>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#intFromError">@intFromError</a></li>
</ul>

      

      <h3 id="errorName"><a href="https://ziglang.org/documentation/0.15.2/#toc-errorName">@errorName</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#errorName">§</a></h3>

      <pre><code><span class="tok-builtin">@errorName</span>(err: <span class="tok-type">anyerror</span>) [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre>
      <p>
      此函数返回错误的字符串表示形式。
      <code><span class="tok-kw">error</span>.OutOfMem</code> 的字符串表示形式是 <code><span class="tok-str">"OutOfMem"</span></code>。
      </p>
      <p>
      如果在整个应用程序中没有对 <code><span class="tok-builtin">@errorName</span></code> 的调用，
      或者所有调用对 <code>err</code> 都有编译时已知的值，那么不会
      生成错误名称表。
      </p>
      

      <h3 id="errorReturnTrace"><a href="https://ziglang.org/documentation/0.15.2/#toc-errorReturnTrace">@errorReturnTrace</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#errorReturnTrace">§</a></h3>

      <pre><code><span class="tok-builtin">@errorReturnTrace</span>() ?*builtin.StackTrace</code></pre>
      <p>
      如果二进制文件构建时启用了错误返回跟踪，并且在
      调用具有错误或错误联合返回类型的函数的函数中调用此函数，则返回
      堆栈跟踪对象。否则返回 <a href="https://ziglang.org/documentation/0.15.2/#null">null</a>。
      </p>
      

      <h3 id="errorCast"><a href="https://ziglang.org/documentation/0.15.2/#toc-errorCast">@errorCast</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#errorCast">§</a></h3>

      <pre><code><span class="tok-builtin">@errorCast</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      将错误集或错误联合值从一个错误集转换为另一个错误集。返回类型是
			推断的结果类型。尝试转换不在目标错误
			集中的错误会导致安全检查的<a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>。
      </p>
      

      <h3 id="export"><a href="https://ziglang.org/documentation/0.15.2/#toc-export">@export</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#export">§</a></h3>

      <pre><code><span class="tok-builtin">@export</span>(<span class="tok-kw">comptime</span> ptr: *<span class="tok-kw">const</span> <span class="tok-type">anyopaque</span>, <span class="tok-kw">comptime</span> options: std.builtin.ExportOptions) <span class="tok-type">void</span></code></pre>
      <p>在输出目标文件中创建一个符号，该符号指向 <code>ptr</code> 的目标。</p>
      <p><code>ptr</code> 必须指向全局变量或编译时已知的常量。</p>
      <p>
      可以从 <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a> 块调用此内建函数以有条件地导出符号。
      当 <code>ptr</code> 指向具有 C 调用约定的函数并且
      <code>options.linkage</code> 为 <code>.strong</code> 时，这等同于
      在函数上使用的 <code><span class="tok-kw">export</span></code> 关键字：
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">export_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-builtin">@export</span>(&amp;internalName, .{ .name = <span class="tok-str">"foo"</span>, .linkage = .strong });
}

<span class="tok-kw">fn</span> <span class="tok-fn">internalName</span>() <span class="tok-kw">callconv</span>(.c) <span class="tok-type">void</span> {}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-obj export_builtin.zig</kbd>
</samp></pre></figure>

      <p>这等同于：</p>
      <figure><figcaption class="zig-cap"><cite class="file">export_builtin_equivalent_code.zig</cite></figcaption><pre><code><span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">void</span> {}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-obj export_builtin_equivalent_code.zig</kbd>
</samp></pre></figure>

      <p>注意，即使使用 <code><span class="tok-kw">export</span></code>，也可以使用 <code>@"foo"</code> 语法作为
      <a href="https://ziglang.org/documentation/0.15.2/#Identifiers">标识符</a>来为符号名称选择任何字符串：</p>
      <figure><figcaption class="zig-cap"><cite class="file">export_any_symbol_name.zig</cite></figcaption><pre><code><span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">@"A function name that is a complete sentence."</span>() <span class="tok-type">void</span> {}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-obj export_any_symbol_name.zig</kbd>
</samp></pre></figure>

      <p>
      查看生成的目标文件时，您可以看到符号是逐字使用的：
      </p>
      <pre><code>00000000000001f0 T A function name that is a complete sentence.</code></pre>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Exporting-a-C-Library">导出 C 库</a></li>
</ul>

      

      <h3 id="extern"><a href="https://ziglang.org/documentation/0.15.2/#toc-extern">@extern</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#extern">§</a></h3>

      <pre><code><span class="tok-builtin">@extern</span>(T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> options: std.builtin.ExternOptions) T</code></pre>
      <p>
      在输出目标文件中创建对外部符号的引用。
      T 必须是指针类型。
      </p>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#export">@export</a></li>
</ul>

      

      <h3 id="field"><a href="https://ziglang.org/documentation/0.15.2/#toc-field">@field</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#field">§</a></h3>

      <pre><code><span class="tok-builtin">@field</span>(lhs: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) (field)</code></pre>
      <p>通过编译时字符串执行字段访问。对字段和声明都有效。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_field_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">const</span> Point = <span class="tok-kw">struct</span> {
    x: <span class="tok-type">u32</span>,
    y: <span class="tok-type">u32</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">var</span> z: <span class="tok-type">u32</span> = <span class="tok-number">1</span>;
};

<span class="tok-kw">test</span> <span class="tok-str">"field access by string"</span> {
    <span class="tok-kw">const</span> expect = std.testing.expect;
    <span class="tok-kw">var</span> p = Point{ .x = <span class="tok-number">0</span>, .y = <span class="tok-number">0</span> };

    <span class="tok-builtin">@field</span>(p, <span class="tok-str">"x"</span>) = <span class="tok-number">4</span>;
    <span class="tok-builtin">@field</span>(p, <span class="tok-str">"y"</span>) = <span class="tok-builtin">@field</span>(p, <span class="tok-str">"x"</span>) + <span class="tok-number">1</span>;

    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@field</span>(p, <span class="tok-str">"x"</span>) == <span class="tok-number">4</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@field</span>(p, <span class="tok-str">"y"</span>) == <span class="tok-number">5</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">"decl access by string"</span> {
    <span class="tok-kw">const</span> expect = std.testing.expect;

    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@field</span>(Point, <span class="tok-str">"z"</span>) == <span class="tok-number">1</span>);

    <span class="tok-builtin">@field</span>(Point, <span class="tok-str">"z"</span>) = <span class="tok-number">2</span>;
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@field</span>(Point, <span class="tok-str">"z"</span>) == <span class="tok-number">2</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_field_builtin.zig</kbd>
1/2 test_field_builtin.test.field access by string...OK
2/2 test_field_builtin.test.decl access by string...OK
All 2 tests passed.
</samp></pre></figure>


      

      <h3 id="fieldParentPtr"><a href="https://ziglang.org/documentation/0.15.2/#toc-fieldParentPtr">@fieldParentPtr</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#fieldParentPtr">§</a></h3>

      <pre><code><span class="tok-builtin">@fieldParentPtr</span>(<span class="tok-kw">comptime</span> field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, field_ptr: *T) <span class="tok-kw">anytype</span></code></pre>
      <p>
      给定指向结构或联合字段的指针，返回指向包含该字段的结构或联合的指针。
      返回类型（指向相关父结构或联合的指针）是推断的结果类型。
      </p>
      <p>
      如果 <code>field_ptr</code> 不指向结果类型实例的 <code>field_name</code> 字段，
      并且结果类型具有未定义的布局，则调用未检查的<a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>。
      </p>
      

      <h3 id="FieldType"><a href="https://ziglang.org/documentation/0.15.2/#toc-FieldType">@FieldType</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#FieldType">§</a></h3>

      <pre><code><span class="tok-builtin">@FieldType</span>(<span class="tok-kw">comptime</span> Type: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">type</span></code></pre>
      <p>
      给定类型和其字段之一的名称，返回该字段的类型。
      </p>
      

      <h3 id="floatCast"><a href="https://ziglang.org/documentation/0.15.2/#toc-floatCast">@floatCast</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#floatCast">§</a></h3>

      <pre><code><span class="tok-builtin">@floatCast</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      从一种浮点类型转换为另一种浮点类型。此转换是安全的，但可能导致
      数值失去精度。返回类型是推断的结果类型。
      </p>
      

      <h3 id="floatFromInt"><a href="https://ziglang.org/documentation/0.15.2/#toc-floatFromInt">@floatFromInt</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#floatFromInt">§</a></h3>

      <pre><code><span class="tok-builtin">@floatFromInt</span>(int: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      将整数转换为最接近的浮点表示形式。返回类型是推断的结果类型。
			要进行相反的转换，请使用 <a href="https://ziglang.org/documentation/0.15.2/#intFromFloat">@intFromFloat</a>。此操作对于
      所有整数类型的所有值都是合法的。
      </p>
      

      <h3 id="frameAddress"><a href="https://ziglang.org/documentation/0.15.2/#toc-frameAddress">@frameAddress</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#frameAddress">§</a></h3>

      <pre><code><span class="tok-builtin">@frameAddress</span>() <span class="tok-type">usize</span></code></pre>
      <p>
      此函数返回当前堆栈帧的基指针。
      </p>
      <p>
      其含义是特定于目标的，并且在所有
      平台上都不一致。由于积极的优化，
      在发布模式下帧地址可能不可用。
      </p>
      <p>
      此函数仅在函数作用域内有效。
      </p>
      

      <h3 id="hasDecl"><a href="https://ziglang.org/documentation/0.15.2/#toc-hasDecl">@hasDecl</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#hasDecl">§</a></h3>

      <pre><code><span class="tok-builtin">@hasDecl</span>(<span class="tok-kw">comptime</span> Container: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span></code></pre>
      <p>
      返回<a href="https://ziglang.org/documentation/0.15.2/#Containers">容器</a>是否具有与
      <code>name</code> 匹配的声明。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_hasDecl_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Foo = <span class="tok-kw">struct</span> {
    nope: <span class="tok-type">i32</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">var</span> blah = <span class="tok-str">"xxx"</span>;
    <span class="tok-kw">const</span> hi = <span class="tok-number">1</span>;
};

<span class="tok-kw">test</span> <span class="tok-str">"@hasDecl"</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@hasDecl</span>(Foo, <span class="tok-str">"blah"</span>));

    <span class="tok-comment">// 即使 `hi` 是私有的，@hasDecl 也会返回 true，因为此测试</span>
    <span class="tok-comment">// 与 Foo 在同一个文件作用域中。如果 Foo 在</span>
    <span class="tok-comment">// 不同的文件中声明，它将返回 false。</span>
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@hasDecl</span>(Foo, <span class="tok-str">"hi"</span>));

    <span class="tok-comment">// @hasDecl 用于声明；不用于字段。</span>
    <span class="tok-kw">try</span> expect(!<span class="tok-builtin">@hasDecl</span>(Foo, <span class="tok-str">"nope"</span>));
    <span class="tok-kw">try</span> expect(!<span class="tok-builtin">@hasDecl</span>(Foo, <span class="tok-str">"nope1234"</span>));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_hasDecl_builtin.zig</kbd>
1/1 test_hasDecl_builtin.test.@hasDecl...OK
All 1 tests passed.
</samp></pre></figure>

      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#hasField">@hasField</a></li>
</ul>

      

      <h3 id="hasField"><a href="https://ziglang.org/documentation/0.15.2/#toc-hasField">@hasField</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#hasField">§</a></h3>

      <pre><code><span class="tok-builtin">@hasField</span>(<span class="tok-kw">comptime</span> Container: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span></code></pre>
      <p>返回结构、联合或枚举的字段名是否存在。</p>
      <p>
      结果是编译时常量。
      </p>
      <p>
      它不包括函数、变量或常量。
      </p>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#hasDecl">@hasDecl</a></li>
</ul>

      

      <h3 id="import"><a href="https://ziglang.org/documentation/0.15.2/#toc-import">@import</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#import">§</a></h3>

      <pre><code><span class="tok-builtin">@import</span>(<span class="tok-kw">comptime</span> target: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>导入 <code>target</code> 处的文件，如果尚未添加，则将其添加到编译中。<code>target</code> 
      可以是从包含 <code><span class="tok-builtin">@import</span></code> 调用的文件到另一个文件的相对路径，
      也可以是<a href="https://ziglang.org/documentation/0.15.2/#Compilation-Model">模块</a>的名称，导入指向该模块的根源文件。
      无论哪种方式，文件路径都必须以 <code>.zig</code>（对于 Zig 源文件）或 <code>.zon</code>（对于 ZON 数据文件）结尾。</p>
      <p>如果 <code>target</code> 指向 Zig 源文件，则 <code><span class="tok-builtin">@import</span></code> 返回
      该文件的<a href="https://ziglang.org/documentation/0.15.2/#Source-File-Structs">对应结构类型</a>，本质上就好像内建调用被
      <code><span class="tok-kw">struct</span> { FILE_CONTENTS }</code> 替换了一样。返回类型是 <code><span class="tok-type">type</span></code>。</p>
      <p>如果 <code>target</code> 指向 ZON 文件，则 <code><span class="tok-builtin">@import</span></code> 返回
      文件中字面量的值。如果有推断的<a href="https://ziglang.org/documentation/0.15.2/#Result-Types">结果类型</a>，
      则返回类型是该类型，并且 ZON 字面量被解释为该类型（<a href="https://ziglang.org/documentation/0.15.2/#Result-Types">结果类型</a>通过
      ZON 表达式传播）。否则，返回类型是等效 Zig 表达式的类型，本质上就好像
      内建调用被 ZON 文件内容替换了一样。</p>
      <p>以下模块始终可用于导入：</p>
      <ul>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>)</code> - Zig 标准库</li>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">"builtin"</span>)</code> - 特定于目标的信息。命令 <code>zig build-exe --show-builtin</code> 将源代码输出到 stdout 以供参考。</li>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">"root"</span>)</code> - 根模块的别名。在典型的项目结构中，这意味着它指向 <code>src/main.zig</code>。
          </li>
      </ul>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Compile-Variables">编译变量</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#embedFile">@embedFile</a></li>
</ul>

      

      <h3 id="inComptime"><a href="https://ziglang.org/documentation/0.15.2/#toc-inComptime">@inComptime</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#inComptime">§</a></h3>

      <pre><code><span class="tok-builtin">@inComptime</span>() <span class="tok-type">bool</span></code></pre>
      <p>
      返回内建函数是否在 <code><span class="tok-kw">comptime</span></code> 上下文中运行。结果是编译时常量。
      </p>
      <p>
      这可用于提供函数的替代编译时友好实现。例如，它不应该用于从编译时评估中排除某些函数。
      </p>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a></li>
</ul>

      

      <h3 id="intCast"><a href="https://ziglang.org/documentation/0.15.2/#toc-intCast">@intCast</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#intCast">§</a></h3>

      <pre><code><span class="tok-builtin">@intCast</span>(int: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      将整数转换为另一个整数，同时保持相同的数值。
			返回类型是推断的结果类型。
      尝试转换超出目标类型范围的数字会导致
      安全检查的<a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_intCast_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">"integer cast panic"</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u16</span> = <span class="tok-number">0xabcd</span>; <span class="tok-comment">// runtime-known</span>
    _ = &amp;a;
    <span class="tok-kw">const</span> b: <span class="tok-type">u8</span> = <span class="tok-builtin">@intCast</span>(a);
    _ = b;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_intCast_builtin.zig</kbd>
1/1 test_intCast_builtin.test.integer cast panic...thread 2898212 panic: integer does not fit in destination type
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_intCast_builtin.zig:4:19</span>: <span class="sgr-2m">0x102c020 in test.integer cast panic (test_intCast_builtin.zig)</span>
    const b: u8 = @intCast(a);
                  <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:218:25</span>: <span class="sgr-2m">0x115cb50 in mainTerminal (test_runner.zig)</span>
        if (test_fn.func()) |_| {
                        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:66:28</span>: <span class="sgr-2m">0x1155d71 in main (test_runner.zig)</span>
        return mainTerminal();
                           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x114fb0d in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x114f3a1 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
error: the following test command crashed:
/home/andy/dev/zig/.zig-cache/o/056fc3b607934a9389a99437800346de/test --seed=0x9fcd81fa
</samp></pre></figure>

      <p>
      要截断超出目标类型范围的数字的有效位，请使用 <a href="https://ziglang.org/documentation/0.15.2/#truncate">@truncate</a>。
      </p>
      <p>
      如果 <code>T</code> 是 <code><span class="tok-type">comptime_int</span></code>，
      那么这在语义上等同于<a href="https://ziglang.org/documentation/0.15.2/#Type-Coercion">类型强制转换</a>。
      </p>
      

      <h3 id="intFromBool"><a href="https://ziglang.org/documentation/0.15.2/#toc-intFromBool">@intFromBool</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#intFromBool">§</a></h3>

      <pre><code><span class="tok-builtin">@intFromBool</span>(value: <span class="tok-type">bool</span>) <span class="tok-type">u1</span></code></pre>
      <p>
      将 <code><span class="tok-null">true</span></code> 转换为 <code><span class="tok-builtin">@as</span>(<span class="tok-type">u1</span>, <span class="tok-number">1</span>)</code>，将 <code><span class="tok-null">false</span></code> 转换为
                  <code><span class="tok-builtin">@as</span>(<span class="tok-type">u1</span>, <span class="tok-number">0</span>)</code>。
      </p>
      

      <h3 id="intFromEnum"><a href="https://ziglang.org/documentation/0.15.2/#toc-intFromEnum">@intFromEnum</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#intFromEnum">§</a></h3>

      <pre><code><span class="tok-builtin">@intFromEnum</span>(enum_or_tagged_union: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      将枚举值转换为其整数标签类型。当传递标记联合时，
      标签值用作枚举值。
      </p>
      <p>
      如果只有一个可能的枚举值，结果是在 <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a> 时已知的 <code><span class="tok-type">comptime_int</span></code>。
      </p>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#enumFromInt">@enumFromInt</a></li>
</ul>

      

      <h3 id="intFromError"><a href="https://ziglang.org/documentation/0.15.2/#toc-intFromError">@intFromError</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#intFromError">§</a></h3>

      <pre><code><span class="tok-builtin">@intFromError</span>(err: <span class="tok-kw">anytype</span>) std.meta.Int(.unsigned, <span class="tok-builtin">@bitSizeOf</span>(<span class="tok-type">anyerror</span>))</code></pre>
      <p>
      支持以下类型：
      </p>
      <ul>
          <li><a href="https://ziglang.org/documentation/0.15.2/#The-Global-Error-Set">全局错误集</a></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#Error-Set-Type">错误集类型</a></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#Error-Union-Type">错误联合类型</a></li>
      </ul>
      <p>
      将错误转换为错误的整数表示形式。
      </p>
      <p>
      通常建议避免此
      转换，因为错误的整数表示形式在源代码更改时不稳定。
      </p>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#errorFromInt">@errorFromInt</a></li>
</ul>

      

      <h3 id="intFromFloat"><a href="https://ziglang.org/documentation/0.15.2/#toc-intFromFloat">@intFromFloat</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#intFromFloat">§</a></h3>

      <pre><code><span class="tok-builtin">@intFromFloat</span>(float: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      将浮点数的整数部分转换为推断的结果类型。
      </p>
      <p>
      如果浮点数的整数部分无法适应目标类型，
      它会调用安全检查的<a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>。
      </p>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#floatFromInt">@floatFromInt</a></li>
</ul>

      

      <h3 id="intFromPtr"><a href="https://ziglang.org/documentation/0.15.2/#toc-intFromPtr">@intFromPtr</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#intFromPtr">§</a></h3>

      <pre><code><span class="tok-builtin">@intFromPtr</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-type">usize</span></code></pre>
      <p>
      将 <code>value</code> 转换为指针地址的 <code><span class="tok-type">usize</span></code>。
      <code>value</code> 可以是 <code>*T</code> 或 <code>?*T</code>。
      </p>
      <p>要进行相反的转换，请使用 <a href="https://ziglang.org/documentation/0.15.2/#ptrFromInt">@ptrFromInt</a></p>
      

      <h3 id="max"><a href="https://ziglang.org/documentation/0.15.2/#toc-max">@max</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#max">§</a></h3>

      <pre><code><span class="tok-builtin">@max</span>(...) T</code></pre>
      <p>
      接受两个或更多参数并返回包含的最大值（最大值）。此内建函数接受整数、浮点数以及两者的向量。在后一种情况下，操作按元素执行。
      </p>
      <p>
      NaN 的处理如下：返回包含的最大非 NaN 值。如果所有操作数都是 NaN，则返回 NaN。
      </p>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#min">@min</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Vectors">向量</a></li>
</ul>

      

      <h3 id="memcpy"><a href="https://ziglang.org/documentation/0.15.2/#toc-memcpy">@memcpy</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#memcpy">§</a></h3>

      <pre><code><span class="tok-builtin">@memcpy</span>(<span class="tok-kw">noalias</span> dest, <span class="tok-kw">noalias</span> source) <span class="tok-type">void</span></code></pre>
      <p>此函数将字节从一个内存区域复制到另一个内存区域。</p>
      <p><code>dest</code> 必须是可变切片、指向数组的可变指针或
        可变多项<a href="https://ziglang.org/documentation/0.15.2/#Pointers">指针</a>。它可以具有任何
        对齐方式，并且可以具有任何元素类型。</p>
      <p><code>source</code> 必须是切片、指向
        数组的指针或多项<a href="https://ziglang.org/documentation/0.15.2/#Pointers">指针</a>。它可以
        具有任何对齐方式，并且可以具有任何元素类型。</p>
      <p><code>source</code> 元素类型必须与 <code>dest</code> 元素类型具有相同的
        内存表示形式。</p>
      <p>与 <a href="https://ziglang.org/documentation/0.15.2/#for">for</a> 循环类似，<code>source</code> 和
        <code>dest</code> 中至少有一个必须提供长度，如果提供两个长度，
        它们必须相等。</p>
      <p>最后，两个内存区域不能重叠。</p>
      

      <h3 id="memset"><a href="https://ziglang.org/documentation/0.15.2/#toc-memset">@memset</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#memset">§</a></h3>

      <pre><code><span class="tok-builtin">@memset</span>(dest, elem) <span class="tok-type">void</span></code></pre>
      <p>此函数将内存区域的所有元素设置为 <code>elem</code>。</p>
      <p><code>dest</code> 必须是可变切片或指向数组的可变指针。
      它可以具有任何对齐方式，并且可以具有任何元素类型。</p>
      <p><code>elem</code> 强制转换为 <code>dest</code> 的元素类型。</p>
      <p>对于安全地从内存中清除敏感内容，您应该使用
      <code>std.crypto.secureZero</code></p>
      

      <h3 id="memmove"><a href="https://ziglang.org/documentation/0.15.2/#toc-memmove">@memmove</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#memmove">§</a></h3>

      <pre><code><span class="tok-builtin">@memmove</span>(dest, source) <span class="tok-type">void</span></code></pre>
      <p>此函数将字节从一个内存区域复制到另一个内存区域，但与
      <a href="https://ziglang.org/documentation/0.15.2/#memcpy">@memcpy</a> 不同，区域可以重叠。</p>
      <p><code>dest</code> 必须是可变切片、指向数组的可变指针或
        可变多项<a href="https://ziglang.org/documentation/0.15.2/#Pointers">指针</a>。它可以具有任何
        对齐方式，并且可以具有任何元素类型。</p>
      <p><code>source</code> 必须是切片、指向
        数组的指针或多项<a href="https://ziglang.org/documentation/0.15.2/#Pointers">指针</a>。它可以
        具有任何对齐方式，并且可以具有任何元素类型。</p>
      <p><code>source</code> 元素类型必须与 <code>dest</code> 元素类型具有相同的
        内存表示形式。</p>
      <p>与 <a href="https://ziglang.org/documentation/0.15.2/#for">for</a> 循环类似，<code>source</code> 和
        <code>dest</code> 中至少有一个必须提供长度，如果提供两个长度，
        它们必须相等。</p>
      

      <h3 id="min"><a href="https://ziglang.org/documentation/0.15.2/#toc-min">@min</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#min">§</a></h3>

      <pre><code><span class="tok-builtin">@min</span>(...) T</code></pre>
      <p>
      接受两个或更多参数并返回包含的最小值（最小值）。此内建函数接受整数、浮点数以及两者的向量。在后一种情况下，操作按元素执行。
      </p>
      <p>
      NaN 的处理如下：返回包含的最小非 NaN 值。如果所有操作数都是 NaN，则返回 NaN。
      </p>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#max">@max</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Vectors">向量</a></li>
</ul>

      

      <h3 id="wasmMemorySize"><a href="https://ziglang.org/documentation/0.15.2/#toc-wasmMemorySize">@wasmMemorySize</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#wasmMemorySize">§</a></h3>

      <pre><code><span class="tok-builtin">@wasmMemorySize</span>(index: <span class="tok-type">u32</span>) <span class="tok-type">usize</span></code></pre>
      <p>
      此函数以 Wasm 页面为单位返回由 <code>index</code> 标识的 Wasm 内存的大小，
      作为无符号值。注意每个 Wasm 页面为 64KB。
      </p>
      <p>
      此函数是低级内在函数，没有安全机制，通常对针对 Wasm 的分配器
      设计者有用。因此，除非您从头开始编写新的分配器，否则应使用
      类似 <code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).heap.WasmPageAllocator</code> 的东西。
      </p>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#wasmMemoryGrow">@wasmMemoryGrow</a></li>
</ul>

      

      <h3 id="wasmMemoryGrow"><a href="https://ziglang.org/documentation/0.15.2/#toc-wasmMemoryGrow">@wasmMemoryGrow</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#wasmMemoryGrow">§</a></h3>

      <pre><code><span class="tok-builtin">@wasmMemoryGrow</span>(index: <span class="tok-type">u32</span>, delta: <span class="tok-type">usize</span>) <span class="tok-type">isize</span></code></pre>
      <p>
      此函数将由 <code>index</code> 标识的 Wasm 内存的大小增加
      <code>delta</code>，以无符号 Wasm 页数为单位。注意每个 Wasm 页面
      为 64KB。成功时，返回之前的内存大小；失败时，如果分配失败，
      返回 -1。
      </p>
      <p>
      此函数是低级内在函数，没有安全机制，通常对针对 Wasm 的分配器
      设计者有用。因此，除非您从头开始编写新的分配器，否则应使用
      类似 <code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).heap.WasmPageAllocator</code> 的东西。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_wasmMemoryGrow_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> native_arch = <span class="tok-builtin">@import</span>(<span class="tok-str">"builtin"</span>).target.cpu.arch;
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"@wasmMemoryGrow"</span> {
    <span class="tok-kw">if</span> (native_arch != .wasm32) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">const</span> prev = <span class="tok-builtin">@wasmMemorySize</span>(<span class="tok-number">0</span>);
    <span class="tok-kw">try</span> expect(prev == <span class="tok-builtin">@wasmMemoryGrow</span>(<span class="tok-number">0</span>, <span class="tok-number">1</span>));
    <span class="tok-kw">try</span> expect(prev + <span class="tok-number">1</span> == <span class="tok-builtin">@wasmMemorySize</span>(<span class="tok-number">0</span>));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_wasmMemoryGrow_builtin.zig</kbd>
1/1 test_wasmMemoryGrow_builtin.test.@wasmMemoryGrow...SKIP
0 passed; 1 skipped; 0 failed.
</samp></pre></figure>

      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#wasmMemorySize">@wasmMemorySize</a></li>
</ul>

      

      <h3 id="mod"><a href="https://ziglang.org/documentation/0.15.2/#toc-mod">@mod</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#mod">§</a></h3>

      <pre><code><span class="tok-builtin">@mod</span>(numerator: T, denominator: T) T</code></pre>
      <p>
      取模除法。对于无符号整数，这与
      <code>numerator % denominator</code> 相同。调用者保证 <code>denominator != <span class="tok-number">0</span></code>，否则
      当启用运行时安全检查时，操作将导致<a href="https://ziglang.org/documentation/0.15.2/#Remainder-Division-by-Zero">余数除零</a>。
      </p>
      <ul>
          <li><code><span class="tok-builtin">@mod</span>(-<span class="tok-number">5</span>, <span class="tok-number">3</span>) == <span class="tok-number">1</span></code></li>
          <li><code>(<span class="tok-builtin">@divFloor</span>(a, b) * b) + <span class="tok-builtin">@mod</span>(a, b) == a</code></li>
      </ul>
      <p>对于返回错误代码的函数，请参阅 <code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).math.mod</code>。</p>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#rem">@rem</a></li>
</ul>

      

      <h3 id="mulWithOverflow"><a href="https://ziglang.org/documentation/0.15.2/#toc-mulWithOverflow">@mulWithOverflow</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#mulWithOverflow">§</a></h3>

      <pre><code><span class="tok-builtin">@mulWithOverflow</span>(a: <span class="tok-kw">anytype</span>, b: <span class="tok-kw">anytype</span>) <span class="tok-kw">struct</span> { <span class="tok-builtin">@TypeOf</span>(a, b), <span class="tok-type">u1</span> }</code></pre>
      <p>
      执行 <code>a * b</code> 并返回一个包含结果和可能的溢出位的元组。
      </p>
      

      <h3 id="panic"><a href="https://ziglang.org/documentation/0.15.2/#toc-panic">@panic</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#panic">§</a></h3>

      <pre><code><span class="tok-builtin">@panic</span>(message: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">noreturn</span></code></pre>
      <p>
      调用 panic 处理函数。默认情况下，panic 处理函数
      调用在根源文件中公开的 <code>panic</code> 函数，或者
      如果没有指定，则调用 <code>std/builtin.zig</code> 中的 <code>std.builtin.default_panic</code>
      函数。
      </p>
      <p>通常使用 <code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.panic</code> 更好。
          但是，<code><span class="tok-builtin">@panic</span></code> 在以下 2 种场景中很有用：
      </p>
      <ul>
        <li>从库代码中，如果程序员在根源文件中公开了 panic 函数，则调用该函数。</li>
        <li>在混合 C 和 Zig 代码时，跨多个 .o 文件调用规范的 panic 实现。</li>
      </ul>
      <p>另请参阅：</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Panic-Handler">Panic 处理程序</a></li>
</ul>

      

      <h3 id="popCount"><a href="https://ziglang.org/documentation/0.15.2/#toc-popCount">@popCount</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#popCount">§</a></h3>
<!-- ====== END CHUNK 10: new_10.html ====== -->

<!-- ====== BEGIN CHUNK 11: new_11.html ====== -->
<pre><code><span class="tok-builtin">@popCount</span>(operand: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p><code><span class="tok-builtin">@TypeOf</span>(operand)</code> 必须是一个整数类型。</p>
      <p><code>operand</code> 可以是一个 <a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a> 或 <a href="https://ziglang.org/documentation/0.15.2/#Vectors">向量</a>。</p>
      <p>
      计算整数中设置的位数 - "种群计数"。
      </p>
      <p>
      返回类型是无符号整数或无符号整数向量,其位数是可以表示该整数类型的位计数的最小位数。
      </p>
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#ctz">@ctz</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#clz">@clz</a></li>
</ul>

      

      <h3 id="prefetch"><a href="https://ziglang.org/documentation/0.15.2/#toc-prefetch">@prefetch</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#prefetch">§</a></h3>

      <pre><code><span class="tok-builtin">@prefetch</span>(ptr: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> options: PrefetchOptions) <span class="tok-type">void</span></code></pre>
      <p>
      这个内建函数告诉编译器在目标 CPU 支持的情况下发出预取指令。如果目标 CPU 不支持请求的预取指令,这个内建函数是一个空操作。这个函数对程序的行为没有影响,只影响性能特性。
      </p>
      <p>
      <code>ptr</code> 参数可以是任何指针类型,并确定要预取的内存地址。这个函数不会解引用指针,向这个函数传递一个指向无效内存的指针是完全合法的,不会导致非法行为。
      </p>
      <p><code>PrefetchOptions</code> 可以通过 <code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).builtin.PrefetchOptions</code> 找到。</p>
      

      <h3 id="ptrCast"><a href="https://ziglang.org/documentation/0.15.2/#toc-ptrCast">@ptrCast</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#ptrCast">§</a></h3>

      <pre><code><span class="tok-builtin">@ptrCast</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      将一种类型的指针转换为另一种类型的指针。返回类型是推断的结果类型。
      </p>
      <p>
      允许使用<a href="https://ziglang.org/documentation/0.15.2/#Optional-Pointers">可选指针</a>。将 <a href="https://ziglang.org/documentation/0.15.2/#null">null</a> 的可选指针转换为非可选指针会调用安全检查的<a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>。
      </p>
      <p>
      <code><span class="tok-builtin">@ptrCast</span></code> 不能用于:
      </p>
      <ul>
          <li>移除 <code><span class="tok-kw">const</span></code> 限定符,使用 <a href="https://ziglang.org/documentation/0.15.2/#constCast">@constCast</a>。</li>
          <li>移除 <code><span class="tok-kw">volatile</span></code> 限定符,使用 <a href="https://ziglang.org/documentation/0.15.2/#volatileCast">@volatileCast</a>。</li>
          <li>更改指针地址空间,使用 <a href="https://ziglang.org/documentation/0.15.2/#addrSpaceCast">@addrSpaceCast</a>。</li>
          <li>增加指针对齐,使用 <a href="https://ziglang.org/documentation/0.15.2/#alignCast">@alignCast</a>。</li>
          <li>将非切片指针转换为切片,使用切片语法 <code>ptr[start..end]</code>。</li>
      </ul>
      

      <h3 id="ptrFromInt"><a href="https://ziglang.org/documentation/0.15.2/#toc-ptrFromInt">@ptrFromInt</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#ptrFromInt">§</a></h3>

      <pre><code><span class="tok-builtin">@ptrFromInt</span>(address: <span class="tok-type">usize</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      将整数转换为<a href="https://ziglang.org/documentation/0.15.2/#Pointers">指针</a>。返回类型是推断的结果类型。
			要进行反向转换,使用 <a href="https://ziglang.org/documentation/0.15.2/#intFromPtr">@intFromPtr</a>。将地址 0 转换为非<a href="https://ziglang.org/documentation/0.15.2/#Optional-Pointers">可选</a>且没有 <code><span class="tok-kw">allowzero</span></code> 属性的目标类型时,在启用运行时安全检查时将导致<a href="https://ziglang.org/documentation/0.15.2/#Pointer-Cast-Invalid-Null">指针转换无效空值</a>恐慌。
      </p>
      <p>
      如果目标指针类型不允许地址零且 <code>address</code> 为零,这会调用安全检查的<a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>。
      </p>
      

      <h3 id="rem"><a href="https://ziglang.org/documentation/0.15.2/#toc-rem">@rem</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#rem">§</a></h3>

      <pre><code><span class="tok-builtin">@rem</span>(numerator: T, denominator: T) T</code></pre>
      <p>
      取余除法。对于无符号整数,这与 <code>numerator % denominator</code> 相同。调用者保证 <code>denominator != <span class="tok-number">0</span></code>,否则在启用运行时安全检查时,该操作将导致<a href="https://ziglang.org/documentation/0.15.2/#Remainder-Division-by-Zero">取余除以零</a>。
      </p>
      <ul>
          <li><code><span class="tok-builtin">@rem</span>(-<span class="tok-number">5</span>, <span class="tok-number">3</span>) == -<span class="tok-number">2</span></code></li>
          <li><code>(<span class="tok-builtin">@divTrunc</span>(a, b) * b) + <span class="tok-builtin">@rem</span>(a, b) == a</code></li>
      </ul>
      <p>对于返回错误代码的函数,参见 <code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).math.rem</code>。</p>
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#mod">@mod</a></li>
</ul>

      

      <h3 id="returnAddress"><a href="https://ziglang.org/documentation/0.15.2/#toc-returnAddress">@returnAddress</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#returnAddress">§</a></h3>

      <pre><code><span class="tok-builtin">@returnAddress</span>() <span class="tok-type">usize</span></code></pre>
      <p>
      此函数返回当前函数返回时将执行的下一条机器代码指令的地址。
      </p>
      <p>
      这样做的含义是特定于目标的,并且在所有平台上并不一致。
      </p>
      <p>
      此函数仅在函数作用域内有效。如果函数被内联到调用函数中,返回的地址将应用于调用函数。
      </p>
      

      <h3 id="select"><a href="https://ziglang.org/documentation/0.15.2/#toc-select">@select</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#select">§</a></h3>

      <pre><code><span class="tok-builtin">@select</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, pred: <span class="tok-builtin">@Vector</span>(len, <span class="tok-type">bool</span>), a: <span class="tok-builtin">@Vector</span>(len, T), b: <span class="tok-builtin">@Vector</span>(len, T)) <span class="tok-builtin">@Vector</span>(len, T)</code></pre>
      <p>
      根据 <code>pred</code> 从 <code>a</code> 或 <code>b</code> 按元素选择值。如果 <code>pred[i]</code> 为 <code><span class="tok-null">true</span></code>,则结果中的相应元素将是 <code>a[i]</code>,否则为 <code>b[i]</code>。
      </p>
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Vectors">向量</a></li>
</ul>

      

      <h3 id="setEvalBranchQuota"><a href="https://ziglang.org/documentation/0.15.2/#toc-setEvalBranchQuota">@setEvalBranchQuota</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#setEvalBranchQuota">§</a></h3>

      <pre><code><span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-kw">comptime</span> new_quota: <span class="tok-type">u32</span>) <span class="tok-type">void</span></code></pre>
      <p>
      增加编译时代码执行在放弃并产生编译错误之前可以使用的最大向后分支数。
      </p>
      <p>
      如果 <code>new_quota</code> 小于默认配额(<code><span class="tok-number">1000</span></code>)或先前明确设置的配额,它将被忽略。
      </p>
      <p>
      示例:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_without_setEvalBranchQuota_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">"foo"</span> {
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">var</span> i = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (i &lt; <span class="tok-number">1001</span>) : (i += <span class="tok-number">1</span>) {}
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_without_setEvalBranchQuota_builtin.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_without_setEvalBranchQuota_builtin.zig:4:9: </span><span class="sgr-31m">error: </span><span class="sgr-1m">evaluation exceeded 1000 backwards branches
</span>        while (i &lt; 1001) : (i += 1) {}
        <span class="sgr-32m">^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_without_setEvalBranchQuota_builtin.zig:4:9: </span><span class="sgr-36m">note: </span><span class="sgr-1m">use @setEvalBranchQuota() to raise the branch limit from 1000
</span>
</samp></pre></figure>

      <p>现在我们使用 <code><span class="tok-builtin">@setEvalBranchQuota</span></code>:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_setEvalBranchQuota_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">"foo"</span> {
    <span class="tok-kw">comptime</span> {
        <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">1001</span>);
        <span class="tok-kw">var</span> i = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (i &lt; <span class="tok-number">1001</span>) : (i += <span class="tok-number">1</span>) {}
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_setEvalBranchQuota_builtin.zig</kbd>
1/1 test_setEvalBranchQuota_builtin.test.foo...OK
All 1 tests passed.
</samp></pre></figure>


      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a></li>
</ul>

      

      <h3 id="setFloatMode"><a href="https://ziglang.org/documentation/0.15.2/#toc-setFloatMode">@setFloatMode</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#setFloatMode">§</a></h3>

      <pre><code><span class="tok-builtin">@setFloatMode</span>(<span class="tok-kw">comptime</span> mode: FloatMode) <span class="tok-type">void</span></code></pre>
      <p>更改当前作用域关于如何定义浮点运算的规则。</p>
      <ul>
        <li>
            <code>Strict</code>(默认) - 浮点运算遵循严格的 IEEE 合规性。
        </li>
        <li>
            <code>Optimized</code> - 浮点运算可能执行以下所有操作:
          <ul>
            <li>假设参数和结果不是 NaN。优化需要保留对 NaN 的合法行为,但结果的值是未定义的。</li>
            <li>假设参数和结果不是 +/-Inf。优化需要保留对 +/-Inf 的合法行为,但结果的值是未定义的。</li>
            <li>将零参数或结果的符号视为无关紧要。</li>
            <li>使用参数的倒数而不是执行除法。</li>
            <li>执行浮点收缩(例如,将乘法后跟加法融合为融合乘加)。</li>
            <li>执行代数等效变换,这些变换可能会改变浮点结果(例如,重新关联)。</li>
          </ul>
          这相当于 GCC 中的 <code>-ffast-math</code>。
        </li>
      </ul>
      <p>
      浮点模式由子作用域继承,并且可以在任何作用域中覆盖。您可以通过使用 comptime 块在结构体或模块作用域中设置浮点模式。
      </p>
      <p><code>FloatMode</code> 可以通过 <code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).builtin.FloatMode</code> 找到。</p>
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Floating-Point-Operations">浮点运算</a></li>
</ul>

      

      <h3 id="setRuntimeSafety"><a href="https://ziglang.org/documentation/0.15.2/#toc-setRuntimeSafety">@setRuntimeSafety</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#setRuntimeSafety">§</a></h3>

      <pre><code><span class="tok-builtin">@setRuntimeSafety</span>(<span class="tok-kw">comptime</span> safety_on: <span class="tok-type">bool</span>) <span class="tok-type">void</span></code></pre>
      <p>
      设置包含函数调用的作用域是否启用运行时安全检查。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_setRuntimeSafety_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">"@setRuntimeSafety"</span> {
    <span class="tok-comment">// 内建函数应用于调用它的作用域。所以在这里,在 ReleaseFast 和 ReleaseSmall 模式下不会捕获整数溢出:</span>
    <span class="tok-comment">// var x: u8 = 255;</span>
    <span class="tok-comment">// x += 1; // ReleaseFast/ReleaseSmall 模式下的未检查非法行为。</span>
    {
        <span class="tok-comment">// 然而这个块启用了安全,所以即使在 ReleaseFast 和 ReleaseSmall 模式下,这里也会进行安全检查。</span>
        <span class="tok-builtin">@setRuntimeSafety</span>(<span class="tok-null">true</span>);
        <span class="tok-kw">var</span> x: <span class="tok-type">u8</span> = <span class="tok-number">255</span>;
        x += <span class="tok-number">1</span>;

        {
            <span class="tok-comment">// 该值可以在任何作用域中覆盖。所以在这里,在任何构建模式下都不会捕获整数溢出。</span>
            <span class="tok-builtin">@setRuntimeSafety</span>(<span class="tok-null">false</span>);
            <span class="tok-comment">// var x: u8 = 255;</span>
            <span class="tok-comment">// x += 1; // 所有构建模式下的未检查非法行为。</span>
        }
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_setRuntimeSafety_builtin.zig -OReleaseFast</kbd>
1/1 test_setRuntimeSafety_builtin.test.@setRuntimeSafety...thread 2902624 panic: integer overflow
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_setRuntimeSafety_builtin.zig:11:11</span>: <span class="sgr-2m">0x103dc78 in test.@setRuntimeSafety (test)</span>
        x += 1;
          <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:218:25</span>: <span class="sgr-2m">0x10312bf in main (test)</span>
        if (test_fn.func()) |_| {
                        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x102ee5d in posixCallMainAndExit (test)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x102e95d in _start (test)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
error: the following test command crashed:
/home/andy/dev/zig/.zig-cache/o/7c580cf55e0b1cb6bb40fde0c61723ab/test --seed=0x2879e8a6
</samp></pre></figure>

      <p>注意:<a href="https://github.com/ziglang/zig/issues/978">计划</a>用 <code>@optimizeFor</code> 替换 <code><span class="tok-builtin">@setRuntimeSafety</span></code></p>

      

      <h3 id="shlExact"><a href="https://ziglang.org/documentation/0.15.2/#toc-shlExact">@shlExact</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#shlExact">§</a></h3>

      <pre><code><span class="tok-builtin">@shlExact</span>(value: T, shift_amt: Log2T) T</code></pre>
      <p>
      执行左移操作(<code>&lt;&lt;</code>)。
      对于无符号整数,如果任何 1 位被移出,则结果是<a href="https://ziglang.org/documentation/0.15.2/#undefined">未定义的</a>。对于有符号整数,如果任何与结果符号位不一致的位被移出,则结果是<a href="https://ziglang.org/documentation/0.15.2/#undefined">未定义的</a>。
      </p>
      <p>
      <code>shift_amt</code> 的类型是具有 <code>log2(<span class="tok-builtin">@typeInfo</span>(T).int.bits)</code> 位的无符号整数。
      这是因为 <code>shift_amt &gt;= <span class="tok-builtin">@typeInfo</span>(T).int.bits</code> 会触发安全检查的<a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>。
      </p>
      <p>
      <code><span class="tok-type">comptime_int</span></code> 被建模为具有无限位数的整数,
      这意味着在这种情况下,<code><span class="tok-builtin">@shlExact</span></code> 总是产生结果,不会产生编译错误。
      </p>
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#shrExact">@shrExact</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#shlWithOverflow">@shlWithOverflow</a></li>
</ul>

      

      <h3 id="shlWithOverflow"><a href="https://ziglang.org/documentation/0.15.2/#toc-shlWithOverflow">@shlWithOverflow</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#shlWithOverflow">§</a></h3>

      <pre><code><span class="tok-builtin">@shlWithOverflow</span>(a: <span class="tok-kw">anytype</span>, shift_amt: Log2T) <span class="tok-kw">struct</span> { <span class="tok-builtin">@TypeOf</span>(a), <span class="tok-type">u1</span> }</code></pre>
      <p>
      执行 <code>a &lt;&lt; b</code> 并返回一个包含结果和可能的溢出位的元组。
      </p>
      <p>
      <code>shift_amt</code> 的类型是具有 <code>log2(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(a)).int.bits)</code> 位的无符号整数。
      这是因为 <code>shift_amt &gt;= <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(a)).int.bits</code> 会触发安全检查的<a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>。
      </p>
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#shlExact">@shlExact</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#shrExact">@shrExact</a></li>
</ul>

      

      <h3 id="shrExact"><a href="https://ziglang.org/documentation/0.15.2/#toc-shrExact">@shrExact</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#shrExact">§</a></h3>

      <pre><code><span class="tok-builtin">@shrExact</span>(value: T, shift_amt: Log2T) T</code></pre>
      <p>
      执行右移操作(<code>&gt;&gt;</code>)。调用者保证移位不会移出任何 1 位。
      </p>
      <p>
      <code>shift_amt</code> 的类型是具有 <code>log2(<span class="tok-builtin">@typeInfo</span>(T).int.bits)</code> 位的无符号整数。
      这是因为 <code>shift_amt &gt;= <span class="tok-builtin">@typeInfo</span>(T).int.bits</code> 会触发安全检查的<a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>。
      </p>
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#shlExact">@shlExact</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#shlWithOverflow">@shlWithOverflow</a></li>
</ul>

      

      <h3 id="shuffle"><a href="https://ziglang.org/documentation/0.15.2/#toc-shuffle">@shuffle</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#shuffle">§</a></h3>

      <pre><code><span class="tok-builtin">@shuffle</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>, a: <span class="tok-builtin">@Vector</span>(a_len, E), b: <span class="tok-builtin">@Vector</span>(b_len, E), <span class="tok-kw">comptime</span> mask: <span class="tok-builtin">@Vector</span>(mask_len, <span class="tok-type">i32</span>)) <span class="tok-builtin">@Vector</span>(mask_len, E)</code></pre>
      <p>
      通过根据 <code>mask</code> 从 <code>a</code> 和 <code>b</code> 选择元素来构造一个新的<a href="https://ziglang.org/documentation/0.15.2/#Vectors">向量</a>。
      </p>
      <p>
      <code>mask</code> 中的每个元素从 <code>a</code> 或 <code>b</code> 中选择一个元素。正数从 <code>a</code> 开始选择,从 0 开始。负值从 <code>b</code> 选择,从 <code>-<span class="tok-number">1</span></code> 开始并递减。建议对来自 <code>b</code> 的索引使用 <code>~</code> 运算符,以便两个索引都可以从 <code><span class="tok-number">0</span></code> 开始(即 <code>~<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">0</span>)</code> 是 <code>-<span class="tok-number">1</span></code>)。
      </p>
      <p>
      对于 <code>mask</code> 的每个元素,如果它或从 <code>a</code> 或 <code>b</code> 选择的值是 <code><span class="tok-null">undefined</span></code>,则结果元素是 <code><span class="tok-null">undefined</span></code>。
      </p>
      <p>
      <code>a_len</code> 和 <code>b_len</code> 的长度可能不同。<code>mask</code> 中的越界元素索引会导致编译错误。
      </p>
      <p>
      如果 <code>a</code> 或 <code>b</code> 是 <code><span class="tok-null">undefined</span></code>,它相当于一个所有元素都是 <code><span class="tok-null">undefined</span></code> 且长度与另一个向量相同的向量。如果两个向量都是 <code><span class="tok-null">undefined</span></code>,<code><span class="tok-builtin">@shuffle</span></code> 返回一个所有元素都是 <code><span class="tok-null">undefined</span></code> 的向量。
      </p>
      <p>
      <code>E</code> 必须是<a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a>、<a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a>、<a href="https://ziglang.org/documentation/0.15.2/#Pointers">指针</a>或 <code><span class="tok-type">bool</span></code>。掩码可以是任何向量长度,其长度决定结果长度。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_shuffle_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"vector @shuffle"</span> {
    <span class="tok-kw">const</span> a = <span class="tok-builtin">@Vector</span>(<span class="tok-number">7</span>, <span class="tok-type">u8</span>){ <span class="tok-str">'o'</span>, <span class="tok-str">'l'</span>, <span class="tok-str">'h'</span>, <span class="tok-str">'e'</span>, <span class="tok-str">'r'</span>, <span class="tok-str">'z'</span>, <span class="tok-str">'w'</span> };
    <span class="tok-kw">const</span> b = <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">u8</span>){ <span class="tok-str">'w'</span>, <span class="tok-str">'d'</span>, <span class="tok-str">'!'</span>, <span class="tok-str">'x'</span> };

    <span class="tok-comment">// 要在单个向量内进行混洗,将 undefined 作为第二个参数传递。</span>
    <span class="tok-comment">// 注意,我们可以重新排序、复制或省略输入向量的元素</span>
    <span class="tok-kw">const</span> mask1 = <span class="tok-builtin">@Vector</span>(<span class="tok-number">5</span>, <span class="tok-type">i32</span>){ <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span> };
    <span class="tok-kw">const</span> res1: <span class="tok-builtin">@Vector</span>(<span class="tok-number">5</span>, <span class="tok-type">u8</span>) = <span class="tok-builtin">@shuffle</span>(<span class="tok-type">u8</span>, a, <span class="tok-null">undefined</span>, mask1);
    <span class="tok-kw">try</span> expect(std.mem.eql(<span class="tok-type">u8</span>, &amp;<span class="tok-builtin">@as</span>([<span class="tok-number">5</span>]<span class="tok-type">u8</span>, res1), <span class="tok-str">"hello"</span>));

    <span class="tok-comment">// 组合两个向量</span>
    <span class="tok-kw">const</span> mask2 = <span class="tok-builtin">@Vector</span>(<span class="tok-number">6</span>, <span class="tok-type">i32</span>){ -<span class="tok-number">1</span>, <span class="tok-number">0</span>, <span class="tok-number">4</span>, <span class="tok-number">1</span>, -<span class="tok-number">2</span>, -<span class="tok-number">3</span> };
    <span class="tok-kw">const</span> res2: <span class="tok-builtin">@Vector</span>(<span class="tok-number">6</span>, <span class="tok-type">u8</span>) = <span class="tok-builtin">@shuffle</span>(<span class="tok-type">u8</span>, a, b, mask2);
    <span class="tok-kw">try</span> expect(std.mem.eql(<span class="tok-type">u8</span>, &amp;<span class="tok-builtin">@as</span>([<span class="tok-number">6</span>]<span class="tok-type">u8</span>, res2), <span class="tok-str">"world!"</span>));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_shuffle_builtin.zig</kbd>
1/1 test_shuffle_builtin.test.vector @shuffle...OK
All 1 tests passed.
</samp></pre></figure>

      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Vectors">向量</a></li>
</ul>

      

      <h3 id="sizeOf"><a href="https://ziglang.org/documentation/0.15.2/#toc-sizeOf">@sizeOf</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#sizeOf">§</a></h3>

      <pre><code><span class="tok-builtin">@sizeOf</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">comptime_int</span></code></pre>
      <p>
      此函数返回在内存中存储 <code>T</code> 所需的字节数。
      结果是特定于目标的编译时常量。
      </p>
      <p>
      这个大小可能包含填充字节。如果内存中有两个连续的 T,填充将是索引 0 处的元素和索引 1 处的元素之间的字节偏移量。对于<a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a>,请考虑您是想使用 <code><span class="tok-builtin">@sizeOf</span>(T)</code> 还是 <code><span class="tok-builtin">@typeInfo</span>(T).int.bits</code>。
      </p>
      <p>
      此函数测量运行时的大小。对于运行时不允许的类型,例如 <code><span class="tok-type">comptime_int</span></code> 和 <code><span class="tok-type">type</span></code>,结果是 <code><span class="tok-number">0</span></code>。
      </p>
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#bitSizeOf">@bitSizeOf</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#typeInfo">@typeInfo</a></li>
</ul>

      

      <h3 id="splat"><a href="https://ziglang.org/documentation/0.15.2/#toc-splat">@splat</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#splat">§</a></h3>

      <pre><code><span class="tok-builtin">@splat</span>(scalar: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      生成一个数组或向量,其中每个元素都是值 <code>scalar</code>。返回类型以及向量的长度是推断的。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_splat_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"vector @splat"</span> {
    <span class="tok-kw">const</span> scalar: <span class="tok-type">u32</span> = <span class="tok-number">5</span>;
    <span class="tok-kw">const</span> result: <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">u32</span>) = <span class="tok-builtin">@splat</span>(scalar);
    <span class="tok-kw">try</span> expect(std.mem.eql(<span class="tok-type">u32</span>, &amp;<span class="tok-builtin">@as</span>([<span class="tok-number">4</span>]<span class="tok-type">u32</span>, result), &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">5</span>, <span class="tok-number">5</span>, <span class="tok-number">5</span>, <span class="tok-number">5</span> }));
}

<span class="tok-kw">test</span> <span class="tok-str">"array @splat"</span> {
    <span class="tok-kw">const</span> scalar: <span class="tok-type">u32</span> = <span class="tok-number">5</span>;
    <span class="tok-kw">const</span> result: [<span class="tok-number">4</span>]<span class="tok-type">u32</span> = <span class="tok-builtin">@splat</span>(scalar);
    <span class="tok-kw">try</span> expect(std.mem.eql(<span class="tok-type">u32</span>, &amp;<span class="tok-builtin">@as</span>([<span class="tok-number">4</span>]<span class="tok-type">u32</span>, result), &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">5</span>, <span class="tok-number">5</span>, <span class="tok-number">5</span>, <span class="tok-number">5</span> }));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_splat_builtin.zig</kbd>
1/2 test_splat_builtin.test.vector @splat...OK
2/2 test_splat_builtin.test.array @splat...OK
All 2 tests passed.
</samp></pre></figure>

      <p>
      <code>scalar</code> 必须是<a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a>、<a href="https://ziglang.org/documentation/0.15.2/#Primitive-Types">bool</a>、<a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a>或<a href="https://ziglang.org/documentation/0.15.2/#Pointers">指针</a>。
      </p>
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Vectors">向量</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#shuffle">@shuffle</a></li>
</ul>

      

      <h3 id="reduce"><a href="https://ziglang.org/documentation/0.15.2/#toc-reduce">@reduce</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#reduce">§</a></h3>

      <pre><code><span class="tok-builtin">@reduce</span>(<span class="tok-kw">comptime</span> op: std.builtin.ReduceOp, value: <span class="tok-kw">anytype</span>) E</code></pre>
      <p>
      通过使用指定的运算符 <code>op</code> 对其元素执行顺序水平归约,将<a href="https://ziglang.org/documentation/0.15.2/#Vectors">向量</a>转换为标量值(类型为 <code>E</code>)。
      </p>
      <p>
      并非每个运算符都可用于每种向量元素类型:
      </p>
      <ul>
          <li>每个运算符都可用于<a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a>向量。</li>
          <li><code>.And</code>、<code>.Or</code>、<code>.Xor</code> 另外可用于 <code><span class="tok-type">bool</span></code> 向量,</li>
          <li><code>.Min</code>、<code>.Max</code>、<code>.Add</code>、<code>.Mul</code> 另外可用于<a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点</a>向量,</li>
      </ul>
      <p>
      请注意,整数类型上的 <code>.Add</code> 和 <code>.Mul</code> 归约是回绕的;当应用于浮点类型时,除非浮点模式设置为 <code>Optimized</code>,否则保留操作结合性。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_reduce_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"vector @reduce"</span> {
    <span class="tok-kw">const</span> V = <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">i32</span>);
    <span class="tok-kw">const</span> value = V{ <span class="tok-number">1</span>, -<span class="tok-number">1</span>, <span class="tok-number">1</span>, -<span class="tok-number">1</span> };
    <span class="tok-kw">const</span> result = value &gt; <span class="tok-builtin">@as</span>(V, <span class="tok-builtin">@splat</span>(<span class="tok-number">0</span>));
    <span class="tok-comment">// result 是 { true, false, true, false };</span>
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> expect(<span class="tok-builtin">@TypeOf</span>(result) == <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">bool</span>));
    <span class="tok-kw">const</span> is_all_true = <span class="tok-builtin">@reduce</span>(.And, result);
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> expect(<span class="tok-builtin">@TypeOf</span>(is_all_true) == <span class="tok-type">bool</span>);
    <span class="tok-kw">try</span> expect(is_all_true == <span class="tok-null">false</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_reduce_builtin.zig</kbd>
1/1 test_reduce_builtin.test.vector @reduce...OK
All 1 tests passed.
</samp></pre></figure>

      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Vectors">向量</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#setFloatMode">@setFloatMode</a></li>
</ul>

      

      <h3 id="src"><a href="https://ziglang.org/documentation/0.15.2/#toc-src">@src</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#src">§</a></h3>

      <pre><code><span class="tok-builtin">@src</span>() std.builtin.SourceLocation</code></pre>
      <p>
      返回一个 <code>SourceLocation</code> 结构体,表示函数的名称及其在源代码中的位置。必须在函数中调用此函数。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_src_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"@src"</span> {
    <span class="tok-kw">try</span> doTheTest();
}

<span class="tok-kw">fn</span> <span class="tok-fn">doTheTest</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> src = <span class="tok-builtin">@src</span>();

    <span class="tok-kw">try</span> expect(src.line == <span class="tok-number">9</span>);
    <span class="tok-kw">try</span> expect(src.column == <span class="tok-number">17</span>);
    <span class="tok-kw">try</span> expect(std.mem.endsWith(<span class="tok-type">u8</span>, src.fn_name, <span class="tok-str">"doTheTest"</span>));
    <span class="tok-kw">try</span> expect(std.mem.endsWith(<span class="tok-type">u8</span>, src.file, <span class="tok-str">"test_src_builtin.zig"</span>));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_src_builtin.zig</kbd>
1/1 test_src_builtin.test.@src...OK
All 1 tests passed.
</samp></pre></figure>

      
      <h3 id="sqrt"><a href="https://ziglang.org/documentation/0.15.2/#toc-sqrt">@sqrt</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#sqrt">§</a></h3>

      <pre><code><span class="tok-builtin">@sqrt</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      执行浮点数的平方根。在可用时使用专用硬件指令。
      </p>
      <p>
      支持<a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a>和浮点数的<a href="https://ziglang.org/documentation/0.15.2/#Vectors">向量</a>。
      </p>
      
      <h3 id="sin"><a href="https://ziglang.org/documentation/0.15.2/#toc-sin">@sin</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#sin">§</a></h3>

      <pre><code><span class="tok-builtin">@sin</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      对弧度制浮点数进行正弦三角函数运算。在可用时使用专用硬件指令。
      </p>
      <p>
      支持<a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a>和浮点数的<a href="https://ziglang.org/documentation/0.15.2/#Vectors">向量</a>。
      </p>
      

      <h3 id="cos"><a href="https://ziglang.org/documentation/0.15.2/#toc-cos">@cos</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#cos">§</a></h3>

      <pre><code><span class="tok-builtin">@cos</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      对弧度制浮点数进行余弦三角函数运算。在可用时使用专用硬件指令。
      </p>
      <p>
      支持<a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a>和浮点数的<a href="https://ziglang.org/documentation/0.15.2/#Vectors">向量</a>。
      </p>
      

      <h3 id="tan"><a href="https://ziglang.org/documentation/0.15.2/#toc-tan">@tan</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#tan">§</a></h3>

      <pre><code><span class="tok-builtin">@tan</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      对弧度制浮点数进行正切三角函数运算。
      在可用时使用专用硬件指令。
      </p>
      <p>
      支持<a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a>和浮点数的<a href="https://ziglang.org/documentation/0.15.2/#Vectors">向量</a>。
      </p>
      

      <h3 id="exp"><a href="https://ziglang.org/documentation/0.15.2/#toc-exp">@exp</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#exp">§</a></h3>

      <pre><code><span class="tok-builtin">@exp</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      对浮点数进行以 e 为底的指数函数运算。在可用时使用专用硬件指令。
      </p>
      <p>
      支持<a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a>和浮点数的<a href="https://ziglang.org/documentation/0.15.2/#Vectors">向量</a>。
      </p>
      
      <h3 id="exp2"><a href="https://ziglang.org/documentation/0.15.2/#toc-exp2">@exp2</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#exp2">§</a></h3>

      <pre><code><span class="tok-builtin">@exp2</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      对浮点数进行以 2 为底的指数函数运算。在可用时使用专用硬件指令。
      </p>
      <p>
      支持<a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a>和浮点数的<a href="https://ziglang.org/documentation/0.15.2/#Vectors">向量</a>。
      </p>
      
      <h3 id="log"><a href="https://ziglang.org/documentation/0.15.2/#toc-log">@log</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#log">§</a></h3>

      <pre><code><span class="tok-builtin">@log</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      返回浮点数的自然对数。在可用时使用专用硬件指令。
      </p>
      <p>
      支持<a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a>和浮点数的<a href="https://ziglang.org/documentation/0.15.2/#Vectors">向量</a>。
      </p>
      
      <h3 id="log2"><a href="https://ziglang.org/documentation/0.15.2/#toc-log2">@log2</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#log2">§</a></h3>

      <pre><code><span class="tok-builtin">@log2</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      返回浮点数以 2 为底的对数。在可用时使用专用硬件指令。
      </p>
      <p>
      支持<a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a>和浮点数的<a href="https://ziglang.org/documentation/0.15.2/#Vectors">向量</a>。
      </p>
      
      <h3 id="log10"><a href="https://ziglang.org/documentation/0.15.2/#toc-log10">@log10</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#log10">§</a></h3>

      <pre><code><span class="tok-builtin">@log10</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      返回浮点数以 10 为底的对数。在可用时使用专用硬件指令。
      </p>
      <p>
      支持<a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a>和浮点数的<a href="https://ziglang.org/documentation/0.15.2/#Vectors">向量</a>。
      </p>
      
      <h3 id="abs"><a href="https://ziglang.org/documentation/0.15.2/#toc-abs">@abs</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#abs">§</a></h3>

      <pre><code><span class="tok-builtin">@abs</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      返回整数或浮点数的绝对值。在可用时使用专用硬件指令。

      如果操作数是整数,返回类型始终是与操作数位宽相同的无符号整数。
      支持无符号整数操作数。对于有符号整数操作数,内建函数不会溢出。
      </p>
      <p>
      支持<a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a>、<a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a>以及浮点数或整数的<a href="https://ziglang.org/documentation/0.15.2/#Vectors">向量</a>。
      </p>
      
      <h3 id="floor"><a href="https://ziglang.org/documentation/0.15.2/#toc-floor">@floor</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#floor">§</a></h3>

      <pre><code><span class="tok-builtin">@floor</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      返回不大于给定浮点数的最大整数值。
      在可用时使用专用硬件指令。
      </p>
      <p>
      支持<a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a>和浮点数的<a href="https://ziglang.org/documentation/0.15.2/#Vectors">向量</a>。
      </p>
      
      <h3 id="ceil"><a href="https://ziglang.org/documentation/0.15.2/#toc-ceil">@ceil</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#ceil">§</a></h3>

      <pre><code><span class="tok-builtin">@ceil</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      返回不小于给定浮点数的最小整数值。
      在可用时使用专用硬件指令。
      </p>
      <p>
      支持<a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a>和浮点数的<a href="https://ziglang.org/documentation/0.15.2/#Vectors">向量</a>。
      </p>
      
      <h3 id="trunc"><a href="https://ziglang.org/documentation/0.15.2/#toc-trunc">@trunc</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#trunc">§</a></h3>

      <pre><code><span class="tok-builtin">@trunc</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      将给定的浮点数向零舍入为整数。
      在可用时使用专用硬件指令。
      </p>
      <p>
      支持<a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a>和浮点数的<a href="https://ziglang.org/documentation/0.15.2/#Vectors">向量</a>。
      </p>
      
      <h3 id="round"><a href="https://ziglang.org/documentation/0.15.2/#toc-round">@round</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#round">§</a></h3>

      <pre><code><span class="tok-builtin">@round</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      将给定的浮点数舍入到最接近的整数。如果两个整数同样接近,则远离零舍入。
      在可用时使用专用硬件指令。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_round_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"@round"</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@round</span>(<span class="tok-number">1.4</span>) == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@round</span>(<span class="tok-number">1.5</span>) == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@round</span>(-<span class="tok-number">1.4</span>) == -<span class="tok-number">1</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@round</span>(-<span class="tok-number">2.5</span>) == -<span class="tok-number">3</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_round_builtin.zig</kbd>
1/1 test_round_builtin.test.@round...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      支持<a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a>和浮点数的<a href="https://ziglang.org/documentation/0.15.2/#Vectors">向量</a>。
      </p>
      

      <h3 id="subWithOverflow"><a href="https://ziglang.org/documentation/0.15.2/#toc-subWithOverflow">@subWithOverflow</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#subWithOverflow">§</a></h3>

      <pre><code><span class="tok-builtin">@subWithOverflow</span>(a: <span class="tok-kw">anytype</span>, b: <span class="tok-kw">anytype</span>) <span class="tok-kw">struct</span> { <span class="tok-builtin">@TypeOf</span>(a, b), <span class="tok-type">u1</span> }</code></pre>
      <p>
      执行 <code>a - b</code> 并返回一个包含结果和可能的溢出位的元组。
      </p>
      

      <h3 id="tagName"><a href="https://ziglang.org/documentation/0.15.2/#toc-tagName">@tagName</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#tagName">§</a></h3>

      <pre><code><span class="tok-builtin">@tagName</span>(value: <span class="tok-kw">anytype</span>) [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre>
      <p>
      将枚举值或联合值转换为表示名称的字符串字面量。</p><p>如果枚举是非穷尽的并且标签值未映射到名称,它会调用安全检查的<a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>。
      </p>
      

      <h3 id="This"><a href="https://ziglang.org/documentation/0.15.2/#toc-This">@This</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#This">§</a></h3>

      <pre><code><span class="tok-builtin">@This</span>() <span class="tok-type">type</span></code></pre>
      <p>
      返回此函数调用所在的最内层结构体、枚举或联合。
      这对于需要引用自身的匿名结构体很有用:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_this_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"@This()"</span> {
    <span class="tok-kw">var</span> items = [_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };
    <span class="tok-kw">const</span> list = List(<span class="tok-type">i32</span>){ .items = items[<span class="tok-number">0</span>..] };
    <span class="tok-kw">try</span> expect(list.length() == <span class="tok-number">4</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">List</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        items: []T,

        <span class="tok-kw">fn</span> <span class="tok-fn">length</span>(self: Self) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.items.len;
        }
    };
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_this_builtin.zig</kbd>
1/1 test_this_builtin.test.@This()...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      当 <code><span class="tok-builtin">@This</span>()</code> 在文件作用域使用时,它返回对应于当前文件的结构体的引用。
      </p>
      

      <h3 id="trap"><a href="https://ziglang.org/documentation/0.15.2/#toc-trap">@trap</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#trap">§</a></h3>

      <pre><code><span class="tok-builtin">@trap</span>() <span class="tok-type">noreturn</span></code></pre>
      <p>
      此函数插入一个特定于平台的陷阱/卡住指令,可用于异常退出程序。
      这可能通过显式发出无效指令来实现,这可能会导致某种非法指令异常。
      与 <code><span class="tok-builtin">@breakpoint</span>()</code> 不同,执行不会在此点之后继续。
      </p>
      <p>
      在函数作用域之外,此内建函数会导致编译错误。
      </p>
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#breakpoint">@breakpoint</a></li>
</ul>

      

      <h3 id="truncate"><a href="https://ziglang.org/documentation/0.15.2/#toc-truncate">@truncate</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#truncate">§</a></h3>

      <pre><code><span class="tok-builtin">@truncate</span>(integer: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      此函数从整数类型截断位,生成一个更小或相同大小的整数类型。返回类型是推断的结果类型。
      </p>
      <p>
      此函数始终截断整数的有效位,无论目标平台上的字节序如何。
      </p>
      <p>
      对超出目标类型范围的数字调用 <code><span class="tok-builtin">@truncate</span></code> 是定义明确的工作代码:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_truncate_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"integer truncation"</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">u16</span> = <span class="tok-number">0xabcd</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">u8</span> = <span class="tok-builtin">@truncate</span>(a);
    <span class="tok-kw">try</span> expect(b == <span class="tok-number">0xcd</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_truncate_builtin.zig</kbd>
1/1 test_truncate_builtin.test.integer truncation...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      使用 <a href="https://ziglang.org/documentation/0.15.2/#intCast">@intCast</a> 转换保证适合目标类型的数字。
      </p>
      

      <h3 id="Type"><a href="https://ziglang.org/documentation/0.15.2/#toc-Type">@Type</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Type">§</a></h3>

      <pre><code><span class="tok-builtin">@Type</span>(<span class="tok-kw">comptime</span> info: std.builtin.Type) <span class="tok-type">type</span></code></pre>
      <p>
      此函数是 <a href="https://ziglang.org/documentation/0.15.2/#typeInfo">@typeInfo</a> 的逆函数。它将类型信息具体化为 <code><span class="tok-type">type</span></code>。
      </p>
      <p>
      它适用于以下类型:
      </p>
      <ul>
          <li><code><span class="tok-type">type</span></code></li>
          <li><code><span class="tok-type">noreturn</span></code></li>
          <li><code><span class="tok-type">void</span></code></li>
          <li><code><span class="tok-type">bool</span></code></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#Integers">整数</a> - 整数类型的最大位数是 <code><span class="tok-number">65535</span></code>。</li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#Floats">浮点数</a></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#Pointers">指针</a></li>
          <li><code><span class="tok-type">comptime_int</span></code></li>
          <li><code><span class="tok-type">comptime_float</span></code></li>
          <li><code><span class="tok-builtin">@TypeOf</span>(<span class="tok-null">undefined</span>)</code></li>
          <li><code><span class="tok-builtin">@TypeOf</span>(<span class="tok-null">null</span>)</code></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#Arrays">数组</a></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#Optionals">可选类型</a></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#Error-Set-Type">错误集类型</a></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#Error-Union-Type">错误联合类型</a></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#Vectors">向量</a></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#opaque">opaque</a></li>
          <li><code><span class="tok-kw">anyframe</span></code></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#struct">struct</a></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#enum">enum</a></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#Enum-Literals">枚举字面量</a></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#union">union</a></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#Functions">函数</a></li>
      </ul>
      
      <h3 id="typeInfo"><a href="https://ziglang.org/documentation/0.15.2/#toc-typeInfo">@typeInfo</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#typeInfo">§</a></h3>

      <pre><code><span class="tok-builtin">@typeInfo</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) std.builtin.Type</code></pre>
      <p>
      提供类型反射。
      </p>
      <p>
      <a href="https://ziglang.org/documentation/0.15.2/#struct">结构体</a>、<a href="https://ziglang.org/documentation/0.15.2/#union">联合</a>、<a href="https://ziglang.org/documentation/0.15.2/#enum">枚举</a>和<a href="https://ziglang.org/documentation/0.15.2/#Error-Set-Type">错误集</a>的类型信息具有字段,这些字段保证与源文件中出现的顺序相同。
      </p>
      <p>
      <a href="https://ziglang.org/documentation/0.15.2/#struct">结构体</a>、<a href="https://ziglang.org/documentation/0.15.2/#union">联合</a>、<a href="https://ziglang.org/documentation/0.15.2/#enum">枚举</a>和<a href="https://ziglang.org/documentation/0.15.2/#opaque">不透明类型</a>的类型信息具有声明,这些声明也保证与源文件中出现的顺序相同。
      </p>
      

      <h3 id="typeName"><a href="https://ziglang.org/documentation/0.15.2/#toc-typeName">@typeName</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#typeName">§</a></h3>

      <pre><code><span class="tok-builtin">@typeName</span>(T: <span class="tok-type">type</span>) *<span class="tok-kw">const</span> [N:<span class="tok-number">0</span>]<span class="tok-type">u8</span></code></pre>
      <p>
      此函数以数组形式返回类型的字符串表示形式。它相当于类型名称的字符串字面量。
      返回的类型名称是完全限定的,父命名空间作为类型名称的一部分包含在内,使用一系列点。
      </p>
      

      <h3 id="TypeOf"><a href="https://ziglang.org/documentation/0.15.2/#toc-TypeOf">@TypeOf</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#TypeOf">§</a></h3>

      <pre><code><span class="tok-builtin">@TypeOf</span>(...) <span class="tok-type">type</span></code></pre>
      <p>
      <code><span class="tok-builtin">@TypeOf</span></code> 是一个特殊的内建函数,它接受任意数量(非零)的表达式作为参数,并使用<a href="https://ziglang.org/documentation/0.15.2/#Peer-Type-Resolution">对等类型解析</a>返回结果的类型。
      </p>
      <p>
      表达式会被求值,但保证它们没有<em>运行时</em>副作用:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_TypeOf_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"no runtime side effects"</span> {
    <span class="tok-kw">var</span> data: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> T = <span class="tok-builtin">@TypeOf</span>(foo(<span class="tok-type">i32</span>, &amp;data));
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> expect(T == <span class="tok-type">i32</span>);
    <span class="tok-kw">try</span> expect(data == <span class="tok-number">0</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *T) T {
    ptr.* += <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> ptr.*;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_TypeOf_builtin.zig</kbd>
1/1 test_TypeOf_builtin.test.no runtime side effects...OK
All 1 tests passed.
</samp></pre></figure>

      

      <h3 id="unionInit"><a href="https://ziglang.org/documentation/0.15.2/#toc-unionInit">@unionInit</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#unionInit">§</a></h3>

      <pre><code><span class="tok-builtin">@unionInit</span>(<span class="tok-kw">comptime</span> Union: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> active_field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, init_expr) Union</code></pre>
      <p>
      这与<a href="https://ziglang.org/documentation/0.15.2/#union">联合</a>初始化语法相同,只是字段名称是<a href="https://ziglang.org/documentation/0.15.2/#comptime">编译期</a>已知的值,而不是标识符标记。
      </p>
      <p>
      <code><span class="tok-builtin">@unionInit</span></code> 将其<a href="https://ziglang.org/documentation/0.15.2/#Result-Location-Semantics">结果位置</a>转发给 <code>init_expr</code>。
      </p>
      


      <h3 id="Vector"><a href="https://ziglang.org/documentation/0.15.2/#toc-Vector">@Vector</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Vector">§</a></h3>

      <pre><code><span class="tok-builtin">@Vector</span>(len: <span class="tok-type">comptime_int</span>, Element: <span class="tok-type">type</span>) <span class="tok-type">type</span></code></pre>
      <p>创建<a href="https://ziglang.org/documentation/0.15.2/#Vectors">向量</a>。</p>
      

      <h3 id="volatileCast"><a href="https://ziglang.org/documentation/0.15.2/#toc-volatileCast">@volatileCast</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#volatileCast">§</a></h3>

      <pre><code><span class="tok-builtin">@volatileCast</span>(value: <span class="tok-kw">anytype</span>) DestType</code></pre>
      <p>
      从指针中移除 <code><span class="tok-kw">volatile</span></code> 限定符。
      </p>
      

      <h3 id="workGroupId"><a href="https://ziglang.org/documentation/0.15.2/#toc-workGroupId">@workGroupId</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#workGroupId">§</a></h3>

      <pre><code><span class="tok-builtin">@workGroupId</span>(<span class="tok-kw">comptime</span> dimension: <span class="tok-type">u32</span>) <span class="tok-type">u32</span></code></pre>
      <p>
      返回当前内核调用中维度 <code>dimension</code> 的工作组索引。
      </p>
      

      <h3 id="workGroupSize"><a href="https://ziglang.org/documentation/0.15.2/#toc-workGroupSize">@workGroupSize</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#workGroupSize">§</a></h3>

      <pre><code><span class="tok-builtin">@workGroupSize</span>(<span class="tok-kw">comptime</span> dimension: <span class="tok-type">u32</span>) <span class="tok-type">u32</span></code></pre>
      <p>
      返回工作组在维度 <code>dimension</code> 中具有的工作项数。
      </p>
      

      <h3 id="workItemId"><a href="https://ziglang.org/documentation/0.15.2/#toc-workItemId">@workItemId</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#workItemId">§</a></h3>

      <pre><code><span class="tok-builtin">@workItemId</span>(<span class="tok-kw">comptime</span> dimension: <span class="tok-type">u32</span>) <span class="tok-type">u32</span></code></pre>
      <p>
      返回工作项在工作组中维度 <code>dimension</code> 的索引。此函数返回介于 <code><span class="tok-number">0</span></code>(包含)和 <code><span class="tok-builtin">@workGroupSize</span>(dimension)</code>(不包含)之间的值。
      </p>
      

      

      <h2 id="Build-Mode"><a href="https://ziglang.org/documentation/0.15.2/#toc-Build-Mode">构建模式</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Build-Mode">§</a></h2>

      <p>
      Zig 有四种构建模式:
      </p>
      <ul>
        <li><a href="https://ziglang.org/documentation/0.15.2/#Debug">Debug</a>(默认)</li>
        <li><a href="https://ziglang.org/documentation/0.15.2/#ReleaseFast">ReleaseFast</a></li>
        <li><a href="https://ziglang.org/documentation/0.15.2/#ReleaseSafe">ReleaseSafe</a></li>
        <li><a href="https://ziglang.org/documentation/0.15.2/#ReleaseSmall">ReleaseSmall</a></li>
      </ul>
      <p>
      要向 <code class="file">build.zig</code> 文件添加标准构建选项:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">build.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">build</span>(b: *std.Build) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> optimize = b.standardOptimizeOption(.{});
    <span class="tok-kw">const</span> exe = b.addExecutable(.{
        .name = <span class="tok-str">"example"</span>,
        .root_module = b.createModule(.{
            .root_source_file = b.path(<span class="tok-str">"example.zig"</span>),
            .optimize = optimize,
        }),
    });
    b.default_step.dependOn(&amp;exe.step);
}</code></pre></figure>

      <p>
      这会使这些选项可用:
      </p>
      <dl>
        <dt><kbd>-Doptimize=Debug</kbd></dt><dd>优化关闭,安全检查开启(默认)</dd>
        <dt><kbd>-Doptimize=ReleaseSafe</kbd></dt><dd>优化开启,安全检查开启</dd>
        <dt><kbd>-Doptimize=ReleaseFast</kbd></dt><dd>优化开启,安全检查关闭</dd>
        <dt><kbd>-Doptimize=ReleaseSmall</kbd></dt><dd>大小优化开启,安全检查关闭</dd>
      </dl>
      <h3 id="Debug"><a href="https://ziglang.org/documentation/0.15.2/#toc-Debug">Debug</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Debug">§</a></h3>

      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe example.zig</kbd>
</samp></pre></figure>
      <ul>
        <li>快速编译速度</li>
        <li>启用安全检查</li>
        <li>慢速运行时性能</li>
        <li>大的二进制大小</li>
        <li>无可重现构建要求</li>
      </ul>
      
      <h3 id="ReleaseFast"><a href="https://ziglang.org/documentation/0.15.2/#toc-ReleaseFast">ReleaseFast</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#ReleaseFast">§</a></h3>

      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe example.zig -O ReleaseFast</kbd>
</samp></pre></figure>
      <ul>
        <li>快速运行时性能</li>
        <li>禁用安全检查</li>
        <li>慢速编译速度</li>
        <li>大的二进制大小</li>
        <li>可重现构建</li>
      </ul>
      
      <h3 id="ReleaseSafe"><a href="https://ziglang.org/documentation/0.15.2/#toc-ReleaseSafe">ReleaseSafe</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#ReleaseSafe">§</a></h3>

      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe example.zig -O ReleaseSafe</kbd>
</samp></pre></figure>
      <ul>
        <li>中等运行时性能</li>
        <li>启用安全检查</li>
        <li>慢速编译速度</li>
        <li>大的二进制大小</li>
        <li>可重现构建</li>
      </ul>
      
      <h3 id="ReleaseSmall"><a href="https://ziglang.org/documentation/0.15.2/#toc-ReleaseSmall">ReleaseSmall</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#ReleaseSmall">§</a></h3>

      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe example.zig -O ReleaseSmall</kbd>
</samp></pre></figure>
      <ul>
        <li>中等运行时性能</li>
        <li>禁用安全检查</li>
        <li>慢速编译速度</li>
        <li>小的二进制大小</li>
        <li>可重现构建</li>
      </ul>
      
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Compile-Variables">编译变量</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Zig-Build-System">Zig 构建系统</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a></li>
</ul>

      

      <h2 id="Single-Threaded-Builds"><a href="https://ziglang.org/documentation/0.15.2/#toc-Single-Threaded-Builds">单线程构建</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Single-Threaded-Builds">§</a></h2>

      <p>Zig 有一个编译选项 <kbd>-fsingle-threaded</kbd>,它有以下效果:</p>
      <ul>
        <li>所有<a href="https://ziglang.org/documentation/0.15.2/#Thread-Local-Variables">线程局部变量</a>都被视为常规的<a href="https://ziglang.org/documentation/0.15.2/#Container-Level-Variables">容器级变量</a>。</li>
        <li><a href="https://ziglang.org/documentation/0.15.2/#Async-Functions">异步函数</a>的开销变得等同于函数调用开销。</li>
        <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">"builtin"</span>).single_threaded</code> 变为 <code><span class="tok-null">true</span></code>,因此读取此变量的各种用户态 API 变得更加高效。例如 <code>std.Mutex</code> 变为空数据结构,其所有函数都变为空操作。</li>
      </ul>
      

      <h2 id="Illegal-Behavior"><a href="https://ziglang.org/documentation/0.15.2/#toc-Illegal-Behavior">非法行为</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">§</a></h2>

      <p>
      Zig 中的许多操作都会触发所谓的"非法行为"(IB)。如果在编译时检测到非法行为,Zig 会发出编译错误并拒绝继续。否则,当非法行为在编译时未被捕获时,它会属于两类中的一类。
      </p>
      <p>
      一些非法行为是<em>安全检查的</em>:这意味着编译器会在可能在运行时发生非法行为的任何地方插入"安全检查",以确定它是否即将发生。如果是,安全检查"失败",从而触发恐慌。
      </p>
      <p>
      所有其他非法行为都是<em>未检查的</em>,这意味着编译器无法为其插入安全检查。如果在运行时调用未检查的非法行为,可能会发生任何事情:通常是某种形式的崩溃,但优化器可以自由地使未检查的非法行为执行任何操作,例如调用任意函数或破坏任意数据。这类似于某些其他语言中"未定义行为"的概念。请注意,未检查的非法行为如果在 <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a> 时求值,仍然总是导致编译错误,因为 Zig 编译器能够在编译时执行比在运行时更复杂的检查。
      </p>
      <p>
      大多数非法行为都是安全检查的。但是,为了便于优化,默认情况下在 <a href="https://ziglang.org/documentation/0.15.2/#ReleaseFast">ReleaseFast</a> 和 <a href="https://ziglang.org/documentation/0.15.2/#ReleaseSmall">ReleaseSmall</a> 优化模式下禁用安全检查。也可以使用 <a href="https://ziglang.org/documentation/0.15.2/#setRuntimeSafety">@setRuntimeSafety</a> 在每个块的基础上启用或禁用安全检查,从而覆盖当前优化模式的默认值。当安全检查被禁用时,安全检查的非法行为表现得像未检查的非法行为;也就是说,调用它可能导致任何行为。
      </p>
      <p>
      当安全检查失败时,Zig 的默认恐慌处理程序会崩溃并显示堆栈跟踪,如下所示:
      </p>
<!-- ====== END CHUNK 11: new_11.html ====== -->

<!-- ====== BEGIN CHUNK 12: new_12.html ====== -->
<figure><figcaption class="zig-cap"><cite class="file">test_illegal_behavior.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">"安全检查"</span> {
    <span class="tok-kw">unreachable</span>;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_illegal_behavior.zig</kbd>
1/1 test_illegal_behavior.test.安全检查...thread 2892891 panic: 到达了不可达代码
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_illegal_behavior.zig:2:5</span>: <span class="sgr-2m">0x102c00c in test.安全检查 (test_illegal_behavior.zig)</span>
    unreachable;
    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:218:25</span>: <span class="sgr-2m">0x115cb20 in mainTerminal (test_runner.zig)</span>
        if (test_fn.func()) |_| {
                        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/compiler/test_runner.zig:66:28</span>: <span class="sgr-2m">0x1155d41 in main (test_runner.zig)</span>
        return mainTerminal();
                           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x114fadd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x114f371 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
error: 以下测试命令崩溃:
/home/andy/dev/zig/.zig-cache/o/e72b27fd3a681a218f2215fb6e7fd433/test --seed=0xeebe2201
</samp></pre></figure>

      <h3 id="Reaching-Unreachable-Code"><a href="https://ziglang.org/documentation/0.15.2/#toc-Reaching-Unreachable-Code">到达不可达代码</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Reaching-Unreachable-Code">§</a></h3>

      <p>在编译时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_reaching_unreachable.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    assert(<span class="tok-null">false</span>);
}
<span class="tok-kw">fn</span> <span class="tok-fn">assert</span>(ok: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!ok) <span class="tok-kw">unreachable</span>; <span class="tok-comment">// 断言失败</span>
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_reaching_unreachable.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_reaching_unreachable.zig:5:14: </span><span class="sgr-31m">error: </span><span class="sgr-1m">到达了不可达代码
</span>    if (!ok) unreachable; // 断言失败
             <span class="sgr-32m">^~~~~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_reaching_unreachable.zig:2:11: </span><span class="sgr-36m">note: </span><span class="sgr-1m">在编译时调用
</span>    assert(false);
    <span class="sgr-32m">~~~~~~^~~~~~~
</span>
</samp></pre></figure>

      <p>在运行时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_reaching_unreachable.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    std.debug.assert(<span class="tok-null">false</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_reaching_unreachable.zig</kbd>
$ <kbd>./runtime_reaching_unreachable</kbd>
thread 2897013 panic: 到达了不可达代码
<span class="sgr-1m">/home/andy/dev/zig/lib/std/debug.zig:559:14</span>: <span class="sgr-2m">0x1044179 in assert (std.zig)</span>
    if (!ok) unreachable; // 断言失败
             <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_reaching_unreachable.zig:4:21</span>: <span class="sgr-2m">0x113e86e in main (runtime_reaching_unreachable.zig)</span>
    std.debug.assert(false);
                    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(进程被信号终止)
</samp></pre></figure>

      
      <h3 id="Index-out-of-Bounds"><a href="https://ziglang.org/documentation/0.15.2/#toc-Index-out-of-Bounds">索引越界</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Index-out-of-Bounds">§</a></h3>

      <p>在编译时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_index_out_of_bounds.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> array: [<span class="tok-number">5</span>]<span class="tok-type">u8</span> = <span class="tok-str">"hello"</span>.*;
    <span class="tok-kw">const</span> garbage = array[<span class="tok-number">5</span>];
    _ = garbage;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_index_out_of_bounds.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_index_out_of_bounds.zig:3:27: </span><span class="sgr-31m">error: </span><span class="sgr-1m">索引 5 超出长度为 5 的数组范围
</span>    const garbage = array[5];
                          <span class="sgr-32m">^
</span>
</samp></pre></figure>

      <p>在运行时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_index_out_of_bounds.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> x = foo(<span class="tok-str">"hello"</span>);
    _ = x;
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(x: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> x[<span class="tok-number">5</span>];
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_index_out_of_bounds.zig</kbd>
$ <kbd>./runtime_index_out_of_bounds</kbd>
thread 2893998 panic: 索引越界: 索引 5, 长度 5
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_index_out_of_bounds.zig:7:13</span>: <span class="sgr-2m">0x113fae6 in foo (runtime_index_out_of_bounds.zig)</span>
    return x[5];
            <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_index_out_of_bounds.zig:2:18</span>: <span class="sgr-2m">0x113e87a in main (runtime_index_out_of_bounds.zig)</span>
    const x = foo("hello");
                 <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(进程被信号终止)
</samp></pre></figure>

      
      <h3 id="Cast-Negative-Number-to-Unsigned-Integer"><a href="https://ziglang.org/documentation/0.15.2/#toc-Cast-Negative-Number-to-Unsigned-Integer">将负数转换为无符号整数</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Cast-Negative-Number-to-Unsigned-Integer">§</a></h3>

      <p>在编译时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_invalid_cast.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> value: <span class="tok-type">i32</span> = -<span class="tok-number">1</span>;
    <span class="tok-kw">const</span> unsigned: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(value);
    _ = unsigned;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_invalid_cast.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_invalid_cast.zig:3:36: </span><span class="sgr-31m">error: </span><span class="sgr-1m">类型 'u32' 无法表示整数值 '-1'
</span>    const unsigned: u32 = @intCast(value);
                                   <span class="sgr-32m">^~~~~
</span>
</samp></pre></figure>

      <p>在运行时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_invalid_cast.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> value: <span class="tok-type">i32</span> = -<span class="tok-number">1</span>; <span class="tok-comment">// 运行时已知</span>
    _ = &amp;value;
    <span class="tok-kw">const</span> unsigned: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(value);
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{unsigned});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_invalid_cast.zig</kbd>
$ <kbd>./runtime_invalid_cast</kbd>
thread 2899906 panic: 整数无法适配目标类型
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_invalid_cast.zig:6:27</span>: <span class="sgr-2m">0x113e87f in main (runtime_invalid_cast.zig)</span>
    const unsigned: u32 = @intCast(value);
                          <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(进程被信号终止)
</samp></pre></figure>

      <p>
      要获取无符号整数的最大值,请使用 <code>std.math.maxInt</code>。
      </p>
      
      <h3 id="Cast-Truncates-Data"><a href="https://ziglang.org/documentation/0.15.2/#toc-Cast-Truncates-Data">转换截断数据</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Cast-Truncates-Data">§</a></h3>

      <p>在编译时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_invalid_cast_truncate.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> spartan_count: <span class="tok-type">u16</span> = <span class="tok-number">300</span>;
    <span class="tok-kw">const</span> byte: <span class="tok-type">u8</span> = <span class="tok-builtin">@intCast</span>(spartan_count);
    _ = byte;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_invalid_cast_truncate.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_invalid_cast_truncate.zig:3:31: </span><span class="sgr-31m">error: </span><span class="sgr-1m">类型 'u8' 无法表示整数值 '300'
</span>    const byte: u8 = @intCast(spartan_count);
                              <span class="sgr-32m">^~~~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>在运行时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_invalid_cast_truncate.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> spartan_count: <span class="tok-type">u16</span> = <span class="tok-number">300</span>; <span class="tok-comment">// 运行时已知</span>
    _ = &amp;spartan_count;
    <span class="tok-kw">const</span> byte: <span class="tok-type">u8</span> = <span class="tok-builtin">@intCast</span>(spartan_count);
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{byte});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_invalid_cast_truncate.zig</kbd>
$ <kbd>./runtime_invalid_cast_truncate</kbd>
thread 2899317 panic: 整数无法适配目标类型
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_invalid_cast_truncate.zig:6:22</span>: <span class="sgr-2m">0x113e880 in main (runtime_invalid_cast_truncate.zig)</span>
    const byte: u8 = @intCast(spartan_count);
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(进程被信号终止)
</samp></pre></figure>

      <p>
      要截断位,请使用 <a href="https://ziglang.org/documentation/0.15.2/#truncate">@truncate</a>。
      </p>
      
      <h3 id="Integer-Overflow"><a href="https://ziglang.org/documentation/0.15.2/#toc-Integer-Overflow">整数溢出</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Integer-Overflow">§</a></h3>

      <h4 id="Default-Operations"><a href="https://ziglang.org/documentation/0.15.2/#toc-Default-Operations">默认操作</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Default-Operations">§</a></h4>

      <p>以下操作可能导致整数溢出:</p>
      <ul>
          <li><code>+</code> (加法)</li>
          <li><code>-</code> (减法)</li>
          <li><code>-</code> (取负)</li>
          <li><code>*</code> (乘法)</li>
          <li><code>/</code> (除法)</li>
        <li><a href="https://ziglang.org/documentation/0.15.2/#divTrunc">@divTrunc</a> (除法)</li>
        <li><a href="https://ziglang.org/documentation/0.15.2/#divFloor">@divFloor</a> (除法)</li>
        <li><a href="https://ziglang.org/documentation/0.15.2/#divExact">@divExact</a> (除法)</li>
      </ul>
      <p>编译时加法溢出示例:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_overflow.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">var</span> byte: <span class="tok-type">u8</span> = <span class="tok-number">255</span>;
    byte += <span class="tok-number">1</span>;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_overflow.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_overflow.zig:3:10: </span><span class="sgr-31m">error: </span><span class="sgr-1m">类型 'u8' 的整数溢出,值为 '256'
</span>    byte += 1;
    <span class="sgr-32m">~~~~~^~~~
</span>
</samp></pre></figure>

      <p>在运行时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_overflow.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> byte: <span class="tok-type">u8</span> = <span class="tok-number">255</span>;
    byte += <span class="tok-number">1</span>;
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{byte});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_overflow.zig</kbd>
$ <kbd>./runtime_overflow</kbd>
thread 2892886 panic: 整数溢出
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_overflow.zig:5:10</span>: <span class="sgr-2m">0x113e895 in main (runtime_overflow.zig)</span>
    byte += 1;
         <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(进程被信号终止)
</samp></pre></figure>

      
      <h4 id="Standard-Library-Math-Functions"><a href="https://ziglang.org/documentation/0.15.2/#toc-Standard-Library-Math-Functions">标准库数学函数</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Standard-Library-Math-Functions">§</a></h4>

      <p>标准库提供的这些函数返回可能的错误。</p>
      <ul>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).math.add</code></li>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).math.sub</code></li>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).math.mul</code></li>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).math.divTrunc</code></li>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).math.divFloor</code></li>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).math.divExact</code></li>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).math.shl</code></li>
      </ul>
      <p>捕获加法溢出的示例:</p>
      <figure><figcaption class="zig-cap"><cite class="file">math_add.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> math = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).math;
<span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> byte: <span class="tok-type">u8</span> = <span class="tok-number">255</span>;

    byte = <span class="tok-kw">if</span> (math.add(<span class="tok-type">u8</span>, byte, <span class="tok-number">1</span>)) |result| result <span class="tok-kw">else</span> |err| {
        print(<span class="tok-str">"无法加一: {s}\n"</span>, .{<span class="tok-builtin">@errorName</span>(err)});
        <span class="tok-kw">return</span> err;
    };

    print(<span class="tok-str">"结果: {}\n"</span>, .{byte});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe math_add.zig</kbd>
$ <kbd>./math_add</kbd>
无法加一: Overflow
error: Overflow
<span class="sgr-1m">/home/andy/dev/zig/lib/std/math.zig:570:21</span>: <span class="sgr-2m">0x113ebae in add__anon_22552 (std.zig)</span>
    if (ov[1] != 0) return error.Overflow;
                    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/math_add.zig:8:9</span>: <span class="sgr-2m">0x113d422 in main (math_add.zig)</span>
        return err;
        <span class="sgr-32m">^</span>
</samp></pre></figure>

      
      <h4 id="Builtin-Overflow-Functions"><a href="https://ziglang.org/documentation/0.15.2/#toc-Builtin-Overflow-Functions">内建溢出函数</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Builtin-Overflow-Functions">§</a></h4>

      <p>
      这些内建函数返回一个元组,包含是否发生溢出(作为 <code><span class="tok-type">u1</span></code>)以及操作可能溢出的位:
      </p>
      <ul>
          <li><a href="https://ziglang.org/documentation/0.15.2/#addWithOverflow">@addWithOverflow</a></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#subWithOverflow">@subWithOverflow</a></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#mulWithOverflow">@mulWithOverflow</a></li>
          <li><a href="https://ziglang.org/documentation/0.15.2/#shlWithOverflow">@shlWithOverflow</a></li>
      </ul>
      <p>
      <a href="https://ziglang.org/documentation/0.15.2/#addWithOverflow">@addWithOverflow</a> 示例:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">addWithOverflow_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> byte: <span class="tok-type">u8</span> = <span class="tok-number">255</span>;

    <span class="tok-kw">const</span> ov = <span class="tok-builtin">@addWithOverflow</span>(byte, <span class="tok-number">10</span>);
    <span class="tok-kw">if</span> (ov[<span class="tok-number">1</span>] != <span class="tok-number">0</span>) {
        print(<span class="tok-str">"溢出结果: {}\n"</span>, .{ov[<span class="tok-number">0</span>]});
    } <span class="tok-kw">else</span> {
        print(<span class="tok-str">"结果: {}\n"</span>, .{ov[<span class="tok-number">0</span>]});
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe addWithOverflow_builtin.zig</kbd>
$ <kbd>./addWithOverflow_builtin</kbd>
溢出结果: 9
</samp></pre></figure>

      
      <h4 id="Wrapping-Operations"><a href="https://ziglang.org/documentation/0.15.2/#toc-Wrapping-Operations">环绕操作</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Wrapping-Operations">§</a></h4>

      <p>
      这些操作具有保证的环绕语义。
      </p>
      <ul>
          <li><code>+%</code> (环绕加法)</li>
          <li><code>-%</code> (环绕减法)</li>
          <li><code>-%</code> (环绕取负)</li>
          <li><code>*%</code> (环绕乘法)</li>
      </ul>
      <figure><figcaption class="zig-cap"><cite class="file">test_wraparound_semantics.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;
<span class="tok-kw">const</span> minInt = std.math.minInt;
<span class="tok-kw">const</span> maxInt = std.math.maxInt;

<span class="tok-kw">test</span> <span class="tok-str">"环绕加法和减法"</span> {
    <span class="tok-kw">const</span> x: <span class="tok-type">i32</span> = maxInt(<span class="tok-type">i32</span>);
    <span class="tok-kw">const</span> min_val = x +% <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> expect(min_val == minInt(<span class="tok-type">i32</span>));
    <span class="tok-kw">const</span> max_val = min_val -% <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> expect(max_val == maxInt(<span class="tok-type">i32</span>));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_wraparound_semantics.zig</kbd>
1/1 test_wraparound_semantics.test.环绕加法和减法...OK
所有 1 个测试通过。
</samp></pre></figure>

      
      
      <h3 id="Exact-Left-Shift-Overflow"><a href="https://ziglang.org/documentation/0.15.2/#toc-Exact-Left-Shift-Overflow">精确左移溢出</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Exact-Left-Shift-Overflow">§</a></h3>

      <p>在编译时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_shlExact_overflow.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> x = <span class="tok-builtin">@shlExact</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0b01010101</span>), <span class="tok-number">2</span>);
    _ = x;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_shlExact_overflow.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_shlExact_overflow.zig:2:15: </span><span class="sgr-31m">error: </span><span class="sgr-1m">类型 'u8' 的整数溢出,值为 '340'
</span>    const x = @shlExact(@as(u8, 0b01010101), 2);
              <span class="sgr-32m">^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>在运行时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_shlExact_overflow.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">u8</span> = <span class="tok-number">0b01010101</span>; <span class="tok-comment">// 运行时已知</span>
    _ = &amp;x;
    <span class="tok-kw">const</span> y = <span class="tok-builtin">@shlExact</span>(x, <span class="tok-number">2</span>);
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{y});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_shlExact_overflow.zig</kbd>
$ <kbd>./runtime_shlExact_overflow</kbd>
thread 2896313 panic: 左移溢出位
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_shlExact_overflow.zig:6:5</span>: <span class="sgr-2m">0x113e8a1 in main (runtime_shlExact_overflow.zig)</span>
    const y = @shlExact(x, 2);
    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(进程被信号终止)
</samp></pre></figure>

      
      <h3 id="Exact-Right-Shift-Overflow"><a href="https://ziglang.org/documentation/0.15.2/#toc-Exact-Right-Shift-Overflow">精确右移溢出</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Exact-Right-Shift-Overflow">§</a></h3>

      <p>在编译时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_shrExact_overflow.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> x = <span class="tok-builtin">@shrExact</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0b10101010</span>), <span class="tok-number">2</span>);
    _ = x;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_shrExact_overflow.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_shrExact_overflow.zig:2:15: </span><span class="sgr-31m">error: </span><span class="sgr-1m">精确移位移出了 1 位
</span>    const x = @shrExact(@as(u8, 0b10101010), 2);
              <span class="sgr-32m">^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>在运行时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_shrExact_overflow.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">"builtin"</span>);
<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">u8</span> = <span class="tok-number">0b10101010</span>; <span class="tok-comment">// 运行时已知</span>
    _ = &amp;x;
    <span class="tok-kw">const</span> y = <span class="tok-builtin">@shrExact</span>(x, <span class="tok-number">2</span>);
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{y});

    <span class="tok-kw">if</span> (builtin.cpu.arch.isRISCV() <span class="tok-kw">and</span> builtin.zig_backend == .stage2_llvm) <span class="tok-builtin">@panic</span>(<span class="tok-str">"https://github.com/ziglang/zig/issues/24304"</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_shrExact_overflow.zig</kbd>
$ <kbd>./runtime_shrExact_overflow</kbd>
thread 2897712 panic: 右移溢出位
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_shrExact_overflow.zig:7:5</span>: <span class="sgr-2m">0x113e88a in main (runtime_shrExact_overflow.zig)</span>
    const y = @shrExact(x, 2);
    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(进程被信号终止)
</samp></pre></figure>

      
      <h3 id="Division-by-Zero"><a href="https://ziglang.org/documentation/0.15.2/#toc-Division-by-Zero">除以零</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Division-by-Zero">§</a></h3>

      <p>在编译时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_division_by_zero.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> c = a / b;
    _ = c;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_division_by_zero.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_division_by_zero.zig:4:19: </span><span class="sgr-31m">error: </span><span class="sgr-1m">此处除以零导致非法行为
</span>    const c = a / b;
                  <span class="sgr-32m">^
</span>
</samp></pre></figure>

      <p>在运行时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_division_by_zero.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u32</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">var</span> b: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    _ = .{ &amp;a, &amp;b };
    <span class="tok-kw">const</span> c = a / b;
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{c});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_division_by_zero.zig</kbd>
$ <kbd>./runtime_division_by_zero</kbd>
thread 2902461 panic: 除以零
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_division_by_zero.zig:7:17</span>: <span class="sgr-2m">0x113e890 in main (runtime_division_by_zero.zig)</span>
    const c = a / b;
                <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(进程被信号终止)
</samp></pre></figure>

      
      <h3 id="Remainder-Division-by-Zero"><a href="https://ziglang.org/documentation/0.15.2/#toc-Remainder-Division-by-Zero">取余除以零</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Remainder-Division-by-Zero">§</a></h3>

      <p>在编译时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_remainder_division_by_zero.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">i32</span> = <span class="tok-number">10</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> c = a % b;
    _ = c;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_remainder_division_by_zero.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_remainder_division_by_zero.zig:4:19: </span><span class="sgr-31m">error: </span><span class="sgr-1m">此处除以零导致非法行为
</span>    const c = a % b;
                  <span class="sgr-32m">^
</span>
</samp></pre></figure>

      <p>在运行时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_remainder_division_by_zero.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u32</span> = <span class="tok-number">10</span>;
    <span class="tok-kw">var</span> b: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    _ = .{ &amp;a, &amp;b };
    <span class="tok-kw">const</span> c = a % b;
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{c});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_remainder_division_by_zero.zig</kbd>
$ <kbd>./runtime_remainder_division_by_zero</kbd>
thread 2899727 panic: 除以零
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_remainder_division_by_zero.zig:7:17</span>: <span class="sgr-2m">0x113e890 in main (runtime_remainder_division_by_zero.zig)</span>
    const c = a % b;
                <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(进程被信号终止)
</samp></pre></figure>

      
      <h3 id="Exact-Division-Remainder"><a href="https://ziglang.org/documentation/0.15.2/#toc-Exact-Division-Remainder">精确除法余数</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Exact-Division-Remainder">§</a></h3>

      <p>在编译时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_divExact_remainder.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">u32</span> = <span class="tok-number">10</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">u32</span> = <span class="tok-number">3</span>;
    <span class="tok-kw">const</span> c = <span class="tok-builtin">@divExact</span>(a, b);
    _ = c;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_divExact_remainder.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_divExact_remainder.zig:4:15: </span><span class="sgr-31m">error: </span><span class="sgr-1m">精确除法产生了余数
</span>    const c = @divExact(a, b);
              <span class="sgr-32m">^~~~~~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>在运行时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_divExact_remainder.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u32</span> = <span class="tok-number">10</span>;
    <span class="tok-kw">var</span> b: <span class="tok-type">u32</span> = <span class="tok-number">3</span>;
    _ = .{ &amp;a, &amp;b };
    <span class="tok-kw">const</span> c = <span class="tok-builtin">@divExact</span>(a, b);
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{c});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_divExact_remainder.zig</kbd>
$ <kbd>./runtime_divExact_remainder</kbd>
thread 2901529 panic: 精确除法产生了余数
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_divExact_remainder.zig:7:15</span>: <span class="sgr-2m">0x113e8c7 in main (runtime_divExact_remainder.zig)</span>
    const c = @divExact(a, b);
              <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(进程被信号终止)
</samp></pre></figure>

      
      <h3 id="Attempt-to-Unwrap-Null"><a href="https://ziglang.org/documentation/0.15.2/#toc-Attempt-to-Unwrap-Null">尝试解包空值</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Attempt-to-Unwrap-Null">§</a></h3>

      <p>在编译时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_unwrap_null.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> optional_number: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> number = optional_number.?;
    _ = number;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_unwrap_null.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_unwrap_null.zig:3:35: </span><span class="sgr-31m">error: </span><span class="sgr-1m">无法解包空值
</span>    const number = optional_number.?;
                   <span class="sgr-32m">~~~~~~~~~~~~~~~^~
</span>
</samp></pre></figure>

      <p>在运行时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_unwrap_null.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> optional_number: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>;
    _ = &amp;optional_number;
    <span class="tok-kw">const</span> number = optional_number.?;
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{number});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_unwrap_null.zig</kbd>
$ <kbd>./runtime_unwrap_null</kbd>
thread 2892887 panic: 尝试使用空值
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_unwrap_null.zig:6:35</span>: <span class="sgr-2m">0x113e8b4 in main (runtime_unwrap_null.zig)</span>
    const number = optional_number.?;
                                  <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(进程被信号终止)
</samp></pre></figure>

      <p>避免这种崩溃的一种方法是测试空值而不是假设非空,使用 <code><span class="tok-kw">if</span></code> 表达式:</p>
      <figure><figcaption class="zig-cap"><cite class="file">testing_null_with_if.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> optional_number: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>;

    <span class="tok-kw">if</span> (optional_number) |number| {
        print(<span class="tok-str">"得到数字: {}\n"</span>, .{number});
    } <span class="tok-kw">else</span> {
        print(<span class="tok-str">"是空值\n"</span>, .{});
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe testing_null_with_if.zig</kbd>
$ <kbd>./testing_null_with_if</kbd>
是空值
</samp></pre></figure>

      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Optionals">可选类型</a></li>
</ul>

      
      <h3 id="Attempt-to-Unwrap-Error"><a href="https://ziglang.org/documentation/0.15.2/#toc-Attempt-to-Unwrap-Error">尝试解包错误</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Attempt-to-Unwrap-Error">§</a></h3>

      <p>在编译时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_unwrap_error.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> number = getNumberOrFail() <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    _ = number;
}

<span class="tok-kw">fn</span> <span class="tok-fn">getNumberOrFail</span>() !<span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReturnNumber;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_unwrap_error.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_unwrap_error.zig:2:44: </span><span class="sgr-31m">error: </span><span class="sgr-1m">捕获到意外错误 'UnableToReturnNumber'
</span>    const number = getNumberOrFail() catch unreachable;
                                           <span class="sgr-32m">^~~~~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_unwrap_error.zig:7:18: </span><span class="sgr-36m">note: </span><span class="sgr-1m">错误在此返回
</span>    return error.UnableToReturnNumber;
                 <span class="sgr-32m">^~~~~~~~~~~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>在运行时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_unwrap_error.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> number = getNumberOrFail() <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{number});
}

<span class="tok-kw">fn</span> <span class="tok-fn">getNumberOrFail</span>() !<span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReturnNumber;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_unwrap_error.zig</kbd>
$ <kbd>./runtime_unwrap_error</kbd>
thread 2895126 panic: 尝试解包错误: UnableToReturnNumber
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_unwrap_error.zig:9:5</span>: <span class="sgr-2m">0x113e86c in getNumberOrFail (runtime_unwrap_error.zig)</span>
    return error.UnableToReturnNumber;
    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_unwrap_error.zig:4:44</span>: <span class="sgr-2m">0x113e8d3 in main (runtime_unwrap_error.zig)</span>
    const number = getNumberOrFail() catch unreachable;
                                           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(进程被信号终止)
</samp></pre></figure>

      <p>避免这种崩溃的一种方法是测试错误而不是假设成功结果,使用 <code><span class="tok-kw">if</span></code> 表达式:</p>
      <figure><figcaption class="zig-cap"><cite class="file">testing_error_with_if.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).debug.print;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = getNumberOrFail();

    <span class="tok-kw">if</span> (result) |number| {
        print(<span class="tok-str">"得到数字: {}\n"</span>, .{number});
    } <span class="tok-kw">else</span> |err| {
        print(<span class="tok-str">"得到错误: {s}\n"</span>, .{<span class="tok-builtin">@errorName</span>(err)});
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">getNumberOrFail</span>() !<span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReturnNumber;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe testing_error_with_if.zig</kbd>
$ <kbd>./testing_error_with_if</kbd>
得到错误: UnableToReturnNumber
</samp></pre></figure>

      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Errors">错误</a></li>
</ul>

      
      <h3 id="Invalid-Error-Code"><a href="https://ziglang.org/documentation/0.15.2/#toc-Invalid-Error-Code">无效的错误代码</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Invalid-Error-Code">§</a></h3>

      <p>在编译时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_invalid_error_code.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> err = <span class="tok-kw">error</span>.AnError;
    <span class="tok-kw">const</span> number = <span class="tok-builtin">@intFromError</span>(err) + <span class="tok-number">10</span>;
    <span class="tok-kw">const</span> invalid_err = <span class="tok-builtin">@errorFromInt</span>(number);
    _ = invalid_err;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_invalid_error_code.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_invalid_error_code.zig:4:39: </span><span class="sgr-31m">error: </span><span class="sgr-1m">整数值 '11' 不代表任何错误
</span>    const invalid_err = @errorFromInt(number);
                                      <span class="sgr-32m">^~~~~~
</span>
</samp></pre></figure>

      <p>在运行时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_invalid_error_code.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> err = <span class="tok-kw">error</span>.AnError;
    <span class="tok-kw">var</span> number = <span class="tok-builtin">@intFromError</span>(err) + <span class="tok-number">500</span>;
    _ = &amp;number;
    <span class="tok-kw">const</span> invalid_err = <span class="tok-builtin">@errorFromInt</span>(number);
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{invalid_err});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_invalid_error_code.zig</kbd>
$ <kbd>./runtime_invalid_error_code</kbd>
thread 2900570 panic: 无效的错误代码
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_invalid_error_code.zig:7:5</span>: <span class="sgr-2m">0x113e8a7 in main (runtime_invalid_error_code.zig)</span>
    const invalid_err = @errorFromInt(number);
    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(进程被信号终止)
</samp></pre></figure>

      
      <h3 id="Invalid-Enum-Cast"><a href="https://ziglang.org/documentation/0.15.2/#toc-Invalid-Enum-Cast">无效的枚举转换</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Invalid-Enum-Cast">§</a></h3>

      <p>在编译时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_invalid_enum_cast.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Foo = <span class="tok-kw">enum</span> {
    a,
    b,
    c,
};
<span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">u2</span> = <span class="tok-number">3</span>;
    <span class="tok-kw">const</span> b: Foo = <span class="tok-builtin">@enumFromInt</span>(a);
    _ = b;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_invalid_enum_cast.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_invalid_enum_cast.zig:8:20: </span><span class="sgr-31m">error: </span><span class="sgr-1m">枚举 'test_comptime_invalid_enum_cast.Foo' 没有值为 '3' 的标签
</span>    const b: Foo = @enumFromInt(a);
                   <span class="sgr-32m">^~~~~~~~~~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_invalid_enum_cast.zig:1:13: </span><span class="sgr-36m">note: </span><span class="sgr-1m">枚举在此声明
</span>const Foo = enum {
            <span class="sgr-32m">^~~~
</span>
</samp></pre></figure>

      <p>在运行时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_invalid_enum_cast.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">const</span> Foo = <span class="tok-kw">enum</span> {
    a,
    b,
    c,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u2</span> = <span class="tok-number">3</span>;
    _ = &amp;a;
    <span class="tok-kw">const</span> b: Foo = <span class="tok-builtin">@enumFromInt</span>(a);
    std.debug.print(<span class="tok-str">"value: {s}\n"</span>, .{<span class="tok-builtin">@tagName</span>(b)});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_invalid_enum_cast.zig</kbd>
$ <kbd>./runtime_invalid_enum_cast</kbd>
thread 2902395 panic: 无效的枚举值
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_invalid_enum_cast.zig:12:20</span>: <span class="sgr-2m">0x113e8f0 in main (runtime_invalid_enum_cast.zig)</span>
    const b: Foo = @enumFromInt(a);
                   <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(进程被信号终止)
</samp></pre></figure>

      

      <h3 id="Invalid-Error-Set-Cast"><a href="https://ziglang.org/documentation/0.15.2/#toc-Invalid-Error-Set-Cast">无效的错误集转换</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Invalid-Error-Set-Cast">§</a></h3>

      <p>在编译时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_invalid_error_set_cast.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Set1 = <span class="tok-kw">error</span>{
    A,
    B,
};
<span class="tok-kw">const</span> Set2 = <span class="tok-kw">error</span>{
    A,
    C,
};
<span class="tok-kw">comptime</span> {
    _ = <span class="tok-builtin">@as</span>(Set2, <span class="tok-builtin">@errorCast</span>(Set1.B));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_invalid_error_set_cast.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_invalid_error_set_cast.zig:10:19: </span><span class="sgr-31m">error: </span><span class="sgr-1m">'error.B' 不是错误集 'error{A,C}' 的成员
</span>    _ = @as(Set2, @errorCast(Set1.B));
                  <span class="sgr-32m">^~~~~~~~~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>在运行时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_invalid_error_set_cast.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">const</span> Set1 = <span class="tok-kw">error</span>{
    A,
    B,
};
<span class="tok-kw">const</span> Set2 = <span class="tok-kw">error</span>{
    A,
    C,
};
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    foo(Set1.B);
}
<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(set1: Set1) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> x: Set2 = <span class="tok-builtin">@errorCast</span>(set1);
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{x});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_invalid_error_set_cast.zig</kbd>
$ <kbd>./runtime_invalid_error_set_cast</kbd>
thread 2900078 panic: 无效的错误代码
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_invalid_error_set_cast.zig:15:21</span>: <span class="sgr-2m">0x113fb3c in foo (runtime_invalid_error_set_cast.zig)</span>
    const x: Set2 = @errorCast(set1);
                    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_invalid_error_set_cast.zig:12:8</span>: <span class="sgr-2m">0x113e877 in main (runtime_invalid_error_set_cast.zig)</span>
    foo(Set1.B);
       <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(进程被信号终止)
</samp></pre></figure>

      

      <h3 id="Incorrect-Pointer-Alignment"><a href="https://ziglang.org/documentation/0.15.2/#toc-Incorrect-Pointer-Alignment">不正确的指针对齐</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Incorrect-Pointer-Alignment">§</a></h3>

      <p>在编译时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_incorrect_pointer_alignment.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> ptr: *<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-type">i32</span> = <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-number">0x1</span>);
    <span class="tok-kw">const</span> aligned: *<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">i32</span> = <span class="tok-builtin">@alignCast</span>(ptr);
    _ = aligned;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_incorrect_pointer_alignment.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_incorrect_pointer_alignment.zig:3:47: </span><span class="sgr-31m">error: </span><span class="sgr-1m">指针地址 0x1 未对齐到 4 字节
</span>    const aligned: *align(4) i32 = @alignCast(ptr);
                                              <span class="sgr-32m">^~~
</span>
</samp></pre></figure>

      <p>在运行时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_incorrect_pointer_alignment.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).mem;
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> array <span class="tok-kw">align</span>(<span class="tok-number">4</span>) = [_]<span class="tok-type">u32</span>{ <span class="tok-number">0x11111111</span>, <span class="tok-number">0x11111111</span> };
    <span class="tok-kw">const</span> bytes = mem.sliceAsBytes(array[<span class="tok-number">0</span>..]);
    <span class="tok-kw">if</span> (foo(bytes) != <span class="tok-number">0x11111111</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Wrong;
}
<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(bytes: []<span class="tok-type">u8</span>) <span class="tok-type">u32</span> {
    <span class="tok-kw">const</span> slice4 = bytes[<span class="tok-number">1</span>..<span class="tok-number">5</span>];
    <span class="tok-kw">const</span> int_slice = mem.bytesAsSlice(<span class="tok-type">u32</span>, <span class="tok-builtin">@as</span>([]<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">u8</span>, <span class="tok-builtin">@alignCast</span>(slice4)));
    <span class="tok-kw">return</span> int_slice[<span class="tok-number">0</span>];
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_incorrect_pointer_alignment.zig</kbd>
$ <kbd>./runtime_incorrect_pointer_alignment</kbd>
thread 2897041 panic: 不正确的对齐
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_incorrect_pointer_alignment.zig:9:64</span>: <span class="sgr-2m">0x113ec08 in foo (runtime_incorrect_pointer_alignment.zig)</span>
    const int_slice = mem.bytesAsSlice(u32, @as([]align(4) u8, @alignCast(slice4)));
                                                               <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_incorrect_pointer_alignment.zig:5:12</span>: <span class="sgr-2m">0x113d3f2 in main (runtime_incorrect_pointer_alignment.zig)</span>
    if (foo(bytes) != 0x11111111) return error.Wrong;
           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:627:37</span>: <span class="sgr-2m">0x113dbc9 in posixCallMainAndExit (std.zig)</span>
            const result = root.main() catch |err| {
                                    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(进程被信号终止)
</samp></pre></figure>

      
      <h3 id="Wrong-Union-Field-Access"><a href="https://ziglang.org/documentation/0.15.2/#toc-Wrong-Union-Field-Access">错误的联合体字段访问</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Wrong-Union-Field-Access">§</a></h3>

      <p>在编译时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_wrong_union_field_access.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">var</span> f = Foo{ .int = <span class="tok-number">42</span> };
    f.float = <span class="tok-number">12.34</span>;
}

<span class="tok-kw">const</span> Foo = <span class="tok-kw">union</span> {
    float: <span class="tok-type">f32</span>,
    int: <span class="tok-type">u32</span>,
};</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_wrong_union_field_access.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_wrong_union_field_access.zig:3:6: </span><span class="sgr-31m">error: </span><span class="sgr-1m">字段 'int' 处于活动状态时访问联合体字段 'float'
</span>    f.float = 12.34;
    <span class="sgr-32m">~^~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_wrong_union_field_access.zig:6:13: </span><span class="sgr-36m">note: </span><span class="sgr-1m">联合体在此声明
</span>const Foo = union {
            <span class="sgr-32m">^~~~~
</span>
</samp></pre></figure>

      <p>在运行时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_wrong_union_field_access.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">const</span> Foo = <span class="tok-kw">union</span> {
    float: <span class="tok-type">f32</span>,
    int: <span class="tok-type">u32</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> f = Foo{ .int = <span class="tok-number">42</span> };
    bar(&amp;f);
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>(f: *Foo) <span class="tok-type">void</span> {
    f.float = <span class="tok-number">12.34</span>;
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{f.float});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_wrong_union_field_access.zig</kbd>
$ <kbd>./runtime_wrong_union_field_access</kbd>
thread 2901950 panic: 字段 'int' 处于活动状态时访问联合体字段 'float'
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_wrong_union_field_access.zig:14:6</span>: <span class="sgr-2m">0x113fb1e in bar (runtime_wrong_union_field_access.zig)</span>
    f.float = 12.34;
     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_wrong_union_field_access.zig:10:8</span>: <span class="sgr-2m">0x113e89f in main (runtime_wrong_union_field_access.zig)</span>
    bar(&amp;f);
       <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(进程被信号终止)
</samp></pre></figure>

      <p>
      此安全性不适用于 <code><span class="tok-kw">extern</span></code> 或 <code><span class="tok-kw">packed</span></code> 联合体。
      </p>
      <p>
      要更改联合体的活动字段,请像这样赋值整个联合体:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">change_active_union_field.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">const</span> Foo = <span class="tok-kw">union</span> {
    float: <span class="tok-type">f32</span>,
    int: <span class="tok-type">u32</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> f = Foo{ .int = <span class="tok-number">42</span> };
    bar(&amp;f);
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>(f: *Foo) <span class="tok-type">void</span> {
    f.* = Foo{ .float = <span class="tok-number">12.34</span> };
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{f.float});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe change_active_union_field.zig</kbd>
$ <kbd>./change_active_union_field</kbd>
value: 12.34
</samp></pre></figure>

      <p>
      当字段的有意义的值未知时,要更改联合体的活动字段,请使用 <a href="https://ziglang.org/documentation/0.15.2/#undefined">undefined</a>,像这样:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">undefined_active_union_field.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">const</span> Foo = <span class="tok-kw">union</span> {
    float: <span class="tok-type">f32</span>,
    int: <span class="tok-type">u32</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> f = Foo{ .int = <span class="tok-number">42</span> };
    f = Foo{ .float = <span class="tok-null">undefined</span> };
    bar(&amp;f);
    std.debug.print(<span class="tok-str">"value: {}\n"</span>, .{f.float});
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>(f: *Foo) <span class="tok-type">void</span> {
    f.float = <span class="tok-number">12.34</span>;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe undefined_active_union_field.zig</kbd>
$ <kbd>./undefined_active_union_field</kbd>
value: 12.34
</samp></pre></figure>

      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#union">union</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#extern-union">extern union</a></li>
</ul>

      

      <h3 id="Out-of-Bounds-Float-to-Integer-Cast"><a href="https://ziglang.org/documentation/0.15.2/#toc-Out-of-Bounds-Float-to-Integer-Cast">浮点数转整数越界</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Out-of-Bounds-Float-to-Integer-Cast">§</a></h3>

      <p>
      当浮点数转换为整数时,如果浮点数的值超出整数类型的范围,就会发生这种情况。
      </p>
      <p>在编译时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_out_of_bounds_float_to_integer_cast.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> float: <span class="tok-type">f32</span> = <span class="tok-number">4294967296</span>;
    <span class="tok-kw">const</span> int: <span class="tok-type">i32</span> = <span class="tok-builtin">@intFromFloat</span>(float);
    _ = int;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_out_of_bounds_float_to_integer_cast.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_out_of_bounds_float_to_integer_cast.zig:3:36: </span><span class="sgr-31m">error: </span><span class="sgr-1m">浮点值 '4294967296' 无法存储在整数类型 'i32' 中
</span>    const int: i32 = @intFromFloat(float);
                                   <span class="sgr-32m">^~~~~
</span>
</samp></pre></figure>

      <p>在运行时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_out_of_bounds_float_to_integer_cast.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> float: <span class="tok-type">f32</span> = <span class="tok-number">4294967296</span>; <span class="tok-comment">// 运行时已知</span>
    _ = &amp;float;
    <span class="tok-kw">const</span> int: <span class="tok-type">i32</span> = <span class="tok-builtin">@intFromFloat</span>(float);
    _ = int;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_out_of_bounds_float_to_integer_cast.zig</kbd>
$ <kbd>./runtime_out_of_bounds_float_to_integer_cast</kbd>
thread 2898584 panic: 浮点值的整数部分超出范围
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_out_of_bounds_float_to_integer_cast.zig:4:22</span>: <span class="sgr-2m">0x113e8d2 in main (runtime_out_of_bounds_float_to_integer_cast.zig)</span>
    const int: i32 = @intFromFloat(float);
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(进程被信号终止)
</samp></pre></figure>
<!-- ====== END CHUNK 12: new_12.html ====== -->

<!-- ====== BEGIN CHUNK 13: new_13.html ====== -->
<h3 id="Pointer-Cast-Invalid-Null"><a href="https://ziglang.org/documentation/0.15.2/#toc-Pointer-Cast-Invalid-Null">指针转换无效空值</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Pointer-Cast-Invalid-Null">§</a></h3>

      <p>
      当将地址为 0 的指针转换为不允许地址为 0 的指针时会发生这种情况。
      例如,<a href="https://ziglang.org/documentation/0.15.2/#C-Pointers">C 指针</a>、<a href="https://ziglang.org/documentation/0.15.2/#Optional-Pointers">可选指针</a>和 <a href="https://ziglang.org/documentation/0.15.2/#allowzero">allowzero</a> 指针
      允许地址为零,但普通的<a href="https://ziglang.org/documentation/0.15.2/#Pointers">指针</a>不允许。
      </p>
      <p>在编译期:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_invalid_null_pointer_cast.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> opt_ptr: ?*<span class="tok-type">i32</span> = <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> ptr: *<span class="tok-type">i32</span> = <span class="tok-builtin">@ptrCast</span>(opt_ptr);
    _ = ptr;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_invalid_null_pointer_cast.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_comptime_invalid_null_pointer_cast.zig:3:32: </span><span class="sgr-31m">error: </span><span class="sgr-1m">null pointer casted to type '*i32'
</span>    const ptr: *i32 = @ptrCast(opt_ptr);
                               <span class="sgr-32m">^~~~~~~
</span>
</samp></pre></figure>

      <p>在运行时:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_invalid_null_pointer_cast.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> opt_ptr: ?*<span class="tok-type">i32</span> = <span class="tok-null">null</span>;
    _ = &amp;opt_ptr;
    <span class="tok-kw">const</span> ptr: *<span class="tok-type">i32</span> = <span class="tok-builtin">@ptrCast</span>(opt_ptr);
    _ = ptr;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_invalid_null_pointer_cast.zig</kbd>
$ <kbd>./runtime_invalid_null_pointer_cast</kbd>
thread 2892939 panic: cast causes pointer to be null
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/runtime_invalid_null_pointer_cast.zig:4:23</span>: <span class="sgr-2m">0x113e88a in main (runtime_invalid_null_pointer_cast.zig)</span>
    const ptr: *i32 = @ptrCast(opt_ptr);
                      <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:618:22</span>: <span class="sgr-2m">0x113dabd in posixCallMainAndExit (std.zig)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/dev/zig/lib/std/start.zig:232:5</span>: <span class="sgr-2m">0x113d351 in _start (std.zig)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      

      
      <h2 id="Memory"><a href="https://ziglang.org/documentation/0.15.2/#toc-Memory">内存</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Memory">§</a></h2>

      <p>
      Zig 语言不代表程序员执行任何内存管理。这就是为什么 Zig 没有运行时,以及为什么 Zig 代码可以在如此多的环境中无缝工作,包括实时软件、操作系统内核、嵌入式设备和低延迟服务器。因此,Zig 程序员必须始终能够回答这个问题:
      </p>
      <p><a href="https://ziglang.org/documentation/0.15.2/#Where-are-the-bytes">字节在哪里?</a></p>
      <p>
      与 Zig 一样,C 编程语言具有手动内存管理。但是,与 Zig 不同,C 有一个默认分配器 - <code>malloc</code>、<code>realloc</code> 和 <code>free</code>。
      当链接 libc 时,Zig 通过 <code>std.heap.c_allocator</code> 公开此分配器。
      但是,按照惯例,Zig 中没有默认分配器。相反,需要分配内存的函数接受一个 <code>Allocator</code> 参数。同样,一些数据结构在其初始化函数中接受 <code>Allocator</code> 参数:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_allocator.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> Allocator = std.mem.Allocator;
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">"using an allocator"</span> {
    <span class="tok-kw">var</span> buffer: [<span class="tok-number">100</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> fba = std.heap.FixedBufferAllocator.init(&amp;buffer);
    <span class="tok-kw">const</span> allocator = fba.allocator();
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> concat(allocator, <span class="tok-str">"foo"</span>, <span class="tok-str">"bar"</span>);
    <span class="tok-kw">try</span> expect(std.mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">"foobar"</span>, result));
}

<span class="tok-kw">fn</span> <span class="tok-fn">concat</span>(allocator: Allocator, a: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, b: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, a.len + b.len);
    <span class="tok-builtin">@memcpy</span>(result[<span class="tok-number">0</span>..a.len], a);
    <span class="tok-builtin">@memcpy</span>(result[a.len..], b);
    <span class="tok-kw">return</span> result;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_allocator.zig</kbd>
1/1 test_allocator.test.using an allocator...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      在上面的示例中,100 字节的栈内存用于初始化 <code>FixedBufferAllocator</code>,然后将其传递给函数。
      为了方便起见,在 <code>std.testing.allocator</code> 有一个全局 <code>FixedBufferAllocator</code> 可用于快速测试,它还将执行基本的泄漏检测。
      </p>
      <p>
      Zig 有一个通用的分配器可以通过 <code>std.heap.GeneralPurposeAllocator</code> 导入。但是,仍然建议遵循<a href="https://ziglang.org/documentation/0.15.2/#Choosing-an-Allocator">选择分配器</a>指南。
      </p>

      <h3 id="Choosing-an-Allocator"><a href="https://ziglang.org/documentation/0.15.2/#toc-Choosing-an-Allocator">选择分配器</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Choosing-an-Allocator">§</a></h3>

      <p>使用什么分配器取决于许多因素。这里有一个流程图可以帮助你决定:
      </p>
      <ol>
          <li>
              你在创建一个库吗?在这种情况下,最好接受一个 <code>Allocator</code> 作为参数,并允许库的用户决定使用什么分配器。
          </li>
          <li>你在链接 libc 吗?在这种情况下,<code>std.heap.c_allocator</code> 可能是正确的选择,至少对于你的主分配器来说是这样。</li>
          <li>
              你需要的最大字节数是否由在<a href="https://ziglang.org/documentation/0.15.2/#comptime">编译期</a>已知的数字限定?在这种情况下,使用 <code>std.heap.FixedBufferAllocator</code>。
          </li>
          <li>
              你的程序是一个命令行应用程序,它从头到尾运行,没有任何基本的循环模式(例如视频游戏主循环或 Web 服务器请求处理程序),以至于在最后一次性释放所有内容是有意义的吗?
              在这种情况下,建议遵循此模式:
              <figure><figcaption class="zig-cap"><cite class="file">cli_allocation.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    <span class="tok-kw">defer</span> arena.deinit();

    <span class="tok-kw">const</span> allocator = arena.allocator();

    <span class="tok-kw">const</span> ptr = <span class="tok-kw">try</span> allocator.create(<span class="tok-type">i32</span>);
    std.debug.print(<span class="tok-str">"ptr={*}\n"</span>, .{ptr});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe cli_allocation.zig</kbd>
$ <kbd>./cli_allocation</kbd>
ptr=i32@7f1a3ed8e010
</samp></pre></figure>

              当使用这种分配器时,不需要手动释放任何东西。一切都通过调用 <code>arena.deinit()</code> 一次性释放。
          </li>
          <li>
              分配是否是循环模式的一部分,例如视频游戏主循环或 Web 服务器请求处理程序?如果可以在循环结束时一次性释放所有分配,例如一旦视频游戏帧已完全渲染,或者 Web 服务器请求已得到服务,那么 <code>std.heap.ArenaAllocator</code> 是一个很好的候选者。如前面的项目符号所示,这允许你一次释放整个 arena。
              还要注意,如果可以建立内存的上限,那么 <code>std.heap.FixedBufferAllocator</code> 可以用作进一步的优化。
          </li>
          <li>
              你在编写测试,并且想要确保正确处理 <code><span class="tok-kw">error</span>.OutOfMemory</code>?在这种情况下,使用 <code>std.testing.FailingAllocator</code>。
          </li>
          <li>
              你在编写测试吗?在这种情况下,使用 <code>std.testing.allocator</code>。
          </li>
          <li>
              最后,如果上述情况都不适用,你需要一个通用的分配器。
              如果你处于 Debug 模式,<code>std.heap.DebugAllocator</code> 可用作一个函数,该函数接受一个<a href="https://ziglang.org/documentation/0.15.2/#comptime">编译期</a> <a href="https://ziglang.org/documentation/0.15.2/#struct">结构体</a>的配置选项并返回一个类型。
              通常,你将在主函数中恰好设置一个,然后将其或子分配器传递给应用程序的各个部分。
          </li>
          <li>
              如果你在 ReleaseFast 模式下编译,<code>std.heap.smp_allocator</code> 是通用分配器的可靠选择。
          </li>
          <li>
              你也可以考虑实现一个分配器。
          </li>
      </ol>
      

      <h3 id="Where-are-the-bytes"><a href="https://ziglang.org/documentation/0.15.2/#toc-Where-are-the-bytes">字节在哪里?</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Where-are-the-bytes">§</a></h3>

      <p>诸如 <code><span class="tok-str">"hello"</span></code> 之类的字符串字面量位于全局常量数据段中。
      这就是为什么将字符串字面量传递给可变切片会出错,如下所示:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_string_literal_to_slice.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(s: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    _ = s;
}

<span class="tok-kw">test</span> <span class="tok-str">"string literal to mutable slice"</span> {
    foo(<span class="tok-str">"hello"</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_string_literal_to_slice.zig</kbd>
<span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_string_literal_to_slice.zig:6:9: </span><span class="sgr-31m">error: </span><span class="sgr-1m">expected type '[]u8', found '*const [5:0]u8'
</span>    foo("hello");
        <span class="sgr-32m">^~~~~~~
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_string_literal_to_slice.zig:6:9: </span><span class="sgr-36m">note: </span><span class="sgr-1m">cast discards const qualifier
</span><span class="sgr-1m">/home/andy/dev/zig/doc/langref/test_string_literal_to_slice.zig:1:11: </span><span class="sgr-36m">note: </span><span class="sgr-1m">parameter type declared here
</span>fn foo(s: []u8) void {
          <span class="sgr-32m">^~~~
</span>
</samp></pre></figure>

      <p>但是,如果你将切片设为常量,那么它就可以工作:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_string_literal_to_const_slice.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(s: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    _ = s;
}

<span class="tok-kw">test</span> <span class="tok-str">"string literal to constant slice"</span> {
    foo(<span class="tok-str">"hello"</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_string_literal_to_const_slice.zig</kbd>
1/1 test_string_literal_to_const_slice.test.string literal to constant slice...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      就像字符串字面量一样,当值在<a href="https://ziglang.org/documentation/0.15.2/#comptime">编译期</a>已知时,<code><span class="tok-kw">const</span></code> 声明存储在全局常量数据段中。此外,<a href="https://ziglang.org/documentation/0.15.2/#Compile-Time-Variables">编译期变量</a>也存储在全局常量数据段中。
      </p>
      <p>
      函数内的 <code><span class="tok-kw">var</span></code> 声明存储在函数的栈帧中。一旦函数返回,任何指向函数栈帧中变量的<a href="https://ziglang.org/documentation/0.15.2/#Pointers">指针</a>都会成为无效引用,取消引用它们会成为未经检查的<a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>。
      </p>
      <p>
      顶层或<a href="https://ziglang.org/documentation/0.15.2/#struct">结构体</a>声明中的 <code><span class="tok-kw">var</span></code> 声明存储在全局数据段中。
      </p>
      <p>
      使用 <code>allocator.alloc</code> 或 <code>allocator.create</code> 分配的内存的位置由分配器的实现确定。
      </p>
      <p>TODO: 线程局部变量</p>
      

      <h3 id="Heap-Allocation-Failure"><a href="https://ziglang.org/documentation/0.15.2/#toc-Heap-Allocation-Failure">堆分配失败</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Heap-Allocation-Failure">§</a></h3>

      <p>
      许多编程语言选择通过无条件崩溃来处理堆分配失败的可能性。按照惯例,Zig 程序员不认为这是一个令人满意的解决方案。相反,<code><span class="tok-kw">error</span>.OutOfMemory</code> 表示堆分配失败,并且当堆分配失败阻止操作成功完成时,Zig 库会返回此错误代码。
      </p>
      <p>
      有些人认为,由于某些操作系统(如 Linux)默认启用了内存过度提交,因此处理堆分配失败是毫无意义的。这种推理有许多问题:
      </p>
      <ul>
          <li>只有某些操作系统具有过度提交功能。
              <ul>
                  <li>Linux 默认启用它,但它是可配置的。</li>
                  <li>Windows 不会过度提交。</li>
                  <li>嵌入式系统没有过度提交。</li>
                  <li>业余操作系统可能有或没有过度提交。</li>
              </ul>
          </li>
          <li>
              对于实时系统,不仅没有过度提交,而且通常每个应用程序的最大内存量是提前确定的。
          </li>
          <li>
              在编写库时,主要目标之一是代码重用。通过使代码正确处理分配失败,库就有资格在更多环境中重用。
          </li>
          <li>
              尽管某些软件已经开始依赖启用过度提交,但它的存在是无数用户体验灾难的根源。当启用过度提交的系统(如默认设置的 Linux)接近内存耗尽时,系统会锁定并变得无法使用。此时,OOM Killer 根据启发式算法选择要杀死的应用程序。这种非确定性决定通常会导致重要进程被杀死,并且通常无法使系统恢复到工作状态。
          </li>
      </ul>
      

      <h3 id="Recursion"><a href="https://ziglang.org/documentation/0.15.2/#toc-Recursion">递归</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Recursion">§</a></h3>

      <p>
      递归是建模软件的基本工具。但是,它有一个经常被忽视的问题:无限内存分配。
      </p>
      <p>
      递归是 Zig 中活跃实验的领域,因此这里的文档并不是最终的。
      你可以在 <a href="https://ziglang.org/download/0.3.0/release-notes.html#recursion">0.3.0 发布说明中阅读递归状态摘要</a>。
      </p>
      <p>
      简短的摘要是,目前递归可以像你期望的那样正常工作。尽管 Zig 代码尚未受到栈溢出的保护,但计划在 Zig 的未来版本中提供此类保护,需要 Zig 代码进行一定程度的配合。
      </p>
      

      <h3 id="Lifetime-and-Ownership"><a href="https://ziglang.org/documentation/0.15.2/#toc-Lifetime-and-Ownership">生命周期和所有权</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Lifetime-and-Ownership">§</a></h3>

      <p>
      确保在指向的内存不再可用时不访问<a href="https://ziglang.org/documentation/0.15.2/#Pointers">指针</a>是 Zig 程序员的责任。注意,<a href="https://ziglang.org/documentation/0.15.2/#Slices">切片</a>是指针的一种形式,因为它引用其他内存。
      </p>
      <p>
      为了防止错误,在处理指针时遵循一些有用的约定。通常,当函数返回指针时,函数的文档应该解释谁"拥有"该指针。这个概念帮助程序员决定何时释放指针(如果有的话)是合适的。
      </p>
      <p>
      例如,函数的文档可能会说"调用者拥有返回的内存",在这种情况下,调用函数的代码必须有一个计划来决定何时释放该内存。在这种情况下,函数可能会接受一个 <code>Allocator</code> 参数。
      </p>
      <p>
      有时指针的生命周期可能更复杂。例如,<code>std.ArrayList(T).items</code> 切片的生命周期在列表下次调整大小之前保持有效,例如通过追加新元素。
      </p>
      <p>
      函数和数据结构的 API 文档应该非常注意解释指针的所有权和生命周期语义。所有权决定谁有责任释放指针引用的内存,生命周期决定内存变得不可访问的时间点(以免发生<a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>)。
      </p>
      

      
      <h2 id="Compile-Variables"><a href="https://ziglang.org/documentation/0.15.2/#toc-Compile-Variables">编译变量</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Compile-Variables">§</a></h2>

      <p>
      通过导入 <code><span class="tok-str">"builtin"</span></code> 包可以访问编译变量,编译器使该包对每个 Zig 源文件都可用。它包含编译时常量,例如当前目标、字节序和发布模式。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">compile_variables.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">"builtin"</span>);
<span class="tok-kw">const</span> separator = <span class="tok-kw">if</span> (builtin.os.tag == .windows) <span class="tok-str">'\\'</span> <span class="tok-kw">else</span> <span class="tok-str">'/'</span>;</code></pre></figure>

      <p>
      使用 <code><span class="tok-builtin">@import</span>(<span class="tok-str">"builtin"</span>)</code> 导入的内容示例:
      </p>
      <figure><figcaption class="zig-cap"><cite>@import("builtin")</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-comment">/// Zig 版本。在编写支持多个 Zig 版本的代码时,更倾向于</span>
<span class="tok-comment">/// 功能检测(即使用 `@hasDecl` 或 `@hasField`)而不是版本检查。</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> zig_version = std.SemanticVersion.parse(zig_version_string) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> zig_version_string = <span class="tok-str">"0.15.2"</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> zig_backend = std.builtin.CompilerBackend.stage2_x86_64;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> output_mode: std.builtin.OutputMode = .Exe;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> link_mode: std.builtin.LinkMode = .static;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> unwind_tables: std.builtin.UnwindTables = .async;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> is_test = <span class="tok-null">false</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> single_threaded = <span class="tok-null">false</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> abi: std.Target.Abi = .gnu;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> cpu: std.Target.Cpu = .{
    .arch = .x86_64,
    .model = &amp;std.Target.x86.cpu.znver4,
    .features = std.Target.x86.featureSet(&amp;.{
        .@"64bit",
        .adx,
        .aes,
        .allow_light_256_bit,
        .avx,
        .avx2,
        .avx512bf16,
        .avx512bitalg,
        .avx512bw,
        .avx512cd,
        .avx512dq,
        .avx512f,
        .avx512ifma,
        .avx512vbmi,
        .avx512vbmi2,
        .avx512vl,
        .avx512vnni,
        .avx512vpopcntdq,
        .bmi,
        .bmi2,
        .branchfusion,
        .clflushopt,
        .clwb,
        .clzero,
        .cmov,
        .crc32,
        .cx16,
        .cx8,
        .evex512,
        .f16c,
        .fast_15bytenop,
        .fast_bextr,
        .fast_dpwssd,
        .fast_imm16,
        .fast_lzcnt,
        .fast_movbe,
        .fast_scalar_fsqrt,
        .fast_scalar_shift_masks,
        .fast_variable_perlane_shuffle,
        .fast_vector_fsqrt,
        .fma,
        .fsgsbase,
        .fsrm,
        .fxsr,
        .gfni,
        .idivq_to_divl,
        .invpcid,
        .lzcnt,
        .macrofusion,
        .mmx,
        .movbe,
        .mwaitx,
        .nopl,
        .pclmul,
        .pku,
        .popcnt,
        .prfchw,
        .rdpid,
        .rdpru,
        .rdrnd,
        .rdseed,
        .sahf,
        .sbb_dep_breaking,
        .sha,
        .shstk,
        .slow_shld,
        .smap,
        .smep,
        .sse,
        .sse2,
        .sse3,
        .sse4_1,
        .sse4_2,
        .sse4a,
        .ssse3,
        .vaes,
        .vpclmulqdq,
        .vzeroupper,
        .wbnoinvd,
        .x87,
        .xsave,
        .xsavec,
        .xsaveopt,
        .xsaves,
    }),
};
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> os: std.Target.Os = .{
    .tag = .linux,
    .version_range = .{ .linux = .{
        .range = .{
            .min = .{
                .major = <span class="tok-number">6</span>,
                .minor = <span class="tok-number">16</span>,
                .patch = <span class="tok-number">0</span>,
            },
            .max = .{
                .major = <span class="tok-number">6</span>,
                .minor = <span class="tok-number">16</span>,
                .patch = <span class="tok-number">0</span>,
            },
        },
        .glibc = .{
            .major = <span class="tok-number">2</span>,
            .minor = <span class="tok-number">39</span>,
            .patch = <span class="tok-number">0</span>,
        },
        .android = <span class="tok-number">29</span>,
    }},
};
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> target: std.Target = .{
    .cpu = cpu,
    .os = os,
    .abi = abi,
    .ofmt = object_format,
    .dynamic_linker = .init(<span class="tok-str">"/nix/store/zdpby3l6azi78sl83cpad2qjpfj25aqx-glibc-2.40-66/lib/ld-linux-x86-64.so.2"</span>),
};
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> object_format: std.Target.ObjectFormat = .elf;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> mode: std.builtin.OptimizeMode = .Debug;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> link_libc = <span class="tok-null">false</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> link_libcpp = <span class="tok-null">false</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> have_error_return_tracing = <span class="tok-null">true</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> valgrind_support = <span class="tok-null">true</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> sanitize_thread = <span class="tok-null">false</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> fuzz = <span class="tok-null">false</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> position_independent_code = <span class="tok-null">false</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> position_independent_executable = <span class="tok-null">false</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> strip_debug_info = <span class="tok-null">false</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> code_model: std.builtin.CodeModel = .default;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> omit_frame_pointer = <span class="tok-null">false</span>;</code></pre></figure>
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Build-Mode">构建模式</a></li>
</ul>

      
      <h2 id="Compilation-Model"><a href="https://ziglang.org/documentation/0.15.2/#toc-Compilation-Model">编译模型</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Compilation-Model">§</a></h2>

      <p>
      Zig 编译被分为<em>模块</em>。每个模块是 Zig 源文件的集合,其中之一是模块的<em>根源文件</em>。每个模块可以<em>依赖</em>任意数量的其他模块,形成一个有向图(模块之间允许依赖循环)。如果模块 A 依赖于模块 B,那么模块 A 中的任何 Zig 源文件都可以使用 <code><span class="tok-builtin">@import</span></code> 和模块名称导入模块 B 的<em>根源文件</em>。本质上,模块充当导入 Zig 源文件(可能存在于文件系统的完全不同部分)的别名。
      </p>
      <p>
      使用 <code>zig build-exe</code> 编译的简单 Zig 程序有两个关键模块:包含你代码的模块,称为"main"或"root"模块,以及标准库。你的模块在名称"std"下<em>依赖于</em>标准库模块,这就是允许你编写 <code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>)</code> 的原因!事实上,Zig 编译中的每个模块 — 包括标准库本身 — 都隐式依赖于名称"std"下的标准库模块。
      </p>
      <p>
      "根模块"(在 <code>zig build-exe</code> 示例中由你提供的模块)具有一个特殊属性。与标准库一样,它被隐式地提供给所有模块(包括它自己),这次使用名称"root"。因此,<code><span class="tok-builtin">@import</span>(<span class="tok-str">"root"</span>)</code> 将始终等同于 <code><span class="tok-builtin">@import</span></code> 你的"main"源文件(通常但不一定命名为 <code>main.zig</code>)。
      </p>
      <h3 id="Source-File-Structs"><a href="https://ziglang.org/documentation/0.15.2/#toc-Source-File-Structs">源文件结构体</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Source-File-Structs">§</a></h3>

      <p>
      每个 Zig 源文件都隐式地是一个 <code><span class="tok-kw">struct</span></code> 声明;你可以想象文件的内容实际上被 <code><span class="tok-kw">struct</span> { ... }</code> 包围。这意味着除了声明之外,文件的顶层还允许包含字段:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">TopLevelFields.zig</cite></figcaption><pre><code><span class="tok-comment">//! 因为此文件包含字段,它是一个旨在被实例化的类型,因此</span>
<span class="tok-comment">//! 按照惯例使用 TitleCase 命名,而不是 snake_case。</span>

foo: <span class="tok-type">u32</span>,
bar: <span class="tok-type">u64</span>,

<span class="tok-comment">/// `@This()` 可用于引用此结构体类型。在有字段的文件中,通常会</span>
<span class="tok-comment">/// 在这里命名类型,以便此文件中的其他声明可以轻松引用它。</span>
<span class="tok-kw">const</span> TopLevelFields = <span class="tok-builtin">@This</span>();

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(val: <span class="tok-type">u32</span>) TopLevelFields {
    <span class="tok-kw">return</span> .{
        .foo = val,
        .bar = val * <span class="tok-number">10</span>,
    };
}</code></pre></figure>
      <p>
      这样的文件可以像任何其他 <code><span class="tok-kw">struct</span></code> 类型一样被实例化。文件的"根结构体类型"可以在该文件中使用 <a href="https://ziglang.org/documentation/0.15.2/#This">@This</a> 引用。
      </p>
      
      <h3 id="File-and-Declaration-Discovery"><a href="https://ziglang.org/documentation/0.15.2/#toc-File-and-Declaration-Discovery">文件和声明发现</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#File-and-Declaration-Discovery">§</a></h3>

      <p>
      Zig 重视任何代码片段是否被<em>语义分析</em>的概念;本质上,编译器是否"查看"它。哪些代码被分析是基于从某个点"发现"了哪些文件和声明。这个"发现"过程基于一组简单的递归规则:
      </p>
      <ul>
        <li>如果分析了对 <code><span class="tok-builtin">@import</span></code> 的调用,则会分析被导入的文件。</li>
        <li>如果分析了一个类型(包括文件),则会分析其中的所有 <code><span class="tok-kw">comptime</span></code> 和 <code><span class="tok-kw">export</span></code> 声明。</li>
        <li>如果分析了一个类型(包括文件),并且编译是用于<a href="https://ziglang.org/documentation/0.15.2/#Zig-Test">测试</a>,并且该类型所在的模块是编译的根模块,则还会分析其中的所有 <code><span class="tok-kw">test</span></code> 声明。</li>
        <li>如果分析了对命名声明的引用(即使用它),则会分析被引用的声明。声明是顺序无关的,因此此引用可能在被引用声明的上方或下方,甚至在完全不同的文件中。</li>
      </ul>
      <p>
      就是这样!这些规则定义了如何发现 Zig 文件和声明。剩下的就是理解这个过程从哪里<em>开始</em>。
      </p>
      <p>
      答案是标准库的根:每次 Zig 编译都从分析文件 <code>lib/std/std.zig</code> 开始。此文件包含一个 <code><span class="tok-kw">comptime</span></code> 声明,该声明导入 <code>lib/std/start.zig</code>,该文件又使用 <code><span class="tok-builtin">@import</span>(<span class="tok-str">"root"</span>)</code> 引用"根模块";因此,你作为主模块的根源文件提供的文件实际上也是一个根,因为标准库总是会引用它。
      </p>
      <p>
      通常需要确保某些声明 — 特别是 <code><span class="tok-kw">test</span></code> 或 <code><span class="tok-kw">export</span></code> 声明 — 被发现。根据上述规则,一个常见的策略是在 <code><span class="tok-kw">comptime</span></code> 或 <code><span class="tok-kw">test</span></code> 块中使用 <code><span class="tok-builtin">@import</span></code>:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">force_file_discovery.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-comment">// 这将确保文件 'api.zig' 始终被发现(只要此文件被发现)。</span>
    <span class="tok-comment">// 如果 'api.zig' 包含重要的导出声明,这很有用。</span>
    _ = <span class="tok-builtin">@import</span>(<span class="tok-str">"api.zig"</span>);

    <span class="tok-comment">// 我们也可以有一个文件,其中包含我们只想根据 comptime 条件导出的声明。</span>
    <span class="tok-comment">// 在这种情况下,我们可以在这里使用 `if` 语句:</span>
    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {
        _ = <span class="tok-builtin">@import</span>(<span class="tok-str">"windows_api.zig"</span>);
    }
}

<span class="tok-kw">test</span> {
    <span class="tok-comment">// 这将确保文件 'tests.zig' 始终被发现(只要此文件被发现),</span>
    <span class="tok-comment">// 如果此编译是测试。如果 'tests.zig' 包含我们想要确保运行的测试,这很有用。</span>
    _ = <span class="tok-builtin">@import</span>(<span class="tok-str">"tests.zig"</span>);

    <span class="tok-comment">// 我们也可以有一个文件,其中包含我们只想根据 comptime 条件运行的测试。</span>
    <span class="tok-comment">// 在这种情况下,我们可以在这里使用 `if` 语句:</span>
    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {
        _ = <span class="tok-builtin">@import</span>(<span class="tok-str">"windows_tests.zig"</span>);
    }
}

<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">"builtin"</span>);</code></pre></figure>
      
      <h3 id="Special-Root-Declarations"><a href="https://ziglang.org/documentation/0.15.2/#toc-Special-Root-Declarations">特殊根声明</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Special-Root-Declarations">§</a></h3>

      <p>
      因为根模块的根源文件始终可以使用 <code><span class="tok-builtin">@import</span>(<span class="tok-str">"root"</span>)</code> 访问,所以它有时被库 — 包括 Zig 标准库 — 用作程序向该库公开某些"全局"信息的地方。Zig 标准库将在此文件中查找几个声明。
      </p>
      <h4 id="Entry-Point"><a href="https://ziglang.org/documentation/0.15.2/#toc-Entry-Point">入口点</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Entry-Point">§</a></h4>

      <p>
      在构建可执行文件时,在此文件中查找的最重要的内容是程序的<em>入口点</em>。最常见的是一个名为 <code>main</code> 的函数,<code>std.start</code> 将在执行重要的初始化工作后调用它。
      </p>
      <p>
      或者,名为 <code>_start</code> 的声明的存在(例如,<code><span class="tok-kw">pub</span> <span class="tok-kw">const</span> _start = {};</code>)将禁用默认的 <code>std.start</code> 逻辑,允许你的根源文件根据需要导出低级入口点。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">entry_point.zig</cite></figcaption><pre><code><span class="tok-comment">/// `std.start` 使用 `@import("root")` 导入此文件,并将此声明用作程序的</span>
<span class="tok-comment">/// 用户提供的入口点。它可以返回以下任何类型:</span>
<span class="tok-comment">/// * `void`</span>
<span class="tok-comment">/// * `E!void`,对于任何错误集 `E`</span>
<span class="tok-comment">/// * `u8`</span>
<span class="tok-comment">/// * `E!u8`,对于任何错误集 `E`</span>
<span class="tok-comment">/// 从此函数返回 `void` 值将以代码 0 退出。</span>
<span class="tok-comment">/// 从此函数返回 `u8` 值将以给定的状态代码退出。</span>
<span class="tok-comment">/// 从此函数返回错误值将打印错误返回跟踪并以代码 1 退出。</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    std.debug.print(<span class="tok-str">"Hello, World!\n"</span>, .{});
}

<span class="tok-comment">// 如果取消注释,此声明将抑制通常的 std.start 逻辑,导致</span>
<span class="tok-comment">// 上面的 `main` 声明被忽略。</span>
<span class="tok-comment">//pub const _start = {};</span>

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe entry_point.zig</kbd>
$ <kbd>./entry_point</kbd>
Hello, World!
</samp></pre></figure>
      <p>
      如果 Zig 编译链接 libc,<code>main</code> 函数可以选择是一个 <code><span class="tok-kw">export</span> <span class="tok-kw">fn</span></code>,它匹配 C <code>main</code> 函数的签名:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">libc_export_entry_point.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>(argc: <span class="tok-type">c_int</span>, argv: [*]<span class="tok-kw">const</span> [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">c_int</span> {
    <span class="tok-kw">const</span> args = argv[<span class="tok-number">0</span>..<span class="tok-builtin">@intCast</span>(argc)];
    std.debug.print(<span class="tok-str">"Hello! argv[0] is '{s}'\n"</span>, .{args[<span class="tok-number">0</span>]});
    <span class="tok-kw">return</span> <span class="tok-number">0</span>;
}

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe libc_export_entry_point.zig -lc</kbd>
$ <kbd>./libc_export_entry_point</kbd>
Hello! argv[0] is './libc_export_entry_point'
</samp></pre></figure>
      <p>
      在某些情况下,<code>std.start</code> 还可能使用其他入口点声明,例如 <code>wWinMain</code> 或 <code>EfiMain</code>。有关这些声明的详细信息,请参阅 <code>lib/std/start.zig</code> 逻辑。
      </p>
      
      <h4 id="Standard-Library-Options"><a href="https://ziglang.org/documentation/0.15.2/#toc-Standard-Library-Options">标准库选项</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Standard-Library-Options">§</a></h4>

      <p>
      标准库还在根模块的根源文件中查找名为 <code>std_options</code> 的声明。如果存在,此声明应该是类型为 <code>std.Options</code> 的结构体,并允许程序自定义某些标准库功能,例如 <code>std.log</code> 实现。
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">std_options.zig</cite></figcaption><pre><code><span class="tok-comment">/// 此声明的存在允许程序覆盖标准库的某些行为。</span>
<span class="tok-comment">/// 有关可用选项的完整列表,请参阅 `std.Options` 的文档。</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> std_options: std.Options = .{
    <span class="tok-comment">// 默认情况下,在安全构建模式下,标准库将为程序附加一个段错误处理程序,以</span>
    <span class="tok-comment">// 在发生段错误时打印有用的堆栈跟踪。在这里,我们可以禁用它,甚至在不安全的构建模式下启用它。</span>
    .enable_segfault_handler = <span class="tok-null">true</span>,
    <span class="tok-comment">// 这是 `std.log` 使用的日志函数。</span>
    .logFn = myLogFn,
};

<span class="tok-kw">fn</span> <span class="tok-fn">myLogFn</span>(
    <span class="tok-kw">comptime</span> level: std.log.Level,
    <span class="tok-kw">comptime</span> scope: <span class="tok-builtin">@Type</span>(.enum_literal),
    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    args: <span class="tok-kw">anytype</span>,
) <span class="tok-type">void</span> {
    <span class="tok-comment">// 我们可以在这里做任何我们想做的事情!</span>
    <span class="tok-comment">// ...但实际上,让我们只调用默认实现。</span>
    std.log.defaultLog(level, scope, format, args);
}

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);</code></pre></figure>
      
      <h4 id="Panic-Handler"><a href="https://ziglang.org/documentation/0.15.2/#toc-Panic-Handler">恐慌处理程序</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Panic-Handler">§</a></h4>

      <p>
      Zig 标准库在根模块的根源文件中查找名为 <code>panic</code> 的声明。如果存在,它应该是一个命名空间(容器类型),其中包含提供不同恐慌处理程序的声明。
      </p>
      <p>
      有关此命名空间的基本实现,请参阅 <code>std.debug.simple_panic</code>。
      </p>
      <p>
      覆盖恐慌处理程序实际输出消息的方式,但保留默认启用的格式化安全恐慌,可以通过 <code>std.debug.FullPanic</code> 轻松实现:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">panic_handler.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-builtin">@setRuntimeSafety</span>(<span class="tok-null">true</span>);
    <span class="tok-kw">var</span> x: <span class="tok-type">u8</span> = <span class="tok-number">255</span>;
    <span class="tok-comment">// 让我们溢出这个整数!</span>
    x += <span class="tok-number">1</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> panic = std.debug.FullPanic(myPanic);

<span class="tok-kw">fn</span> <span class="tok-fn">myPanic</span>(msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, first_trace_addr: ?<span class="tok-type">usize</span>) <span class="tok-type">noreturn</span> {
    _ = first_trace_addr;
    std.debug.print(<span class="tok-str">"Panic! {s}\n"</span>, .{msg});
    std.process.exit(<span class="tok-number">1</span>);
}

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe panic_handler.zig</kbd>
$ <kbd>./panic_handler</kbd>
Panic! integer overflow
</samp></pre></figure>
      
      
      
      <h2 id="Zig-Build-System"><a href="https://ziglang.org/documentation/0.15.2/#toc-Zig-Build-System">Zig 构建系统</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Zig-Build-System">§</a></h2>

      <p>
      Zig 构建系统提供了一种跨平台、无依赖的方式来声明构建项目所需的逻辑。使用此系统,构建项目的逻辑在 build.zig 文件中编写,使用 Zig 构建系统 API 来声明和配置构建工件和其他任务。
      </p>
      <p>
      构建系统可以帮助完成的一些任务示例:
      </p>
      <ul>
        <li>并行执行任务并缓存结果。</li>
        <li>依赖于其他项目。</li>
        <li>为其他项目提供一个包以供依赖。</li>
        <li>通过执行 Zig 编译器创建构建工件。这包括构建 Zig 源代码以及 C 和 C++ 源代码。</li>
        <li>捕获用户配置的选项并使用这些选项来配置构建。</li>
        <li>通过提供一个可以被 Zig 代码<a href="https://ziglang.org/documentation/0.15.2/#import">导入</a>的文件,将构建配置作为<a href="https://ziglang.org/documentation/0.15.2/#comptime">编译期</a>值公开。</li>
        <li>缓存构建工件以避免不必要地重复步骤。</li>
        <li>执行构建工件或系统安装的工具。</li>
        <li>运行测试并验证执行构建工件的输出与预期值匹配。</li>
        <li>在代码库或其子集上运行 <code>zig fmt</code>。</li>
        <li>自定义任务。</li>
      </ul>
      <p>
      要使用构建系统,请运行 <kbd>zig build --help</kbd> 以查看命令行使用帮助菜单。这将包括在 build.zig 脚本中声明的项目特定选项。
      </p>
      <p>
      目前,构建系统文档托管在外部:
      <a href="https://ziglang.org/learn/build-system/">构建系统文档</a>
      </p>
      
      <h2 id="C"><a href="https://ziglang.org/documentation/0.15.2/#toc-C">C</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#C">§</a></h2>

      <p>
      尽管 Zig 独立于 C,并且与大多数其他语言不同,不依赖于 libc,但 Zig 承认与现有 C 代码交互的重要性。
      </p>
      <p>
      Zig 通过几种方式促进 C 互操作。
      </p>
      <h3 id="C-Type-Primitives"><a href="https://ziglang.org/documentation/0.15.2/#toc-C-Type-Primitives">C 类型原语</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#C-Type-Primitives">§</a></h3>

      <p>
      这些具有保证的 C ABI 兼容性,并且可以像任何其他类型一样使用。
      </p>
      <ul>
          <li><code><span class="tok-type">c_char</span></code></li>
          <li><code><span class="tok-type">c_short</span></code></li>
          <li><code><span class="tok-type">c_ushort</span></code></li>
          <li><code><span class="tok-type">c_int</span></code></li>
          <li><code><span class="tok-type">c_uint</span></code></li>
          <li><code><span class="tok-type">c_long</span></code></li>
          <li><code><span class="tok-type">c_ulong</span></code></li>
          <li><code><span class="tok-type">c_longlong</span></code></li>
          <li><code><span class="tok-type">c_ulonglong</span></code></li>
          <li><code><span class="tok-type">c_longdouble</span></code></li>
      </ul>
      <p>
      要与 C <code><span class="tok-type">void</span></code> 类型互操作,请使用 <code><span class="tok-type">anyopaque</span></code>。
      </p>
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Primitive-Types">原语类型</a></li>
</ul>

      
      <h3 id="Import-from-C-Header-File"><a href="https://ziglang.org/documentation/0.15.2/#toc-Import-from-C-Header-File">从 C 头文件导入</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Import-from-C-Header-File">§</a></h3>

      <p>
      <code><span class="tok-builtin">@cImport</span></code> 内置函数可用于直接从 <code class="file">.h</code> 文件导入符号:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">cImport_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> c = <span class="tok-builtin">@cImport</span>({
    <span class="tok-comment">// 参见 https://github.com/ziglang/zig/issues/515</span>
    <span class="tok-builtin">@cDefine</span>(<span class="tok-str">"_NO_CRT_STDIO_INLINE"</span>, <span class="tok-str">"1"</span>);
    <span class="tok-builtin">@cInclude</span>(<span class="tok-str">"stdio.h"</span>);
});
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    _ = c.printf(<span class="tok-str">"hello\n"</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe cImport_builtin.zig -lc</kbd>
$ <kbd>./cImport_builtin</kbd>
hello
</samp></pre></figure>

      <p>
      <code><span class="tok-builtin">@cImport</span></code> 函数将表达式作为参数。此表达式在编译时求值,用于控制预处理器指令并包含多个 <code class="file">.h</code> 文件:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">@cImport 表达式</cite></figcaption><pre><code><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">"builtin"</span>);

<span class="tok-kw">const</span> c = <span class="tok-builtin">@cImport</span>({
    <span class="tok-builtin">@cDefine</span>(<span class="tok-str">"NDEBUG"</span>, builtin.mode == .ReleaseFast);
    <span class="tok-kw">if</span> (something) {
        <span class="tok-builtin">@cDefine</span>(<span class="tok-str">"_GNU_SOURCE"</span>, {});
    }
    <span class="tok-builtin">@cInclude</span>(<span class="tok-str">"stdlib.h"</span>);
    <span class="tok-kw">if</span> (something) {
        <span class="tok-builtin">@cUndef</span>(<span class="tok-str">"_GNU_SOURCE"</span>);
    }
    <span class="tok-builtin">@cInclude</span>(<span class="tok-str">"soundio.h"</span>);
});</code></pre></figure>
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#cImport">@cImport</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cInclude">@cInclude</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cDefine">@cDefine</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cUndef">@cUndef</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#import">@import</a></li>
</ul>

      

      <h3 id="C-Translation-CLI"><a href="https://ziglang.org/documentation/0.15.2/#toc-C-Translation-CLI">C 翻译 CLI</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#C-Translation-CLI">§</a></h3>

      <p>
      Zig 的 C 翻译功能可通过 <kbd>zig translate-c</kbd> 作为 CLI 工具使用。它需要一个文件名作为参数。它还可能接受一组可选的标志,这些标志被转发到 clang。它将翻译后的文件写入 stdout。
      </p>
      <h4 id="Command-line-flags"><a href="https://ziglang.org/documentation/0.15.2/#toc-Command-line-flags">命令行标志</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Command-line-flags">§</a></h4>

      <ul>
        <li>
          <kbd>-I</kbd>:
          指定包含文件的搜索目录。可以多次使用。等同于 <a href="https://releases.llvm.org/12.0.0/tools/clang/docs/ClangCommandLineReference.html#cmdoption-clang-i-dir">clang 的 <kbd>-I</kbd> 标志</a>。默认情况下<em>不</em>包括当前目录;使用 <kbd>-I.</kbd> 包含它。
        </li>
        <li>
          <kbd>-D</kbd>: 定义预处理器宏。等同于 <a href="https://releases.llvm.org/12.0.0/tools/clang/docs/ClangCommandLineReference.html#cmdoption-clang-d-macro">clang 的 <kbd>-D</kbd> 标志</a>。
        </li>
        <li>
          <kbd>-cflags [flags] --</kbd>: 将任意附加的<a href="https://releases.llvm.org/12.0.0/tools/clang/docs/ClangCommandLineReference.html">命令行标志</a>传递给 clang。注意:标志列表必须以 <kbd>--</kbd> 结束
        </li>
        <li>
          <kbd>-target</kbd>: 翻译后的 Zig 代码的<a href="https://ziglang.org/documentation/0.15.2/#Targets">目标三元组</a>。如果未指定目标,将使用当前主机目标。
        </li>
      </ul>
      
      <h4 id="Using--target-and--cflags"><a href="https://ziglang.org/documentation/0.15.2/#toc-Using--target-and--cflags">使用 -target 和 -cflags</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Using--target-and--cflags">§</a></h4>

      <p>
        <strong>重要!</strong> 使用 <kbd>zig translate-c</kbd> 翻译 C 代码时,你<strong>必须</strong>使用与编译翻译后的代码时将使用的相同的 <kbd>-target</kbd> 三元组。此外,你<strong>必须</strong>确保使用的 <kbd>-cflags</kbd>(如果有)与目标系统上代码使用的 cflags 匹配。使用不正确的 <kbd>-target</kbd> 或 <kbd>-cflags</kbd> 可能导致 clang 或 Zig 解析失败,或在与 C 代码链接时出现细微的 ABI 不兼容性。
      </p>
      <figure><figcaption class="c-cap"><cite class="file">varytarget.h</cite></figcaption><pre><code>long FOO = __LONG_MAX__;</code></pre></figure>
      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig translate-c -target thumb-freestanding-gnueabihf varytarget.h|grep FOO</kbd>
pub export var FOO: c_long = 2147483647;
$ <kbd>zig translate-c -target x86_64-macos-gnu varytarget.h|grep FOO</kbd>
pub export var FOO: c_long = 9223372036854775807;
</samp></pre></figure>
      <figure><figcaption class="c-cap"><cite class="file">varycflags.h</cite></figcaption><pre><code>enum FOO { BAR };
int do_something(enum FOO foo);</code></pre></figure>
      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig translate-c varycflags.h|grep -B1 do_something</kbd>
pub const enum_FOO = c_uint;
pub extern fn do_something(foo: enum_FOO) c_int;
$ <kbd>zig translate-c -cflags -fshort-enums -- varycflags.h|grep -B1 do_something</kbd>
pub const enum_FOO = u8;
pub extern fn do_something(foo: enum_FOO) c_int;
</samp></pre></figure>
      
      <h4 id="cImport-vs-translate-c"><a href="https://ziglang.org/documentation/0.15.2/#toc-cImport-vs-translate-c">@cImport vs translate-c</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#cImport-vs-translate-c">§</a></h4>

      <p><code><span class="tok-builtin">@cImport</span></code> 和 <kbd>zig translate-c</kbd> 使用相同的底层 C 翻译功能,因此在技术层面上它们是等效的。在实践中,<code><span class="tok-builtin">@cImport</span></code> 作为一种快速轻松地访问数字常量、typedef 和记录类型的方式很有用,无需任何额外设置。如果你需要将 <a href="https://ziglang.org/documentation/0.15.2/#Using--target-and--cflags">cflags</a> 传递给 clang,或者如果你想编辑翻译后的代码,建议使用 <kbd>zig translate-c</kbd> 并将结果保存到文件中。编辑生成的代码的常见原因包括:将函数类宏中的 <code><span class="tok-kw">anytype</span></code> 参数更改为更具体的类型;将 <code>[*c]T</code> 指针更改为 <code>[*]T</code> 或 <code>*T</code> 指针以提高类型安全性;以及在特定函数中<a href="https://ziglang.org/documentation/0.15.2/#setRuntimeSafety">启用或禁用运行时安全</a>。
      </p>
      
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Targets">目标</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#C-Type-Primitives">C 类型原语</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Pointers">指针</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#C-Pointers">C 指针</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Import-from-C-Header-File">从 C 头文件导入</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cInclude">@cInclude</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cImport">@cImport</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#setRuntimeSafety">@setRuntimeSafety</a></li>
</ul>

      
      <h3 id="C-Translation-Caching"><a href="https://ziglang.org/documentation/0.15.2/#toc-C-Translation-Caching">C 翻译缓存</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#C-Translation-Caching">§</a></h3>

      <p>
        C 翻译功能(无论是通过 <kbd>zig translate-c</kbd> 还是 <code><span class="tok-builtin">@cImport</span></code> 使用)都与 Zig 缓存系统集成。使用相同的源文件、目标和 cflags 的后续运行将使用缓存,而不是重复翻译相同的代码。
      </p>
      <p>
        要查看在编译使用 <code><span class="tok-builtin">@cImport</span></code> 的代码时缓存文件的存储位置,请使用 <kbd>--verbose-cimport</kbd> 标志:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">verbose_cimport_flag.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> c = <span class="tok-builtin">@cImport</span>({
    <span class="tok-builtin">@cDefine</span>(<span class="tok-str">"_NO_CRT_STDIO_INLINE"</span>, <span class="tok-str">"1"</span>);
    <span class="tok-builtin">@cInclude</span>(<span class="tok-str">"stdio.h"</span>);
});
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    _ = c;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe verbose_cimport_flag.zig -lc --verbose-cimport</kbd>
info(compilation): C import source: /home/andy/dev/zig/.zig-cache/o/f9216ef6681abef94b056af4b875b0bd/cimport.h
info(compilation): C import .d file: /home/andy/dev/zig/.zig-cache/o/f9216ef6681abef94b056af4b875b0bd/cimport.h.d
$ <kbd>./verbose_cimport_flag</kbd>
</samp></pre></figure>

      <p>
        <code class="file">cimport.h</code> 包含要翻译的文件(由对 <code><span class="tok-builtin">@cInclude</span></code>、<code><span class="tok-builtin">@cDefine</span></code> 和 <code><span class="tok-builtin">@cUndef</span></code> 的调用构造),<code class="file">cimport.h.d</code> 是文件依赖项列表,<code class="file">cimport.zig</code> 包含翻译后的输出。
      </p>
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Import-from-C-Header-File">从 C 头文件导入</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#C-Translation-CLI">C 翻译 CLI</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cInclude">@cInclude</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#cImport">@cImport</a></li>
</ul>

      
      <h3 id="Translation-failures"><a href="https://ziglang.org/documentation/0.15.2/#toc-Translation-failures">翻译失败</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Translation-failures">§</a></h3>

      <p>
        某些 C 构造无法翻译为 Zig - 例如,<em>goto</em>、带位域的结构体和标记粘贴宏。Zig 使用<em>降级</em>来允许在遇到不可翻译的实体时继续翻译。
      </p>
      <p>
        降级有三种变体 - <a href="https://ziglang.org/documentation/0.15.2/#opaque">opaque</a>、<em>extern</em> 和 <code><span class="tok-builtin">@compileError</span></code>。

        无法正确翻译的 C 结构体和联合体将被翻译为 <code><span class="tok-kw">opaque</span>{}</code>。
        包含不透明类型或无法翻译的代码构造的函数将被降级为 <code><span class="tok-kw">extern</span></code> 声明。

        因此,不可翻译的类型仍然可以用作指针,并且只要链接器知道编译后的函数,就可以调用不可翻译的函数。
      </p>
      <p>
        当顶级定义(全局变量、函数原型、宏)无法翻译或降级时,使用 <code><span class="tok-builtin">@compileError</span></code>。由于 Zig 对顶级声明使用惰性分析,因此不可翻译的实体不会导致代码中的编译错误,除非你实际使用它们。
      </p>
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#opaque">opaque</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#extern">extern</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#compileError">@compileError</a></li>
</ul>

      
      <h3 id="C-Macros"><a href="https://ziglang.org/documentation/0.15.2/#toc-C-Macros">C 宏</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#C-Macros">§</a></h3>

      <p>
        C 翻译尽最大努力尝试将类函数宏翻译为等效的 Zig 函数。由于 C 宏在词法标记级别运行,因此并非所有 C 宏都可以翻译为 Zig。无法翻译的宏将被降级为 <code><span class="tok-builtin">@compileError</span></code>。注意,<em>使用</em>宏的 C 代码将被翻译而不会出现任何额外的问题(因为 Zig 对宏展开后的预处理源进行操作)。仅仅是宏本身可能无法翻译为 Zig。
      </p>
      <p>考虑以下示例:</p>
      <figure><figcaption class="c-cap"><cite class="file">macro.c</cite></figcaption><pre><code>#define MAKELOCAL(NAME, INIT) int NAME = INIT
int foo(void) {
   MAKELOCAL(a, 1);
   MAKELOCAL(b, 2);
   return a + b;
}</code></pre></figure>
      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig translate-c macro.c &gt; macro.zig</kbd>
</samp></pre></figure>
      <figure><figcaption class="zig-cap"><cite class="file">macro.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">c_int</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">c_int</span> = <span class="tok-number">1</span>;
    _ = &amp;a;
    <span class="tok-kw">var</span> b: <span class="tok-type">c_int</span> = <span class="tok-number">2</span>;
    _ = &amp;b;
    <span class="tok-kw">return</span> a + b;
}
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> MAKELOCAL = <span class="tok-builtin">@compileError</span>(<span class="tok-str">"unable to translate C expr: unexpected token .Equal"</span>); <span class="tok-comment">// macro.c:1:9</span></code></pre></figure>

      <p>注意,尽管使用了不可翻译的宏,<code>foo</code> 仍被正确翻译。<code>MAKELOCAL</code> 被降级为 <code><span class="tok-builtin">@compileError</span></code>,因为它不能表示为 Zig 函数;这仅仅意味着你不能直接从 Zig 使用 <code>MAKELOCAL</code>。
      </p>
      <p>另请参阅:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#compileError">@compileError</a></li>
</ul>

      

      <h3 id="C-Pointers"><a href="https://ziglang.org/documentation/0.15.2/#toc-C-Pointers">C 指针</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#C-Pointers">§</a></h3>

      <p>
      应尽可能避免使用此类型。使用 C 指针的唯一有效理由是在从翻译 C 代码生成的自动生成代码中。
      </p>
      <p>
      在导入 C 头文件时,指针应该翻译为单项指针(<code>*T</code>)还是多项指针(<code>[*]T</code>)是不明确的。
      C 指针是一种折衷方案,以便 Zig 代码可以直接利用翻译后的头文件。
      </p>
      <p><code>[*c]T</code> - C 指针。</p>
      <ul>
        <li>支持其他两种指针类型(<code>*T</code>)和(<code>[*]T</code>)的所有语法。</li>
        <li>强制转换为其他指针类型,以及<a href="https://ziglang.org/documentation/0.15.2/#Optional-Pointers">可选指针</a>。
            当 C 指针强制转换为非可选指针时,如果地址为 0,则会发生安全检查的<a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>。
        </li>
        <li>允许地址 0。在非独立目标上,取消引用地址 0 是安全检查的<a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>。可选 C 指针引入另一个位来跟踪 null,就像 <code>?<span class="tok-type">usize</span></code> 一样。注意,创建可选 C 指针是不必要的,因为可以使用普通的<a href="https://ziglang.org/documentation/0.15.2/#Optional-Pointers">可选指针</a>。
        </li>
        <li>支持与整数之间的<a href="https://ziglang.org/documentation/0.15.2/#Type-Coercion">类型强制转换</a>。</li>
        <li>支持与整数的比较。</li>
        <li>不支持仅限 Zig 的指针属性,例如对齐。请使用普通<a href="https://ziglang.org/documentation/0.15.2/#Pointers">指针</a>!</li>
      </ul>
      <p>当 C 指针指向单个结构体(不是数组)时,取消引用 C 指针以访问结构体的字段或成员数据。该语法如下所示: </p>
        <p><code>ptr_to_struct.*.struct_member</code></p>
        <p>这相当于在 C 中执行 <code>-&gt;</code>。</p>
        <p> 当 C 指针指向结构体数组时,语法恢复为:</p>
        <p><code>ptr_to_struct_array[index].struct_member</code></p>
      

      <h3 id="C-Variadic-Functions"><a href="https://ziglang.org/documentation/0.15.2/#toc-C-Variadic-Functions">C 可变参数函数</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#C-Variadic-Functions">§</a></h3>

      <p>Zig 支持 extern 可变参数函数。</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_variadic_function.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> testing = std.testing;

<span class="tok-kw">pub</span> <span class="tok-kw">extern</span> <span class="tok-str">"c"</span> <span class="tok-kw">fn</span> <span class="tok-fn">printf</span>(format: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ...) <span class="tok-type">c_int</span>;

<span class="tok-kw">test</span> <span class="tok-str">"variadic function"</span> {
    <span class="tok-kw">try</span> testing.expect(printf(<span class="tok-str">"Hello, world!\n"</span>) == <span class="tok-number">14</span>);
    <span class="tok-kw">try</span> testing.expect(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(printf)).@"fn".is_var_args);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_variadic_function.zig -lc</kbd>
1/1 test_variadic_function.test.variadic function...OK
All 1 tests passed.
Hello, world!
</samp></pre></figure>

      <p>
        可以使用 <a href="https://ziglang.org/documentation/0.15.2/#cVaStart">@cVaStart</a>、<a href="https://ziglang.org/documentation/0.15.2/#cVaEnd">@cVaEnd</a>、<a href="https://ziglang.org/documentation/0.15.2/#cVaArg">@cVaArg</a> 和 <a href="https://ziglang.org/documentation/0.15.2/#cVaCopy">@cVaCopy</a> 来实现可变参数函数。
      </p>
<!-- ====== END CHUNK 13: new_13.html ====== -->

<!-- ====== BEGIN CHUNK 14: new_14.html ====== -->
<figure><figcaption class="zig-cap"><cite class="file">test_defining_variadic_function.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> testing = std.testing;
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">"builtin"</span>);

<span class="tok-kw">fn</span> <span class="tok-fn">add</span>(count: <span class="tok-type">c_int</span>, ...) <span class="tok-kw">callconv</span>(.c) <span class="tok-type">c_int</span> {
    <span class="tok-kw">var</span> ap = <span class="tok-builtin">@cVaStart</span>();
    <span class="tok-kw">defer</span> <span class="tok-builtin">@cVaEnd</span>(&amp;ap);
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> sum: <span class="tok-type">c_int</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; count) : (i += <span class="tok-number">1</span>) {
        sum += <span class="tok-builtin">@cVaArg</span>(&amp;ap, <span class="tok-type">c_int</span>);
    }
    <span class="tok-kw">return</span> sum;
}

<span class="tok-kw">test</span> <span class="tok-str">"defining a variadic function"</span> {
    <span class="tok-kw">if</span> (builtin.cpu.arch == .aarch64 <span class="tok-kw">and</span> builtin.os.tag != .macos) {
        <span class="tok-comment">// https://github.com/ziglang/zig/issues/14096</span>
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    }
    <span class="tok-kw">if</span> (builtin.cpu.arch == .x86_64 <span class="tok-kw">and</span> builtin.os.tag == .windows) {
        <span class="tok-comment">// https://github.com/ziglang/zig/issues/16961</span>
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    }

    <span class="tok-kw">try</span> std.testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">c_int</span>, <span class="tok-number">0</span>), add(<span class="tok-number">0</span>));
    <span class="tok-kw">try</span> std.testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">c_int</span>, <span class="tok-number">1</span>), add(<span class="tok-number">1</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">c_int</span>, <span class="tok-number">1</span>)));
    <span class="tok-kw">try</span> std.testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">c_int</span>, <span class="tok-number">3</span>), add(<span class="tok-number">2</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">c_int</span>, <span class="tok-number">1</span>), <span class="tok-builtin">@as</span>(<span class="tok-type">c_int</span>, <span class="tok-number">2</span>)));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_defining_variadic_function.zig</kbd>
1/1 test_defining_variadic_function.test.defining a variadic function...OK
All 1 tests passed.
</samp></pre></figure>

      
      <h3 id="Exporting-a-C-Library"><a href="https://ziglang.org/documentation/0.15.2/#toc-Exporting-a-C-Library">导出 C 库</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Exporting-a-C-Library">§</a></h3>

      <p>
      Zig 的主要用例之一是导出一个具有 C ABI 的库供其他编程语言调用。在函数、变量和类型前面使用 <code><span class="tok-kw">export</span></code> 关键字会使它们成为库 API 的一部分:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">mathtest.zig</cite></figcaption><pre><code><span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(a: <span class="tok-type">i32</span>, b: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> a + b;
}</code></pre></figure>

      <p>制作静态库:</p>
      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-lib mathtest.zig</kbd>
</samp></pre></figure>
      <p>制作动态库:</p>
      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-lib mathtest.zig -dynamic</kbd>
</samp></pre></figure>
      <p>这是一个使用 <a href="https://ziglang.org/documentation/0.15.2/#Zig-Build-System">Zig 构建系统</a>的示例:</p>
      <figure><figcaption class="c-cap"><cite class="file">test.c</cite></figcaption><pre><code>// This header is generated by zig from mathtest.zig
#include "mathtest.h"
#include &lt;stdio.h&gt;

int main(int argc, char **argv) {
    int32_t result = add(42, 1337);
    printf("%d\n", result);
    return 0;
}</code></pre></figure>
      <figure><figcaption class="zig-cap"><cite class="file">build_c.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">build</span>(b: *std.Build) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> lib = b.addLibrary(.{
        .linkage = .dynamic,
        .name = <span class="tok-str">"mathtest"</span>,
        .root_module = b.createModule(.{
            .root_source_file = b.path(<span class="tok-str">"mathtest.zig"</span>),
        }),
        .version = .{ .major = <span class="tok-number">1</span>, .minor = <span class="tok-number">0</span>, .patch = <span class="tok-number">0</span> },
    });
    <span class="tok-kw">const</span> exe = b.addExecutable(.{
        .name = <span class="tok-str">"test"</span>,
        .root_module = b.createModule(.{
            .link_libc = <span class="tok-null">true</span>,
        }),
    });
    exe.root_module.addCSourceFile(.{ .file = b.path(<span class="tok-str">"test.c"</span>), .flags = &amp;.{<span class="tok-str">"-std=c99"</span>} });
    exe.root_module.linkLibrary(lib);

    b.default_step.dependOn(&amp;exe.step);

    <span class="tok-kw">const</span> run_cmd = exe.run();

    <span class="tok-kw">const</span> test_step = b.step(<span class="tok-str">"test"</span>, <span class="tok-str">"Test the program"</span>);
    test_step.dependOn(&amp;run_cmd.step);
}</code></pre></figure>

      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build test</kbd>
1379
</samp></pre></figure>
      <p>另见:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#export">export</a></li>
</ul>

      
      <h3 id="Mixing-Object-Files"><a href="https://ziglang.org/documentation/0.15.2/#toc-Mixing-Object-Files">混合目标文件</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Mixing-Object-Files">§</a></h3>

      <p>
      您可以将 Zig 目标文件与任何其他遵循 C ABI 的目标文件混合。示例:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">base64.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> base64 = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>).base64;

<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">decode_base_64</span>(
    dest_ptr: [*]<span class="tok-type">u8</span>,
    dest_len: <span class="tok-type">usize</span>,
    source_ptr: [*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    source_len: <span class="tok-type">usize</span>,
) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> src = source_ptr[<span class="tok-number">0</span>..source_len];
    <span class="tok-kw">const</span> dest = dest_ptr[<span class="tok-number">0</span>..dest_len];
    <span class="tok-kw">const</span> base64_decoder = base64.standard.Decoder;
    <span class="tok-kw">const</span> decoded_size = base64_decoder.calcSizeForSlice(src) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    base64_decoder.decode(dest[<span class="tok-number">0</span>..decoded_size], src) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    <span class="tok-kw">return</span> decoded_size;
}</code></pre></figure>

      <figure><figcaption class="c-cap"><cite class="file">test.c</cite></figcaption><pre><code>// This header is generated by zig from base64.zig
#include "base64.h"

#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char **argv) {
    const char *encoded = "YWxsIHlvdXIgYmFzZSBhcmUgYmVsb25nIHRvIHVz";
    char buf[200];

    size_t len = decode_base_64(buf, 200, encoded, strlen(encoded));
    buf[len] = 0;
    puts(buf);

    return 0;
}</code></pre></figure>
      <figure><figcaption class="zig-cap"><cite class="file">build_object.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">build</span>(b: *std.Build) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> obj = b.addObject(.{
        .name = <span class="tok-str">"base64"</span>,
        .root_module = b.createModule(.{
            .root_source_file = b.path(<span class="tok-str">"base64.zig"</span>),
        }),
    });

    <span class="tok-kw">const</span> exe = b.addExecutable(.{
        .name = <span class="tok-str">"test"</span>,
        .root_module = b.createModule(.{
            .link_libc = <span class="tok-null">true</span>,
        }),
    });
    exe.root_module.addCSourceFile(.{ .file = b.path(<span class="tok-str">"test.c"</span>), .flags = &amp;.{<span class="tok-str">"-std=c99"</span>} });
    exe.root_module.addObject(obj);
    b.installArtifact(exe);
}</code></pre></figure>

      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build</kbd>
$ <kbd>./zig-out/bin/test</kbd>
all your base are belong to us
</samp></pre></figure>
      <p>另见:</p><ul>
<li><a href="https://ziglang.org/documentation/0.15.2/#Targets">目标</a></li>
<li><a href="https://ziglang.org/documentation/0.15.2/#Zig-Build-System">Zig 构建系统</a></li>
</ul>

      
      
      <h2 id="WebAssembly"><a href="https://ziglang.org/documentation/0.15.2/#toc-WebAssembly">WebAssembly</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#WebAssembly">§</a></h2>

      <p>Zig 开箱即支持构建 WebAssembly。</p>
      <h3 id="Freestanding"><a href="https://ziglang.org/documentation/0.15.2/#toc-Freestanding">独立环境</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Freestanding">§</a></h3>

      <p>对于像 web 浏览器和 nodejs 这样的宿主环境,使用独立操作系统目标构建可执行文件。这是一个使用 nodejs 运行编译为 WebAssembly 的 Zig 代码的示例。</p>
      <figure><figcaption class="zig-cap"><cite class="file">math.zig</cite></figcaption><pre><code><span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">print</span>(<span class="tok-type">i32</span>) <span class="tok-type">void</span>;

<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(a: <span class="tok-type">i32</span>, b: <span class="tok-type">i32</span>) <span class="tok-type">void</span> {
    print(a + b);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe math.zig -target wasm32-freestanding -fno-entry --export=add</kbd>
</samp></pre></figure>

      <figure><figcaption class="javascript-cap"><cite class="file">test.js</cite></figcaption><pre><code>const fs = require('fs');
const source = fs.readFileSync("./math.wasm");
const typedArray = new Uint8Array(source);

WebAssembly.instantiate(typedArray, {
  env: {
    print: (result) =&gt; { console.log(`The result is ${result}`); }
  }}).then(result =&gt; {
  const add = result.instance.exports.add;
  add(1, 2);
});</code></pre></figure>
      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>node test.js</kbd>
The result is 3
</samp></pre></figure>
      
      <h3 id="WASI"><a href="https://ziglang.org/documentation/0.15.2/#toc-WASI">WASI</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#WASI">§</a></h3>

      <p>Zig 对 WebAssembly 系统接口 (WASI) 的支持正在积极开发中。
      使用标准库和读取命令行参数的示例:</p>
      <figure><figcaption class="zig-cap"><cite class="file">wasi_args.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> general_purpose_allocator: std.heap.GeneralPurposeAllocator(.{}) = .init;
    <span class="tok-kw">const</span> gpa = general_purpose_allocator.allocator();
    <span class="tok-kw">const</span> args = <span class="tok-kw">try</span> std.process.argsAlloc(gpa);
    <span class="tok-kw">defer</span> std.process.argsFree(gpa, args);

    <span class="tok-kw">for</span> (args, <span class="tok-number">0</span>..) |arg, i| {
        std.debug.print(<span class="tok-str">"{}: {s}\n"</span>, .{ i, arg });
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe wasi_args.zig -target wasm32-wasi</kbd>
</samp></pre></figure>

      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>wasmtime wasi_args.wasm 123 hello</kbd>
0: wasi_args.wasm
1: 123
2: hello
</samp></pre></figure>
      <p>一个更有趣的示例是从运行时提取预打开列表。
      这现在通过 <code>std.fs.wasi.Preopens</code> 在标准库中得到支持:</p>
      <figure><figcaption class="zig-cap"><cite class="file">wasi_preopens.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);
<span class="tok-kw">const</span> fs = std.fs;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> general_purpose_allocator: std.heap.GeneralPurposeAllocator(.{}) = .init;
    <span class="tok-kw">const</span> gpa = general_purpose_allocator.allocator();

    <span class="tok-kw">var</span> arena_instance = std.heap.ArenaAllocator.init(gpa);
    <span class="tok-kw">defer</span> arena_instance.deinit();
    <span class="tok-kw">const</span> arena = arena_instance.allocator();

    <span class="tok-kw">const</span> preopens = <span class="tok-kw">try</span> fs.wasi.preopensAlloc(arena);

    <span class="tok-kw">for</span> (preopens.names, <span class="tok-number">0</span>..) |preopen, i| {
        std.debug.print(<span class="tok-str">"{}: {s}\n"</span>, .{ i, preopen });
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe wasi_preopens.zig -target wasm32-wasi</kbd>
</samp></pre></figure>

      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>wasmtime --dir=. wasi_preopens.wasm</kbd>
0: stdin
1: stdout
2: stderr
3: .
</samp></pre></figure>
      
      
      <h2 id="Targets"><a href="https://ziglang.org/documentation/0.15.2/#toc-Targets">目标</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Targets">§</a></h2>

      <p>
      <strong>目标</strong>指的是将用于运行可执行文件的计算机。它由 CPU 架构、启用的 CPU 特性集、操作系统、最小和最大操作系统版本、ABI 和 ABI 版本组成。
      </p>
      <p>
      Zig 是一种通用编程语言,这意味着它被设计为针对大量目标生成最优代码。命令 <code>zig targets</code> 提供有关编译器所知的所有目标的信息。</p>
      <p>当没有向编译器提供目标选项时,默认选择是以<strong>宿主计算机</strong>为目标,这意味着生成的可执行文件<em>不适合复制到另一台计算机</em>。为了将可执行文件复制到另一台计算机,编译器需要通过 <code>-target</code> 选项了解目标要求。
      </p>
      <p>
      Zig 标准库(<code><span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>)</code>)具有跨平台抽象,使相同的源代码可以在许多目标上运行。有些代码比其他代码更具可移植性。通常,Zig 代码与其他编程语言相比具有极高的可移植性。
      </p>
      <p>
      每个平台都需要自己的实现以使 Zig 的跨平台抽象正常工作。这些实现处于不同的完成程度。编译器的每个标记发布都附带发布说明,其中提供每个目标的完整支持表。
      </p>
      
      <h2 id="Style-Guide"><a href="https://ziglang.org/documentation/0.15.2/#toc-Style-Guide">风格指南</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Style-Guide">§</a></h2>

      <p>
这些编码约定不由编译器强制执行,但它们与编译器一起在本文档中提供,以便在任何人希望引用公认的 Zig 编码风格权威时提供参考点。
      </p>
      <h3 id="Avoid-Redundancy-in-Names"><a href="https://ziglang.org/documentation/0.15.2/#toc-Avoid-Redundancy-in-Names">避免名称中的冗余</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Avoid-Redundancy-in-Names">§</a></h3>

      <p>避免在类型名称中使用这些词:</p>
      <ul>
        <li>Value</li>
        <li>Data</li>
        <li>Context</li>
        <li>Manager</li>
        <li>utils、misc 或某人的首字母缩写</li>
      </ul>
      <p>一切都是值,所有类型都是数据,一切都是上下文,所有逻辑都管理状态。使用适用于所有类型的词不会传达任何信息。</p>
      <p>使用"实用程序"、"杂项"或某人的首字母缩写的诱惑是分类失败,或者更常见的是过度分类。此类声明可以存在于需要它们的模块的根部,无需命名空间。</p>
      

      <h3 id="Avoid-Redundant-Names-in-Fully-Qualified-Namespaces"><a href="https://ziglang.org/documentation/0.15.2/#toc-Avoid-Redundant-Names-in-Fully-Qualified-Namespaces">避免完全限定命名空间中的冗余名称</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Avoid-Redundant-Names-in-Fully-Qualified-Namespaces">§</a></h3>

      <p>编译器为每个声明分配一个<strong>完全限定命名空间</strong>,创建一个树结构。根据完全限定的命名空间选择名称,并避免冗余的名称段。</p>
      <figure><figcaption class="zig-cap"><cite class="file">redundant_fqn.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">"std"</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> json = <span class="tok-kw">struct</span> {
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> JsonValue = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        number: <span class="tok-type">f64</span>,
        boolean: <span class="tok-type">bool</span>,
        <span class="tok-comment">// ...</span>
    };
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    std.debug.print(<span class="tok-str">"{s}\n"</span>, .{<span class="tok-builtin">@typeName</span>(json.JsonValue)});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe redundant_fqn.zig</kbd>
$ <kbd>./redundant_fqn</kbd>
redundant_fqn.json.JsonValue
</samp></pre></figure>

      <p>在此示例中,"json"在完全限定的命名空间中重复。解决方案是从 <code>JsonValue</code> 中删除 <code>Json</code>。在这个示例中,我们有一个名为 <code>json</code> 的空结构,但请记住文件也充当完全限定命名空间的一部分。</p>
      <p>此示例是<a href="https://ziglang.org/documentation/0.15.2/#Avoid-Redundancy-in-Names">避免名称中的冗余</a>中指定规则的例外。类型的含义已缩减为其核心:它是一个 json 值。该名称不能在不正确的情况下更具体。</p>
      

      <h3 id="Whitespace"><a href="https://ziglang.org/documentation/0.15.2/#toc-Whitespace">空白</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Whitespace">§</a></h3>

      <ul>
        <li>
          4 空格缩进
        </li>
        <li>
          在同一行上打开大括号,除非需要换行。
        </li>
        <li>如果事物列表长度超过 2,则将每个项目放在自己的行上,并在末尾放置一个额外的逗号。
        </li>
        <li>
          行长度:目标为 100;使用常识。
        </li>
      </ul>
      
      <h3 id="Names"><a href="https://ziglang.org/documentation/0.15.2/#toc-Names">名称</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Names">§</a></h3>

      <p>
      大致来说:<code>camelCaseFunctionName</code>、<code>TitleCaseTypeName</code>、<code>snake_case_variable_name</code>。更准确地说:
      </p>
      <ul>
        <li>
            如果 <code>x</code> 是 <code><span class="tok-type">type</span></code>,那么 <code>x</code> 应该是 <code>TitleCase</code>,除非它是一个包含 0 个字段且永远不会被实例化的 <code><span class="tok-kw">struct</span></code>,在这种情况下它被视为"命名空间"并使用 <code>snake_case</code>。
        </li>
        <li>
            如果 <code>x</code> 是可调用的,并且 <code>x</code> 的返回类型是 <code><span class="tok-type">type</span></code>,那么 <code>x</code> 应该是 <code>TitleCase</code>。
        </li>
        <li>
            如果 <code>x</code> 在其他情况下是可调用的,那么 <code>x</code> 应该是 <code>camelCase</code>。
        </li>
        <li>
            否则,<code>x</code> 应该是 <code>snake_case</code>。
        </li>
      </ul>
      <p>
      首字母缩略词、首字母缩写词、专有名词或书面英语中具有大写规则的任何其他单词都与任何其他单词一样受命名约定的约束。甚至只有 2 个字母长的首字母缩略词也受这些约定的约束。
      </p>
      <p>
      文件名分为两类:类型和命名空间。如果文件(隐式为结构)具有顶级字段,则应使用 <code class="file">TitleCase</code> 像任何其他具有字段的结构一样命名。否则,应使用 <code class="file">snake_case</code>。目录名称应为 <code class="file">snake_case</code>。
      </p>
      <p>
      这些是一般经验法则;如果做不同的事情更有意义,那就做有意义的事情。例如,如果有一个既定的约定,如 <code>ENOENT</code>,遵循既定的约定。
      </p>
      
      <h3 id="Examples"><a href="https://ziglang.org/documentation/0.15.2/#toc-Examples">示例</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Examples">§</a></h3>

      <figure><figcaption class="zig-cap"><cite class="file">style_example.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> namespace_name = <span class="tok-builtin">@import</span>(<span class="tok-str">"dir_name/file_name.zig"</span>);
<span class="tok-kw">const</span> TypeName = <span class="tok-builtin">@import</span>(<span class="tok-str">"dir_name/TypeName.zig"</span>);
<span class="tok-kw">var</span> global_var: <span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;
<span class="tok-kw">const</span> const_name = <span class="tok-number">42</span>;
<span class="tok-kw">const</span> primitive_type_alias = <span class="tok-type">f32</span>;
<span class="tok-kw">const</span> string_alias = []<span class="tok-type">u8</span>;

<span class="tok-kw">const</span> StructName = <span class="tok-kw">struct</span> {
    field: <span class="tok-type">i32</span>,
};
<span class="tok-kw">const</span> StructAlias = StructName;

<span class="tok-kw">fn</span> <span class="tok-fn">functionName</span>(param_name: TypeName) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> functionPointer = functionName;
    functionPointer();
    functionPointer = otherFunction;
    functionPointer();
}
<span class="tok-kw">const</span> functionAlias = functionName;

<span class="tok-kw">fn</span> <span class="tok-fn">ListTemplateFunction</span>(<span class="tok-kw">comptime</span> ChildType: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> fixed_size: <span class="tok-type">usize</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> List(ChildType, fixed_size);
}

<span class="tok-kw">fn</span> <span class="tok-fn">ShortList</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        field_name: [n]T,
        <span class="tok-kw">fn</span> <span class="tok-fn">methodName</span>() <span class="tok-type">void</span> {}
    };
}

<span class="tok-comment">// The word XML loses its casing when used in Zig identifiers.</span>
<span class="tok-kw">const</span> xml_document =
    <span class="tok-str">\\&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
    <span class="tok-str">\\&lt;document&gt;</span>
    <span class="tok-str">\\&lt;/document&gt;</span>
;
<span class="tok-kw">const</span> XmlParser = <span class="tok-kw">struct</span> {
    field: <span class="tok-type">i32</span>,
};

<span class="tok-comment">// The initials BE (Big Endian) are just another word in Zig identifier names.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">readU32Be</span>() <span class="tok-type">u32</span> {}</code></pre></figure>
      <p>
      有关更多示例,请参阅 <a href="https://ziglang.org/documentation/0.15.2/#Zig-Standard-Library">Zig 标准库</a>。
      </p>
      
      <h3 id="Doc-Comment-Guidance"><a href="https://ziglang.org/documentation/0.15.2/#toc-Doc-Comment-Guidance">文档注释指南</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Doc-Comment-Guidance">§</a></h3>

      <ul>
        <li>省略基于所记录事物的名称而冗余的任何信息。</li>
        <li>鼓励在多个类似函数上复制信息,因为它有助于 IDE 和其他工具提供更好的帮助文本。</li>
        <li>使用词<strong>假设</strong>来表示在违反时导致<em>未检查</em><a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>的不变量。</li>
        <li>使用词<strong>断言</strong>来表示在违反时导致<em>安全检查</em><a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>的不变量。</li>
      </ul>
      
      
      <h2 id="Source-Encoding"><a href="https://ziglang.org/documentation/0.15.2/#toc-Source-Encoding">源码编码</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Source-Encoding">§</a></h2>

      <p>Zig 源代码以 UTF-8 编码。无效的 UTF-8 字节序列会导致编译错误。</p>
      <p>在所有 zig 源代码中(包括在注释中),永远不允许某些码位:</p>
      <ul>
        <li>Ascii 控制字符,除了 U+000a (LF)、U+000d (CR) 和 U+0009 (HT):U+0000 - U+0008、U+000b - U+000c、U+000e - U+0001f、U+007f。</li>
        <li>非 Ascii Unicode 行结束符:U+0085 (NEL)、U+2028 (LS)、U+2029 (PS)。</li>
      </ul>
      <p>
      LF(字节值 0x0a,码位 U+000a,<code><span class="tok-str">'\n'</span></code>)是 Zig 源代码中的行终止符。此字节值终止 zig 源代码的每一行,除了文件的最后一行。建议非空源文件以空行结尾,这意味着最后一个字节将是 0x0a (LF)。
      </p>
      <p>
      每个 LF 可以紧接着一个 CR(字节值 0x0d,码位 U+000d,<code><span class="tok-str">'\r'</span></code>)形成 Windows 样式的行尾,但这是不鼓励的。请注意,在多行字符串中,CRLF 序列在编译到 zig 程序中时将被编码为 LF。在任何其他上下文中都不允许 CR。
      </p>
      <p>
      HT 硬制表符(字节值 0x09,码位 U+0009,<code><span class="tok-str">'\t'</span></code>)作为标记分隔符可与 SP 空格(字节值 0x20,码位 U+0020,<code><span class="tok-str">' '</span></code>)互换使用,但不鼓励使用硬制表符。参见<a href="https://ziglang.org/documentation/0.15.2/#Grammar">语法</a>。
      </p>
      <p>
      为了与其他工具兼容,如果 UTF-8 编码的字节顺序标记(U+FEFF)是源文本中的第一个 Unicode 码位,编译器会忽略它。源代码中的任何其他位置都不允许字节顺序标记。
      </p>
      <p>
      请注意,在源文件上运行 <kbd>zig fmt</kbd> 将实现此处提到的所有建议。
      </p>
      <p>
      请注意,读取 Zig 源代码的工具可以在假定源代码是正确的 Zig 代码的情况下做出假设。例如,在识别行尾时,工具可以使用简单的搜索,如 <code>/\n/</code>,或<a href="https://msdn.microsoft.com/en-us/library/dd409797.aspx">高级</a>搜索,如 <code>/\r\n?|[\n\u0085\u2028\u2029]/</code>,在任何一种情况下,行尾都将被正确识别。再例如,在识别一行第一个标记之前的空白时,工具可以使用简单的搜索,如 <code>/[ \t]/</code>,或<a href="https://tc39.es/ecma262/#sec-characterclassescape">高级</a>搜索,如 <code>/\s/</code>,在任何一种情况下,空白都将被正确识别。
      </p>
      

      <h2 id="Keyword-Reference"><a href="https://ziglang.org/documentation/0.15.2/#toc-Keyword-Reference">关键字参考</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Keyword-Reference">§</a></h2>

      <div class="table-wrapper">
      <table>
        <thead>
        <tr>
          <th scope="col">关键字</th>
          <th scope="col">描述</th>
        </tr>
        </thead>
        <tbody>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">addrspace</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">addrspace</span></code> 关键字。
            <ul>
              <li>TODO 添加 addrspace 的文档</li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">align</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">align</span></code> 可用于指定指针的对齐。它也可以在变量或函数声明之后使用,以指定指向该变量或函数的指针的对齐。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Alignment">对齐</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">allowzero</span></code></pre>
          </th>
          <td>
            指针属性 <code><span class="tok-kw">allowzero</span></code> 允许指针具有地址零。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#allowzero">allowzero</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">and</span></code></pre>
          </th>
          <td>
            布尔运算符 <code><span class="tok-kw">and</span></code>。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Operators">运算符</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">anyframe</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">anyframe</span></code> 可用作保存指向函数帧的指针的变量的类型。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Async-Functions">异步函数</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">anytype</span></code></pre>
          </th>
          <td>
            函数参数可以用 <code><span class="tok-kw">anytype</span></code> 代替类型进行声明。类型将在调用函数的位置推断。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Function-Parameter-Type-Inference">函数参数类型推断</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">asm</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">asm</span></code> 开始一个内联汇编表达式。这允许直接控制编译时生成的机器代码。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Assembly">汇编</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">break</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">break</span></code> 可以与块标签一起使用以从块返回值。它也可以用于在迭代自然完成之前退出循环。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Blocks">块</a>、<a href="https://ziglang.org/documentation/0.15.2/#while">while</a>、<a href="https://ziglang.org/documentation/0.15.2/#for">for</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">callconv</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">callconv</span></code> 可用于在函数类型中指定调用约定。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Functions">函数</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">catch</span></code></pre>
          </th>
          <td>
            如果它之前的表达式计算为错误,则可以使用 <code><span class="tok-kw">catch</span></code> 来计算表达式。<code><span class="tok-kw">catch</span></code> 之后的表达式可以选择捕获错误值。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#catch">catch</a>、<a href="https://ziglang.org/documentation/0.15.2/#Operators">运算符</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">comptime</span></code></pre>
          </th>
          <td>
            声明前的 <code><span class="tok-kw">comptime</span></code> 可用于将变量或函数参数标记为在编译时已知。它也可以用于保证表达式在编译时运行。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#comptime">comptime</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">const</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">const</span></code> 声明一个无法修改的变量。用作指针属性时,它表示指针引用的值无法修改。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Variables">变量</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">continue</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">continue</span></code> 可以在循环中使用以跳回到循环的开始。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#while">while</a>、<a href="https://ziglang.org/documentation/0.15.2/#for">for</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">defer</span></code></pre>
          </th>
          <td>
            当控制流离开当前块时,<code><span class="tok-kw">defer</span></code> 将执行一个表达式。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#defer">defer</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">else</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">else</span></code> 可用于为 <code><span class="tok-kw">if</span></code>、<code><span class="tok-kw">switch</span></code>、<code><span class="tok-kw">while</span></code> 和 <code><span class="tok-kw">for</span></code> 表达式提供备用分支。
            <ul>
              <li>如果在 if 表达式之后使用,如果测试值返回 false、null 或错误,则将执行 else 分支。</li>
              <li>如果在 switch 表达式中使用,如果测试值不匹配其他情况,则将执行 else 分支。</li>
              <li>如果在循环表达式之后使用,如果循环在没有中断的情况下完成,则将执行 else 分支。</li>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#if">if</a>、<a href="https://ziglang.org/documentation/0.15.2/#switch">switch</a>、<a href="https://ziglang.org/documentation/0.15.2/#while">while</a>、<a href="https://ziglang.org/documentation/0.15.2/#for">for</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">enum</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">enum</span></code> 定义一个枚举类型。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#enum">enum</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">errdefer</span></code></pre>
          </th>
          <td>
            如果函数返回错误,当控制流离开当前块时,<code><span class="tok-kw">errdefer</span></code> 将执行一个表达式,errdefer 表达式可以捕获解包的值。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#errdefer">errdefer</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">error</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">error</span></code> 定义一个错误类型。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Errors">错误</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">export</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">export</span></code> 使函数或变量在生成的目标文件中外部可见。导出的函数默认使用 C 调用约定。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Functions">函数</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">extern</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">extern</span></code> 可用于声明将在静态链接时或在动态链接时在运行时解析的函数或变量。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Functions">函数</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">fn</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">fn</span></code> 声明一个函数。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Functions">函数</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">for</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">for</span></code> 表达式可用于迭代切片、数组或元组的元素。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#for">for</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">if</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">if</span></code> 表达式可以测试布尔表达式、可选值或错误联合。对于可选值或错误联合,if 表达式可以捕获解包的值。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#if">if</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">inline</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">inline</span></code> 可用于标记循环表达式,使其在编译时展开。它也可以用于强制函数在所有调用位置内联。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#inline-while">inline while</a>、<a href="https://ziglang.org/documentation/0.15.2/#inline-for">inline for</a>、<a href="https://ziglang.org/documentation/0.15.2/#Functions">函数</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">linksection</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">linksection</span></code> 关键字可用于指定函数或全局变量将放入哪个节(例如 <code>.text</code>)。
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">noalias</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">noalias</span></code> 关键字。
            <ul>
              <li>TODO 添加 noalias 的文档</li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">noinline</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">noinline</span></code> 禁止函数在所有调用位置内联。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Functions">函数</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">nosuspend</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">nosuspend</span></code> 关键字可用于块、语句或表达式之前,以标记未到达挂起点的范围。特别是,在 <code><span class="tok-kw">nosuspend</span></code> 范围内:
            <ul>
              <li>使用 <code><span class="tok-kw">suspend</span></code> 关键字会导致编译错误。</li>
              <li>对尚未完成的函数帧使用 <code>await</code> 会导致安全检查的<a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>。</li>
              <li>调用异步函数可能导致安全检查的<a href="https://ziglang.org/documentation/0.15.2/#Illegal-Behavior">非法行为</a>,因为它等效于 <code>await async some_async_fn()</code>,其中包含 <code>await</code>。</li>
            </ul>
            <code><span class="tok-kw">nosuspend</span></code> 范围内的代码不会导致封闭函数成为<a href="https://ziglang.org/documentation/0.15.2/#Async-Functions">异步函数</a>。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Async-Functions">异步函数</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">opaque</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">opaque</span></code> 定义一个不透明类型。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#opaque">opaque</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">or</span></code></pre>
          </th>
          <td>
            布尔运算符 <code><span class="tok-kw">or</span></code>。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Operators">运算符</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">orelse</span></code></pre>
          </th>
          <td>
            如果它之前的表达式计算为 null,则可以使用 <code><span class="tok-kw">orelse</span></code> 来计算表达式。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Optionals">可选值</a>、<a href="https://ziglang.org/documentation/0.15.2/#Operators">运算符</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">packed</span></code></pre>
          </th>
          <td>
            struct 定义前的 <code><span class="tok-kw">packed</span></code> 关键字会将 struct 的内存布局更改为保证的 <code><span class="tok-kw">packed</span></code> 布局。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#packed-struct">packed struct</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">pub</span></code></pre>
          </th>
          <td>
            顶级声明前的 <code><span class="tok-kw">pub</span></code> 使该声明可以从声明它的文件以外的文件中引用。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#import">import</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">resume</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">resume</span></code> 将在函数挂起的点之后继续执行函数帧。
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">return</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">return</span></code> 使用一个值退出函数。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Functions">函数</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">struct</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">struct</span></code> 定义一个结构。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#struct">struct</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">suspend</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">suspend</span></code> 将使控制流返回到函数的调用位置或恢复者。<code><span class="tok-kw">suspend</span></code> 也可以在函数内的块之前使用,以允许函数在控制流返回到调用位置之前访问其帧。
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">switch</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">switch</span></code> 表达式可用于测试通用类型的值。<code><span class="tok-kw">switch</span></code> case 可以捕获<a href="https://ziglang.org/documentation/0.15.2/#Tagged-union">标记联合</a>的字段值。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#switch">switch</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">test</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">test</span></code> 关键字可用于表示用于确保行为符合预期的顶级代码块。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Zig-Test">Zig 测试</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">threadlocal</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">threadlocal</span></code> 可用于将变量指定为线程局部。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Thread-Local-Variables">线程局部变量</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">try</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">try</span></code> 计算错误联合表达式。如果它是错误,则使用相同的错误从当前函数返回。否则,表达式结果为解包的值。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#try">try</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">union</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">union</span></code> 定义一个联合。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#union">union</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">unreachable</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">unreachable</span></code> 可用于断言控制流永远不会到达特定位置。根据构建模式,<code><span class="tok-kw">unreachable</span></code> 可能会触发 panic。
            <ul>
              <li>在 <code>Debug</code> 和 <code>ReleaseSafe</code> 模式下触发 panic,或使用 <kbd>zig test</kbd> 时。</li>
              <li>在 <code>ReleaseFast</code> 和 <code>ReleaseSmall</code> 模式下不触发 panic。</li>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#unreachable">unreachable</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">var</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">var</span></code> 声明一个可以修改的变量。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#Variables">变量</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">volatile</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">volatile</span></code> 可用于表示指针的加载或存储具有副作用。它也可以修改内联汇编表达式以表示它具有副作用。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#volatile">volatile</a>、<a href="https://ziglang.org/documentation/0.15.2/#Assembly">汇编</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">while</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">while</span></code> 表达式可用于重复测试布尔、可选或错误联合表达式,并在该表达式分别计算为 false、null 或错误时停止循环。
            <ul>
              <li>另见 <a href="https://ziglang.org/documentation/0.15.2/#while">while</a></li>
            </ul>
          </td>
        </tr>
        </tbody>
      </table>
      </div>
      

      <h2 id="Appendix"><a href="https://ziglang.org/documentation/0.15.2/#toc-Appendix">附录</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Appendix">§</a></h2>

      <h3 id="Containers"><a href="https://ziglang.org/documentation/0.15.2/#toc-Containers">容器</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Containers">§</a></h3>

      <p>
      Zig 中的<em>容器</em>是充当命名空间以保存<a href="https://ziglang.org/documentation/0.15.2/#Container-Level-Variables">变量</a>和<a href="https://ziglang.org/documentation/0.15.2/#Functions">函数</a>声明的任何语法结构。容器也是可以实例化的类型定义。<a href="https://ziglang.org/documentation/0.15.2/#struct">结构</a>、<a href="https://ziglang.org/documentation/0.15.2/#enum">枚举</a>、<a href="https://ziglang.org/documentation/0.15.2/#union">联合</a>、<a href="https://ziglang.org/documentation/0.15.2/#opaque">不透明</a>,甚至 Zig 源文件本身都是容器。
      </p>
      <p>
      尽管容器(除 Zig 源文件外)使用花括号包围其定义,但它们不应与<a href="https://ziglang.org/documentation/0.15.2/#Blocks">块</a>或函数混淆。容器不包含语句。
      </p>
      

      <h3 id="Grammar"><a href="https://ziglang.org/documentation/0.15.2/#toc-Grammar">语法</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Grammar">§</a></h3>
<!-- ====== END CHUNK 14: new_14.html ====== -->

<!-- ====== BEGIN CHUNK 15: new_15.html ====== -->
<figure><figcaption class="peg-cap"><cite class="file">grammar.y</cite></figcaption><pre><code>Root &lt;- skip container_doc_comment? ContainerMembers eof

# *** 顶层 ***
ContainerMembers &lt;- ContainerDeclaration* (ContainerField COMMA)* (ContainerField / ContainerDeclaration*)

ContainerDeclaration &lt;- TestDecl / ComptimeDecl / doc_comment? KEYWORD_pub? Decl

TestDecl &lt;- KEYWORD_test (STRINGLITERALSINGLE / IDENTIFIER)? Block

ComptimeDecl &lt;- KEYWORD_comptime Block

Decl
    &lt;- (KEYWORD_export / KEYWORD_extern STRINGLITERALSINGLE? / KEYWORD_inline / KEYWORD_noinline)? FnProto (SEMICOLON / Block)
     / (KEYWORD_export / KEYWORD_extern STRINGLITERALSINGLE?)? KEYWORD_threadlocal? GlobalVarDecl

FnProto &lt;- KEYWORD_fn IDENTIFIER? LPAREN ParamDeclList RPAREN ByteAlign? AddrSpace? LinkSection? CallConv? EXCLAMATIONMARK? TypeExpr

VarDeclProto &lt;- (KEYWORD_const / KEYWORD_var) IDENTIFIER (COLON TypeExpr)? ByteAlign? AddrSpace? LinkSection?

GlobalVarDecl &lt;- VarDeclProto (EQUAL Expr)? SEMICOLON

ContainerField &lt;- doc_comment? KEYWORD_comptime? !KEYWORD_fn (IDENTIFIER COLON)? TypeExpr ByteAlign? (EQUAL Expr)?

# *** 块级 ***
Statement
    &lt;- KEYWORD_comptime ComptimeStatement
     / KEYWORD_nosuspend BlockExprStatement
     / KEYWORD_suspend BlockExprStatement
     / KEYWORD_defer BlockExprStatement
     / KEYWORD_errdefer Payload? BlockExprStatement
     / IfStatement
     / LabeledStatement
     / SwitchExpr
     / VarDeclExprStatement

ComptimeStatement
    &lt;- BlockExpr
     / VarDeclExprStatement

IfStatement
    &lt;- IfPrefix BlockExpr ( KEYWORD_else Payload? Statement )?
     / IfPrefix AssignExpr ( SEMICOLON / KEYWORD_else Payload? Statement )

LabeledStatement &lt;- BlockLabel? (Block / LoopStatement)

LoopStatement &lt;- KEYWORD_inline? (ForStatement / WhileStatement)

ForStatement
    &lt;- ForPrefix BlockExpr ( KEYWORD_else Statement )?
     / ForPrefix AssignExpr ( SEMICOLON / KEYWORD_else Statement )

WhileStatement
    &lt;- WhilePrefix BlockExpr ( KEYWORD_else Payload? Statement )?
     / WhilePrefix AssignExpr ( SEMICOLON / KEYWORD_else Payload? Statement )

BlockExprStatement
    &lt;- BlockExpr
     / AssignExpr SEMICOLON

BlockExpr &lt;- BlockLabel? Block

# 表达式、赋值或任何解构,作为语句。
VarDeclExprStatement
    &lt;- VarDeclProto (COMMA (VarDeclProto / Expr))* EQUAL Expr SEMICOLON
     / Expr (AssignOp Expr / (COMMA (VarDeclProto / Expr))+ EQUAL Expr)? SEMICOLON

# *** 表达式级 ***

# 一个赋值或解构,其左侧都是左值表达式。
AssignExpr &lt;- Expr (AssignOp Expr / (COMMA Expr)+ EQUAL Expr)?

SingleAssignExpr &lt;- Expr (AssignOp Expr)?

Expr &lt;- BoolOrExpr

BoolOrExpr &lt;- BoolAndExpr (KEYWORD_or BoolAndExpr)*

BoolAndExpr &lt;- CompareExpr (KEYWORD_and CompareExpr)*

CompareExpr &lt;- BitwiseExpr (CompareOp BitwiseExpr)?

BitwiseExpr &lt;- BitShiftExpr (BitwiseOp BitShiftExpr)*

BitShiftExpr &lt;- AdditionExpr (BitShiftOp AdditionExpr)*

AdditionExpr &lt;- MultiplyExpr (AdditionOp MultiplyExpr)*

MultiplyExpr &lt;- PrefixExpr (MultiplyOp PrefixExpr)*

PrefixExpr &lt;- PrefixOp* PrimaryExpr

PrimaryExpr
    &lt;- AsmExpr
     / IfExpr
     / KEYWORD_break BreakLabel? Expr?
     / KEYWORD_comptime Expr
     / KEYWORD_nosuspend Expr
     / KEYWORD_continue BreakLabel?
     / KEYWORD_resume Expr
     / KEYWORD_return Expr?
     / BlockLabel? LoopExpr
     / Block
     / CurlySuffixExpr

IfExpr &lt;- IfPrefix Expr (KEYWORD_else Payload? Expr)?

Block &lt;- LBRACE Statement* RBRACE

LoopExpr &lt;- KEYWORD_inline? (ForExpr / WhileExpr)

ForExpr &lt;- ForPrefix Expr (KEYWORD_else Expr)?

WhileExpr &lt;- WhilePrefix Expr (KEYWORD_else Payload? Expr)?

CurlySuffixExpr &lt;- TypeExpr InitList?

InitList
    &lt;- LBRACE FieldInit (COMMA FieldInit)* COMMA? RBRACE
     / LBRACE Expr (COMMA Expr)* COMMA? RBRACE
     / LBRACE RBRACE

TypeExpr &lt;- PrefixTypeOp* ErrorUnionExpr

ErrorUnionExpr &lt;- SuffixExpr (EXCLAMATIONMARK TypeExpr)?

SuffixExpr
    &lt;- PrimaryTypeExpr (SuffixOp / FnCallArguments)*

PrimaryTypeExpr
    &lt;- BUILTINIDENTIFIER FnCallArguments
     / CHAR_LITERAL
     / ContainerDecl
     / DOT IDENTIFIER
     / DOT InitList
     / ErrorSetDecl
     / FLOAT
     / FnProto
     / GroupedExpr
     / LabeledTypeExpr
     / IDENTIFIER
     / IfTypeExpr
     / INTEGER
     / KEYWORD_comptime TypeExpr
     / KEYWORD_error DOT IDENTIFIER
     / KEYWORD_anyframe
     / KEYWORD_unreachable
     / STRINGLITERAL
     / SwitchExpr

ContainerDecl &lt;- (KEYWORD_extern / KEYWORD_packed)? ContainerDeclAuto

ErrorSetDecl &lt;- KEYWORD_error LBRACE IdentifierList RBRACE

GroupedExpr &lt;- LPAREN Expr RPAREN

IfTypeExpr &lt;- IfPrefix TypeExpr (KEYWORD_else Payload? TypeExpr)?

LabeledTypeExpr
    &lt;- BlockLabel Block
     / BlockLabel? LoopTypeExpr

LoopTypeExpr &lt;- KEYWORD_inline? (ForTypeExpr / WhileTypeExpr)

ForTypeExpr &lt;- ForPrefix TypeExpr (KEYWORD_else TypeExpr)?

WhileTypeExpr &lt;- WhilePrefix TypeExpr (KEYWORD_else Payload? TypeExpr)?

SwitchExpr &lt;- KEYWORD_switch LPAREN Expr RPAREN LBRACE SwitchProngList RBRACE

# *** 汇编 ***
AsmExpr &lt;- KEYWORD_asm KEYWORD_volatile? LPAREN Expr AsmOutput? RPAREN

AsmOutput &lt;- COLON AsmOutputList AsmInput?

AsmOutputItem &lt;- LBRACKET IDENTIFIER RBRACKET STRINGLITERAL LPAREN (MINUSRARROW TypeExpr / IDENTIFIER) RPAREN

AsmInput &lt;- COLON AsmInputList AsmClobbers?

AsmInputItem &lt;- LBRACKET IDENTIFIER RBRACKET STRINGLITERAL LPAREN Expr RPAREN

AsmClobbers &lt;- COLON Expr

# *** 辅助语法 ***
BreakLabel &lt;- COLON IDENTIFIER

BlockLabel &lt;- IDENTIFIER COLON

FieldInit &lt;- DOT IDENTIFIER EQUAL Expr

WhileContinueExpr &lt;- COLON LPAREN AssignExpr RPAREN

LinkSection &lt;- KEYWORD_linksection LPAREN Expr RPAREN

AddrSpace &lt;- KEYWORD_addrspace LPAREN Expr RPAREN

# 函数特定
CallConv &lt;- KEYWORD_callconv LPAREN Expr RPAREN

ParamDecl
    &lt;- doc_comment? (KEYWORD_noalias / KEYWORD_comptime)? (IDENTIFIER COLON)? ParamType
     / DOT3

ParamType
    &lt;- KEYWORD_anytype
     / TypeExpr

# 控制流前缀
IfPrefix &lt;- KEYWORD_if LPAREN Expr RPAREN PtrPayload?

WhilePrefix &lt;- KEYWORD_while LPAREN Expr RPAREN PtrPayload? WhileContinueExpr?

ForPrefix &lt;- KEYWORD_for LPAREN ForArgumentsList RPAREN PtrListPayload

# 载荷
Payload &lt;- PIPE IDENTIFIER PIPE

PtrPayload &lt;- PIPE ASTERISK? IDENTIFIER PIPE

PtrIndexPayload &lt;- PIPE ASTERISK? IDENTIFIER (COMMA IDENTIFIER)? PIPE

PtrListPayload &lt;- PIPE ASTERISK? IDENTIFIER (COMMA ASTERISK? IDENTIFIER)* COMMA? PIPE

# Switch 特定
SwitchProng &lt;- KEYWORD_inline? SwitchCase EQUALRARROW PtrIndexPayload? SingleAssignExpr

SwitchCase
    &lt;- SwitchItem (COMMA SwitchItem)* COMMA?
     / KEYWORD_else

SwitchItem &lt;- Expr (DOT3 Expr)?

# For 特定
ForArgumentsList &lt;- ForItem (COMMA ForItem)* COMMA?

ForItem &lt;- Expr (DOT2 Expr?)?

# 运算符
AssignOp
    &lt;- ASTERISKEQUAL
     / ASTERISKPIPEEQUAL
     / SLASHEQUAL
     / PERCENTEQUAL
     / PLUSEQUAL
     / PLUSPIPEEQUAL
     / MINUSEQUAL
     / MINUSPIPEEQUAL
     / LARROW2EQUAL
     / LARROW2PIPEEQUAL
     / RARROW2EQUAL
     / AMPERSANDEQUAL
     / CARETEQUAL
     / PIPEEQUAL
     / ASTERISKPERCENTEQUAL
     / PLUSPERCENTEQUAL
     / MINUSPERCENTEQUAL
     / EQUAL

CompareOp
    &lt;- EQUALEQUAL
     / EXCLAMATIONMARKEQUAL
     / LARROW
     / RARROW
     / LARROWEQUAL
     / RARROWEQUAL

BitwiseOp
    &lt;- AMPERSAND
     / CARET
     / PIPE
     / KEYWORD_orelse
     / KEYWORD_catch Payload?

BitShiftOp
    &lt;- LARROW2
     / RARROW2
     / LARROW2PIPE

AdditionOp
    &lt;- PLUS
     / MINUS
     / PLUS2
     / PLUSPERCENT
     / MINUSPERCENT
     / PLUSPIPE
     / MINUSPIPE

MultiplyOp
    &lt;- PIPE2
     / ASTERISK
     / SLASH
     / PERCENT
     / ASTERISK2
     / ASTERISKPERCENT
     / ASTERISKPIPE

PrefixOp
    &lt;- EXCLAMATIONMARK
     / MINUS
     / TILDE
     / MINUSPERCENT
     / AMPERSAND
     / KEYWORD_try

PrefixTypeOp
    &lt;- QUESTIONMARK
     / KEYWORD_anyframe MINUSRARROW
     / SliceTypeStart (ByteAlign / AddrSpace / KEYWORD_const / KEYWORD_volatile / KEYWORD_allowzero)*
     / PtrTypeStart (AddrSpace / KEYWORD_align LPAREN Expr (COLON Expr COLON Expr)? RPAREN / KEYWORD_const / KEYWORD_volatile / KEYWORD_allowzero)*
     / ArrayTypeStart

SuffixOp
    &lt;- LBRACKET Expr (DOT2 (Expr? (COLON Expr)?)?)? RBRACKET
     / DOT IDENTIFIER
     / DOTASTERISK
     / DOTQUESTIONMARK

FnCallArguments &lt;- LPAREN ExprList RPAREN

# 指针特定
SliceTypeStart &lt;- LBRACKET (COLON Expr)? RBRACKET

PtrTypeStart
    &lt;- ASTERISK
     / ASTERISK2
     / LBRACKET ASTERISK (LETTERC / COLON Expr)? RBRACKET

ArrayTypeStart &lt;- LBRACKET Expr (COLON Expr)? RBRACKET

# 容器声明特定
ContainerDeclAuto &lt;- ContainerDeclType LBRACE container_doc_comment? ContainerMembers RBRACE

ContainerDeclType
    &lt;- KEYWORD_struct (LPAREN Expr RPAREN)?
     / KEYWORD_opaque
     / KEYWORD_enum (LPAREN Expr RPAREN)?
     / KEYWORD_union (LPAREN (KEYWORD_enum (LPAREN Expr RPAREN)? / Expr) RPAREN)?

# 对齐
ByteAlign &lt;- KEYWORD_align LPAREN Expr RPAREN

# 列表
IdentifierList &lt;- (doc_comment? IDENTIFIER COMMA)* (doc_comment? IDENTIFIER)?

SwitchProngList &lt;- (SwitchProng COMMA)* SwitchProng?

AsmOutputList &lt;- (AsmOutputItem COMMA)* AsmOutputItem?

AsmInputList &lt;- (AsmInputItem COMMA)* AsmInputItem?

StringList &lt;- (STRINGLITERAL COMMA)* STRINGLITERAL?

ParamDeclList &lt;- (ParamDecl COMMA)* ParamDecl?

ExprList &lt;- (Expr COMMA)* Expr?

# *** 词法单元 ***
eof &lt;- !.
bin &lt;- [01]
bin_ &lt;- '_'? bin
oct &lt;- [0-7]
oct_ &lt;- '_'? oct
hex &lt;- [0-9a-fA-F]
hex_ &lt;- '_'? hex
dec &lt;- [0-9]
dec_ &lt;- '_'? dec

bin_int &lt;- bin bin_*
oct_int &lt;- oct oct_*
dec_int &lt;- dec dec_*
hex_int &lt;- hex hex_*

ox80_oxBF &lt;- [\200-\277]
oxF4 &lt;- '\364'
ox80_ox8F &lt;- [\200-\217]
oxF1_oxF3 &lt;- [\361-\363]
oxF0 &lt;- '\360'
ox90_0xBF &lt;- [\220-\277]
oxEE_oxEF &lt;- [\356-\357]
oxED &lt;- '\355'
ox80_ox9F &lt;- [\200-\237]
oxE1_oxEC &lt;- [\341-\354]
oxE0 &lt;- '\340'
oxA0_oxBF &lt;- [\240-\277]
oxC2_oxDF &lt;- [\302-\337]

# 来自 https://lemire.me/blog/2018/05/09/how-quickly-can-you-check-that-a-string-is-valid-unicode-utf-8/
# 第一字节      第二字节        第三字节        第四字节
# [0x00,0x7F]
# [0xC2,0xDF]   [0x80,0xBF]
#    0xE0       [0xA0,0xBF]     [0x80,0xBF]
# [0xE1,0xEC]   [0x80,0xBF]     [0x80,0xBF]
#    0xED       [0x80,0x9F]     [0x80,0xBF]
# [0xEE,0xEF]   [0x80,0xBF]     [0x80,0xBF]
#    0xF0       [0x90,0xBF]     [0x80,0xBF]     [0x80,0xBF]
# [0xF1,0xF3]   [0x80,0xBF]     [0x80,0xBF]     [0x80,0xBF]
#    0xF4       [0x80,0x8F]     [0x80,0xBF]     [0x80,0xBF]

mb_utf8_literal &lt;-
       oxF4      ox80_ox8F ox80_oxBF ox80_oxBF
     / oxF1_oxF3 ox80_oxBF ox80_oxBF ox80_oxBF
     / oxF0      ox90_0xBF ox80_oxBF ox80_oxBF
     / oxEE_oxEF ox80_oxBF ox80_oxBF
     / oxED      ox80_ox9F ox80_oxBF
     / oxE1_oxEC ox80_oxBF ox80_oxBF
     / oxE0      oxA0_oxBF ox80_oxBF
     / oxC2_oxDF ox80_oxBF

ascii_char_not_nl_slash_squote &lt;- [\000-\011\013-\046\050-\133\135-\177]

char_escape
    &lt;- "\\x" hex hex
     / "\\u{" hex+ "}"
     / "\\" [nr\\t'"]
char_char
    &lt;- mb_utf8_literal
     / char_escape
     / ascii_char_not_nl_slash_squote

string_char
    &lt;- char_escape
     / [^\\"\n]

container_doc_comment &lt;- ('//!' [^\n]* [ \n]* skip)+
doc_comment &lt;- ('///' [^\n]* [ \n]* skip)+
line_comment &lt;- '//' ![!/][^\n]* / '////' [^\n]*
line_string &lt;- ("\\\\" [^\n]* [ \n]*)+
skip &lt;- ([ \n] / line_comment)*

CHAR_LITERAL &lt;- "'" char_char "'" skip
FLOAT
    &lt;- "0x" hex_int "." hex_int ([pP] [-+]? dec_int)? skip
     /      dec_int "." dec_int ([eE] [-+]? dec_int)? skip
     / "0x" hex_int [pP] [-+]? dec_int skip
     /      dec_int [eE] [-+]? dec_int skip
INTEGER
    &lt;- "0b" bin_int skip
     / "0o" oct_int skip
     / "0x" hex_int skip
     /      dec_int   skip
STRINGLITERALSINGLE &lt;- "\"" string_char* "\"" skip
STRINGLITERAL
    &lt;- STRINGLITERALSINGLE
     / (line_string                 skip)+
IDENTIFIER
    &lt;- !keyword [A-Za-z_] [A-Za-z0-9_]* skip
     / "@" STRINGLITERALSINGLE
BUILTINIDENTIFIER &lt;- "@"[A-Za-z_][A-Za-z0-9_]* skip


AMPERSAND            &lt;- '&amp;'      ![=]      skip
AMPERSANDEQUAL       &lt;- '&amp;='               skip
ASTERISK             &lt;- '*'      ![*%=|]   skip
ASTERISK2            &lt;- '**'               skip
ASTERISKEQUAL        &lt;- '*='               skip
ASTERISKPERCENT      &lt;- '*%'     ![=]      skip
ASTERISKPERCENTEQUAL &lt;- '*%='              skip
ASTERISKPIPE         &lt;- '*|'     ![=]      skip
ASTERISKPIPEEQUAL    &lt;- '*|='              skip
CARET                &lt;- '^'      ![=]      skip
CARETEQUAL           &lt;- '^='               skip
COLON                &lt;- ':'                skip
COMMA                &lt;- ','                skip
DOT                  &lt;- '.'      ![*.?]    skip
DOT2                 &lt;- '..'     ![.]      skip
DOT3                 &lt;- '...'              skip
DOTASTERISK          &lt;- '.*'               skip
DOTQUESTIONMARK      &lt;- '.?'               skip
EQUAL                &lt;- '='      ![&gt;=]     skip
EQUALEQUAL           &lt;- '=='               skip
EQUALRARROW          &lt;- '=&gt;'               skip
EXCLAMATIONMARK      &lt;- '!'      ![=]      skip
EXCLAMATIONMARKEQUAL &lt;- '!='               skip
LARROW               &lt;- '&lt;'      ![&lt;=]     skip
LARROW2              &lt;- '&lt;&lt;'     ![=|]     skip
LARROW2EQUAL         &lt;- '&lt;&lt;='              skip
LARROW2PIPE          &lt;- '&lt;&lt;|'    ![=]      skip
LARROW2PIPEEQUAL     &lt;- '&lt;&lt;|='             skip
LARROWEQUAL          &lt;- '&lt;='               skip
LBRACE               &lt;- '{'                skip
LBRACKET             &lt;- '['                skip
LPAREN               &lt;- '('                skip
MINUS                &lt;- '-'      ![%=&gt;|]   skip
MINUSEQUAL           &lt;- '-='               skip
MINUSPERCENT         &lt;- '-%'     ![=]      skip
MINUSPERCENTEQUAL    &lt;- '-%='              skip
MINUSPIPE            &lt;- '-|'     ![=]      skip
MINUSPIPEEQUAL       &lt;- '-|='              skip
MINUSRARROW          &lt;- '-&gt;'               skip
PERCENT              &lt;- '%'      ![=]      skip
PERCENTEQUAL         &lt;- '%='               skip
PIPE                 &lt;- '|'      ![|=]     skip
PIPE2                &lt;- '||'               skip
PIPEEQUAL            &lt;- '|='               skip
PLUS                 &lt;- '+'      ![%+=|]   skip
PLUS2                &lt;- '++'               skip
PLUSEQUAL            &lt;- '+='               skip
PLUSPERCENT          &lt;- '+%'     ![=]      skip
PLUSPERCENTEQUAL     &lt;- '+%='              skip
PLUSPIPE             &lt;- '+|'     ![=]      skip
PLUSPIPEEQUAL        &lt;- '+|='              skip
LETTERC              &lt;- 'c'                skip
QUESTIONMARK         &lt;- '?'                skip
RARROW               &lt;- '&gt;'      ![&gt;=]     skip
RARROW2              &lt;- '&gt;&gt;'     ![=]      skip
RARROW2EQUAL         &lt;- '&gt;&gt;='              skip
RARROWEQUAL          &lt;- '&gt;='               skip
RBRACE               &lt;- '}'                skip
RBRACKET             &lt;- ']'                skip
RPAREN               &lt;- ')'                skip
SEMICOLON            &lt;- ';'                skip
SLASH                &lt;- '/'      ![=]      skip
SLASHEQUAL           &lt;- '/='               skip
TILDE                &lt;- '~'                skip

end_of_word &lt;- ![a-zA-Z0-9_] skip
KEYWORD_addrspace   &lt;- 'addrspace'   end_of_word
KEYWORD_align       &lt;- 'align'       end_of_word
KEYWORD_allowzero   &lt;- 'allowzero'   end_of_word
KEYWORD_and         &lt;- 'and'         end_of_word
KEYWORD_anyframe    &lt;- 'anyframe'    end_of_word
KEYWORD_anytype     &lt;- 'anytype'     end_of_word
KEYWORD_asm         &lt;- 'asm'         end_of_word
KEYWORD_break       &lt;- 'break'       end_of_word
KEYWORD_callconv    &lt;- 'callconv'    end_of_word
KEYWORD_catch       &lt;- 'catch'       end_of_word
KEYWORD_comptime    &lt;- 'comptime'    end_of_word
KEYWORD_const       &lt;- 'const'       end_of_word
KEYWORD_continue    &lt;- 'continue'    end_of_word
KEYWORD_defer       &lt;- 'defer'       end_of_word
KEYWORD_else        &lt;- 'else'        end_of_word
KEYWORD_enum        &lt;- 'enum'        end_of_word
KEYWORD_errdefer    &lt;- 'errdefer'    end_of_word
KEYWORD_error       &lt;- 'error'       end_of_word
KEYWORD_export      &lt;- 'export'      end_of_word
KEYWORD_extern      &lt;- 'extern'      end_of_word
KEYWORD_fn          &lt;- 'fn'          end_of_word
KEYWORD_for         &lt;- 'for'         end_of_word
KEYWORD_if          &lt;- 'if'          end_of_word
KEYWORD_inline      &lt;- 'inline'      end_of_word
KEYWORD_noalias     &lt;- 'noalias'     end_of_word
KEYWORD_nosuspend   &lt;- 'nosuspend'   end_of_word
KEYWORD_noinline    &lt;- 'noinline'    end_of_word
KEYWORD_opaque      &lt;- 'opaque'      end_of_word
KEYWORD_or          &lt;- 'or'          end_of_word
KEYWORD_orelse      &lt;- 'orelse'      end_of_word
KEYWORD_packed      &lt;- 'packed'      end_of_word
KEYWORD_pub         &lt;- 'pub'         end_of_word
KEYWORD_resume      &lt;- 'resume'      end_of_word
KEYWORD_return      &lt;- 'return'      end_of_word
KEYWORD_linksection &lt;- 'linksection' end_of_word
KEYWORD_struct      &lt;- 'struct'      end_of_word
KEYWORD_suspend     &lt;- 'suspend'     end_of_word
KEYWORD_switch      &lt;- 'switch'      end_of_word
KEYWORD_test        &lt;- 'test'        end_of_word
KEYWORD_threadlocal &lt;- 'threadlocal' end_of_word
KEYWORD_try         &lt;- 'try'         end_of_word
KEYWORD_union       &lt;- 'union'       end_of_word
KEYWORD_unreachable &lt;- 'unreachable' end_of_word
KEYWORD_var         &lt;- 'var'         end_of_word
KEYWORD_volatile    &lt;- 'volatile'    end_of_word
KEYWORD_while       &lt;- 'while'       end_of_word

keyword &lt;- KEYWORD_addrspace / KEYWORD_align / KEYWORD_allowzero / KEYWORD_and
         / KEYWORD_anyframe / KEYWORD_anytype / KEYWORD_asm
         / KEYWORD_break / KEYWORD_callconv / KEYWORD_catch
         / KEYWORD_comptime / KEYWORD_const / KEYWORD_continue / KEYWORD_defer
         / KEYWORD_else / KEYWORD_enum / KEYWORD_errdefer / KEYWORD_error / KEYWORD_export
         / KEYWORD_extern / KEYWORD_fn / KEYWORD_for / KEYWORD_if
         / KEYWORD_inline / KEYWORD_noalias / KEYWORD_nosuspend / KEYWORD_noinline
         / KEYWORD_opaque / KEYWORD_or / KEYWORD_orelse / KEYWORD_packed
         / KEYWORD_pub / KEYWORD_resume / KEYWORD_return / KEYWORD_linksection
         / KEYWORD_struct / KEYWORD_suspend / KEYWORD_switch / KEYWORD_test
         / KEYWORD_threadlocal / KEYWORD_try / KEYWORD_union / KEYWORD_unreachable
         / KEYWORD_var / KEYWORD_volatile / KEYWORD_while</code></pre></figure>
      
      <h3 id="Zen"><a href="https://ziglang.org/documentation/0.15.2/#toc-Zen">禅意</a> <a class="hdr" href="https://ziglang.org/documentation/0.15.2/#Zen">§</a></h3>

      <ul>
        <li>精确传达意图。</li>
        <li>边界情况很重要。</li>
        <li>优先阅读代码,而非编写代码。</li>
        <li>只有一种明显的方式来做事情。</li>
        <li>运行时崩溃优于错误。</li>
        <li>编译错误优于运行时崩溃。</li>
        <li>渐进式改进。</li>
        <li>避免局部最优。</li>
        <li>减少必须记住的内容。</li>
        <li>专注于代码而非风格。</li>
        <li>资源分配可能失败;资源释放必须成功。</li>
        <li>内存是一种资源。</li>
        <li>我们共同服务于用户。</li>
      </ul>
      
      
      </main></div>
    </div>
  

</body></html>
<!-- ====== END CHUNK 15: new_15.html ====== -->
